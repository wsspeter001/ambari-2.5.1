// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  var anymatch, changedSince, each, formatError, generate, getFiles, getPaths, helpers, logger, sysPath, write,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  each = require('async-each');

  sysPath = require('path');

  generate = require('./generate');

  helpers = require('../helpers');

  logger = require('loggy');

  anymatch = require('anymatch');

  getPaths = function(sourceFile, joinConfig) {
    var sourceFileJoinConfig;
    sourceFileJoinConfig = joinConfig[sourceFile.type + 's'] || {};
    return Object.keys(sourceFileJoinConfig).filter(function(key) {
      return key !== 'pluginHelpers';
    }).filter(function(generatedFilePath) {
      var checker;
      if (sourceFile.isHelper) {
        return __indexOf.call(sourceFileJoinConfig.pluginHelpers, generatedFilePath) >= 0;
      } else {
        checker = sourceFileJoinConfig[generatedFilePath];
        return checker(sourceFile.path);
      }
    });
  };

  getFiles = function(fileList, config, joinConfig, startTime) {
    var anyJoinTo, checkAnyJoinTo, map;
    map = {};
    anyJoinTo = {};
    checkAnyJoinTo = function(file) {
      var joinSpecs, _name;
      joinSpecs = anyJoinTo[_name = file.type] != null ? anyJoinTo[_name] : anyJoinTo[_name] = Object.keys(config.overrides).map(function(_) {
        return config.overrides[_].files;
      }).map(function(_) {
        var _ref;
        return _ != null ? (_ref = _["" + file.type + "s"]) != null ? _ref.joinTo : void 0 : void 0;
      }).filter(function(_) {
        return _;
      });
      if (typeof joinSpecs === 'function') {
        return joinSpecs(file.path);
      } else if (joinSpecs.some(function(_) {
        return typeof _ === 'string';
      })) {
        return anyJoinTo[file.type] = function() {
          return true;
        };
      } else if (!joinSpecs.length) {
        anyJoinTo[file.type] = function() {
          return false;
        };
        return false;
      } else {
        anyJoinTo[file.type] = anymatch(joinSpecs.reduce(function(flat, aJoinTo) {
          return flat.concat(Object.keys(aJoinTo).map(function(_) {
            return aJoinTo[_];
          }));
        }, []));
        return anyJoinTo[file.type](file.path);
      }
    };
    fileList.files.forEach(function(file) {
      var paths;
      if ((file.error == null) && (file.data == null)) {
        return;
      }
      paths = getPaths(file, joinConfig);
      paths.forEach(function(path) {
        if (map[path] == null) {
          map[path] = [];
        }
        return map[path].push(file);
      });
      if (!paths.length) {
        if (file.error) {
          logger.error(formatError(file));
        }
        if (file.data && file.compilationTime >= startTime) {
          if (!checkAnyJoinTo(file)) {
            return logger.warn("'" + file.path + "' compiled, but not written. Check your " + file.type + "s.joinTo config.");
          }
        }
      }
    });
    return Object.keys(map).map(function(generatedFilePath) {
      var fullPath, sourceFiles;
      sourceFiles = map[generatedFilePath];
      fullPath = sysPath.join(config.paths["public"], generatedFilePath);
      return {
        sourceFiles: sourceFiles,
        path: fullPath
      };
    });
  };

  changedSince = function(startTime) {
    return function(generated) {
      return generated.sourceFiles.some(function(sourceFile) {
        return sourceFile.compilationTime >= startTime || sourceFile.removed;
      });
    };
  };

  formatError = function(sourceFile) {
    return helpers.formatError(sourceFile.error, sourceFile.path);
  };

  module.exports = write = function(fileList, config, joinConfig, optimizers, startTime, callback) {
    var changed, disposed, errors, files, gen;
    files = getFiles(fileList, config, joinConfig, startTime);
    errors = files.map(function(generated) {
      return generated.sourceFiles.filter(function(_) {
        return _.error != null;
      }).map(formatError);
    }).reduce((function(a, b) {
      return a.concat(b);
    }), []);
    if (errors.length > 0) {
      return callback(errors.join(' ; '));
    }
    changed = files.filter(changedSince(startTime));
    disposed = {
      generated: [],
      sourcePaths: []
    };
    changed.forEach(function(generated) {
      var sourceFiles;
      sourceFiles = generated.sourceFiles;
      return sourceFiles.filter(function(file) {
        return file.removed;
      }).forEach(function(file) {
        disposed.generated.push(generated);
        disposed.sourcePaths.push(sysPath.basename(file.path));
        file.dispose();
        return sourceFiles.splice(sourceFiles.indexOf(file), 1);
      });
    });
    gen = function(file, next) {
      return generate(file.path, file.sourceFiles, config, optimizers, next);
    };
    return each(changed, gen, function(error) {
      if (error != null) {
        return callback(error);
      }
      return callback(null, changed, disposed);
    });
  };

}).call(this);
