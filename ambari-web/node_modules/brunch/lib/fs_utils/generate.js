// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  var SourceMapConsumer, SourceMapGenerator, SourceNode, anysort, common, concat, debug, extractOrder, flatten, fs, generate, mapOptimizerChain, optimize, sort, sortByConfig, sysPath, waterfall, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  debug = require('debug')('brunch:generate');

  fs = require('fs');

  sysPath = require('path');

  waterfall = require('async-waterfall');

  anysort = require('anysort');

  common = require('./common');

  _ref = require('source-map'), SourceMapConsumer = _ref.SourceMapConsumer, SourceMapGenerator = _ref.SourceMapGenerator, SourceNode = _ref.SourceNode;

  sortByConfig = function(files, config) {
    var criteria, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    if (toString.call(config) === '[object Object]') {
      criteria = [
        (_ref1 = config.before) != null ? _ref1 : [], (_ref2 = config.after) != null ? _ref2 : [], (_ref3 = config.joinToValue) != null ? _ref3 : [], (_ref4 = config.bower) != null ? _ref4 : [], (_ref5 = config.component) != null ? _ref5 : [], (_ref6 = config.vendorConvention) != null ? _ref6 : function() {
          return false;
        }
      ];
      return anysort.grouped(files, criteria, [0, 2, 3, 4, 5, 6, 1]);
    } else {
      return files;
    }
  };

  flatten = function(array) {
    return array.reduce(function(acc, elem) {
      return acc.concat(Array.isArray(elem) ? flatten(elem) : [elem]);
    }, []);
  };

  extractOrder = function(files, config) {
    var after, before, bower, component, conventions, orders, packageInfo, types, vendorConvention, _ref1;
    types = files.map(function(file) {
      return file.type + 's';
    });
    orders = Object.keys(config.files).filter(function(key) {
      return __indexOf.call(types, key) >= 0;
    }).map(function(key) {
      var _ref1;
      return (_ref1 = config.files[key].order) != null ? _ref1 : {};
    });
    before = flatten(orders.map(function(type) {
      var _ref1;
      return (_ref1 = type.before) != null ? _ref1 : [];
    }));
    after = flatten(orders.map(function(type) {
      var _ref1;
      return (_ref1 = type.after) != null ? _ref1 : [];
    }));
    _ref1 = config._normalized, conventions = _ref1.conventions, packageInfo = _ref1.packageInfo;
    vendorConvention = conventions.vendor;
    bower = packageInfo.bower.order;
    component = packageInfo.component.order;
    return {
      before: before,
      after: after,
      vendorConvention: vendorConvention,
      bower: bower,
      component: component
    };
  };

  sort = function(files, config, joinToValue) {
    var indexes, order, paths;
    paths = files.map(function(file) {
      return file.path;
    });
    indexes = Object.create(null);
    files.forEach(function(file, index) {
      return indexes[file.path] = file;
    });
    order = extractOrder(files, config);
    if (Array.isArray(joinToValue)) {
      order.joinToValue = joinToValue;
    }
    return sortByConfig(paths, order).map(function(path) {
      return indexes[path];
    });
  };

  concat = function(files, path, type, definition, aliases) {
    var root;
    root = new SourceNode();
    debug("Concatenating " + (files.map(function(_) {
      return _.path;
    }).join(', ')) + " to " + path);
    files.forEach(function(file) {
      var data;
      root.add(file.node);
      data = file.node.isIdentity ? file.data : file.source;
      if (type === 'javascript' && ';' !== data.trim().substr(-1)) {
        root.add(';');
      }
      return root.setSourceContent(file.node.source, data);
    });
    if (type === 'javascript') {
      root.prepend(definition(path, root.sourceContents));
    }
    if (aliases != null) {
      aliases.forEach(function(alias) {
        var key;
        key = Object.keys(alias)[0];
        return root.add("require.alias('" + key + "', '" + alias[key] + "');");
      });
    }
    return root.toStringWithSourceMap({
      file: path
    });
  };

  mapOptimizerChain = function(optimizer) {
    return function(params, next) {
      var code, data, map, optimizerArgs, path, sourceFiles;
      data = params.data, code = params.code, map = params.map, path = params.path, sourceFiles = params.sourceFiles;
      debug("Optimizing '" + path + "' with '" + optimizer.constructor.name + "'");
      optimizerArgs = optimizer.optimize.length === 2 ? [params] : [data, path];
      optimizerArgs.push(function(error, optimized) {
        var newMap, optimizedCode, optimizedMap;
        if (error != null) {
          return next(error);
        }
        if (toString.call(optimized) === '[object Object]') {
          optimizedCode = optimized.data;
          optimizedMap = optimized.map;
        } else {
          optimizedCode = optimized;
        }
        if (optimizedMap != null) {
          newMap = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(optimizedMap));
          if (newMap._sourcesContents == null) {
            newMap._sourcesContents = {};
          }
          sourceFiles.forEach(function(_arg) {
            var path, source;
            path = _arg.path, source = _arg.source;
            return newMap._sourcesContents["$" + path] = source;
          });
        } else {
          newMap = map;
        }
        return next(error, {
          data: optimizedCode,
          code: optimizedCode,
          map: newMap,
          path: path,
          sourceFiles: sourceFiles
        });
      });
      return optimizer.optimize.apply(optimizer, optimizerArgs);
    };
  };

  optimize = function(data, map, path, optimizers, sourceFiles, callback) {
    var first, initial;
    initial = {
      data: data,
      code: data,
      map: map,
      path: path,
      sourceFiles: sourceFiles
    };
    first = function(next) {
      return next(null, initial);
    };
    return waterfall([first].concat(optimizers.map(mapOptimizerChain)), callback);
  };

  generate = function(path, sourceFiles, config, optimizers, callback) {
    var code, joinToValue, map, mapPath, sorted, type, withMaps, _ref1;
    type = sourceFiles.some(function(file) {
      var _ref1;
      return (_ref1 = file.type) === 'javascript' || _ref1 === 'template';
    }) ? 'javascript' : 'stylesheet';
    optimizers = optimizers.filter(function(optimizer) {
      return optimizer.type === type;
    });
    joinToValue = config.files["" + type + "s"].joinTo[path.slice(config.paths["public"].length + 1)];
    sorted = sort(sourceFiles, config, joinToValue);
    _ref1 = concat(sorted, path, type, config._normalized.modules.definition, config._normalized.packageInfo['component'].aliases), code = _ref1.code, map = _ref1.map;
    withMaps = map && config.sourceMaps;
    mapPath = "" + path + ".map";
    return optimize(code, map, path, optimizers, sourceFiles, function(error, data) {
      var controlChar, mapRoute;
      if (error != null) {
        return callback(error);
      }
      if (withMaps) {
        mapRoute = config.sourceMaps === 'absoluteUrl' ? mapPath.replace(config.paths["public"], '').replace('\\', '/') : sysPath.basename(mapPath);
        controlChar = config.sourceMaps === 'old' ? '@' : '#';
        data.code += type === 'javascript' ? "\n//" + controlChar + " sourceMappingURL=" + mapRoute : "\n/*" + controlChar + " sourceMappingURL=" + mapRoute + "*/";
      }
      return common.writeFile(path, data.code, function() {
        if (withMaps) {
          return common.writeFile(mapPath, data.map.toString(), callback);
        } else {
          return callback();
        }
      });
    });
  };

  generate.sortByConfig = sortByConfig;

  module.exports = generate;

}).call(this);
