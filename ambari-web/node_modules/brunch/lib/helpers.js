// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  var SourceNode, anymatch, applyOverrides, cleanModuleName, coffee, commonRequireDefinition, createJoinConfig, debug, deepExtend, deepFreeze, exec, extend, fs, getModuleWrapper, http, identityNode, install, isWindows, loadComponents, logger, normalizeChecker, normalizeConfig, normalizeDefinition, normalizeWrapper, os, readComponents, replaceBackSlashes, replaceConfigSlashes, replaceSlashes, setConfigDefaults, sysPath, warnAboutConfigDeprecations, windowsStringReplace,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  exec = require('child_process').exec;

  http = require('http');

  fs = require('fs');

  os = require('os');

  sysPath = require('path');

  logger = require('loggy');

  SourceNode = require('source-map').SourceNode;

  readComponents = require('read-components');

  debug = require('debug')('brunch:helpers');

  commonRequireDefinition = require('commonjs-require-definition');

  anymatch = require('anymatch');

  coffee = require('coffee-script');

  coffee.register();

  exports.extend = extend = function(object, properties) {
    Object.keys(properties).forEach(function(key) {
      return object[key] = properties[key];
    });
    return object;
  };

  applyOverrides = function(config, options) {
    var environments;
    environments = options.env;
    if (process.env.BRUNCH_ENV != null) {
      environments.unshift(process.env.BRUNCH_ENV);
    }
    if (environments.length && 'overrides' in config) {
      config.overrides._default = {};
      Object.keys(config).forEach(function(prop) {
        var isObject;
        isObject = toString.call(config[prop]) === '[object Object]';
        if (prop === 'overrides' || !isObject) {
          return;
        }
        config.overrides._default[prop] = {};
        return deepExtend(config.overrides._default[prop], config[prop]);
      });
    }
    environments.forEach(function(override) {
      var k, overrideProps, v, _ref, _ref1, _ref2;
      overrideProps = ((_ref = config.overrides) != null ? _ref[override] : void 0) || {};
      _ref1 = {
        on: 'off',
        off: 'on'
      };
      for (k in _ref1) {
        v = _ref1[k];
        if ((_ref2 = config.plugins) != null ? _ref2[v] : void 0) {
          if (overrideProps.plugins == null) {
            overrideProps.plugins = {};
          }
          overrideProps.plugins[v] = (overrideProps.plugins[v] || []).concat((config.plugins[v] || []).filter(function(plugin) {
            return __indexOf.call(overrideProps.plugins[k] || [], plugin) < 0;
          }));
        }
      }
      return deepExtend(config, overrideProps, config.files);
    });
    return config;
  };

  deepExtend = function(object, properties, rootFiles) {
    var nestedObjs;
    if (rootFiles == null) {
      rootFiles = {};
    }
    nestedObjs = Object.keys(rootFiles).map(function(_) {
      return rootFiles[_];
    });
    Object.keys(properties).forEach(function(key) {
      var value;
      value = properties[key];
      if (toString.call(value) === '[object Object]' && __indexOf.call(nestedObjs, object) < 0) {
        if (object[key] == null) {
          object[key] = {};
        }
        return deepExtend(object[key], value, rootFiles);
      } else {
        return object[key] = value;
      }
    });
    return object;
  };

  exports.deepFreeze = deepFreeze = function(object) {
    Object.keys(Object.freeze(object)).map(function(key) {
      return object[key];
    }).filter(function(value) {
      return typeof value === 'object' && (value != null) && !Object.isFrozen(value);
    }).forEach(deepFreeze);
    return object;
  };

  exports.formatError = function(error, path) {
    return "" + error.code + " of '" + path + "' failed. " + (error.toString().slice(7));
  };

  exports.install = install = function(rootPath, command, callback) {
    var prevDir;
    if (callback == null) {
      callback = (function() {});
    }
    prevDir = process.cwd();
    logger.info("Installing " + command + " packages...");
    process.chdir(rootPath);
    return exec("" + command + " install", function(error, stdout, stderr) {
      var log;
      process.chdir(prevDir);
      if (error != null) {
        log = stderr.toString();
        logger.error(log);
        return callback(log);
      }
      return callback(null, stdout);
    });
  };

  exports.isWindows = isWindows = (function() {
    return os.platform() === 'win32';
  })();

  windowsStringReplace = function(search, replacement) {
    return function(_) {
      if (isWindows && typeof _ === 'string') {
        return _.replace(search, replacement);
      } else {
        return _;
      }
    };
  };

  exports.replaceSlashes = replaceSlashes = windowsStringReplace(/\//g, '\\');

  exports.replaceBackSlashes = replaceBackSlashes = windowsStringReplace(/\\/g, '\/');

  exports.replaceConfigSlashes = replaceConfigSlashes = function(config) {
    var files;
    if (!isWindows) {
      return config;
    }
    files = config.files || {};
    Object.keys(files).forEach(function(language) {
      var lang, newJoinTo, order;
      lang = files[language] || {};
      order = lang.order || {};
      Object.keys(order).forEach(function(orderKey) {
        return lang.order[orderKey] = lang.order[orderKey].map(replaceSlashes);
      });
      switch (toString.call(lang.joinTo)) {
        case '[object String]':
          return lang.joinTo = replaceSlashes(lang.joinTo);
        case '[object Object]':
          newJoinTo = {};
          Object.keys(lang.joinTo).forEach(function(joinToKey) {
            return newJoinTo[replaceSlashes(joinToKey)] = lang.joinTo[joinToKey];
          });
          return lang.joinTo = newJoinTo;
      }
    });
    return config;
  };

  normalizeChecker = anymatch;

  createJoinConfig = function(configFiles) {
    var joinConfig, listToObj, types;
    listToObj = function(acc, elem) {
      acc[elem[0]] = elem[1];
      return acc;
    };
    types = Object.keys(configFiles);
    joinConfig = types.map(function(type) {
      return configFiles[type].joinTo;
    }).map(function(joinTo) {
      var object;
      if (typeof joinTo === 'string') {
        object = {};
        object[joinTo] = /.+/;
        return object;
      } else {
        return joinTo;
      }
    }).map(function(joinTo, index) {
      var makeChecker, subConfig;
      makeChecker = function(generatedFilePath) {
        return [generatedFilePath, normalizeChecker(joinTo[generatedFilePath])];
      };
      subConfig = Object.keys(joinTo).map(makeChecker).reduce(listToObj, {});
      return [types[index], subConfig];
    }).reduce(listToObj, {});
    types.forEach(function(type) {
      var pluginHelpers;
      pluginHelpers = configFiles[type].pluginHelpers;
      return joinConfig[type].pluginHelpers = Array.isArray(pluginHelpers) ? pluginHelpers : pluginHelpers ? [pluginHelpers] : (function() {
        var destFiles, joinMatch, nameMatch;
        destFiles = Object.keys(joinConfig[type]);
        joinMatch = destFiles.filter(function(file) {
          return joinConfig[type][file]('vendor/.');
        });
        if (joinMatch.length > 0) {
          return [joinMatch[0]];
        }
        nameMatch = destFiles.filter(function(file) {
          return /vendor/i.test(file);
        });
        if (nameMatch.length > 0) {
          return [nameMatch[0]];
        }
        return [destFiles.shift()];
      })();
    });
    return Object.freeze(joinConfig);
  };

  identityNode = exports.identityNode = function(code, source) {
    return new SourceNode(1, 0, null, code.split('\n').map(function(line, index) {
      return new SourceNode(index + 1, 0, source, line + '\n');
    }));
  };

  exports.cleanModuleName = cleanModuleName = function(path, nameCleaner) {
    return nameCleaner(path.replace(new RegExp('\\\\', 'g'), '/').replace(new RegExp('^(\.\.\/)*', 'g'), ''));
  };

  getModuleWrapper = function(type, nameCleaner) {
    return function(fullPath, data, isVendor) {
      var moduleName, path, sourceURLPath;
      sourceURLPath = cleanModuleName(fullPath, nameCleaner);
      moduleName = sourceURLPath.replace(/\.\w+$/, '');
      path = JSON.stringify(moduleName);
      if (isVendor) {
        debug('Wrapping is vendor');
        return data;
      } else {
        if (type === 'commonjs') {
          return {
            prefix: "require.register(" + path + ", function(exports, require, module) {\n",
            suffix: "});\n\n"
          };
        } else if (type === 'amd') {
          return {
            data: data.replace(/define\s*\(/, function(match) {
              return "" + match + path + ", ";
            })
          };
        }
      }
    };
  };

  normalizeWrapper = function(typeOrFunction, nameCleaner) {
    switch (typeOrFunction) {
      case 'commonjs':
        return getModuleWrapper('commonjs', nameCleaner);
      case 'amd':
        return getModuleWrapper('amd', nameCleaner);
      case false:
        return function(path, data) {
          return data;
        };
      default:
        if (typeof typeOrFunction === 'function') {
          return typeOrFunction;
        } else {
          throw new Error('config.modules.wrapper should be a function or one of: "commonjs", "amd", false');
        }
    }
  };

  normalizeDefinition = function(typeOrFunction) {
    switch (typeOrFunction) {
      case 'commonjs':
        return function() {
          return commonRequireDefinition;
        };
      case 'amd':
      case false:
        return function() {
          return '';
        };
      default:
        if (typeof typeOrFunction === 'function') {
          return typeOrFunction;
        } else {
          throw new Error('config.modules.definition should be a function or one of: "commonjs", false');
        }
    }
  };

  exports.setConfigDefaults = setConfigDefaults = function(config, configPath) {
    var conventions, join, joinRoot, modules, overrides, paths, production, server, _base, _base1, _ref;
    join = (function(_this) {
      return function(parent, name) {
        return sysPath.join(config.paths[parent], name);
      };
    })(this);
    joinRoot = function(name) {
      return join('root', name);
    };
    paths = config.paths != null ? config.paths : config.paths = {};
    if (paths.root == null) {
      paths.root = '.';
    }
    if (paths["public"] == null) {
      paths["public"] = joinRoot('public');
    }
    if (paths.watched == null) {
      paths.watched = ['app', 'test', 'vendor'].map(joinRoot);
    }
    if (paths.config == null) {
      paths.config = configPath != null ? configPath : joinRoot('config');
    }
    if (paths.packageConfig == null) {
      paths.packageConfig = joinRoot('package.json');
    }
    if (paths.bowerConfig == null) {
      paths.bowerConfig = joinRoot('bower.json');
    }
    conventions = config.conventions != null ? config.conventions : config.conventions = {};
    if (conventions.assets == null) {
      conventions.assets = /assets[\\/]/;
    }
    if (conventions.ignored == null) {
      conventions.ignored = (_ref = paths.ignored) != null ? _ref : [/[\\/]_/, /vendor[\\/](node|j?ruby-.*|bundle)[\\/]/];
    }
    if (conventions.vendor == null) {
      conventions.vendor = /(^bower_components|vendor)[\\/]/;
    }
    if (config.notifications == null) {
      config.notifications = true;
    }
    if (config.sourceMaps == null) {
      config.sourceMaps = true;
    }
    if (config.optimize == null) {
      config.optimize = false;
    }
    if (config.plugins == null) {
      config.plugins = {};
    }
    modules = config.modules != null ? config.modules : config.modules = {};
    if (modules.wrapper == null) {
      modules.wrapper = 'commonjs';
    }
    if (modules.definition == null) {
      modules.definition = 'commonjs';
    }
    if (modules.nameCleaner == null) {
      modules.nameCleaner = function(path) {
        return path.replace(/^app\//, '');
      };
    }
    server = config.server != null ? config.server : config.server = {};
    if (server.base == null) {
      server.base = '';
    }
    if (server.port == null) {
      server.port = 3333;
    }
    if (server.run == null) {
      server.run = false;
    }
    overrides = config.overrides != null ? config.overrides : config.overrides = {};
    production = overrides.production != null ? overrides.production : overrides.production = {};
    if (production.optimize == null) {
      production.optimize = true;
    }
    if (production.sourceMaps == null) {
      production.sourceMaps = false;
    }
    if (production.plugins == null) {
      production.plugins = {};
    }
    if ((_base = production.plugins).autoReload == null) {
      _base.autoReload = {};
    }
    if ((_base1 = production.plugins.autoReload).enabled == null) {
      _base1.enabled = false;
    }
    return config;
  };

  warnAboutConfigDeprecations = function(config) {
    var ensureNotArray, messages, warnMoved, warnRemoved;
    messages = [];
    warnRemoved = function(path) {
      if (config.paths[path]) {
        return messages.push("config.paths." + path + " was removed, use config.paths.watched");
      }
    };
    warnMoved = function(configItem, from, to) {
      if (configItem) {
        return messages.push("config." + from + " moved to config." + to);
      }
    };
    warnRemoved('app');
    warnRemoved('test');
    warnRemoved('vendor');
    warnRemoved('assets');
    warnMoved(config.paths.ignored, 'paths.ignored', 'conventions.ignored');
    warnMoved(config.rootPath, 'rootPath', 'paths.root');
    warnMoved(config.buildPath, 'buildPath', 'paths.public');
    ensureNotArray = function(name) {
      if (Array.isArray(config.paths[name])) {
        return messages.push("config.paths." + name + " can't be an array. Use config.conventions." + name);
      }
    };
    ensureNotArray('assets');
    ensureNotArray('test');
    ensureNotArray('vendor');
    messages.forEach(logger.warn);
    return config;
  };

  normalizeConfig = function(config) {
    var mod, normalized;
    normalized = {};
    normalized.join = createJoinConfig(config.files);
    mod = config.modules;
    normalized.modules = {};
    normalized.modules.wrapper = normalizeWrapper(mod.wrapper, config.modules.nameCleaner);
    normalized.modules.definition = normalizeDefinition(mod.definition);
    normalized.conventions = {};
    Object.keys(config.conventions).forEach(function(name) {
      return normalized.conventions[name] = normalizeChecker(config.conventions[name]);
    });
    normalized.paths = {};
    normalized.paths.possibleConfigFiles = Object.keys(require.extensions).map(function(_) {
      return config.paths.config + _;
    }).reduce(function(obj, _) {
      obj[_] = true;
      return obj;
    }, {});
    normalized.paths.allConfigFiles = [config.paths.packageConfig, config.paths.bowerConfig].concat(Object.keys(normalized.paths.possibleConfigFiles));
    config._normalized = normalized;
    ['on', 'off', 'only'].forEach(function(key) {
      if (typeof config.plugins[key] === 'string') {
        return config.plugins[key] = [config.plugins[key]];
      }
    });
    return config;
  };

  loadComponents = function(config, type, callback) {
    return readComponents('.', type, function(error, components, aliases) {
      var order;
      if (error && !/ENOENT/.test(error.toString())) {
        logger.error(error);
      }
      if (components == null) {
        components = [];
      }
      order = components.sort(function(a, b) {
        if (a.sortingLevel === b.sortingLevel) {
          if (a.files[0] < b.files[0]) {
            return -1;
          } else {
            return 1;
          }
        } else {
          return b.sortingLevel - a.sortingLevel;
        }
      }).reduce(function(flat, component) {
        return flat.concat(component.files);
      }, []);
      return callback({
        components: components,
        aliases: aliases,
        order: order
      });
    });
  };

  exports.loadConfig = function(configPath, options, callback) {
    var config, error, fullPath;
    if (configPath == null) {
      configPath = 'brunch-config';
    }
    if (options == null) {
      options = {};
    }
    try {
      fullPath = sysPath.resolve(configPath);
      fullPath = require.resolve(fullPath);
      delete require.cache[fullPath];
      config = require(fullPath).config;
      if (!(config != null ? config.files : void 0)) {
        throw new Error('Brunch config must have "files" property');
      }
    } catch (_error) {
      error = _error;
      if (configPath === 'brunch-config' && error.code === 'MODULE_NOT_FOUND') {
        return exports.loadConfig('config', options, callback);
      } else {
        throw new Error("couldn\'t load config " + fullPath + ". " + error);
      }
    }
    setConfigDefaults(config, configPath);
    warnAboutConfigDeprecations(config);
    applyOverrides(config, options);
    deepExtend(config, options);
    replaceConfigSlashes(config);
    normalizeConfig(config);
    config._normalized.packageInfo = {};
    return loadComponents(config, 'bower', function(bowerRes) {
      config._normalized.packageInfo.bower = bowerRes;
      return loadComponents(config, 'component', function(componentRes) {
        config._normalized.packageInfo.component = componentRes;
        deepFreeze(config);
        return callback(null, config);
      });
    });
  };

}).call(this);
