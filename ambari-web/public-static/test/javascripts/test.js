(function(/*! Brunch !*/) {
  'use strict';

  var globals = typeof window !== 'undefined' ? window : global;
  if (typeof globals.require === 'function') return;

  var modules = {};
  var cache = {};

  var has = function(object, name) {
    return ({}).hasOwnProperty.call(object, name);
  };

  var expand = function(root, name) {
    var results = [], parts, part;
    if (/^\.\.?(\/|$)/.test(name)) {
      parts = [root, name].join('/').split('/');
    } else {
      parts = name.split('/');
    }
    for (var i = 0, length = parts.length; i < length; i++) {
      part = parts[i];
      if (part === '..') {
        results.pop();
      } else if (part !== '.' && part !== '') {
        results.push(part);
      }
    }
    return results.join('/');
  };

  var dirname = function(path) {
    return path.split('/').slice(0, -1).join('/');
  };

  var localRequire = function(path) {
    return function(name) {
      var dir = dirname(path);
      var absolute = expand(dir, name);
      return globals.require(absolute, path);
    };
  };

  var initModule = function(name, definition) {
    var module = {id: name, exports: {}};
    cache[name] = module;
    definition(module.exports, localRequire(name), module);
    return module.exports;
  };

  var require = function(name, loaderPath) {
    var path = expand(name, '.');
    if (loaderPath == null) loaderPath = '/';

    if (has(cache, path)) return cache[path].exports;
    if (has(modules, path)) return initModule(path, modules[path]);

    var dirIndex = expand(path, './index');
    if (has(cache, dirIndex)) return cache[dirIndex].exports;
    if (has(modules, dirIndex)) return initModule(dirIndex, modules[dirIndex]);

    throw new Error('Cannot find module "' + name + '" from '+ '"' + loaderPath + '"');
  };

  var define = function(bundle, fn) {
    if (typeof bundle === 'object') {
      for (var key in bundle) {
        if (has(bundle, key)) {
          modules[key] = bundle[key];
        }
      }
    } else {
      modules[bundle] = fn;
    }
  };

  var list = function() {
    var result = [];
    for (var item in modules) {
      if (has(modules, item)) {
        result.push(item);
      }
    }
    return result;
  };

  globals.require = require;
  globals.require.define = define;
  globals.require.register = define;
  globals.require.list = list;
  globals.require.brunch = true;
})();
require.register("test/aliases/computed/alias", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey
 * @param {string} [type]
 */
App.TestAliases.testAsComputedAlias = function (context, propertyName, dependentKey, type) {
  var testsCases = [];
  var typesMap = {
    string: ['1234', '', 'abc', '{}'],
    number: [1234, 0, -1234, 1.2, -1.2],
    boolean: [true, false],
    object: [{a: 12345}, {}],
    array: [[1,2,3], [], [{}, {a: 1}]]
  };

  if (type) {
    testsCases = typesMap[type] || [];
  }
  else {
   // all
    testsCases = [].concat(Object.keys(typesMap).map(function (key) {return typesMap[key]}));
  }

  describe('#' + propertyName + ' as Em.computed.alias', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey]);
    });

    testsCases.forEach(function (testedValue) {
      it('should be equal to the ' + JSON.stringify(dependentKey) + ' (' + Em.typeOf(testedValue) + ')', function () {
        helpers.smartStubGet(context, dependentKey, testedValue)
          .propertyDidChange(context, propertyName);
        var value = helpers.smartGet(context, propertyName);
        expect(value).to.eql(testedValue);
      });
    });

  });

};
});

require.register("test/aliases/computed/and", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var objectUtils = require('utils/object_utils');

var helpers = App.TestAliases.helpers;

function getTrulyCombination(dependentKeys) {
  var hash = {};
  dependentKeys.forEach(function (key) {
    if (key.startsWith('!')) {
      hash[key.substr(1)] = false;
    }
    else {
      hash[key] = true;
    }
  });
  return hash;
}

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string[]} dependentKeys
 */
App.TestAliases.testAsComputedAnd = function (context, propertyName, dependentKeys) {

  var realKeys = dependentKeys.map(function (key) {
    return key.startsWith('!') ? key.substr(1) : key;
  });
  var trulyCombination = getTrulyCombination(dependentKeys);
  var binaryCombos = helpers.getBinaryCombos(realKeys);

  describe('#' + propertyName + ' as Em.computed.and', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql(realKeys);
    });

    binaryCombos.forEach(function (combo) {

      var expectedResult = objectUtils.deepEqual(trulyCombination, combo);

      it('`' + expectedResult + '` for ' + JSON.stringify(combo), function() {
        helpers.smartStubGet(context, combo)
          .propertyDidChange(context, propertyName);
        var value = helpers.smartGet(context, propertyName);
        expect(value).to.equal(expectedResult);
      });

    });

  });

};
});

require.register("test/aliases/computed/countBasedMessage", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey
 * @param {string} zeroMessage
 * @param {string} oneMessage
 * @param {string} manyMessage
 */
App.TestAliases.testAsComputedCountBasedMessage = function (context, propertyName, dependentKey, zeroMessage, oneMessage, manyMessage) {

  describe('#' + propertyName + ' as Em.computed.countBasedMessage', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey]);
    });

    it('should be equal to `zeroMessage` if ' + JSON.stringify(dependentKey) + ' is 0', function () {
      helpers.smartStubGet(context, dependentKey, 0)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.equal(zeroMessage);
    });

    it('should be equal to `oneMessage` if ' + JSON.stringify(dependentKey) + ' is 1', function () {
      helpers.smartStubGet(context, dependentKey, 1)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.equal(oneMessage);
    });

    it('should be equal to `manyMessage` if ' + JSON.stringify(dependentKey) + ' is 1+', function () {
      helpers.smartStubGet(context, dependentKey, 2)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.equal(manyMessage);
    });

  });

};
});

require.register("test/aliases/computed/equal", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey
 * @param {*} neededValue
 */
App.TestAliases.testAsComputedEqual = function (context, propertyName, dependentKey, neededValue) {

  describe('#' + propertyName + ' as Em.computed.equal', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey]);
    });

    it('should be `true` if ' + JSON.stringify(dependentKey) + ' is equal to the ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, neededValue)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

    it('should be `false` if ' + JSON.stringify(dependentKey) + ' is not equal to the ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, Math.random())
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

  });

};
});

require.register("test/aliases/computed/equalProperties", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {object} context
 * @param {string} propertyName
 * @param {string} dependentKey1
 * @param {string} dependentKey2
 */
App.TestAliases.testAsComputedEqualProperties = function (context, propertyName, dependentKey1, dependentKey2) {

  describe('#' + propertyName + ' as Em.computed.equalProperties', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey1, dependentKey2]);
    });

    it('should be `true` if ' + JSON.stringify(dependentKey1) + ' is equal to ' + JSON.stringify(dependentKey2), function () {
      var someValue = '1234567';
      var hash = {};
      hash[dependentKey1] = someValue;
      hash[dependentKey2] = someValue;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

    it('should be `false` if ' + JSON.stringify(dependentKey1) + ' is not equal to ' + JSON.stringify(dependentKey2), function () {
      var hash = {};
      hash[dependentKey1] = '12345';
      hash[dependentKey2] = '54321';
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

  });

};
});

require.register("test/aliases/computed/everyBy", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} collectionName
 * @param {string} keyName
 * @param {*} neededValue
 */
App.TestAliases.testAsComputedEveryBy = function (context, propertyName, collectionName, keyName, neededValue) {

  describe('#' + propertyName + ' as Em.computed.everyBy', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([collectionName + '.@each.' + keyName]);
    });

    it('should be `true` if ' + JSON.stringify(collectionName) + ' is empty', function () {
      helpers.smartStubGet(context, collectionName, [])
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

    it('should be `false` if ' + JSON.stringify(collectionName) + ' does not exist', function () {
      helpers.smartStubGet(context, collectionName, null)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `false` if no one object in the ' + JSON.stringify(collectionName) + ' does not have ' + JSON.stringify(keyName) + ' with value equal to the ' + JSON.stringify(neededValue), function () {
      var collection = [{}, {}, {}];
      collection.setEach(keyName, !neededValue); // something that not equal to the `neededValue`
      helpers.smartStubGet(context, collectionName, collection)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `false` if at least one object in the ' + JSON.stringify(collectionName) + ' does not have ' + JSON.stringify(keyName) + ' with value equal to the ' + JSON.stringify(neededValue), function () {
      var collection = [{}, {}, {}];
      collection.setEach(keyName, neededValue);
      collection[1][keyName] = !neededValue;
      helpers.smartStubGet(context, collectionName, collection)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `true` if all objects in the ' + JSON.stringify(collectionName) + ' have ' + JSON.stringify(keyName) + ' with value equal to the ' + JSON.stringify(neededValue), function () {
      var collection = [{}, {}, {}];
      collection.setEach(keyName, neededValue);
      helpers.smartStubGet(context, collectionName, collection)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

  });

};
});

require.register("test/aliases/computed/everyByKey", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} collectionName
 * @param {string} keyName
 * @param {string} neededValueKey
 */
App.TestAliases.testAsComputedEveryByKey = function (context, propertyName, collectionName, keyName, neededValueKey) {

  describe('#' + propertyName + ' as Em.computed.everyByKey', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([collectionName + '.@each.' + keyName, neededValueKey]);
    });

    it('should be `true` if ' + JSON.stringify(collectionName) + ' is empty', function () {
      helpers.smartStubGet(context, collectionName, [])
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

    it('should be `false` if ' + JSON.stringify(collectionName) + ' does not exist', function () {
      helpers.smartStubGet(context, collectionName, null)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `false` if no one object in the ' + JSON.stringify(collectionName) + ' does not have ' + JSON.stringify(keyName) + ' with value equal to the value in ' + JSON.stringify(neededValueKey), function () {
      var collection = [{}, {}, {}];
      var neededValue = Math.random();
      collection.setEach(keyName, !neededValue); // something that not equal to the `neededValue`
      helpers.smartStubGet(context, {collectionName: collection, neededValueKey: neededValue})
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `false` if at least one object in the ' + JSON.stringify(collectionName) + ' does not have ' + JSON.stringify(keyName) + ' with value equal to the value in ' + JSON.stringify(neededValueKey), function () {
      var collection = [{}, {}, {}];
      var neededValue = Math.random();
      collection.setEach(keyName, neededValue);
      collection[1][keyName] = !neededValue;
      helpers.smartStubGet(context, {collectionName: collection, neededValueKey: neededValue})
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `true` if all objects in the ' + JSON.stringify(collectionName) + ' have ' + JSON.stringify(keyName) + ' with value equal to the value in ' + JSON.stringify(neededValueKey), function () {
      var collection = [{}, {}, {}];
      var neededValue = Math.random();
      collection.setEach(keyName, neededValue);
      var hash = {};
      hash[collectionName] = collection;
      hash[neededValueKey] = neededValue;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

  });

};
});

require.register("test/aliases/computed/existsIn", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey
 * @param {array} neededValues
 */
App.TestAliases.testAsComputedExistsIn = function (context, propertyName, dependentKey, neededValues) {

  describe('#' + propertyName + ' as Em.computed.existsIn', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey]);
    });

    neededValues.forEach(function (neededValue) {

      it('should be `true` if ' + JSON.stringify(dependentKey) + ' is equal to ' + JSON.stringify(neededValue), function () {
        helpers.smartStubGet(context, dependentKey, neededValue)
          .propertyDidChange(context, propertyName);
        var value = helpers.smartGet(context, propertyName);
        expect(value).to.be.true;
      });

    });

  });

};
});

require.register("test/aliases/computed/filterBy", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} collectionName
 * @param {string} keyName
 * @param {*} neededValue
 */
App.TestAliases.testAsComputedFilterBy = function (context, propertyName, collectionName, keyName, neededValue) {

  describe('#' + propertyName + ' as Em.computed.filterBy', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([collectionName + '.@each.' + keyName]);
    });

    it('should be `[]` if ' + JSON.stringify(collectionName) + ' is empty', function () {
      helpers.smartStubGet(context, collectionName, [])
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.eql([]);
    });

    it('should be `[]` if ' + JSON.stringify(collectionName) + ' does not exist', function () {
      helpers.smartStubGet(context, collectionName, null)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.eql([]);
    });

    it('should be an array objects from  ' + JSON.stringify(collectionName) + ' with ' + JSON.stringify(keyName) + ' equal to the ' + JSON.stringify(neededValue), function () {
      var collection = [{}, {}, {}];
      collection.forEach(function (item) {
        Ember.setFullPath(item, keyName, neededValue);
      });

      collection.setEach(keyName, neededValue);
      Em.set(collection[2], keyName, !neededValue);
      helpers.smartStubGet(context, collectionName, collection)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.eql(collection.slice(0, 2));
    });

  });

};
});

require.register("test/aliases/computed/filterByKey", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} collectionName
 * @param {string} keyName
 * @param {string} neededValueKey
 */
App.TestAliases.testAsComputedFilterByKey = function (context, propertyName, collectionName, keyName, neededValueKey) {

  describe('#' + propertyName + ' as Em.computed.filterByKey', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([collectionName + '.@each.' + keyName, neededValueKey]);
    });

    it('should be `[]` if ' + JSON.stringify(collectionName) + ' is empty', function () {
      helpers.smartStubGet(context, collectionName, [])
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.eql([]);
    });

    it('should be `[]` if ' + JSON.stringify(collectionName) + ' does not exist', function () {
      helpers.smartStubGet(context, collectionName, null)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.eql([]);
    });

    it('should be an array objects from  ' + JSON.stringify(collectionName) + ' with ' + JSON.stringify(keyName) + ' equal to the value in ' + JSON.stringify(neededValueKey), function () {
      var collection = [{}, {}, {}];
      var neededValue = Math.random();
      collection.forEach(function (item) {
        Ember.setFullPath(item, keyName, neededValue);
      });

      Em.set(collection[2], keyName, !neededValue);
      var hash = {};
      hash[collectionName] = collection;
      hash[neededValueKey] = neededValue;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.eql(collection.slice(0, 2));
    });

  });

};
});

require.register("test/aliases/computed/findBy", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} collectionName
 * @param {string} keyName
 * @param {*} neededValue
 */
App.TestAliases.testAsComputedFindBy = function (context, propertyName, collectionName, keyName, neededValue) {

  describe('#' + propertyName + ' as Em.computed.findBy', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([collectionName + '.@each.' + keyName]);
    });

    it('should be `undefined` if ' + JSON.stringify(collectionName) + ' is empty', function () {
      helpers.smartStubGet(context, collectionName, [])
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.undefined;
    });

    it('should be `null` if ' + JSON.stringify(collectionName) + ' does not exist', function () {
      helpers.smartStubGet(context, collectionName, null)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.null;
    });

    it('should be a first object from ' + JSON.stringify(collectionName) + ' with ' + JSON.stringify(keyName) + ' equal to the ' + JSON.stringify(neededValue), function () {
      var collection = [{i: 0}, {i: 1}, {i: 2}];
      collection.forEach(function (item) {
        Ember.setFullPath(item, keyName, neededValue)
      });
      Em.set(collection[2], keyName, !neededValue);
      helpers.smartStubGet(context, collectionName, collection)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.eql(collection[0]);
    });

  });

};
});

require.register("test/aliases/computed/findByKey", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} collectionName
 * @param {string} keyName
 * @param {string} neededValueKey
 */
App.TestAliases.testAsComputedFindByKey = function (context, propertyName, collectionName, keyName, neededValueKey) {

  describe('#' + propertyName + ' as Em.computed.findByKey', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([collectionName + '.@each.' + keyName, neededValueKey]);
    });

    it('should be `undefined` if ' + JSON.stringify(collectionName) + ' is empty', function () {
      helpers.smartStubGet(context, collectionName, [])
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.undefined;
    });

    it('should be `null` if ' + JSON.stringify(collectionName) + ' does not exist', function () {
      helpers.smartStubGet(context, collectionName, null)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.null;
    });

    it('should be a first object from ' + JSON.stringify(collectionName) + ' with ' + JSON.stringify(keyName) + ' equal to the value in ' + JSON.stringify(neededValueKey), function () {
      var collection = [{i: 0}, {i: 1}, {i: 2}];
      var neededValue = Math.random();
      collection.forEach(function (item) {
        Ember.setFullPath(item, keyName, neededValue)
      });
      Em.set(collection[2], keyName, !neededValue);
      var hash = {};
      hash[collectionName] = collection;
      hash[neededValueKey] = neededValue;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.eql(collection[0]);
    });

  });

};
});

require.register("test/aliases/computed/firstNotBlank", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

function prepareHash(dependentKeys, index) {
  var hash = {};
  dependentKeys.forEach(function (key, i) {
    hash[key] = i < index ? null : '' + i;
  });
  return hash;
}

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string[]} dependentKeys
 */
App.TestAliases.testAsComputedFirstNotBlank = function (context, propertyName, dependentKeys) {

  describe('#' + propertyName + ' as Em.computed.firstNotBlank', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql(dependentKeys);
    });

    dependentKeys.forEach(function(dependentKey, index) {

      it('should be equal to the ' + JSON.stringify(dependentKey), function () {
        helpers.smartStubGet(context, prepareHash(dependentKeys, index))
          .propertyDidChange(context, propertyName);
        var value = helpers.smartGet(context, propertyName);
        expect(value).to.equal('' + index);
      });

    });

  });

};
});

require.register("test/aliases/computed/formatUnavailable", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey
 */
App.TestAliases.testAsComputedFormatNa = function (context, propertyName, dependentKey) {

  describe('#' + propertyName + ' as Em.computed.formatUnavailable', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey]);
    });

    it('should be `0` if ' + JSON.stringify(dependentKey) + ' is  `0`', function () {
      helpers.smartStubGet(context, dependentKey, 0)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.equal(0);
    });

    it('should be `12` if ' + JSON.stringify(dependentKey) + ' is `12`', function () {
      helpers.smartStubGet(context, dependentKey, 12)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.equal(12);
    });

    it('should be `n/a` if ' + JSON.stringify(dependentKey) + ' is not number >= 0', function () {
      helpers.smartStubGet(context, dependentKey, null)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.equal(Em.I18n.t('services.service.summary.notAvailable'));
    });

  });

};
});

require.register("test/aliases/computed/getByKey", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} objectKey
 * @param {string} propertyKey
 * @param {{defaultValue: *, map: object}} [checks]
 */
App.TestAliases.testAsComputedGetByKey = function (context, propertyName, objectKey, propertyKey, checks) {

  var _checks = checks || {};
  var obj = _checks.map || Em.get(context, objectKey);
  var defaultValueIsSet = _checks.hasOwnProperty('defaultValue');

  describe('#' + propertyName + ' as Em.computed.getByKey', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([objectKey, propertyKey]);
    });

    Object.keys(obj).forEach(function (key) {
      var expectedValue = obj[key];
      it('should be `' + JSON.stringify(expectedValue) + '` if ' + JSON.stringify(propertyKey) + ' is ' + JSON.stringify(key), function () {
        helpers.smartStubGet(context, propertyKey, key)
          .propertyDidChange(context, propertyName);
        var value = helpers.smartGet(context, propertyName);
        expect(value).to.be.eql(expectedValue);
      });
    });

    if (defaultValueIsSet) {
      var defaultValue = _checks.defaultValue;
      it('should be `' + JSON.stringify(defaultValue) + '` if ' + JSON.stringify(propertyKey) + ' is not exist in the tested object', function () {
        helpers.smartStubGet(context, propertyKey, '' + Math.random())
          .propertyDidChange(context, propertyName);
        var value = helpers.smartGet(context, propertyName);
        expect(value).to.be.eql(defaultValue);
      });
    }

  });

};
});

require.register("test/aliases/computed/gt", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey
 * @param {number} neededValue
 */
App.TestAliases.testAsComputedGt = function (context, propertyName, dependentKey, neededValue) {

  describe('#' + propertyName + ' as Em.computed.gt', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey]);
    });

    it('should be `true` if ' + JSON.stringify(dependentKey) + ' is greater than ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, neededValue + 1)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

    it('should be `false` if ' + JSON.stringify(dependentKey) + ' is equal to ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, neededValue)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `false` if ' + JSON.stringify(dependentKey) + ' is lower than ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, neededValue - 1)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

  });

};
});

require.register("test/aliases/computed/gtProperties", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey1
 * @param {string} dependentKey2
 */
App.TestAliases.testAsComputedGtProperties = function (context, propertyName, dependentKey1, dependentKey2) {

  describe('#' + propertyName + ' as Em.computed.gtProperties', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey1, dependentKey2]);
    });

    it('should be `true` if ' + JSON.stringify(dependentKey1) + ' is greater than ' + JSON.stringify(dependentKey2), function () {
      var hash = {};
      hash[dependentKey1] = 6;
      hash[dependentKey2] = 5;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

    it('should be `false` if ' + JSON.stringify(dependentKey1) + ' is equal to ' + JSON.stringify(dependentKey2), function () {
      var hash = {};
      hash[dependentKey1] = 5;
      hash[dependentKey2] = 5;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `true` if ' + JSON.stringify(dependentKey1) + ' is lower than ' + JSON.stringify(dependentKey2), function () {
      var hash = {};
      hash[dependentKey1] = 4;
      hash[dependentKey2] = 5;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

  });

};

});

require.register("test/aliases/computed/gte", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey
 * @param {number} neededValue
 */
App.TestAliases.testAsComputedGte = function (context, propertyName, dependentKey, neededValue) {

  describe('#' + propertyName + ' as Em.computed.gte', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey]);
    });

    it('should be `true` if ' + JSON.stringify(dependentKey) + ' is greater than ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, neededValue + 1)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

    it('should be `true` if ' + JSON.stringify(dependentKey) + ' is equal to ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, neededValue)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

    it('should be `false` if ' + JSON.stringify(dependentKey) + ' is lower than ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, neededValue - 1)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

  });

};
});

require.register("test/aliases/computed/gteProperties", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey1
 * @param {string} dependentKey2
 */
App.TestAliases.testAsComputedGteProperties = function (context, propertyName, dependentKey1, dependentKey2) {

  describe('#' + propertyName + ' as Em.computed.gteProperties', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey1, dependentKey2]);
    });

    it('should be `true` if ' + JSON.stringify(dependentKey1) + ' is greater than ' + JSON.stringify(dependentKey2), function () {
      var hash = {};
      hash[dependentKey1] = 6;
      hash[dependentKey2] = 5;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

    it('should be `true` if ' + JSON.stringify(dependentKey1) + ' is equal to ' + JSON.stringify(dependentKey2), function () {
      var hash = {};
      hash[dependentKey1] = 5;
      hash[dependentKey2] = 5;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

    it('should be `true` if ' + JSON.stringify(dependentKey1) + ' is lower than ' + JSON.stringify(dependentKey2), function () {
      var hash = {};
      hash[dependentKey1] = 4;
      hash[dependentKey2] = 5;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

  });

};
});

require.register("test/aliases/computed/ifThenElse", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey
 * @param {*} trueValue
 * @param {*} falseValue
 */
App.TestAliases.testAsComputedIfThenElse = function (context, propertyName, dependentKey, trueValue, falseValue) {

  describe('#' + propertyName + ' as Em.computed.ifThenElse', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey]);
    });

    it('should be `trueValue` if ' + JSON.stringify(dependentKey) + ' is `true`', function () {
      helpers.smartStubGet(context, dependentKey, true)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.equal(trueValue);
    });

    it('should be `falseValue` if ' + JSON.stringify(dependentKey) + ' is `false`', function () {
      helpers.smartStubGet(context, dependentKey, false)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.equal(falseValue);
    });

  });

};
});

require.register("test/aliases/computed/lt", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey
 * @param {number} neededValue
 */
App.TestAliases.testAsComputedLt = function (context, propertyName, dependentKey, neededValue) {

  describe('#' + propertyName + ' as Em.computed.lt', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey]);
    });

    it('should be `false` if ' + JSON.stringify(dependentKey) + ' is greater than ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, neededValue + 1)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `false` if ' + JSON.stringify(dependentKey) + ' is equal to ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, neededValue)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `true` if ' + JSON.stringify(dependentKey) + ' is lower than ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, neededValue - 1)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

  });

};
});

require.register("test/aliases/computed/ltProperties", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey1
 * @param {string} dependentKey2
 */
App.TestAliases.testAsComputedLtProperties = function (context, propertyName, dependentKey1, dependentKey2) {

  describe('#' + propertyName + ' as Em.computed.lteProperties', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey1, dependentKey2]);
    });

    it('should be `false` if ' + JSON.stringify(dependentKey1) + ' is greater than ' + JSON.stringify(dependentKey2), function () {
      var hash = {};
      hash[dependentKey1] = 6;
      hash[dependentKey2] = 5;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `false` if ' + JSON.stringify(dependentKey1) + ' is equal to ' + JSON.stringify(dependentKey2), function () {
      var hash = {};
      hash[dependentKey1] = 5;
      hash[dependentKey2] = 5;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `true` if ' + JSON.stringify(dependentKey1) + ' is lower than ' + JSON.stringify(dependentKey2), function () {
      var hash = {};
      hash[dependentKey1] = 4;
      hash[dependentKey2] = 5;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

  });

};
});

require.register("test/aliases/computed/lte", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey
 * @param {number} neededValue
 */
App.TestAliases.testAsComputedLte = function (context, propertyName, dependentKey, neededValue) {

  describe('#' + propertyName + ' as Em.computed.lte', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey]);
    });

    it('should be `false` if ' + JSON.stringify(dependentKey) + ' is greater than ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, neededValue + 1)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `true` if ' + JSON.stringify(dependentKey) + ' is equal to ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, neededValue)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

    it('should be `true` if ' + JSON.stringify(dependentKey) + ' is lower than ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, neededValue - 1)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

  });

};
});

require.register("test/aliases/computed/lteProperties", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey1
 * @param {string} dependentKey2
 */
App.TestAliases.testAsComputedLteProperties = function (context, propertyName, dependentKey1, dependentKey2) {

  describe('#' + propertyName + ' as Em.computed.lteProperties', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey1, dependentKey2]);
    });

    it('should be `false` if ' + JSON.stringify(dependentKey1) + ' is greater than ' + JSON.stringify(dependentKey2), function () {
      var hash = {};
      hash[dependentKey1] = 6;
      hash[dependentKey2] = 5;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `true` if ' + JSON.stringify(dependentKey1) + ' is equal to ' + JSON.stringify(dependentKey2), function () {
      var hash = {};
      hash[dependentKey1] = 5;
      hash[dependentKey2] = 5;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

    it('should be `true` if ' + JSON.stringify(dependentKey1) + ' is lower than ' + JSON.stringify(dependentKey2), function () {
      var hash = {};
      hash[dependentKey1] = 4;
      hash[dependentKey2] = 5;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

  });

};
});

require.register("test/aliases/computed/mapBy", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} collectionName
 * @param {string} keyName
 */
App.TestAliases.testAsComputedMapBy = function (context, propertyName, collectionName, keyName) {

  describe('#' + propertyName + ' as Em.computed.mapBy', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([collectionName + '.@each.' + keyName]);
    });

    it('should be `[]` if ' + JSON.stringify(collectionName) + ' is empty', function () {
      helpers.smartStubGet(context, collectionName, [])
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.eql([]);
    });

    it('should be `[]` if ' + JSON.stringify(collectionName) + ' does not exist', function () {
      helpers.smartStubGet(context, collectionName, null)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.eql([]);
    });

    it('should be an array with values of each ' + JSON.stringify(keyName) + ' in the ' + JSON.stringify(collectionName), function () {
      var collection = [{}, {}, {}];
      collection.forEach(function (item, index) {
        Ember.setFullPath(item, keyName, index);
      });
      helpers.smartStubGet(context, collectionName, collection)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.eql([0, 1, 2]);
    });

  });

};
});

require.register("test/aliases/computed/notEqual", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey
 * @param {*} neededValue
 */
App.TestAliases.testAsComputedNotEqual = function (context, propertyName, dependentKey, neededValue) {

  describe('#' + propertyName + ' as Em.computed.notEqual', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey]);
    });

    it('should be `false` if ' + JSON.stringify(dependentKey) + ' is equal to the ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, neededValue)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `true` if ' + JSON.stringify(dependentKey) + ' is not equal to the ' + JSON.stringify(neededValue), function () {
      helpers.smartStubGet(context, dependentKey, Math.random())
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

  });

};
});

require.register("test/aliases/computed/notEqualProperties", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {object} context
 * @param {string} propertyName
 * @param {string} dependentKey1
 * @param {string} dependentKey2
 */
App.TestAliases.testAsComputedNotEqualProperties = function (context, propertyName, dependentKey1, dependentKey2) {

  describe('#' + propertyName + ' as Em.computed.notEqualProperties', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey1, dependentKey2]);
    });

    it('should be `false` if ' + JSON.stringify(dependentKey1) + ' is equal to the ' + JSON.stringify(dependentKey2), function () {
      var someValue = '1234567';
      var hash = {};
      hash[dependentKey1] = someValue;
      hash[dependentKey2] = someValue;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `true` if ' + JSON.stringify(dependentKey1) + ' is not equal to the ' + JSON.stringify(dependentKey2), function () {
      var hash = {};
      hash[dependentKey1] = '12345';
      hash[dependentKey2] = '54321';
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

  });

};
});

require.register("test/aliases/computed/notExistsIn", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey
 * @param {array} neededValues
 */
App.TestAliases.testAsComputedNotExistsIn = function (context, propertyName, dependentKey, neededValues) {

  describe('#' + propertyName + ' as Em.computed.notExistsIn', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey]);
    });

    neededValues.forEach(function (neededValue) {

      it('should be `false` if ' + JSON.stringify(dependentKey) + ' is equal to ' + JSON.stringify(neededValue), function () {
        helpers.smartStubGet(context, dependentKey, neededValue)
          .propertyDidChange(context, propertyName);
        var value = helpers.smartGet(context, propertyName);
        expect(value).to.be.false;
      });

    });

  });

};
});

require.register("test/aliases/computed/or", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var objectUtils = require('utils/object_utils');

var helpers = App.TestAliases.helpers;

function getFalsyCombination(dependentKeys) {
  var hash = {};
  dependentKeys.forEach(function (key) {
    if (key.startsWith('!')) {
      hash[key.substr(1)] = true;
    }
    else {
      hash[key] = false;
    }
  });
  return hash;
}


/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string[]} dependentKeys
 */
App.TestAliases.testAsComputedOr = function (context, propertyName, dependentKeys) {

  var realKeys = dependentKeys.map(function (key) {
    return key.startsWith('!') ? key.substr(1) : key;
  });
  var falsyCombination = getFalsyCombination(dependentKeys);
  var binaryCombos = helpers.getBinaryCombos(realKeys);

  describe('#' + propertyName + ' as Em.computed.or', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql(realKeys);
    });

    binaryCombos.forEach(function (combo) {

      var expectedResult = !objectUtils.deepEqual(falsyCombination, combo);

      it('`' + expectedResult + '` for ' + JSON.stringify(combo), function() {
        helpers.smartStubGet(context, combo)
          .propertyDidChange(context, propertyName);
        var value = helpers.smartGet(context, propertyName);
        expect(value).to.equal(expectedResult);
      });

    });

  });

};
});

require.register("test/aliases/computed/percents", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey1
 * @param {string} dependentKey2
 * @param {number} [accuracy=0]
 */
App.TestAliases.testAsComputedPercents = function (context, propertyName, dependentKey1, dependentKey2, accuracy) {

  describe('#' + propertyName + ' as Em.computed.percents', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey1, dependentKey2]);
    });

    it('should be calculated with ' + JSON.stringify(dependentKey1) + ' and ' + JSON.stringify(dependentKey2), function() {
      var hash = {};
      hash[dependentKey1] = 10;
      hash[dependentKey2] = 20;
      var result = 10 / 20 * 100;
      result = accuracy ? parseFloat(result.toFixed(accuracy)) : Math.round(result);
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.equal(result);
    });

  });

};
});

require.register("test/aliases/computed/someBy", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} collectionName
 * @param {string} keyName
 * @param {*} neededValue
 */
App.TestAliases.testAsComputedSomeBy = function (context, propertyName, collectionName, keyName, neededValue) {

  describe('#' + propertyName + ' as Em.computed.someBy', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([collectionName + '.@each.' + keyName]);
    });

    it('should be `false` if ' + JSON.stringify(collectionName) + ' is empty', function () {
      helpers.smartStubGet(context, collectionName, [])
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `false` if ' + JSON.stringify(collectionName) + ' does not exist', function () {
      helpers.smartStubGet(context, collectionName, null)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `false` if no one object in the ' + JSON.stringify(collectionName) + ' does not have ' + JSON.stringify(keyName) + ' with value equal to the ' + JSON.stringify(neededValue), function () {
      var collection = [{}, {}, {}];
      collection.setEach(keyName, !neededValue); // something that not equal to the `neededValue`
      helpers.smartStubGet(context, collectionName, collection)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `true` if at least one object in the ' + JSON.stringify(collectionName) + ' has ' + JSON.stringify(keyName) + ' with value equal to the ' + JSON.stringify(neededValue), function () {
      var collection = [{}, {}, {}];
      collection.setEach(keyName, !neededValue);
      collection.forEach(function (item) {
        Em.setFullPath(item, keyName, !neededValue);
      });
      Em.set(collection[1], keyName, neededValue);
      helpers.smartStubGet(context, collectionName, collection)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

    it('should be `true` if all objects in the ' + JSON.stringify(collectionName) + ' have ' + JSON.stringify(keyName) + ' with value equal to the ' + JSON.stringify(neededValue), function () {
      var collection = [{}, {}, {}];
      collection.forEach(function (item) {
        Em.setFullPath(item, keyName, neededValue);
      });
      helpers.smartStubGet(context, collectionName, collection)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

  });

};
});

require.register("test/aliases/computed/someByKey", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} collectionName
 * @param {string} keyName
 * @param {string} neededValueKey
 */
App.TestAliases.testAsComputedSomeByKey = function (context, propertyName, collectionName, keyName, neededValueKey) {

  describe('#' + propertyName + ' as Em.computed.someByKey', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([collectionName + '.@each.' + keyName, neededValueKey]);
    });

    it('should be `false` if ' + JSON.stringify(collectionName) + ' is empty', function () {
      helpers.smartStubGet(context, collectionName, [])
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `false` if ' + JSON.stringify(collectionName) + ' does not exist', function () {
      helpers.smartStubGet(context, collectionName, null)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `false` if no one object in the ' + JSON.stringify(collectionName) + ' does not have ' + JSON.stringify(keyName) + ' with value equal to the value in ' + JSON.stringify(neededValueKey), function () {
      var collection = [{}, {}, {}];
      var neededValue = Math.random();
      collection.setEach(keyName, !neededValue); // something that not equal to the `neededValue`
      helpers.smartStubGet(context, {collectionName: collection, neededValueKey: neededValue})
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.false;
    });

    it('should be `true` if at least one object in the ' + JSON.stringify(collectionName) + ' has ' + JSON.stringify(keyName) + ' with value equal to the value in ' + JSON.stringify(neededValueKey), function () {
      var collection = [{}, {}, {}];
      var neededValue = Math.random();
      collection.setEach(keyName, !neededValue);
      collection.forEach(function (item) {
        Em.setFullPath(item, keyName, !neededValue);
      });
      Em.set(collection[1], keyName, neededValue);
      helpers.smartStubGet(context, {collectionName: collection, neededValueKey: neededValue})
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

    it('should be `true` if all objects in the ' + JSON.stringify(collectionName) + ' have ' + JSON.stringify(keyName) + ' with value equal to the value in ' + JSON.stringify(neededValueKey), function () {
      var collection = [{}, {}, {}];
      var neededValue = Math.random();
      collection.forEach(function (item) {
        Em.setFullPath(item, keyName, neededValue);
      });
      var hash = {};
      hash[collectionName] = collection;
      hash[neededValueKey] = neededValue;
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.true;
    });

  });

};
});

require.register("test/aliases/computed/sumBy", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} collectionName
 * @param {string} keyName
 */
App.TestAliases.testAsComputedSumBy = function (context, propertyName, collectionName, keyName) {

  describe('#' + propertyName + ' as Em.computed.sumBy', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([collectionName + '.@each.' + keyName]);
    });

    it('should be `0` if ' + JSON.stringify(collectionName) + ' is empty', function () {
      helpers.smartStubGet(context, collectionName, [])
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.equal(0);
    });

    it('should be `0` if ' + JSON.stringify(collectionName) + ' does not exist', function () {
      helpers.smartStubGet(context, collectionName, null)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.equal(0);
    });

    it('should be a sum of the values of each ' + JSON.stringify(keyName) + ' in the ' + JSON.stringify(collectionName), function () {
      var collection = [{}, {}, {}];
      collection.forEach(function (item, index) {
        Ember.setFullPath(item, keyName, index);
      });
      helpers.smartStubGet(context, collectionName, collection)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.equal(3); // 0 + 1 + 2
    });

  });

};
});

require.register("test/aliases/computed/sumProperties", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string[]} dependentKeys
 */
App.TestAliases.testAsComputedSumProperties = function (context, propertyName, dependentKeys) {

  describe('#' + propertyName + ' as Em.computed.sumProperties', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql(dependentKeys);
    });

    it('should calculate sum of the ' + JSON.stringify(dependentKeys), function () {
      var hash = {};
      var result = 0;
      dependentKeys.forEach(function (k, i) {
        hash[k] = i;
        result += i;
      });
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.equal(result);
    });

    it('should calculate sum of the ' + JSON.stringify(dependentKeys) + ' (2)', function () {
      var hash = {};
      var result = 0;
      dependentKeys.forEach(function (k, i) {
        hash[k] = i * 2;
        result += i * 2;
      });
      helpers.smartStubGet(context, hash)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.equal(result);
    });

  });

};
});

require.register("test/aliases/computed/truncate", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var helpers = App.TestAliases.helpers;

var strTemplate = '0123456789';

/**
 * 10 -> '0123456789'
 *  5 -> '01234'
 * 15 -> '012345678901234'
 *
 * @param length
 * @returns {string}
 */
function getStr(length) {
  var ret = '';
  var n = Math.floor(length / 10);
  var m = length % 10;
  for (var i = 0; i < n; i++) {
    ret += strTemplate;
  }
  ret += strTemplate.substr(0, m);
  return ret;
}

/**
 *
 * @param {Em.Object} context
 * @param {string} propertyName
 * @param {string} dependentKey
 * @param {number} maxLength
 * @param {number} reduceTo
 * @param {string} [replacer]
 */
App.TestAliases.testAsComputedTruncate = function (context, propertyName, dependentKey, maxLength, reduceTo, replacer) {

  var _replacer = arguments.length > 5 ? replacer : '...';

  describe('#' + propertyName + ' as Em.computed.truncate', function () {

    afterEach(function () {
      helpers.smartRestoreGet(context);
    });

    it('has valid dependent keys', function () {
      expect(Em.meta(context).descs[propertyName]._dependentKeys).to.eql([dependentKey]);
    });

    it('should be truncated if `maxLength` > ' + JSON.stringify(dependentKey) + ' length', function () {
      var val = getStr(maxLength + 1);
      var expectedValue = val.substr(0, reduceTo) + _replacer;
      helpers.smartStubGet(context, dependentKey, val)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.equal(expectedValue);
    });

    it('should not be truncated if `maxLength` = ' + JSON.stringify(dependentKey) + ' length', function () {
      var val = getStr(maxLength);
      var expectedValue = val;
      helpers.smartStubGet(context, dependentKey, val)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.equal(expectedValue);
    });

    it('should not be truncated if `maxLength` < ' + JSON.stringify(dependentKey) + ' length', function () {
      var val = getStr(maxLength - 1);
      var expectedValue = val;
      helpers.smartStubGet(context, dependentKey, val)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.equal(expectedValue);
    });

    it('should be "" if ' + JSON.stringify(dependentKey) + ' value is empty', function () {
      var val = null;
      var expectedValue = '';
      helpers.smartStubGet(context, dependentKey, val)
        .propertyDidChange(context, propertyName);
      var value = helpers.smartGet(context, propertyName);
      expect(value).to.be.equal(expectedValue);
    });

  });

};
});

require.register("test/app_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/quick_view_link_view');
require('models/host_component');
require('models/stack_service_component');
App.auth = ["AMBARI.ADD_DELETE_CLUSTERS", "AMBARI.ASSIGN_ROLES", "AMBARI.EDIT_STACK_REPOS", "AMBARI.MANAGE_GROUPS", "AMBARI.MANAGE_STACK_VERSIONS", "AMBARI.MANAGE_USERS", "AMBARI.MANAGE_VIEWS", "AMBARI.RENAME_CLUSTER", "SERVICE.SET_SERVICE_USERS_GROUPS", "CLUSTER.TOGGLE_ALERTS", "CLUSTER.TOGGLE_KERBEROS", "CLUSTER.UPGRADE_DOWNGRADE_STACK", "CLUSTER.VIEW_ALERTS", "CLUSTER.VIEW_CONFIGS", "CLUSTER.VIEW_METRICS", "CLUSTER.VIEW_STACK_DETAILS", "CLUSTER.VIEW_STATUS_INFO", "HOST.ADD_DELETE_COMPONENTS", "HOST.ADD_DELETE_HOSTS", "HOST.TOGGLE_MAINTENANCE", "HOST.VIEW_CONFIGS", "HOST.VIEW_METRICS", "HOST.VIEW_STATUS_INFO", "SERVICE.ADD_DELETE_SERVICES", "SERVICE.COMPARE_CONFIGS", "SERVICE.DECOMMISSION_RECOMMISSION", "SERVICE.ENABLE_HA", "SERVICE.MANAGE_CONFIG_GROUPS", "SERVICE.MODIFY_CONFIGS", "SERVICE.MOVE", "SERVICE.RUN_CUSTOM_COMMAND", "SERVICE.RUN_SERVICE_CHECK", "SERVICE.START_STOP", "SERVICE.TOGGLE_ALERTS", "SERVICE.TOGGLE_MAINTENANCE", "SERVICE.VIEW_ALERTS", "SERVICE.VIEW_CONFIGS", "SERVICE.VIEW_METRICS", "SERVICE.VIEW_STATUS_INFO", "VIEW.USE"];

describe('App', function () {

  describe('#stackVersionURL', function () {

    App.set('defaultStackVersion', "HDP-1.2.2");
    App.set('currentStackVersion', "HDP-1.2.2");

    var testCases = [
      {
        title: 'if currentStackVersion and defaultStackVersion are empty then stackVersionURL should contain prefix',
        currentStackVersion: '',
        defaultStackVersion: '',
        result: '/stacks/HDP/versions/'
      },
      {
        title: 'if currentStackVersion is "HDP-1.3.1" then stackVersionURL should be "/stacks/HDP/versions/1.3.1"',
        currentStackVersion: 'HDP-1.3.1',
        defaultStackVersion: '',
        result: '/stacks/HDP/versions/1.3.1'
      },
      {
        title: 'if defaultStackVersion is "HDP-1.3.1" then stackVersionURL should be "/stacks/HDP/versions/1.3.1"',
        currentStackVersion: '',
        defaultStackVersion: 'HDP-1.3.1',
        result: '/stacks/HDP/versions/1.3.1'
      },
      {
        title: 'if defaultStackVersion and currentStackVersion are different then stackVersionURL should have currentStackVersion value',
        currentStackVersion: 'HDP-1.3.2',
        defaultStackVersion: 'HDP-1.3.1',
        result: '/stacks/HDP/versions/1.3.2'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        App.set('defaultStackVersion', test.defaultStackVersion);
        App.set('currentStackVersion', test.currentStackVersion);
        expect(App.get('stackVersionURL')).to.equal(test.result);
        App.set('defaultStackVersion', "HDP-1.2.2");
        App.set('currentStackVersion', "HDP-1.2.2");
      });
    });
  });

  describe('#falconServerURL', function () {

    var testCases = [
      {
        title: 'No services installed, url should be empty',
        service: Em.A([]),
        result: ''
      },
      {
        title: 'FALCON is not installed, url should be empty',
        service: Em.A([
          {
            serviceName: 'HDFS'
          }
        ]),
        result: ''
      },
      {
        title: 'FALCON is installed, url should be "host1"',
        service: Em.A([
          Em.Object.create({
            serviceName: 'FALCON',
            hostComponents: [
              Em.Object.create({
                componentName: 'FALCON_SERVER',
                hostName: 'host1'
              })
            ]
          })
        ]),
        result: 'host1'
      }
    ];

    testCases.forEach(function (test) {
      describe(test.title, function () {

        beforeEach(function () {
          sinon.stub(App.Service, 'find', function () {
            return test.service;
          });
        });

        afterEach(function () {
          App.Service.find.restore();
        });

        it('App.falconServerURL is ' + test.result, function () {
          expect(App.get('falconServerURL')).to.equal(test.result);
        });

      });
    });
  });

  describe('#currentStackVersionNumber', function () {

    var testCases = [
      {
        title: 'if currentStackVersion is empty then currentStackVersionNumber should be empty',
        currentStackVersion: '',
        result: ''
      },
      {
        title: 'if currentStackVersion is "HDP-1.3.1" then currentStackVersionNumber should be "1.3.1',
        currentStackVersion: 'HDP-1.3.1',
        result: '1.3.1'
      },
      {
        title: 'if currentStackVersion is "HDPLocal-1.3.1" then currentStackVersionNumber should be "1.3.1',
        currentStackVersion: 'HDPLocal-1.3.1',
        result: '1.3.1'
      }
    ];
    before(function () {
      App.set('defaultStackVersion', '');
    });
    after(function () {
      App.set('defaultStackVersion', 'HDP-2.0.5');
    });
    testCases.forEach(function (test) {
      it(test.title, function () {
        App.set('currentStackVersion', test.currentStackVersion);
        expect(App.get('currentStackVersionNumber')).to.equal(test.result);
        App.set('currentStackVersion', "HDP-1.2.2");
      });
    });
  });

  describe('#isHaEnabled when HDFS is installed:', function () {

    beforeEach(function () {
      sinon.stub(App.Service, 'find').returns(Em.Object.create({'isLoaded': true}));
      this.mock = sinon.stub(App.HostComponent, 'find');
    });
    afterEach(function () {
      App.Service.find.restore();
      this.mock.restore();
    });

    it('if hadoop stack version higher than 2 then isHaEnabled should be true', function () {
      this.mock.returns([]);
      App.propertyDidChange('isHaEnabled');
      expect(App.get('isHaEnabled')).to.equal(true);
    });
    it('if cluster has SECONDARY_NAMENODE then isHaEnabled should be false', function () {
      this.mock.returns([Em.Object.create({componentName: 'SECONDARY_NAMENODE'})]);
      App.propertyDidChange('isHaEnabled');
      expect(App.get('isHaEnabled')).to.equal(false);
    });
  });

  describe('#isHaEnabled when HDFS is not installed:', function () {

    beforeEach(function () {
      sinon.stub(App.Service, 'find').returns(Em.Object.create({'isLoaded': false}));
    });
    afterEach(function () {
      App.Service.find.restore();
    });

    it('if hadoop stack version higher than 2 but HDFS not installed then isHaEnabled should be false', function () {
      App.set('currentStackVersion', 'HDP-2.1');
      expect(App.get('isHaEnabled')).to.equal(false);
      App.set('currentStackVersion', "HDP-1.2.2");
    });

  });


  describe('#services', function () {
    var stackServices = [
      Em.Object.create({
        serviceName: 'S1',
        isClientOnlyService: true
      }),
      Em.Object.create({
        serviceName: 'S2',
        hasClient: true
      }),
      Em.Object.create({
        serviceName: 'S3',
        hasMaster: true
      }),
      Em.Object.create({
        serviceName: 'S4',
        hasSlave: true
      }),
      Em.Object.create({
        serviceName: 'S5',
        isNoConfigTypes: true
      }),
      Em.Object.create({
        serviceName: 'S6',
        isMonitoringService: true
      }),
      Em.Object.create({
        serviceName: 'S7'
      })
    ];

    beforeEach(function () {
      sinon.stub(App.StackService, 'find', function () {
        return stackServices;
      });
    });

    afterEach(function () {
      App.StackService.find.restore();
    });

    it('App.services.all', function () {
      expect(App.get('services.all')).to.eql(['S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7']);
    });

    it('App.services.clientOnly', function () {
      expect(App.get('services.clientOnly')).to.eql(['S1']);
    });

    it('App.services.hasClient', function () {
      expect(App.get('services.hasClient')).to.eql(['S2']);
    });

    it('App.services.hasMaster', function () {
      expect(App.get('services.hasMaster')).to.eql(['S3']);
    });

    it('App.services.hasSlave', function () {
      expect(App.get('services.hasSlave')).to.eql(['S4']);
    });

    it('App.services.noConfigTypes', function () {
      expect(App.get('services.noConfigTypes')).to.eql(['S5']);
    });

    it('App.services.monitoring', function () {
      expect(App.get('services.monitoring')).to.eql(['S6']);
    });
  });


  describe('#components', function () {
    var i = 0,
      testCases = [
        {
          key: 'allComponents',
          data: [
            Em.Object.create({
              componentName: 'C1'
            })
          ],
          result: ['C1']
        },
        {
          key: 'reassignable',
          data: [
            Em.Object.create({
              componentName: 'C2',
              isReassignable: true
            })
          ],
          result: ['C2']
        },
        {
          key: 'restartable',
          data: [
            Em.Object.create({
              componentName: 'C3',
              isRestartable: true
            })
          ],
          result: ['C3']
        },
        {
          key: 'deletable',
          data: [
            Em.Object.create({
              componentName: 'C4',
              isDeletable: true
            })
          ],
          result: ['C4']
        },
        {
          key: 'rollinRestartAllowed',
          data: [
            Em.Object.create({
              componentName: 'C5',
              isRollinRestartAllowed: true
            })
          ],
          result: ['C5']
        },
        {
          key: 'decommissionAllowed',
          data: [
            Em.Object.create({
              componentName: 'C6',
              isDecommissionAllowed: true
            })
          ],
          result: ['C6']
        },
        {
          key: 'refreshConfigsAllowed',
          data: [
            Em.Object.create({
              componentName: 'C7',
              isRefreshConfigsAllowed: true
            })
          ],
          result: ['C7']
        },
        {
          key: 'addableToHost',
          data: [
            Em.Object.create({
              componentName: 'C8',
              isAddableToHost: true
            })
          ],
          result: ['C8']
        },
        {
          key: 'addableMasterInstallerWizard',
          data: [
            Em.Object.create({
              componentName: 'C9',
              isMasterAddableInstallerWizard: true,
              showAddBtnInInstall: true
            })
          ],
          result: ['C9']
        },
        {
          key: 'multipleMasters',
          data: [
            Em.Object.create({
              componentName: 'C10',
              isMasterWithMultipleInstances: true
            })
          ],
          result: ['C10']
        },
        {
          key: 'slaves',
          data: [
            Em.Object.create({
              componentName: 'C11',
              isSlave: true
            })
          ],
          result: ['C11']
        },
        {
          key: 'clients',
          data: [
            Em.Object.create({
              componentName: 'C12',
              isClient: true
            })
          ],
          result: ['C12']
        }
      ];

    beforeEach(function () {
      sinon.stub(App.StackServiceComponent, 'find', function () {
        return testCases[i].data;
      });
    });

    afterEach(function () {
      i++;
      App.StackServiceComponent.find.restore();
    });

    testCases.forEach(function (test) {
      it(test.key + ' should contain ' + test.result, function () {
        expect(App.get('components.' + test.key)).to.eql(test.result);
      })
    })
  });

  describe('#upgradeIsRunning', function () {

    Em.A([
        {
          upgradeState: 'IN_PROGRESS',
          m: 'should be true (1)',
          e: true
        },
        {
          upgradeState: 'HOLDING',
          m: 'should be true (2)',
          e: true
        },
        {
          upgradeState: 'FAKE',
          m: 'should be false',
          e: false
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          App.set('upgradeState', test.upgradeState);
          expect(App.get('upgradeIsRunning')).to.equal(test.e);
        });
      });

  });

  describe('#upgradeSuspended', function () {
    var cases = [
      {
        upgradeState: 'INIT',
        isSuspended: false,
        upgradeSuspended: false
      },
      {
        upgradeState: 'ABORTED',
        isSuspended: false,
        upgradeSuspended: false
      },
      {
        upgradeState: 'ABORTED',
        isSuspended: true,
        upgradeSuspended: true
      }
    ];

    beforeEach(function() {
      this.mock = sinon.stub(App.router, 'get');
    });
    afterEach(function() {
      this.mock.restore();
    });

    cases.forEach(function (test) {
      it(test.upgradeState + ", isSuspended=" + test.isSuspended, function () {
        App.set('upgradeState', test.upgradeState);
        this.mock.returns(test.isSuspended);
        App.propertyDidChange('upgradeSuspended');
        expect(App.get('upgradeSuspended')).to.equal(test.upgradeSuspended);
      });
    });
  });

  describe('#upgradeAborted', function () {

    var cases = [
      {
        upgradeState: 'INIT',
        isSuspended: false,
        upgradeAborted: false
      },
      {
        upgradeState: 'ABORTED',
        isSuspended: true,
        upgradeAborted: false
      },
      {
        upgradeState: 'ABORTED',
        isSuspended: false,
        upgradeAborted: true
      }
    ];

    beforeEach(function() {
      this.mock = sinon.stub(App.router, 'get');
    });
    afterEach(function() {
      this.mock.restore();
    });

    cases.forEach(function (test) {
      it(test.upgradeState + ", isSuspended=" + test.isSuspended, function () {
        App.set('upgradeState', test.upgradeState);
        this.mock.returns(test.isSuspended);
        App.propertyDidChange('upgradeAborted');
        expect(App.get('upgradeAborted')).to.equal(test.upgradeAborted);
      });
    });
  });

  describe('#wizardIsNotFinished', function () {
    var cases = [
      {
        upgradeState: 'INIT',
        wizardIsNotFinished: false
      },
      {
        upgradeState: 'IN_PROGRESS',
        wizardIsNotFinished: true
      },
      {
        upgradeState: 'HOLDING',
        wizardIsNotFinished: true
      },
      {
        upgradeState: 'HOLDING_TIMEDOUT',
        wizardIsNotFinished: true
      },
      {
        upgradeState: 'ABORTED',
        wizardIsNotFinished: true
      }
    ];

    cases.forEach(function (item) {
      it(item.upgradeState, function () {
        App.set('upgradeState', item.upgradeState);
        App.propertyDidChange('wizardIsNotFinished');
        expect(App.get('wizardIsNotFinished')).to.equal(item.wizardIsNotFinished);
      });
    });
  });

  describe("#upgradeHolding", function () {
    var cases = [
      {
        upgradeState: 'INIT',
        upgradeAborted: false,
        upgradeHolding: false
      },
      {
        upgradeState: 'HOLDING',
        upgradeAborted: false,
        upgradeHolding: true
      },
      {
        upgradeState: 'HOLDING_FAILED',
        upgradeAborted: false,
        upgradeHolding: true
      },
      {
        upgradeState: 'INIT',
        upgradeAborted: true,
        upgradeHolding: true
      }
    ];

    beforeEach(function() {
      this.mock = sinon.stub(App.router, 'get');
    });
    afterEach(function() {
      this.mock.restore();
    });

    cases.forEach(function (test) {
      it(test.upgradeState + ", upgradeAborted=" + test.upgradeAborted, function () {
        App.reopen({
          upgradeAborted: test.upgradeAborted,
          upgradeState: test.upgradeState
        });
        App.propertyDidChange('upgradeHolding');
        expect(App.get('upgradeHolding')).to.equal(test.upgradeHolding);
      });
    });
  });
});

});

require.register("test/controllers/application_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('models/cluster');
var testHelpers = require('test/helpers');

function getController() {
  return App.ApplicationController.create();
}

describe('App.ApplicationController', function () {

  var applicationController = getController();

  App.TestAliases.testAsComputedTruncate(getController(), 'clusterDisplayName', 'clusterName', 13, 10);

  App.TestAliases.testAsComputedAnd(getController(), 'isClusterDataLoaded', ['App.router.clusterController.isLoaded','App.router.loggedIn']);

  App.TestAliases.testAsComputedAnd(getController(), 'isExistingClusterDataLoaded', ['App.router.clusterInstallCompleted','isClusterDataLoaded']);

  App.TestAliases.testAsComputedAnd(getController(), 'enableLinks', ['isExistingClusterDataLoaded','!App.isOnlyViewUser']);

  describe('#showAboutPopup', function() {
    var dataToShowRes = {};
    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show', function(dataToShow){
        dataToShowRes = dataToShow;
      });
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
    });
    it ('Should send correct data to popup', function() {
      applicationController.showAboutPopup();
      dataToShowRes = JSON.parse(JSON.stringify(dataToShowRes));
      expect(dataToShowRes).to.eql({
        "header": "About",
        "secondary": false
      });
    });
  });

  describe('#clusterName', function() {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns('cl1');
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it ('Should return cluster name', function() {
      expect(applicationController.get('clusterName')).to.equal('cl1');
    });
  });

  describe('#startKeepAlivePoller', function() {
    it ('Should change run poller state', function() {
      applicationController.set('isPollerRunning', false);
      applicationController.startKeepAlivePoller();
      expect(applicationController.get('isPollerRunning')).to.be.true;
    });
  });

  describe('#goToAdminView', function() {
    var result;
    beforeEach(function () {
      sinon.stub(App.router, 'route', function(data) {
        result = data;
        return false;
      });
    });
    afterEach(function () {
      App.router.route.restore();
    });
    it ('Should call route once', function() {
      applicationController.goToAdminView();
      expect(result).to.be.equal('adminView');
    });
  });

  describe('#getStack', function() {

    it ('Should return send value', function() {
      var callback = {
        'callback': true
      };
      applicationController.getStack(callback);
      var args = testHelpers.findAjaxRequest('name', 'router.login.clusters');
      expect(args[0]).to.exists;
      expect(args[0].callback.callback).to.be.true;
    });
  });

});

});

require.register("test/controllers/experimental_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('controllers/experimental');

var controller,
  supports = {},
  controllerSupports = [
    Em.Object.create({
      name: 'sup0',
      selected: true
    }),
    Em.Object.create({
      name: 'sup1',
      selected: false
    })
  ],
  saveObject = {};

describe('App.ExperimentalController', function () {

  before(function () {
    controllerSupports.forEach(function(item) {
      supports[item.get('name')] = item.get('selected');
    });
    sinon.stub(App, 'get', function(k) {
      if (k === 'supports') return supports;
      return Em.get(App, k);
    });
  });

  beforeEach(function () {
    controller = App.ExperimentalController.create();
  });

  after(function () {
    App.get.restore();
  });

  describe('#supports', function () {
    it('should take data from App.supports', function () {
      expect(controller.get('supports')).to.eql(controllerSupports);
    });
  });

  describe.skip('#doSave', function () {
    before(function () {
      sinon.stub(Ember, 'set', function (p, v) {
        if (p.startsWith('App.supports.')) {
          var key = p.replace('App.supports.', '');
          saveObject[key] = v;
          return v;
        }
        return Ember.set(p, v);
      });
      sinon.stub(App.router, 'transitionTo', Em.K);
    });

    after(function () {
      Em.set.restore();
      App.router.transitionTo.restore();
    });

    it('should pass data to App.supports', function () {
      controller.set('supports', controllerSupports);
      controller.doSave();
      expect(saveObject).to.eql(supports);
    });

  });

  describe('#getUserPrefSuccessCallback', function () {

    var receivedSupports = {
        sup0: false,
        sup2: true
      },
      expectedResult = {
        sup0: false,
        sup1: false,
        sup2: true
      };

    beforeEach(function () {
      sinon.spy(App, 'set');
    });

    afterEach(function () {
      App.set.restore();
    });

    it('no data received', function () {
      controller.getUserPrefSuccessCallback(null);
      expect(App.set.called).to.be.false;
    });

    it('some data received', function () {
      controller.getUserPrefSuccessCallback(receivedSupports);
      expect(App.set.calledWith('supports', expectedResult)).to.be.true;
    });

  });

});

});

require.register("test/controllers/global/background_operations_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('config');
require('utils/updater');
require('utils/ajax/ajax');

require('models/host_component');

require('controllers/global/background_operations_controller');
require('views/common/modal_popup');
require('utils/host_progress_popup');

describe('App.BackgroundOperationsController', function () {

  var controller = App.BackgroundOperationsController.create({
    isInitLoading: Em.K
  });

  describe('#getQueryParams', function () {
    /**
     * Predefined data
     *
     */
    App.set('clusterName', 'testName');

    var tests = Em.A([
      {
        levelInfo: Em.Object.create({
          name: 'REQUESTS_LIST',
          requestId: null,
          taskId: null,
          sync: false
        }),
        e: {
          name: 'background_operations.get_most_recent',
          successCallback: 'callBackForMostRecent',
          data: {
            'operationsCount': 10
          }
        },
        response: {items: []},
        m: '"Get Most Recent"'
      },
      {
        levelInfo: Em.Object.create({
          name: 'TASK_DETAILS',
          requestId: 1,
          taskId: 1
        }),
        e: {
          name: 'background_operations.get_by_task',
          successCallback: 'callBackFilteredByTask',
          data: {
            taskId: 1,
            requestId: 1
          }
        },
        response: {items: {Tasks: {request_id: 0}}},
        m: '"Filtered By task"'
      },
      {
        levelInfo: Em.Object.create({
          name: 'TASKS_LIST',
          requestId: 1,
          taskId: 1
        }),
        e: {
          name: 'background_operations.get_by_request',
          successCallback: 'callBackFilteredByRequest',
          data: {
            requestId: 1
          }
        },
        response: {items: {Requests: {id: 0}}},
        m: '"Filtered By Request (TASKS_LIST)"'
      },
      {
        levelInfo: Em.Object.create({
          name: 'HOSTS_LIST',
          requestId: 1,
          taskId: 1
        }),
        e: {
          name: 'background_operations.get_by_request',
          successCallback: 'callBackFilteredByRequest',
          data: {
            requestId: 1
          }
        },
        response: {items: {Requests: {id: 0}}},
        m: '"Filtered By Request (HOSTS_LIST)"'
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('levelInfo', test.levelInfo);
        var r = controller.getQueryParams();
        expect(r.name).to.equal(test.e.name);
        expect(r.successCallback).to.equal(test.e.successCallback);
        expect(r.data).to.eql(test.e.data);
      });
    });
  });

  describe('#startPolling()', function () {

    beforeEach(function () {
      sinon.spy(controller, 'requestMostRecent');
    });
    afterEach(function () {
      controller.requestMostRecent.restore();
    });

    it('isWorking = false', function () {
      controller.set('isWorking', false);
      expect(App.updater.run.calledOnce).to.equal(false);
      expect(controller.requestMostRecent.calledOnce).to.equal(false);
    });
    it('isWorking = true', function () {
      controller.set('isWorking', true);
      expect(App.updater.run.calledOnce).to.equal(true);
      expect(controller.requestMostRecent.calledOnce).to.equal(true);
    });
  });

  describe('#isUpgradeRequest', function() {

    it('defines if request is upgrade task (true)', function() {
      expect(controller.isUpgradeRequest({Requests: {request_context: "upgrading"}})).to.be.true;
    });

    it('defines if request is upgrade task (true - with uppercase)', function() {
      expect(controller.isUpgradeRequest({Requests: {request_context: "UPGRADING"}})).to.be.true;
    });

    it('defines if request is downgrade task (true - with uppercase)', function() {
      expect(controller.isUpgradeRequest({Requests: {request_context: "downgrading"}})).to.be.true;
    });

    it('defines if request is upgrade task (false)', function() {
      expect(controller.isUpgradeRequest({Requests: {request_context: "install"}})).to.be.false;
    });

    it('defines if request is upgrade task (false - invalid param)', function() {
      expect(controller.isUpgradeRequest({Requests: {}})).to.be.false;
    });
  });

  describe('#callBackForMostRecent()', function () {

    beforeEach(function () {
      sinon.stub(App.router.get('clusterController'), 'restoreUpgradeState', Em.K);
    });

    afterEach(function () {
      App.router.get('clusterController').restoreUpgradeState.restore();
    });

    it('No requests exists', function () {
      var data = {
        items: []
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(0);
      expect(controller.get("services.length")).to.equal(0);
    });
    it('One non-running request', function () {
      var data = {
        items: [
          {
            Requests: {
              id: 1,
              request_context: '',
              task_count: 0,
              aborted_task_count: 0,
              completed_task_count: 0,
              failed_task_count: 0,
              timed_out_task_count: 0,
              queued_task_count: 0
            }
          }
        ]
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(0);
      expect(controller.get("services").mapProperty('id')).to.eql([1]);
    });

    it('One request that is excluded', function () {
      var data = {
        items: [
          {
            Requests: {
              id: 1,
              request_context: 'upgrading'
            }
          }
        ]
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(0);
      expect(controller.get("services").mapProperty('id')).to.eql([]);
    });

    it('One running request', function () {
      var data = {
        items: [
          {
            Requests: {
              id: 1,
              request_context: '',
              task_count: 1,
              aborted_task_count: 0,
              completed_task_count: 0,
              failed_task_count: 0,
              timed_out_task_count: 0,
              queued_task_count: 0
            }
          }
        ]
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(1);
      expect(controller.get("services").mapProperty('id')).to.eql([1]);
    });
    it('Two requests in order', function () {
      var data = {
        items: [
          {
            Requests: {
              id: 1,
              request_context: ''
            }
          },
          {
            Requests: {
              id: 2,
              request_context: ''
            }
          }
        ]
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(0);
      expect(controller.get("services").mapProperty('id')).to.eql([2, 1]);
    });
  });

  describe('#removeOldRequests()', function () {
    var testCases = [
      {
        title: 'No requests exist',
        content: {
          currentRequestIds: [],
          services: []
        },
        result: []
      },
      {
        title: 'One current request',
        content: {
          currentRequestIds: [1],
          services: [
            {id: 1}
          ]
        },
        result: [
          {id: 1}
        ]
      },
      {
        title: 'One old request',
        content: {
          currentRequestIds: [2],
          services: [
            {id: 1}
          ]
        },
        result: []
      },
      {
        title: 'One old request and one is current',
        content: {
          currentRequestIds: [2],
          services: [
            {id: 1},
            {id: 2}
          ]
        },
        result: [
          {id: 2}
        ]
      },
      {
        title: 'two old request and two current',
        content: {
          currentRequestIds: [3, 4],
          services: [
            {id: 1},
            {id: 2},
            {id: 3},
            {id: 4}
          ]
        },
        result: [
          {id: 3},
          {id: 4}
        ]
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('services', test.content.services);
        controller.removeOldRequests(test.content.currentRequestIds);
        expect(controller.get('services')).to.eql(test.result);
      });
    });
  });

  describe('#isRequestRunning()', function () {
    var testCases = [
      {
        title: 'Counters are missing',
        request: {
          Requests: {}
        },
        result: false
      },
      {
        title: 'Request has zero tasks',
        request: {
          Requests: {
            task_count: 0,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in running status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: true
      },
      {
        title: 'One task in queued status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 1
          }
        },
        result: true
      },
      {
        title: 'One task in aborted status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 1,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in completed status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 1,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in failed status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 1,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in timed out status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in timed out status and the second one in running',
        request: {
          Requests: {
            task_count: 2,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: true
      },
      {
        title: 'One task in each status',
        request: {
          Requests: {
            task_count: 5,
            aborted_task_count: 1,
            completed_task_count: 1,
            failed_task_count: 1,
            timed_out_task_count: 1,
            queued_task_count: 1
          }
        },
        result: true
      },
      {
        title: 'One task in each status except queued',
        request: {
          Requests: {
            task_count: 5,
            aborted_task_count: 1,
            completed_task_count: 1,
            failed_task_count: 1,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: true
      },
      {
        title: 'No tasks in running status',
        request: {
          Requests: {
            task_count: 4,
            aborted_task_count: 1,
            completed_task_count: 1,
            failed_task_count: 1,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: false
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.isRequestRunning(test.request)).to.eql(test.result);
      });
    });
  });

  describe('#isOneHost()', function () {
    var testCases = [
      {
        title: 'inputs is null',
        inputs: null,
        result: false
      },
      {
        title: 'inputs is "null"',
        inputs: 'null',
        result: false
      },
      {
        title: 'inputs is empty object',
        inputs: '{}',
        result: false
      },
      {
        title: 'included_hosts is empty',
        inputs: '{"included_hosts": ""}',
        result: false
      },
      {
        title: 'included_hosts contain one host',
        inputs: '{"included_hosts": "host1"}',
        result: true
      },
      {
        title: 'included_hosts contain two hosts',
        inputs: '{"included_hosts": "host1,host2"}',
        result: false
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.isOneHost(test.inputs)).to.eql(test.result);
      });
    });
  });

  describe('#assignScheduleId()', function () {
    var testCases = [
      {
        title: 'isOneHost is false',
        content: {
          request: {
            Requests: {
              request_schedule: {
                schedule_id: 1
              },
              inputs: null
            }
          },
          requestParams: ''
        },
        result: 1
      },
      {
        title: 'isOneHost is true and requestContext is empty',
        content: {
          request: {
            Requests: {
              request_schedule: {
                schedule_id: 1
              },
              inputs: '{"included_hosts": "host1"}'
            }
          },
          requestParams: {
            requestContext: ''
          }
        },
        result: 1
      },
      {
        title: 'isOneHost is true and requestContext contains "Recommission"',
        content: {
          request: {
            Requests: {
              request_schedule: {
                schedule_id: 1
              },
              inputs: '{"included_hosts": "host1"}'
            }
          },
          requestParams: {
            requestContext: 'Recommission'
          }
        },
        result: null
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.assignScheduleId(test.content.request, test.content.requestParams);
        expect(test.content.request.Requests.request_schedule.schedule_id).to.equal(test.result);
      });
    });
  });

  describe('#callBackFilteredByRequest()', function () {

    it('request haven\'t tasks and isRunning false', function () {
      var data = {
        Requests: {id: 1},
        tasks: []
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: false,
        progress: 0,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({});
      expect(request.get('hostsMap')).to.eql({});
      expect(request.get('isRunning')).to.equal(false);
    });

    it('request haven\'t tasks and isRunning true', function () {
      var data = {
        Requests: {id: 1},
        tasks: []
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: true,
        progress: 0,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({});
      expect(request.get('hostsMap')).to.eql({});
      expect(request.get('isRunning')).to.equal(true);
    });

    it('request has one completed task', function () {
      var data = {
        Requests: {id: 1},
        tasks: [
          {
            Tasks: {
              id: 1,
              host_name: 'host1',
              status: 'COMPLETED'
            }
          }
        ]
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: true,
        progress: 100,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({"1": "COMPLETED"});
      expect(request.get('hostsMap.host1.logTasks.length')).to.equal(1);
      expect(request.get('isRunning')).to.equal(false);
    });

    it('request has one completed task and one running task', function () {
      var data = {
        Requests: {id: 1},
        tasks: [
          {
            Tasks: {
              id: 1,
              host_name: 'host1',
              status: 'COMPLETED'
            }
          },
          {
            Tasks: {
              id: 2,
              host_name: 'host1',
              status: 'IN_PROGRESS'
            }
          }
        ]
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: true,
        progress: 100,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({"1": "COMPLETED", "2": "IN_PROGRESS"});
      expect(request.get('hostsMap.host1.logTasks.length')).to.equal(2);
      expect(request.get('isRunning')).to.equal(true);
    });
  });
});

});

require.register("test/controllers/global/cluster_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
var credentialUtils = require('utils/credentials');
var testHelpers = require('test/helpers');
require('controllers/global/cluster_controller');
require('models/host_component');
require('utils/http_client');
require('models/service');
require('models/host');
require('utils/ajax/ajax');
require('utils/string_utils');

var modelSetup = require('test/init_model_test');

describe('App.clusterController', function () {
  var controller = App.ClusterController.create();
  App.Service.FIXTURES = [
    {service_name: 'GANGLIA'}
  ];

  App.TestAliases.testAsComputedAnd(controller, 'isHostContentLoaded', ['isHostsLoaded', 'isComponentsStateLoaded']);

  App.TestAliases.testAsComputedAnd(controller, 'isServiceContentFullyLoaded', ['isServiceMetricsLoaded', 'isComponentsStateLoaded', 'isComponentsConfigLoaded']);

  App.TestAliases.testAsComputedAlias(controller, 'clusterName', 'App.clusterName', 'string');

  describe('#updateLoadStatus()', function () {

    controller.set('dataLoadList', Em.Object.create({
      'item1': false,
      'item2': false
    }));

    it('when none item is loaded then width should be "width:0"', function () {
      expect(controller.get('clusterDataLoadedPercent')).to.equal('width:0');
    });
    it('when first item is loaded then isLoaded should be false', function () {
      controller.updateLoadStatus('item1');
      expect(controller.get('isLoaded')).to.equal(false);
    });
    it('when first item is loaded then width should be "width:50%"', function () {
      controller.updateLoadStatus('item1');
      expect(controller.get('clusterDataLoadedPercent')).to.equal('width:50%');
    });

    it('when all items are loaded then isLoaded should be true', function () {
      controller.updateLoadStatus('item2');
      expect(controller.get('isLoaded')).to.equal(true);
    });
    it('when all items are loaded then width should be "width:100%"', function () {
      controller.updateLoadStatus('item2');
      expect(controller.get('clusterDataLoadedPercent')).to.equal('width:100%');
    });
  });

  describe('#loadClusterName()', function () {

    beforeEach(function () {
      modelSetup.setupStackVersion(this, 'HDP-2.0.5');
      App.ajax.send.restore(); // default ajax-mock can't be used here
      sinon.stub(App.ajax, 'send', function () {
        return {
          then: function (successCallback) {
            App.set('clusterName', 'clusterNameFromServer');
            App.set('currentStackVersion', 'HDP-2.0.5');
            successCallback();
          }
        }
      });
      this.args = testHelpers.findAjaxRequest('name', 'cluster.load_cluster_name');
    });
    afterEach(function () {
      modelSetup.restoreStackVersion(this);
    });

    it('if clusterName is "mycluster" and reload is false then clusterName stays the same', function () {
      App.set('clusterName', 'mycluster');
      controller.loadClusterName(false);
      expect(this.args).to.not.exists;
      expect(App.get('clusterName')).to.equal('mycluster');
    });

    it('reload is true and clusterName is not empty', function () {
      controller.loadClusterName(true);
      expect(this.args).to.exists;
      expect(App.get('clusterName')).to.equal('clusterNameFromServer');
      expect(App.get('currentStackVersion')).to.equal('HDP-2.0.5');
    });

    it('reload is false and clusterName is empty', function () {
      App.set('clusterName', '');
      controller.loadClusterName(false);
      expect(this.args).to.exists;
      expect(App.get('clusterName')).to.equal('clusterNameFromServer');
      expect(App.get('currentStackVersion')).to.equal('HDP-2.0.5');
    });


  });

  describe('#reloadSuccessCallback', function () {
    var testData = {
      "items": [
        {
          "Clusters": {
            "cluster_name": "tdk",
            "version": "HDP-1.3.0"
          }
        }
      ]
    };
    it('Check cluster', function () {
      controller.reloadSuccessCallback(testData);
      expect(App.get('clusterName')).to.equal('tdk');
      expect(App.get('currentStackVersion')).to.equal('HDP-1.3.0');
    });
  });

  describe('#getServerClockSuccessCallback()', function () {
    var testCases = [
      {
        title: 'if server clock is 1 then currentServerTime should be 1000',
        data: {
          RootServiceComponents: {
            server_clock: 1
          }
        },
        result: 1000
      },
      {
        title: 'if server clock is 0 then currentServerTime should be 0',
        data: {
          RootServiceComponents: {
            server_clock: 0
          }
        },
        result: 0
      },
      {
        title: 'if server clock is 111111111111 then currentServerTime should be 111111111111000',
        data: {
          RootServiceComponents: {
            server_clock: 111111111111
          }
        },
        result: 111111111111000
      },
      {
        title: 'if server clock is 1111111111113 then currentServerTime should be 1111111111113',
        data: {
          RootServiceComponents: {
            server_clock: 1111111111113
          }
        },
        result: 1111111111113
      }
    ];
    var currentServerTime = App.get('currentServerTime');
    var clockDistance = App.get('clockDistance');

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.getServerClockSuccessCallback(test.data);
        expect(App.get('currentServerTime')).to.equal(test.result);
        App.set('clockDistance', clockDistance);
        App.set('currentServerTime', currentServerTime);
      });
    });
  });

  describe('#getUrl', function () {
    controller.set('clusterName', 'tdk');
    var tests = ['test1', 'test2', 'test3'];

    tests.forEach(function (test) {
      it(test, function () {
        expect(controller.getUrl(test, test)).to.equal(App.apiPrefix + '/clusters/' + controller.get('clusterName') + test);
      });
    });
  });

  describe("#createKerberosAdminSession()", function() {

    beforeEach(function () {
      sinon.stub(credentialUtils, 'createOrUpdateCredentials', function() {
        return $.Deferred().resolve().promise();
      });
      this.stub = sinon.stub(App, 'get');
      this.stub.withArgs('clusterName').returns('test');
    });

    afterEach(function () {
      credentialUtils.createOrUpdateCredentials.restore();
      App.get.restore();
    });

    it("credentials updated via credentials storage call", function() {
      controller.createKerberosAdminSession({
        principal: 'admin',
        key: 'pass',
        type: 'persistent'
      }, {});
      var args = testHelpers.findAjaxRequest('name', 'common.cluster.update');
      expect(args).to.not.exists;
      expect(credentialUtils.createOrUpdateCredentials.getCall(0).args).to.eql([
        'test', 'kdc.admin.credential', {
          principal: 'admin',
          key: 'pass',
          type: 'persistent'
        }
      ]);
    });
  });

  describe('#checkDetailedRepoVersion()', function () {

    var cases = [
      {
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.1',
        isStormMetricsSupported: false,
        title: 'HDP < 2.2'
      },
      {
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.3',
        isStormMetricsSupported: true,
        title: 'HDP > 2.2'
      },
      {
        currentStackName: 'BIGTOP',
        currentStackVersionNumber: '0.8',
        isStormMetricsSupported: true,
        title: 'not HDP'
      }
    ];

    afterEach(function () {
      App.get.restore();
    });

    describe('should check detailed repo version for HDP 2.2', function () {

      beforeEach(function () {
        sinon.stub(App, 'get').withArgs('currentStackName').returns('HDP').withArgs('currentStackVersionNumber').returns('2.2');
      });

      it('request is sent', function () {
        controller.checkDetailedRepoVersion();
        var args = testHelpers.findAjaxRequest('name', 'cluster.load_detailed_repo_version');
        expect(args).to.exists;
      });
    });

    cases.forEach(function (item) {
      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(App, 'get', function (key) {
            return item[key] || Em.get(App, key);
          });
          controller.checkDetailedRepoVersion();
        });

        it('request is not sent', function () {
          var args = testHelpers.findAjaxRequest('name', 'cluster.load_detailed_repo_version');
          expect(args).to.not.exists;
        });

        it('App.isStormMetricsSupported is ' + item.isStormMetricsSupported, function () {
          expect(App.get('isStormMetricsSupported')).to.equal(item.isStormMetricsSupported);
        });

      });
    });

  });

  describe('#checkDetailedRepoVersionSuccessCallback()', function () {
    beforeEach(function () {
      sinon.stub(App, 'get', function(key) {
        if (key === 'currentStackName') {
          return 'HDP';
        }
        if (key === 'currentStackVersionNumber') {
          return '2.2';
        }
        return Em.get(App, key);
      });
    });
    afterEach(function() {
      App.get.restore();
    });

    var cases = [
      {
        items: [
          {
            ClusterStackVersions: {
              stack: 'HDP',
              version: '2.2'
            },
            repository_versions: [
              {
                RepositoryVersions: {
                  repository_version: '2.1'
                }
              }
            ]
          }
        ],
        isStormMetricsSupported: false,
        title: 'HDP < 2.2.2'
      },
      {
        items: [
          {
            ClusterStackVersions: {
              stack: 'HDP',
              version: '2.2'
            },
            repository_versions: [
              {
                RepositoryVersions: {
                  repository_version: '2.2.2'
                }
              }
            ]
          }
        ],
        isStormMetricsSupported: true,
        title: 'HDP 2.2.2'
      },
      {
        items: [
          {
            repository_versions: [
              {
                RepositoryVersions: {
                  repository_version: '2.2.3'
                }
              }
            ]
          }
        ],
        isStormMetricsSupported: true,
        title: 'HDP > 2.2.2'
      },
      {
        items: null,
        isStormMetricsSupported: true,
        title: 'empty response'
      },
      {
        items: [],
        isStormMetricsSupported: true,
        title: 'no items'
      },
      {
        items: [{}],
        isStormMetricsSupported: true,
        title: 'empty item'
      },
      {
        items: [{
          repository_versions: []
        }],
        isStormMetricsSupported: true,
        title: 'no versions'
      },
      {
        items: [{
          repository_versions: [{}]
        }],
        isStormMetricsSupported: true,
        title: 'no version info'
      },
      {
        items: [{
          repository_versions: [
            {
              RepositoryVersions: {}
            }
          ]
        }],
        isStormMetricsSupported: true,
        title: 'empty version info'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.checkDetailedRepoVersionSuccessCallback({
          items: item.items
        });
        expect(App.get('isStormMetricsSupported')).to.equal(item.isStormMetricsSupported);
      });
    });

  });

  describe('#checkDetailedRepoVersionErrorCallback()', function () {
    it('should set isStormMetricsSupported to default value', function () {
      controller.checkDetailedRepoVersionErrorCallback();
      expect(App.get('isStormMetricsSupported')).to.be.true;
    });
  });

  describe('#getAllUpgrades()', function () {

    it('should send request to get upgrades data', function () {
      controller.getAllUpgrades();
      var args = testHelpers.findAjaxRequest('name', 'cluster.load_last_upgrade');
      expect(args).to.exists;
    });

  });

  describe("#restoreUpgradeState()", function() {
    var data = {upgradeData: {}};
    var mock = {
      done: function (callback) {
        callback(data.upgradeData);
      }
    };
    var upgradeController = Em.Object.create({
      restoreLastUpgrade: Em.K,
      initDBProperties: Em.K,
      loadUpgradeData: Em.K,
      loadStackVersionsToModel: function () {
        return {done: Em.K};
      }
    });

    beforeEach(function () {
      sinon.stub(controller, 'getAllUpgrades').returns(mock);
      sinon.spy(mock, 'done');
      sinon.stub(App.router, 'get').returns(upgradeController);
      sinon.stub(App.db, 'get').returns('PENDING');
      sinon.spy(upgradeController, 'restoreLastUpgrade');
      sinon.spy(upgradeController, 'initDBProperties');
      sinon.spy(upgradeController, 'loadUpgradeData');
      sinon.spy(upgradeController, 'loadStackVersionsToModel');
    });

    afterEach(function () {
      mock.done.restore();
      controller.getAllUpgrades.restore();
      App.router.get.restore();
      App.db.get.restore();
      upgradeController.restoreLastUpgrade.restore();
      upgradeController.initDBProperties.restore();
      upgradeController.loadUpgradeData.restore();
      upgradeController.loadStackVersionsToModel.restore();
    });

    describe("has upgrade request", function() {

      beforeEach(function () {
        data.upgradeData = {items: [
          {
            Upgrade: {
              request_id: 1
            }
          }
        ]};
        controller.restoreUpgradeState();
      });

      it('getAllUpgrades is called once', function () {
        expect(controller.getAllUpgrades.calledOnce).to.be.true;
      });

      it('upgradeState is PENDING', function () {
        expect(App.get('upgradeState')).to.equal('PENDING');
      });

      it('restoreLastUpgrade is called with valid arguments', function () {
        expect(upgradeController.restoreLastUpgrade.calledWith(data.upgradeData.items[0])).to.be.true;
      });

      it('loadStackVersionsToModel is called with valid arguments', function () {
        expect(upgradeController.loadStackVersionsToModel.calledWith(true)).to.be.true;
      });

      it('initDBProperties is not called', function () {
        expect(upgradeController.initDBProperties.called).to.be.false;
      });

      it('loadUpgradeData is not called', function () {
        expect(upgradeController.loadUpgradeData.called).to.be.false;
      });

    });

    describe("has completed upgrade request", function() {

      beforeEach(function () {
        data.upgradeData = {items: [
          {
            Upgrade: {
              request_id: 1,
              request_status: 'COMPLETED'
            }
          }
        ]};
        controller.restoreUpgradeState();
      });

      it('getAllUpgrades is called once', function () {
        expect(controller.getAllUpgrades.calledOnce).to.be.true;
      });

      it('restoreLastUpgrade should not be called', function () {
        expect(upgradeController.restoreLastUpgrade.called).to.be.false;
      });

      it('loadStackVersionsToModel should be called', function () {
        expect(upgradeController.loadStackVersionsToModel).to.be.calledOnce;
      });
    });

    describe("does not have upgrade request", function() {

      beforeEach(function () {
        data.upgradeData = {items: []};
        controller.restoreUpgradeState();
      });

      it('getAllUpgrades is called once', function () {
        expect(controller.getAllUpgrades.calledOnce).to.be.true;
      });

      it('upgradeState is PENDING', function () {
        expect(App.get('upgradeState')).to.equal('PENDING');
      });

      it('restoreLastUpgrade is not called', function () {
        expect(upgradeController.restoreLastUpgrade.called).to.be.false;
      });

      it('loadStackVersionsToModel is called with valid arguments', function () {
        expect(upgradeController.loadStackVersionsToModel.calledWith(true)).to.be.true;
      });

      it('initDBProperties is called once', function () {
        expect(upgradeController.initDBProperties.calledOnce).to.be.true;
      });

      it('loadUpgradeData is called with valid arguments', function () {
        expect(upgradeController.loadUpgradeData.calledWith(true)).to.be.true;
      });

    });
  });
});

});

require.register("test/controllers/global/configuration_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/global/configuration_controller');


describe('App.ConfigurationController', function () {
  var controller = App.ConfigurationController.create();

  describe('#checkTagsChanges()', function () {
    var testCases = [
      {
        title: 'Tags haven\'t been uploaded',
        content: {
          tags: [],
          storedTags: []
        },
        result: false
      },
      {
        title: 'New tag uploaded',
        content: {
          tags: [
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: []
        },
        result: true
      },
      {
        title: 'Existing tag with with new tagName',
        content: {
          tags: [
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site1',
              tagName: 2
            }
          ]
        },
        result: true
      },
      {
        title: 'Tags with different tagNames',
        content: {
          tags: [
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ]
        },
        result: true
      },
      {
        title: 'One new tag uploaded',
        content: {
          tags: [
            {
              siteName: 'site2',
              tagName: 1
            },
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ]
        },
        result: true
      },
      {
        title: 'Tags haven\'t been changed',
        content: {
          tags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ]
        },
        result: false
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.checkTagsChanges(test.content.tags, test.content.storedTags)).to.equal(test.result);
      });
    });
  });
});
});

require.register("test/controllers/global/errors_handler_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('controllers/global/errors_handler_controller');

describe('App.ErrorsHandlerController', function () {
  var controller;

  beforeEach(function() {
    controller = App.ErrorsHandlerController.create();
  });

  describe("#loadErrorLogs()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'getUserPref');
    });

    afterEach(function() {
      controller.getUserPref.restore();
    });

    it("getUserPref should be called", function() {
      controller.loadErrorLogs();
      expect(controller.getUserPref.calledWith('errors')).to.be.true;
    });
  });

  describe("#saveErrorLogs()", function () {

    beforeEach(function() {
      localStorage.removeItem('errors');
      sinon.stub(controller, 'postUserPref');
    });

    afterEach(function() {
      controller.postUserPref.restore();
    });

    it("postUserPref should be called", function() {
      controller.saveErrorLogs('err', 'url', 1, 2, {});
      var args = controller.postUserPref.getCall(0).args;
      expect(JSON.stringify(args[1][Object.keys(args[1])[0]])).to.be.equal(JSON.stringify({
        "file": "url",
        "line": 1,
        "col": 2,
        "error": "err"
      }));
      expect(args[0]).to.be.equal('errors');
    });
  });
});

});

require.register("test/controllers/global/update_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('utils/updater');
require('controllers/global/update_controller');
var testHelpers = require('test/helpers');
var c;

describe('App.UpdateController', function () {
  var controller = App.UpdateController.create({
    clusterName: '',
    location: '',
    updateServiceMetric: function(){}
  });

  beforeEach(function () {
    c = App.UpdateController.create();
  });

  App.TestAliases.testAsComputedAlias(App.UpdateController.create(), 'clusterName', 'App.router.clusterController.clusterName', 'string');

  App.TestAliases.testAsComputedAnd(App.UpdateController.create(), 'updateAlertInstances', ['isWorking', '!App.router.mainAlertInstancesController.isUpdating']);

  describe('#getUrl()', function () {

    it('testMode = false', function () {
      expect(controller.getUrl('test', '/real')).to.equal('/api/v1/clusters//real');
    });

    it('testMode = false (2)', function () {
      controller.set('clusterName', 'mycluster');
      expect(controller.getUrl('test', '/real')).to.equal('/api/v1/clusters/mycluster/real');
    });
  });

  describe('#updateAll()', function () {

    it('isWorking = false', function () {
      controller.set('isWorking', false);
      expect(App.updater.run.called).to.equal(false);
    });

    it('isWorking = true', function () {
      controller.set('isWorking', true);
      expect(App.updater.run.callCount).to.equal(13);
    });
  });

  describe('#getConditionalFields()', function () {

    var testCases = [
      {
        title: 'No services exist',
        services: [],
        result: ['metrics/1']
      },
      {
        title: 'HDFS service',
        services: [
          {
            ServiceInfo: {
              service_name: 'HDFS'
            }
          }
        ],
        result: ['metrics/1']
      },
      {
        title: 'FLUME service',
        services: [
          {
            ServiceInfo: {
              service_name: 'FLUME'
            }
          }
        ],
        result: ['metrics/1', "host_components/processes/HostComponentProcess"]
      },
      {
        title: 'YARN service',
        services: [
          {
            ServiceInfo: {
              service_name: 'YARN'
            }
          }
        ],
        result: ['metrics/1', "host_components/metrics/yarn/Queue," +
        "host_components/metrics/yarn/ClusterMetrics/NumActiveNMs," +
        "host_components/metrics/yarn/ClusterMetrics/NumLostNMs," +
        "host_components/metrics/yarn/ClusterMetrics/NumUnhealthyNMs," +
        "host_components/metrics/yarn/ClusterMetrics/NumRebootedNMs," +
        "host_components/metrics/yarn/ClusterMetrics/NumDecommissionedNMs"]
      },
      {
        title: 'HBASE service',
        services: [
          {
            ServiceInfo: {
              service_name: 'HBASE'
            }
          }
        ],
        result: ['metrics/1', "host_components/metrics/hbase/master/IsActiveMaster," +
        "host_components/metrics/hbase/master/MasterStartTime," +
        "host_components/metrics/hbase/master/MasterActiveTime," +
        "host_components/metrics/hbase/master/AverageLoad," +
        "host_components/metrics/master/AssignmentManger/ritCount"]
      },
      {
        title: 'STORM service',
        services: [
          {
            ServiceInfo: {
              service_name: 'STORM'
            }
          }
        ],
        result: ['metrics/1', "metrics/api/v1/cluster/summary," +
        "metrics/api/v1/topology/summary," +
        "metrics/api/v1/nimbus/summary"]
      }
    ];

    var testCasesByStackVersion = [
      {
        title: 'STORM service stack 2.1',
        services: [
          {
            ServiceInfo: {
              service_name: 'STORM'
            }
          }
        ],
        stackVersionNumber: '2.1',
        result: ['metrics/1', "metrics/api/cluster/summary"]
      },
      {
        title: 'STORM service stack 2.2',
        services: [
          {
            ServiceInfo: {
              service_name: 'STORM'
            }
          }
        ],
        stackVersionNumber: '2.2',
        result: ['metrics/1', "metrics/api/v1/cluster/summary,metrics/api/v1/topology/summary"]
      },
      {
        title: 'STORM service stack 2.3',
        services: [
          {
            ServiceInfo: {
              service_name: 'STORM'
            }
          }
        ],
        stackVersionNumber: '2.3',
        result: ['metrics/1', "metrics/api/v1/cluster/summary,metrics/api/v1/topology/summary,metrics/api/v1/nimbus/summary"]
      }
    ];

    beforeEach(function () {
      this.mock = sinon.stub(App, 'get');
      controller.set('serviceComponentMetrics', ['metrics/1']);
    });
    afterEach(function () {
      this.mock.restore();
    });
    testCases.forEach(function (test) {
      it(test.title, function () {
        App.cache.services = test.services;
        this.mock.withArgs('router.clusterController.isServiceMetricsLoaded').returns(true);
        expect(controller.getConditionalFields()).to.eql(test.result);
      });
    });

    testCasesByStackVersion.forEach(function (test) {
      it(test.title, function () {
        App.cache.services = test.services;
        this.mock.withArgs('currentStackVersionNumber').returns(test.stackVersionNumber);
        this.mock.withArgs('router.clusterController.isServiceMetricsLoaded').returns(true);
        expect(controller.getConditionalFields()).to.eql(test.result);
      });
    });

    it('FLUME service, first load', function () {
      App.cache.services = [
        {
          ServiceInfo: {
            service_name: 'FLUME'
          }
        }
      ];
      this.mock.withArgs('router.clusterController.isServiceMetricsLoaded').returns(false);
      expect(controller.getConditionalFields()).to.eql(["host_components/processes/HostComponentProcess"]);
    });
  });

  describe("#getComplexUrl()", function () {
    beforeEach(function () {
      sinon.stub(App, 'get').returns('mock');
      sinon.stub(controller, 'computeParameters').returns('params');
    });
    afterEach(function () {
      App.get.restore();
      controller.computeParameters.restore();
    });
    it("queryParams is empty", function () {
      expect(controller.getComplexUrl('<parameters>')).to.equal('mock/clusters/mock');
    });
    it("queryParams is present", function () {
      var queryParams = [
        {
          type: "EQUAL",
          key: "key",
          value: "value"
        }
      ];
      expect(controller.getComplexUrl('<parameters>', queryParams)).to.equal('mock/clusters/mockparams&');
    });
  });

  describe("#addParamsToHostsUrl()", function () {
    beforeEach(function () {
      sinon.stub(App, 'get').returns('mock');
      sinon.stub(controller, 'computeParameters').returns('params');
    });
    afterEach(function () {
      App.get.restore();
      controller.computeParameters.restore();
    });
    it("valid params are added", function () {
      expect(controller.addParamsToHostsUrl([], [], 'url')).to.equal('mock/clusters/mockurl&params&params');
    });
  });

  describe("#loadHostsMetric()", function () {
    beforeEach(function () {
      this.mock = sinon.stub(App.Service, 'find');
      sinon.stub(controller, 'computeParameters');
      sinon.stub(controller, 'addParamsToHostsUrl');
    });
    afterEach(function () {
      App.Service.find.restore();
      controller.computeParameters.restore();
      controller.addParamsToHostsUrl.restore();
    });
    it("AMBARI_METRICS is not started", function () {
      this.mock.returns(Em.Object.create({isStarted: false}));
      expect(controller.loadHostsMetric([])).to.be.null;
      var args = testHelpers.findAjaxRequest('name', 'hosts.metrics.lazy_load');
      expect(args).to.not.exists;
    });
    it("AMBARI_METRICS is started", function () {
      this.mock.returns(Em.Object.create({isStarted: true}));
      expect(controller.loadHostsMetric([])).to.be.object;
      var args = testHelpers.findAjaxRequest('name', 'hosts.metrics.lazy_load');
      expect(args).to.exists;
    });
  });

  describe("#loadHostsMetricSuccessCallback()", function () {
    beforeEach(function () {
      sinon.stub(App.hostsMapper, 'setMetrics');
    });
    afterEach(function () {
      App.hostsMapper.setMetrics.restore();
    });
    it("setMetrics called with valid arguments", function () {
      controller.loadHostsMetricSuccessCallback({});
      expect(App.hostsMapper.setMetrics.calledWith({})).to.be.true;
    });
  });

  describe('#updateUpgradeState()', function () {

    var cases = [
        {
          currentStateName: 'versions',
          parentStateName: 'stackAndUpgrade',
          wizardIsNotFinished: true,
          isLoadUpgradeDataPending: true,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'stack versions page'
        },
        {
          currentStateName: 'stackUpgrade',
          parentStateName: 'admin',
          wizardIsNotFinished: true,
          isLoadUpgradeDataPending: true,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'upgrade popup open'
        },
        {
          currentStateName: 'versions',
          parentStateName: 'admin',
          wizardIsNotFinished: true,
          isLoadUpgradeDataPending: false,
          loadUpgradeDataCallCount: 1,
          callbackCallCount: 0,
          title: 'another page with \'versions\' name'
        },
        {
          currentStateName: 'versions',
          parentStateName: 'admin',
          wizardIsNotFinished: false,
          isLoadUpgradeDataPending: false,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'another page with \'versions\' name, upgrade finished'
        },
        {
          currentStateName: 'versions',
          parentStateName: 'admin',
          wizardIsNotFinished: true,
          isLoadUpgradeDataPending: true,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'another page with \'versions\' name, another update upgrade request not completed'
        },
        {
          currentStateName: 'services',
          parentStateName: 'stackAndUpgrade',
          wizardIsNotFinished: true,
          isLoadUpgradeDataPending: false,
          loadUpgradeDataCallCount: 1,
          callbackCallCount: 0,
          title: 'another page from \'Stack and Versions\' section'
        },
        {
          currentStateName: 'services',
          parentStateName: 'stackAndUpgrade',
          wizardIsNotFinished: false,
          isLoadUpgradeDataPending: false,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'another page from \'Stack and Versions\' section, upgrade finished'
        },
        {
          currentStateName: 'services',
          parentStateName: 'stackAndUpgrade',
          wizardIsNotFinished: true,
          isLoadUpgradeDataPending: true,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'another page from \'Stack and Versions\' section, another update upgrade request not completed'
        },
        {
          currentStateName: 'widgets',
          parentStateName: 'dashboard',
          wizardIsNotFinished: true,
          isLoadUpgradeDataPending: false,
          loadUpgradeDataCallCount: 1,
          callbackCallCount: 0,
          title: 'not \'Stack and Versions\' section'
        },
        {
          currentStateName: 'widgets',
          parentStateName: 'dashboard',
          wizardIsNotFinished: false,
          isLoadUpgradeDataPending: false,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'not \'Stack and Versions\' section, upgrade finished'
        },
        {
          currentStateName: 'widgets',
          parentStateName: 'dashboard',
          wizardIsNotFinished: true,
          isLoadUpgradeDataPending: true,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'not \'Stack and Versions\' section, another update upgrade request not completed'
        }
      ],
      mock = {
        callback: Em.K,
        loadUpgradeData: function () {
          return {
            done: Em.K
          };
        }
      },
      appGetMock;

    beforeEach(function () {
      sinon.spy(mock, 'callback');
      sinon.spy(mock, 'loadUpgradeData');
      appGetMock = sinon.stub(App, 'get');
    });

    afterEach(function () {
      mock.callback.restore();
      mock.loadUpgradeData.restore();
      App.get.restore();
      appGetMock.restore();
    });

    cases.forEach(function (item) {
      describe(item.title, function () {

        beforeEach(function () {
          appGetMock.withArgs('router.mainAdminStackAndUpgradeController').returns(Em.Object.create({
            loadUpgradeData: mock.loadUpgradeData,
            isLoadUpgradeDataPending: item.isLoadUpgradeDataPending
          })).withArgs('wizardIsNotFinished').returns(item.wizardIsNotFinished)
            .withArgs('router.currentState.name').returns(item.currentStateName)
            .withArgs('router.currentState.parentState.name').returns(item.parentStateName);
          controller.updateUpgradeState(mock.callback);
        });
        it('loadUpgradeData is called ' + item.loadUpgradeDataCallCount + ' times', function () {
          expect(mock.loadUpgradeData.callCount).to.equal(item.loadUpgradeDataCallCount);
        });
        it('callback is called ' + item.callbackCallCount + ' times', function () {
          expect(mock.callback.callCount).to.equal(item.callbackCallCount);
        });

      });
    });

  });

  describe('#computeParameters', function () {

    Em.A([
      {
        q: [{
          type: 'EQUAL',
          key: 'k',
          value: [1, 2]
        }],
        result: 'k.in(1,2)'
      },
      {
        q: [{
          type: 'MULTIPLE',
          key: 'k',
          value: [1, 2]
        }],
        result: 'k.in(1,2)'
      },
      {
        q: [{
          type: 'EQUAL',
          key: 'k',
          value: 1
        }],
        result: 'k=1'
      },
      {
        q: [
          {
            type: 'LESS',
            key: 'k',
            value: '1'
          }
        ],
        result: 'k<1'
      },
      {
        q: [
          {
            type: 'MORE',
            key: 'k',
            value: '1'
          }
        ],
        result: 'k>1'
      },
      {
        q: [
          {
            type: 'SORT',
            key: 'k',
            value: 'f'
          }
        ],
        result: 'sortBy=k.f'
      },
      {
        q: [
          {
            type: 'MATCH',
            key: 'k',
            value: 'abc'
          }
        ],
        result: 'k.matches(abc)'
      },
      {
        q: [
          {
            type: 'MATCH',
            key: 'k',
            value: ['a', 'b', 'c']
          }
        ],
        result: '(k.matches(a)|k.matches(b)|k.matches(c))'
      },
      {
        q: [
          {type: 'EQUAL', key: 'k1', value: [1,2]},
          {type: 'EQUAL', key: 'k2', value: 'abc'},
          {type: 'LESS', key: 'k3', value: 1},
          {type: 'MORE', key: 'k4', value: 1},
          {type: 'MATCH', key: 'k5', value: ['a', 'b', 'c']}
        ],
        result: 'k1.in(1,2)&k2=abc&k3<1&k4>1&(k5.matches(a)|k5.matches(b)|k5.matches(c))'
      }
    ]).forEach(function (test, index) {

      it('test#' + index, function () {
        var result = c.computeParameters(test.q);
        expect(result).to.be.equal(test.result);
      });

    });

  });

});

});

require.register("test/controllers/global/user_settings_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var userSettingsController;

describe('App.UserSettingsController', function () {

  beforeEach(function () {
    userSettingsController = App.UserSettingsController.create();
  });

  afterEach(function () {
    userSettingsController.destroy();
  });

  describe('#userSettingsKeys', function () {
    it('should not be empty', function () {
      expect(Object.keys(userSettingsController.get('userSettingsKeys'))).to.have.length.gt(0);
    });
  });

});
});

require.register("test/controllers/global/wizard_watcher_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/global/wizard_watcher_controller');

var controller;

describe('App.wizardWatcherController', function () {
  beforeEach(function() {
    controller = App.WizardWatcherController.create();
  });

  describe("#isWizardRunning", function() {
    it("wizardUser is null", function() {
      controller.set('wizardUser', null);
      controller.propertyDidChange('isWizardRunning');
      expect(controller.get('isWizardRunning')).to.be.false;
    });
    it("wizardUser is correct", function() {
      controller.set('wizardUser', 'admin');
      controller.propertyDidChange('isWizardRunning');
      expect(controller.get('isWizardRunning')).to.be.true;
    });
  });

  describe("#wizardDisplayName", function() {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns(Em.Object.create({displayName: 'Wizard'}));
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it("controllerName is null", function() {
      controller.set('controllerName', null);
      controller.propertyDidChange('wizardDisplayName');
      expect(controller.get('wizardDisplayName')).to.be.empty;
    });
    it("controllerName is correct", function() {
      controller.set('controllerName', 'ctrl1');
      controller.propertyDidChange('wizardDisplayName');
      expect(controller.get('wizardDisplayName')).to.equal(Em.I18n.t('wizard.inProgress').format('Wizard'));
    });
  });


  describe("#isNonWizardUser", function() {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns('admin');
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it("isWizardRunning is false", function() {
      controller.reopen({
        isWizardRunning: false
      });
      controller.propertyDidChange('isNonWizardUser');
      expect(controller.get('isNonWizardUser')).to.be.false;
    });
    it("isWizardRunning is true, wizardUser is admin", function() {
      controller.setProperties({
        isWizardRunning: true,
        wizardUser: 'admin'
      });
      controller.propertyDidChange('isNonWizardUser');
      expect(controller.get('isNonWizardUser')).to.be.false;
    });
    it("isWizardRunning is true, wizardUser is admin2", function() {
      controller.setProperties({
        isWizardRunning: true,
        wizardUser: 'admin2'
      });
      controller.propertyDidChange('isNonWizardUser');
      expect(controller.get('isNonWizardUser')).to.be.true;
    });
  });

  describe("#setUser()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'postUserPref', Em.K);
      sinon.stub(App.router, 'get').returns('admin');
    });
    afterEach(function () {
      controller.postUserPref.restore();
      App.router.get.restore();
    });
    it("post user pref", function() {
      controller.setUser('ctrl1');
      expect(controller.postUserPref.calledWith(controller.get('PREF_KEY'), {
        userName: 'admin',
        controllerName: 'ctrl1'
      })).to.be.true;
    });
  });

  describe("#resetUser()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'postUserPref', Em.K);
    });
    afterEach(function () {
      controller.postUserPref.restore();
    });
    it("post user pref", function() {
      controller.resetUser('ctrl1');
      expect(controller.postUserPref.calledWith(controller.get('PREF_KEY'), null)).to.be.true;
    });
  });

  describe("#getUser()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'getUserPref', Em.K);
    });
    afterEach(function () {
      controller.getUserPref.restore();
    });
    it("get user pref", function() {
      controller.getUser('ctrl1');
      expect(controller.getUserPref.calledWith(controller.get('PREF_KEY'))).to.be.true;
    });
  });

  describe("#getUserPrefSuccessCallback()", function() {
    it("data is null", function() {
      controller.getUserPrefSuccessCallback(null);
      expect(controller.get('wizardUser')).to.be.null;
      expect(controller.get('controllerName')).to.be.null;
    });
    it("data is correct", function() {
      controller.getUserPrefSuccessCallback({userName: 'admin', controllerName: 'ctrl1'});
      expect(controller.get('wizardUser')).to.equal('admin');
      expect(controller.get('controllerName')).to.equal('ctrl1');
    });
  });

  describe("#getUserPrefErrorCallback()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'resetUser', Em.K);
    });
    afterEach(function () {
      controller.resetUser.restore();
    });
    it("reset wizard-data", function() {
      controller.getUserPrefErrorCallback();
      expect(controller.resetUser.calledOnce).to.be.true;
    });
  });
});

});

require.register("test/controllers/installer_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('models/cluster');
require('controllers/wizard');
require('controllers/installer');

describe('App.InstallerController', function () {

  var installerController = App.InstallerController.create();

  after(function () {
    installerController.destroy();
  });

  describe('#init', function () {
    var c;
    beforeEach(function () {
      c = App.InstallerController.create({});
    });
    it('all steps are disabled by default', function () {
      expect(c.get('isStepDisabled.length')).to.be.above(0);
      expect(c.get('isStepDisabled').everyProperty('value', true)).to.be.ok;
    });
  });

  describe('#getCluster', function() {
    it ('Should return merged clusterStatusTemplate', function() {
      installerController.set('clusterStatusTemplate', {
        name: 'template'
      });
      expect(installerController.getCluster()).to.eql({
        name: 'template'
      });
    });
  });

  describe('#getHosts', function() {
    it ('Should return empty array', function() {
      expect(installerController.getHosts()).to.eql([]);
    });
  });

  describe('#loadServices', function() {
    it ('Should resolve nothing', function() {
      var res = installerController.loadServices();
      res.then(function(data){
        expect(data).to.be.undefined;
      });
    });
  });

  describe('#checkRepoURL', function() {
    var stacks = Em.A([
      Em.Object.create({
        isSelected: false
      }),
      Em.Object.create({
        isSelected: true,
        reload: false,
        id: 'nn-cc',
        stackNameVersion: 'nn-cc',
        repositories: Em.A([
          Em.Object.create({
            isSelected: true,
            isEmpty: false
          })
        ]),
        operatingSystems: Em.A([
          Em.Object.create({
            isSelected: true,
            isEmpty: false,
            repositories: Em.A([
              Em.Object.create({
                isEmpty: false,
                errorTitle: '1',
                errorContent: '1',
                validation: ''
              })
            ])
          })
        ])
      })
    ]);
    var wizard = Em.Object.create({
      skipValidationChecked: true
    });
    it ('Should reload installed stacks', function() {

      installerController.set('content.stacks', stacks);
      installerController.checkRepoURL(wizard);

      var expected = [
        {
          "isSelected": false
        },
        {
          "isSelected": true,
          "reload": true,
          "id": "nn-cc",
          "stackNameVersion": 'nn-cc',
          "repositories": [
            {
              "isSelected": true,
              "isEmpty": false
            }
          ],
          "operatingSystems": [
            {
              "isSelected": true,
              "isEmpty": false,
              "repositories": [
                {
                  "isEmpty": false,
                  "errorTitle": "",
                  "errorContent": "",
                  "validation": "icon-repeat"
                }
              ]
            }
          ]
        }
      ];

      var res = JSON.parse(JSON.stringify(installerController.get('content.stacks')));

      expect(res).to.be.eql(expected);
    });
  });

  describe('#checkRepoURLSuccessCallback', function() {
    var stacks = Em.A([
      Em.Object.create({
        isSelected: false
      }),
      Em.Object.create({
        isSelected: true,
        reload: false,
        id: 'nn-cc',
        repositories: Em.A([
          Em.Object.create({
            repoId: 11,
            isSelected: true,
            isEmpty: false
          })
        ]),
        operatingSystems: Em.A([
          Em.Object.create({
            isSelected: true,
            isEmpty: false,
            id: 1,
            repositories: Em.A([
              Em.Object.create({
                repoId: 11,
                isEmpty: false,
                errorTitle: '1',
                errorContent: '1',
                validation: ''
              })
            ])
          })
        ])
      })
    ]);
    var resolve = false;
    var data = {
      osId: 1,
      repoId: 11,
      dfd: {
        resolve: function() {
          resolve = true;
        }
      }
    };
    it ('Should check stacks for sucess', function() {

      installerController.set('content.stacks', stacks);
      installerController.checkRepoURLSuccessCallback(null,null,data);

      var expected = [
        {
          "isSelected": false
        },
        {
          "isSelected": true,
          "reload": false,
          "id": "nn-cc",
          "repositories": [
            {
              "repoId": 11,
              "isSelected": true,
              "isEmpty": false
            }
          ],
          "operatingSystems": [
            {
              "isSelected": true,
              "isEmpty": false,
              "id": 1,
              "repositories": [
                {
                  "repoId": 11,
                  "isEmpty": false,
                  "errorTitle": "1",
                  "errorContent": "1",
                  "validation": "icon-ok"
                }
              ]
            }
          ]
        }
      ];

      var res = JSON.parse(JSON.stringify(installerController.get('content.stacks')));
      expect(resolve).to.be.true;
      expect(res).to.be.eql(expected);
    });
  });

  describe('#checkRepoURLErrorCallback', function() {
    var stacks = Em.A([
      Em.Object.create({
        isSelected: false
      }),
      Em.Object.create({
        isSelected: true,
        reload: false,
        id: 'nn-cc',
        repositories: Em.A([
          Em.Object.create({
            repoId: 11,
            isSelected: true
          })
        ]),
        operatingSystems: Em.A([
          Em.Object.create({
            isSelected: true,
            id: 1,
            repositories: Em.A([
              Em.Object.create({
                repoId: 11,
                errorTitle: '1',
                errorContent: '1',
                validation: ''
              })
            ])
          })
        ])
      })
    ]);
    var resolve = false;
    var data = {
      osId: 1,
      repoId: 11,
      dfd: {
        reject: function() {
          resolve = true;
        }
      }
    };
    it ('Should check stacks for error', function() {

      var req = {
        status: 500,
        statusText: 'error'
      };
      installerController.set('content.stacks', stacks);
      installerController.checkRepoURLErrorCallback(req,{},{},{},data);

      var expected = [
        {
          "isSelected": false
        },
        {
          "isSelected": true,
          "reload": false,
          "id": "nn-cc",
          "repositories": [
            {
              "repoId": 11,
              "isSelected": true
            }
          ],
          "operatingSystems": [
            {
              "isSelected": true,
              "id": 1,
              "repositories": [
                {
                  "repoId": 11,
                  "errorTitle": "500:error",
                  "errorContent": "",
                  "validation": "icon-exclamation-sign"
                }
              ]
            }
          ]
        }
      ];

      var res = JSON.parse(JSON.stringify(installerController.get('content.stacks')));
      expect(resolve).to.be.true;
      expect(res).to.be.eql(expected);
    });
  });

  describe('#setLowerStepsDisable', function() {

    beforeEach(function () {
      var steps = Em.A([
        Em.Object.create({
          step: 0,
          value: false
        }),
        Em.Object.create({
          step: 1,
          value: false
        }),
        Em.Object.create({
          step: 2,
          value: false
        }),
        Em.Object.create({
          step: 3,
          value: false
        }),
        Em.Object.create({
          step: 4,
          value: false
        })
      ]);
      installerController.set('isStepDisabled', steps);
      installerController.setLowerStepsDisable(3);
    });

    it ('Should disable lower steps', function() {
      var expected = [
        {
          "step": 0,
          "value": true
        },
        {
          "step": 1,
          "value": true
        },
        {
          "step": 2,
          "value": true
        },
        {
          "step": 3,
          "value": false
        },
        {
          "step": 4,
          "value": false
        }
      ];
      var res = JSON.parse(JSON.stringify(installerController.get('isStepDisabled')));
      expect(res).to.eql(expected);
    });
  });

  describe('#setStepsEnable', function() {

    beforeEach(function () {
      var steps = Em.A([
        Em.Object.create({
          step: 0,
          value: false
        }),
        Em.Object.create({
          step: 1,
          value: false
        }),
        Em.Object.create({
          step: 2,
          value: false
        }),
        Em.Object.create({
          step: 3,
          value: false
        }),
        Em.Object.create({
          step: 4,
          value: false
        })
      ]);
      installerController.set('isStepDisabled', steps);
      installerController.totalSteps = steps.length - 1;
      installerController.set('currentStep',2);
    });

    it ('Should enable next steps', function() {
      var expected = [
        {
          "step": 0,
          "value": false
        },
        {
          "step": 1,
          "value": true
        },
        {
          "step": 2,
          "value": true
        },
        {
          "step": 3,
          "value": true
        },
        {
          "step": 4,
          "value": true
        }
      ];
      var res = JSON.parse(JSON.stringify(installerController.get('isStepDisabled')));
      expect(res).to.eql(expected);
    });
  });

  describe('#loadMap', function() {

    describe('Should load cluster', function() {
      var loadCluster = false;
      var checker = {
        load: function() {
          loadCluster = true;
        }
      };

      beforeEach(function () {
        installerController.loadMap['0'][0].callback.call(checker);
      });

      it('cluster info is loaded', function () {
        expect(loadCluster).to.be.true;
      });
    });

    describe('Should load stacks', function() {
      var loadStacks = false;
      var checker = {
        loadStacks: function() {
          return {
            always: function() {
              loadStacks = true;
            }
          };
        }
      };

      beforeEach(function () {
        installerController.loadMap['1'][0].callback.call(checker);
      });

      it('stack info is loaded', function () {
        expect(loadStacks).to.be.true;
      });
    });

    describe ('Should load stacks async', function() {
      var loadStacksVersions = false;
      var checker = {
        loadStacksVersions: function() {
          loadStacksVersions = true;
        }
      };

      it('stack versions are loaded', function () {
        installerController.loadMap['1'][1].callback.call(checker, true).then(function(data){
          expect(data).to.be.true;
        });
        expect(loadStacksVersions).to.be.false;
      });
    });

    describe('Should load installOptions', function() {
      var installOptions = false;
      var checker = {
        load: function() {
          installOptions = true;
        }
      };

      beforeEach(function () {
        installerController.loadMap['2'][0].callback.call(checker);
      });

      it('install option are loaded', function () {
        expect(installOptions).to.be.true;
      });
    });

    describe('Should load loadConfirmedHosts', function() {
      var loadConfirmedHosts = false;
      var checker = {
        loadConfirmedHosts: function() {
          loadConfirmedHosts = true;
        }
      };

      beforeEach(function () {
        installerController.loadMap['3'][0].callback.call(checker);
      });

      it('confirmed hosts are loaded', function () {
        expect(loadConfirmedHosts).to.be.true;
      });
    });

    describe('Should load loadServices', function() {
      var loadServices = false;
      var checker = {
        loadServices: function() {
          loadServices = true;
        }
      };

      beforeEach(function () {
        installerController.loadMap['4'][0].callback.call(checker);
      });

      it('services are loaded', function () {
        expect(loadServices).to.be.true;
      });
    });

    describe('Should load loadServices (2)', function() {
      var setSkipSlavesStep = false;
      var loadMasterComponentHosts = false;
      var loadConfirmedHosts = false;
      var loadComponentsFromConfigs = false;
      var loadRecommendations = false;

      var checker = {
        setSkipSlavesStep: function() {
          setSkipSlavesStep = true;
        },
        loadMasterComponentHosts: function() {
          loadMasterComponentHosts = true;
        },
        loadConfirmedHosts: function() {
          loadConfirmedHosts = true;
        },
        loadComponentsFromConfigs: function() {
          loadComponentsFromConfigs = true;
        },
        loadRecommendations: function() {
          loadRecommendations = true;
        }
      };

      beforeEach(function () {
        installerController.loadMap['5'][0].callback.call(checker);
      });

      it('confirmed hosts are loaded', function() {
        expect(loadConfirmedHosts).to.be.true;
      });

      it('`skipSlavesStep` is loaded', function() {
        expect(setSkipSlavesStep).to.be.true;
      });

      it('master components hosts are loaded', function() {
        expect(loadMasterComponentHosts).to.be.true;
      });

      it('components added via configs are loaded', function () {
        expect(loadComponentsFromConfigs).to.be.true;
      });

      it('recommendations are loaded', function() {
        expect(loadRecommendations).to.be.true;
      });

    });

    describe ('Should load serviceConfigGroups', function() {
      var loadServiceConfigGroups = false;
      var loadServiceConfigProperties = false;
      var loadCurrentHostGroups = false;
      var loadRecommendationsConfigs = false;
      var loadComponentsFromConfigs = false;
      var loadConfigThemes = false;

      var checker = {
        loadServiceConfigGroups: function() {
          loadServiceConfigGroups = true;
        },
        loadServiceConfigProperties: function() {
          loadServiceConfigProperties = true;
          return $.Deferred().resolve().promise();
        },
        loadCurrentHostGroups: function() {
          loadCurrentHostGroups = true;
        },
        loadRecommendationsConfigs: function() {
          loadRecommendationsConfigs = true;
        },
        loadComponentsFromConfigs: function() {
          loadComponentsFromConfigs = true;
        },
        loadConfigThemes: function() {
          loadConfigThemes = true;
          return $.Deferred().resolve().promise();
        }
      };

      beforeEach(function () {
        installerController.loadMap['7'][0].callback.call(checker);
      });

      it('config groups are loaded', function () {
        expect(loadServiceConfigGroups).to.be.true;
      });

      it('config properties are loaded', function () {
        expect(loadServiceConfigProperties).to.be.true;
      });

      it('current host groups are loaded', function () {
        expect(loadCurrentHostGroups).to.be.true;
      });

      it('recommendations are loaded', function () {
        expect(loadRecommendationsConfigs).to.be.true;
      });

      it('components added via configs are loaded', function () {
        expect(loadComponentsFromConfigs).to.be.true;
      });

      it('config themes are loaded', function () {
        expect(loadConfigThemes).to.be.true;
      });

    });

    describe('Should load clients', function() {
      var loadSlaveComponentHosts = false;
      var loadClients = false;
      var loadRecommendations = false;
      var loadComponentsFromConfigs = false;

      var checker = {
        loadSlaveComponentHosts: function() {
          loadSlaveComponentHosts = true;
        },
        loadClients: function() {
          loadClients = true;
        },
        loadComponentsFromConfigs: function() {
          loadComponentsFromConfigs = true;
        },
        loadRecommendations: function() {
          loadRecommendations = true;
        }
      };

      beforeEach(function () {
        installerController.loadMap['6'][0].callback.call(checker);
      });

      it('slave components hosts are loaded', function () {
        expect(loadSlaveComponentHosts).to.be.true;
      });

      it('clients are loaded', function () {
        expect(loadClients).to.be.true;
      });

      it('components added via configs are loaded', function () {
        expect(loadComponentsFromConfigs).to.be.true;
      });

      it('recommendations are loaded', function () {
        expect(loadRecommendations).to.be.true;
      });

    });

  });

  describe('#removeHosts', function() {
    var hostsDb = {
      'h1': {},
      'h2': {},
      'h3': {},
      'h4': {}
    };
    beforeEach(function () {
      sinon.stub(installerController, 'getDBProperty').returns(hostsDb);
    });
    afterEach(function () {
      installerController.getDBProperty.restore();
    });
    it ('Should remove hosts from the list', function() {
      var hosts = Em.A([
        {
          name: 'h1'
        },
        {
          name: 'h2'
        },
        {
          name: 'h3'
        }
      ]);
      installerController.removeHosts(hosts);
      expect(hostsDb).to.eql({
        'h4': {}
      });
    });
  });

  describe('#allHosts', function() {
    it ('Should return hosts', function() {
      var hosts = {
        'h1': {
          disk_info: Em.A([{
            available: 1,
            size: 10
          }]),
          hostComponents: Em.A([])
        }
      };
      var masterComponentHosts = Em.A([
        {
          hostName: 'h1',
          component: 'component',
          display_name: 'n1'
        }
      ]);
      var slaveComponentHosts = Em.A([
        {
          hosts: Em.A([
          {
            hostName: 'h1'
          }
          ])
        }
      ]);
      installerController.set('content.hosts', hosts);
      installerController.set('content.masterComponentHosts', masterComponentHosts);
      installerController.set('content.slaveComponentHosts', slaveComponentHosts);
      var res = JSON.parse(JSON.stringify(installerController.get('allHosts')));
      expect(res).to.eql([
        {
          "diskInfo": [
            {
              "available": 1,
              "size": 10
            }
          ],
          "diskTotal": 0.0000095367431640625,
          "diskFree": 9.5367431640625e-7,
          "hostComponents": [
            {
              "componentName": "component",
              "displayName": "n1"
            },
            {}
          ]
        }
      ]);
    });
  });

  describe('#loadServiceConfigProperties', function() {
    beforeEach(function () {
      sinon.stub(installerController, 'getPersistentProperty').returns($.Deferred().resolve({
        value: 2
      }).promise());
    });
    afterEach(function () {
      installerController.getPersistentProperty.restore();
    });
    it ('Should load service config property', function() {
      installerController.loadServiceConfigProperties();
      expect(installerController.get('content.serviceConfigProperties')).to.eql({
        "value": 2
      });
    });
  });

  describe('#saveServices', function() {
    it ('Should return correct names', function() {
      var stepController = Em.A([
        Em.Object.create({
          isInstalled: true,
          isSelected: true,
          serviceName: 'i1'
        }),
        Em.Object.create({
          isInstalled: false,
          isSelected: true,
          serviceName: 'i2'
        }),
        Em.Object.create({
          isInstalled: true,
          isSelected: false,
          serviceName: 'i3'
        })
      ]);
      installerController.saveServices(stepController);
      expect(installerController.get('content.selectedServiceNames')).to.eql(['i1','i2']);
      expect(installerController.get('content.installedServiceNames')).to.eql(['i1','i3']);
    });
  });

  describe('#saveClients', function() {
    var stepController;

    beforeEach(function () {
      stepController = Em.Object.create({
        content: Em.A([
          Em.Object.create({
            isInstalled: true,
            isSelected: true,
            serviceName: 'i1',
            serviceComponents: Em.A([
              Em.Object.create({
                isClient: true,
                componentName: 'name',
                displayName: 'dname'
              })
            ])
          }),
          Em.Object.create({
            isInstalled: false,
            isSelected: true,
            serviceName: 'i2',
            serviceComponents: Em.A([
              Em.Object.create({
                isClient: false
              })
            ])
          }),
          Em.Object.create({
            isInstalled: true,
            isSelected: false,
            serviceName: 'i3',
            serviceComponents: Em.A([
              Em.Object.create({
                isClient: false
              })
            ])
          })
        ])
      });
    });
    it ('Should return correct clients names', function() {
      installerController.saveClients(stepController);
      var res = JSON.parse(JSON.stringify(installerController.get('content.clients')));
      expect(res).to.eql([
        {
          "component_name": "name",
          "display_name": "dname",
          "isInstalled": false
        }
      ]);
    });
  });

  describe('#saveMasterComponentHosts', function() {
    beforeEach(function () {
      sinon.stub(installerController, 'getDBProperty').returns({
        'h1': {
          id: 11
        },
        'h3': {
          id: 13
        },
        'h2': {
          id: 12
        }
      });
    });
    afterEach(function () {
      installerController.getDBProperty.restore();
    });
    it ('Should return hosts', function() {
      var stepController = Em.Object.create({
        selectedServicesMasters: Em.A([
          Em.Object.create({
            display_name: 'n1',
            component_name: 'c1',
            serviceId: 1,
            selectedHost: 'h1'
          })
        ])
      });
      installerController.saveMasterComponentHosts(stepController);
      expect(installerController.get('content.masterComponentHosts')).to.eql([
        {
          "display_name": "n1",
          "component": "c1",
          "serviceId": 1,
          "isInstalled": false,
          "host_id": 11
        }
      ]);
    });
  });

  describe('#loadConfirmedHosts', function() {
    beforeEach(function () {
      sinon.stub(installerController, 'getDBProperty').returns({
        'h1': {
          id: 11
        },
        'h3': {
          id: 13
        },
        'h2': {
          id: 12
        }
      });
    });
    afterEach(function () {
      installerController.getDBProperty.restore();
    });
    it ('Should load hosts from db', function() {
      installerController.loadConfirmedHosts();
      expect(installerController.get('content.hosts')).to.eql({
        'h1': {
          id: 11
        },
        'h3': {
          id: 13
        },
        'h2': {
          id: 12
        }
      });
    });
  });

  describe('#loadMasterComponentHosts', function() {
    beforeEach(function () {
      sinon.stub(installerController, 'getDBProperties', function() {
        return {
          masterComponentHosts: Em.A([
            {
              hostName: '',
              host_id: 11
            }
          ]),
          hosts: {
            'h1': {
              id: 11
            },
            'h3': {
              id: 13
            },
            'h2': {
              id: 12
            }
          }
        }
      });
    });
    afterEach(function () {
      installerController.getDBProperties.restore();
    });
    it ('Should load hosts', function() {
      installerController.loadMasterComponentHosts();
      expect(installerController.get('content.masterComponentHosts')).to.eql([
        {
          "hostName": "h1",
          "host_id": 11
        }
      ]);
    });
  });

  describe('#loadSlaveComponentHosts', function() {
    beforeEach(function () {
      sinon.stub(installerController, 'getDBProperties', function() {
        return {
          hosts: {
            'h1': {
              id: 11
            },
            'h3': {
              id: 13
            },
            'h2': {
              id: 12
            }
          },
          slaveComponentHosts: Em.A([
            {
              hosts: Em.A([
                {
                  hostName: '',
                  host_id: 11
                }
              ])
            }
          ])
        };
      });
    });
    afterEach(function () {
      installerController.getDBProperties.restore();
    });
    it ('Should load slave hosts', function() {
      installerController.loadSlaveComponentHosts();
      expect(installerController.get('content.slaveComponentHosts')).to.eql([
        {
          "hosts": [
            {
              "hostName": "h1",
              "host_id": 11
            }
          ]
        }
      ]);
    });
  });

  describe('#getServerVersionSuccessCallback', function () {

    var cases = [
        {
          osFamily: 'redhat5',
          expected: false
        },
        {
          osFamily: 'redhat6',
          expected: true
        },
        {
          osFamily: 'suse11',
          expected: false
        }
      ],
      title = 'App.isManagedMySQLForHiveEnabled should be {0} for {1}';

    cases.forEach(function (item) {
      it(title.format(item.expected, item.osFamily), function () {
        installerController.getServerVersionSuccessCallback({
          'RootServiceComponents': {
            'component_version': '',
            'properties': {
              'server.os_family': item.osFamily
            }
          }
        });
        expect(App.get('isManagedMySQLForHiveEnabled')).to.equal(item.expected);
      });
    });

  });

  describe('#validateJDKVersion', function() {
    var tests = [
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.8'
        },
        successCallbackCalled: false,
        popupCalled: true,
        stacks: [Em.Object.create({
          minJdkVersion: '1.6',
          maxJdkVersion: '1.7',
          isSelected: true
        })],
        m: 'JDK 1.8, stack supports 1.6-1.7 popup should be displayed'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.8'
        },
        successCallbackCalled: true,
        popupCalled: false,
        stacks: [Em.Object.create({
          minJdkVersion: '1.6',
          maxJdkVersion: '1.8',
          isSelected: true
        })],
        m: 'JDK 1.8, stack supports 1.7-1.8 procceed installation without warning'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.5'
        },
        successCallbackCalled: false,
        popupCalled: true,
        stacks: [Em.Object.create({
          minJdkVersion: '1.6',
          maxJdkVersion: '1.8',
          isSelected: true
        })],
        m: 'JDK 1.5, stack supports 1.6-1.8, popup should be displayed'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.5'
        },
        successCallbackCalled: true,
        popupCalled: false,
        stacks: [Em.Object.create({
          minJdkVersion: null,
          maxJdkVersion: null,
          isSelected: true
        })],
        m: 'JDK 1.5, stack supports max and min are null, procceed installation without warning'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.5'
        },
        successCallbackCalled: true,
        popupCalled: false,
        stacks: [Em.Object.create({
          minJdkVersion: '1.5',
          maxJdkVersion: null,
          isSelected: true
        })],
        m: 'JDK 1.5, stack supports max is missed and min is 1.5, procceed installation without warning'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.6'
        },
        successCallbackCalled: false,
        popupCalled: true,
        stacks: [Em.Object.create({
          minJdkVersion: '1.5',
          maxJdkVersion: null,
          isSelected: true
        })],
        m: 'JDK 1.6, stack supports max is missed and min is 1.5, popup should be displayed'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.5'
        },
        successCallbackCalled: true,
        popupCalled: false,
        stacks: [Em.Object.create({
          minJdkVersion: null,
          maxJdkVersion: '1.5',
          isSelected: true
        })],
        m: 'JDK 1.5, stack supports max 1.5 and min is missed, procceed installation without warning'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.5'
        },
        successCallbackCalled: false,
        popupCalled: true,
        stacks: [Em.Object.create({
          minJdkVersion: null,
          maxJdkVersion: '1.8',
          isSelected: true
        })],
        m: 'JDK 1.5, stack supports max 1.8 and min is missed, popup should be displayed'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.8'
        },
        successCallbackCalled: true,
        popupCalled: false,
        stacks: [Em.Object.create({
          isSelected: true
        })],
        m: 'JDK 1.8, min, max jdk missed in stack definition, procceed installation without warning'
      },
      {
        isCustomJDK: true,
        ambariProperties: {
          'java.version': '1.8'
        },
        successCallbackCalled: true,
        popupCalled: false,
        stacks: [Em.Object.create({
          minJdkVersion: '1.6',
          maxJdkVersion: '1.8',
          isSelected: true
        })],
        m: 'JDK 1.8, custom jdk location used, procceed installation without warning'
      }
    ];

    tests.forEach(function(test) {

      describe(test.m, function() {

        var successCallback;

        beforeEach(function () {
          sinon.stub(App.Stack, 'find').returns(test.stacks);
          sinon.stub(App.router, 'get').withArgs('clusterController.isCustomJDK').returns(test.isCustomJDK)
            .withArgs('clusterController.ambariProperties').returns(test.ambariProperties);
          sinon.stub(App, 'showConfirmationPopup', Em.K);
          successCallback = sinon.spy();
          installerController.validateJDKVersion(successCallback);
        });

        afterEach(function () {
          App.router.get.restore();
          App.Stack.find.restore();
          App.showConfirmationPopup.restore();
        });

        it('successCallback is ' + (test.successCallbackCalled ? '' : 'not') + ' called', function () {
          expect(successCallback.called).to.be.equal(test.successCallbackCalled);
        });

        it('App.showConfirmationPopup. is ' + (test.popupCalled ? '' : 'not') + ' called', function () {
          expect(App.showConfirmationPopup.called).to.be.equal(test.popupCalled);
        });

      });
    });
  });

  describe('#postVersionDefinitionFileErrorCallback', function () {

    beforeEach(function () {
      sinon.stub(App, 'showAlertPopup', Em.K);
    });

    afterEach(function () {
      App.showAlertPopup.restore();
    });

    it('should delete VDF-data', function () {
      App.db.setLocalRepoVDFData({});
      expect(App.db.getLocalRepoVDFData()).to.not.be.an.object;
      installerController.postVersionDefinitionFileErrorCallback({}, {}, {}, {}, {dfd: $.Deferred()});
      expect(App.db.getLocalRepoVDFData()).to.be.undefined;
    });

  });

});

});

require.register("test/controllers/login_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('models/cluster');
require('controllers/wizard');
require('controllers/installer');

describe('App.LoginController', function () {

  var loginController = App.LoginController.create();

  describe('#postLogin', function() {
    it ('Should set error connect', function() {
      loginController.postLogin(false, false, null);
      expect(loginController.get('errorMessage')).to.be.equal(Em.I18n.t('login.error.bad.connection'));
    });
    it ('Should set error connect with specific message', function() {
      loginController.postLogin(false, false, 'specific message');
      expect(loginController.get('errorMessage')).to.be.equal('specific message');
    });
    it ('Should set error user is disabled', function() {
      loginController.postLogin(true, false, 'User is disabled');
      expect(loginController.get('errorMessage')).to.be.equal(Em.I18n.t('login.error.disabled'));
    });
    it ('Should set bad credentials error', function() {
      loginController.postLogin(true, false, 'Authentication required');
      expect(loginController.get('errorMessage')).to.be.equal(Em.I18n.t('login.error.bad.credentials'));
    });
    it ('Should set bad credentials error, empty response', function() {
      loginController.postLogin(true, false, null);
      expect(loginController.get('errorMessage')).to.be.equal(Em.I18n.t('login.error.bad.credentials'));
    });
    it ('Should set custom error', function() {
      loginController.postLogin(true, false, 'Login Failed: Please append your domain to your username and try again.  Example: user_dup@domain');
      expect(loginController.get('errorMessage')).to.be.equal('Login Failed: Please append your domain to your username and try again.  Example: user_dup@domain');
    });
  });

});

});

require.register("test/controllers/main/admin/highAvailability/hawq/activateStandby/step2_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/admin/highAvailability/hawq/activateStandby/step2_controller');

describe('App.ActivateHawqStandbyWizardStep2Controller', function () {

  describe('#isSubmitDisabled', function () {

    var controller = App.ActivateHawqStandbyWizardStep2Controller.create({
        content: Em.Object.create({})
      }),
      cases = [
        {
          isLoaded: false,
          isSubmitDisabled: true,
          title: 'wizard step content not loaded'
        },
        {
          isLoaded: true,
          isSubmitDisabled: false,
          title: 'wizard step content loaded'
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('isLoaded', item.isLoaded);
        expect(controller.get('isSubmitDisabled')).to.equal(item.isSubmitDisabled);
      });
    });

  });


  describe('#setDynamicConfigValues', function () {

    var controller = App.ActivateHawqStandbyWizardStep2Controller.create({
        content: Em.Object.create({
          masterComponentHosts: [
            {component: 'HAWQMASTER', hostName: 'h0', isInstalled: true},
            {component: 'HAWQSTANDBY', hostName: 'h1', isInstalled: true}
          ],
          hawqHost: {
            hawqMaster: 'h0',
            hawqStandby: 'h1'
          }
        })
      }),
      configs = {
        configs: [
          Em.Object.create({
            name: 'hawq_master_address_host'
          })
        ]
      };


    beforeEach(function () {
      controller.setDynamicConfigValues(configs);
    });

    it('hawq_master_address_host value', function () {
      expect(configs.configs.findProperty('name', 'hawq_master_address_host').get('value')).to.equal('h1');
    });
    it('hawq_master_address_host recommendedValue', function () {
      expect(configs.configs.findProperty('name', 'hawq_master_address_host').get('recommendedValue')).to.equal('h1');
    });
  });

});

});

require.register("test/controllers/main/admin/highAvailability/hawq/addStandby/step3_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/admin/highAvailability/hawq/addStandby/step3_controller');
var testHelpers = require('test/helpers');

function getController() {
  return App.AddHawqStandbyWizardStep3Controller.create({
    content: Em.Object.create({})
  });
}
var controller;

describe('App.AddHawqStandbyWizardStep3Controller', function () {

  beforeEach(function () {
    controller = getController();
  });

  describe('#isSubmitDisabled', function () {

    var cases = [
        {
          isLoaded: false,
          isSubmitDisabled: true,
          title: 'wizard step content not loaded'
        },
        {
          isLoaded: true,
          isSubmitDisabled: false,
          title: 'wizard step content loaded'
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('isLoaded', item.isLoaded);
        expect(controller.get('isSubmitDisabled')).to.equal(item.isSubmitDisabled);
      });
    });

  });

  describe('#loadConfigTagsSuccessCallback', function () {

    it('should send proper ajax request', function () {
      controller.loadConfigTagsSuccessCallback({
        'Clusters': {
          'desired_configs': {
            'hawq-site': {
              'tag': 1
            }
          }
        }
      }, {}, {
        'serviceConfig': {}
      });
      var data = testHelpers.findAjaxRequest('name', 'reassign.load_configs')[0].data;
      expect(data.urlParams).to.equal('(type=hawq-site&tag=1)');
      expect(data.serviceConfig).to.eql({});
    });

  });

  describe('#loadConfigsSuccessCallback', function () {

    var cases = [
        {
          'title': 'should set properties from load config success callback',
          'items': [
            {
              'type': 'hawq-site',
              'properties': {
                'hawq_master_address_host' : 'h0'
              }
            }
          ],
          'params': {
            'serviceConfig': {}
          }
        }
      ];

    beforeEach(function () {
      sinon.stub(controller, 'setDynamicConfigValues', Em.K);
    });

    afterEach(function () {
      controller.setDynamicConfigValues.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.loadConfigsSuccessCallback({
          items: item.items
        }, {}, item.params);
        expect(controller.get('selectedService')).to.eql({});
        expect(controller.get('isLoaded')).to.be.true;
      });
    });

  });

  describe('#loadConfigsSuccessCallback=loadConfigsErrorCallback(we have one callback for both cases)', function () {

    beforeEach(function () {
      sinon.stub(controller, 'setDynamicConfigValues', Em.K);
    });

    afterEach(function () {
      controller.setDynamicConfigValues.restore();
    });

    it('should proceed with default value', function () {
      controller.loadConfigsSuccessCallback({}, {}, {});
      expect(controller.get('selectedService')).to.eql({});
      expect(controller.get('isLoaded')).to.be.true;
    });

  });

  describe('#setDynamicConfigValues', function () {

    var data = {
      items: [
        {
          type: 'hawq-site',
          properties: {
           hawq_master_address_host : 'h0'
          }
        }
      ]
    };

    var configs = {
      configs: [
        Em.Object.create({
          name: 'hawq_standby_address_host'
        })
      ]
    };


    beforeEach(function () {
      controller = App.AddHawqStandbyWizardStep3Controller.create({
        content: Em.Object.create({
          masterComponentHosts: [
            {component: 'HAWQMASTER', hostName: 'h0', isInstalled: true},
            {component: 'HAWQSTANDBY', hostName: 'h1', isInstalled: false}
          ],
          slaveComponentHosts: [],
          hosts: {},
          hawqHost: {
            hawqMaster: 'h0',
            newHawqStandby: 'h1'
          }
        })
      });
      controller.setDynamicConfigValues(configs, data);
    });

    it('hawq_standby_address_host value', function () {
      expect(configs.configs.findProperty('name', 'hawq_standby_address_host').get('value')).to.equal('h1');
    });
    it('hawq_standby_address_host recommendedValue', function () {
      expect(configs.configs.findProperty('name', 'hawq_standby_address_host').get('recommendedValue')).to.equal('h1');
    });
  });

});

});

require.register("test/controllers/main/admin/highAvailability/hawq/removeStandby/step2_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/admin/highAvailability/hawq/removeStandby/step2_controller');

describe('App.RemoveHawqStandbyWizardStep2Controller', function () {

  describe('#isSubmitDisabled', function () {

    var controller = App.RemoveHawqStandbyWizardStep2Controller.create({
        content: Em.Object.create({})
      }),
      cases = [
        {
          isLoaded: false,
          isSubmitDisabled: true,
          title: 'wizard step content not loaded'
        },
        {
          isLoaded: true,
          isSubmitDisabled: false,
          title: 'wizard step content loaded'
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('isLoaded', item.isLoaded);
        expect(controller.get('isSubmitDisabled')).to.equal(item.isSubmitDisabled);
      });
    });

  });


});

});

require.register("test/controllers/main/admin/highAvailability/nameNode/step2_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

function O (fl) {
  return Em.Object.create({
    isInstalled: fl
  })
}

describe('App.HighAvailabilityWizardStep2Controller', function () {
  var controller = App.HighAvailabilityWizardStep2Controller.create();

  describe('#sortMasterComponents', function () {

    it('should sort installed masters first', function() {
      var init = [O(true), O(false), O(true), O(false), O(true)];
      var sorted = [O(true), O(true), O(true), O(false), O(false)];
      expect(controller.sortMasterComponents(init)).to.eql(sorted);
    });
  });

});
});

require.register("test/controllers/main/admin/highAvailability/nameNode/step3_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var testHelpers = require('test/helpers');
var controller;

describe('App.HighAvailabilityWizardStep3Controller', function() {

  var serverConfigData = {
    items: [
      {
        type: 'hdfs-site',
        properties: {
          'dfs.namenode.http-address': 'h1:1234',
          'dfs.namenode.https-address': 'h1:4321',
          'dfs.namenode.rpc-address': 'h1:1111',
          'dfs.journalnode.edits.dir': '/hadoop/hdfs/journalnode123'
        }
      },
      {
        type: 'zoo.cfg',
        properties: {
          clientPort: '4444'
        }
      },
      {
        type: 'hbase-site',
        properties: {
          'hbase.rootdir': 'hdfs://h34:8020/apps/hbase/data'
        }
      },
      {
        type: 'ams-hbase-site',
        properties: {
          'hbase.rootdir': 'hdfs://h1:8020/user/ams/hbase'
        }
      },
      {
        type: 'accumulo-site',
        properties: {
          'instance.volumes': 'hdfs://localhost:8020/apps/accumulo/data'
        }
      },
      {
        type: 'hawq-site',
        properties: {
          'hawq_dfs_url': 'localhost:8020/hawq_data'
        }
      },
      {
        type: 'ranger-env',
        properties: {
          'xasecure.audit.destination.hdfs.dir': 'hdfs://c6401.ambari.apache.org/ranger/audit'
        }
      }
    ]
  };

  beforeEach(function () {
    controller = App.HighAvailabilityWizardStep3Controller.create();
    controller.set('serverConfigData', serverConfigData);
  });

  afterEach(function () {
    controller.destroy();
  });

  describe('#removeConfigs', function() {

    var tests = [
      {
        m: 'should not delete properties if configsToRemove is empty',
        configs: {
          items: [
            {
              type: 'site1',
              properties: {
                property1: 'value1',
                property2: 'value2',
                property3: 'value3',
                property4: 'value4'
              }
            }
          ]
        },
        toRemove: {},
        expected: {
          items: [
            {
              type: 'site1',
              properties: {
                property1: 'value1',
                property2: 'value2',
                property3: 'value3',
                property4: 'value4'
              }
            }
          ]
        }
      },
      {
        m: 'should delete properties from configsToRemove',
        configs: {
          items: [
            {
              type: 'site1',
              properties: {
                property1: 'value1',
                property2: 'value2',
                property3: 'value3',
                property4: 'value4'
              }
            }
          ]
        },
        toRemove: {
          'site1': ['property1', 'property3']
        },
        expected: {
          items: [
            {
              type: 'site1',
              properties: {
                property2: 'value2',
                property4: 'value4'
              }
            }
          ]
        }
      },
      {
        m: 'should delete properties from configsToRemove from different sites',
        configs: {
          items: [
            {
              type: 'site1',
              properties: {
                property1: 'value1',
                property2: 'value2',
                property3: 'value3',
                property4: 'value4'
              }
            },
            {
              type: 'site2',
              properties: {
                property1: 'value1',
                property2: 'value2',
                property3: 'value3',
                property4: 'value4'
              }
            }
          ]
        },
        toRemove: {
          'site1': ['property1', 'property3'],
          'site2': ['property2', 'property4']
        },
        expected: {
          items: [
            {
              type: 'site1',
              properties: {
                property2: 'value2',
                property4: 'value4'
              }
            },
            {
              type: 'site2',
              properties: {
                property1: 'value1',
                property3: 'value3'
              }
            }
          ]
        }
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        var _controller = App.HighAvailabilityWizardStep3Controller.create({
          configsToRemove: test.toRemove,
          serverConfigData: test.configs
        });
        var result = _controller.removeConfigs(test.toRemove, _controller.get('serverConfigData'));
        expect(JSON.stringify(_controller.get('serverConfigData'))).to.equal(JSON.stringify(test.expected));
        expect(JSON.stringify(result)).to.equal(JSON.stringify(test.expected));
      });
    });
  });

  describe('#tweakServiceConfigs', function () {

    var nameServiceId = 'tdk';

    var masterComponentHosts = [
      {component: 'NAMENODE', isInstalled: true, hostName: 'h1'},
      {component: 'NAMENODE', isInstalled: false, hostName: 'h2'},
      {component: 'RANGER_ADMIN', isInstalled: true, hostName: 'h1'},
      {component: 'JOURNALNODE', hostName: 'h1'},
      {component: 'JOURNALNODE', hostName: 'h2'},
      {component: 'JOURNALNODE', hostName: 'h3'},
      {component: 'ZOOKEEPER_SERVER', hostName: 'h1'},
      {component: 'ZOOKEEPER_SERVER', hostName: 'h2'},
      {component: 'ZOOKEEPER_SERVER', hostName: 'h3'}
    ];

    beforeEach(function () {
      controller.set('content', Em.Object.create({
        masterComponentHosts: masterComponentHosts,
        slaveComponentHosts: [],
        hosts: {},
        nameServiceId: nameServiceId
      }));
      var get = sinon.stub(App, 'get');
      get.withArgs('isHadoopWindowsStack').returns(true);
      sinon.stub(App.Service, 'find', function () {
        return [{serviceName: 'HDFS'}, {serviceName: 'HBASE'}, {serviceName: 'AMBARI_METRICS'}, {serviceName: 'ACCUMULO'}, {serviceName: 'HAWQ'}, {serviceName: 'RANGER'}]
      });
    });

    afterEach(function () {
      App.Service.find.restore();
      App.get.restore();
    });

    Em.A([
      {
        config: {
          name: 'dfs.namenode.rpc-address.${dfs.nameservices}.nn1',
          filename: 'hdfs-site'
        },
        value: 'h1:1111',
        name: 'dfs.namenode.rpc-address.' + nameServiceId + '.nn1'
      },
      {
        config: {
          name: 'dfs.namenode.rpc-address.${dfs.nameservices}.nn2',
          filename: 'hdfs-site'
        },
        value: 'h2:8020',
        name: 'dfs.namenode.rpc-address.' + nameServiceId + '.nn2'
      },
      {
        config: {
          name: 'dfs.namenode.http-address.${dfs.nameservices}.nn1',
          filename: 'hdfs-site'
        },
        value: 'h1:1234',
        name: 'dfs.namenode.http-address.' + nameServiceId + '.nn1'
      },
      {
        config: {
          name: 'dfs.namenode.http-address.${dfs.nameservices}.nn2',
          filename: 'hdfs-site'
        },
        value: 'h2:50070',
        name: 'dfs.namenode.http-address.' + nameServiceId + '.nn2'
      },{
        config: {
          name: 'dfs.namenode.rpc-address.${dfs.nameservices}.nn1',
          filename: 'hdfs-client'
        },
        value: 'h1:1111',
        name: 'dfs.namenode.rpc-address.' + nameServiceId + '.nn1'
      },
      {
        config: {
          name: 'dfs.namenode.rpc-address.${dfs.nameservices}.nn2',
          filename: 'hdfs-client'
        },
        value: 'h2:8020',
        name: 'dfs.namenode.rpc-address.' + nameServiceId + '.nn2'
      },
      {
        config: {
          name: 'dfs.namenode.http-address.${dfs.nameservices}.nn1',
          filename: 'hdfs-client'
        },
        value: 'h1:1234',
        name: 'dfs.namenode.http-address.' + nameServiceId + '.nn1'
      },
      {
        config: {
          name: 'dfs.namenode.http-address.${dfs.nameservices}.nn2',
          filename: 'hdfs-client'
        },
        value: 'h2:50070',
        name: 'dfs.namenode.http-address.' + nameServiceId + '.nn2'
      },
      {
        config: {
          name: 'dfs.namenode.https-address.${dfs.nameservices}.nn1',
          filename: 'hdfs-site'
        },
        value: 'h1:4321',
        name: 'dfs.namenode.https-address.' + nameServiceId + '.nn1'
      },
      {
        config: {
          name: 'dfs.namenode.https-address.${dfs.nameservices}.nn2',
          filename: 'hdfs-site'
        },
        value: 'h2:50470',
        name: 'dfs.namenode.https-address.' + nameServiceId + '.nn2'
      },
      {
        config: {
          name: 'dfs.namenode.shared.edits.dir'
        },
        value: 'qjournal://h1:8485;h2:8485;h3:8485/' + nameServiceId
      },
      {
        config: {
          name: 'ha.zookeeper.quorum'
        },
        value: 'h1:4444,h2:4444,h3:4444'
      },
      {
        config: {
          name: 'hbase.rootdir',
          filename: 'hbase-site'
        },
        value: 'hdfs://' + nameServiceId + '/apps/hbase/data'
      },
      {
        config: {
          name: 'hbase.rootdir',
          filename: 'ams-hbase-site'
        },
        value: 'hdfs://' + nameServiceId + '/user/ams/hbase'
      },
      {
        config: {
          name: 'instance.volumes'
        },
        value: 'hdfs://' + nameServiceId + '/apps/accumulo/data'
      },
      {
        config: {
          name: 'instance.volumes.replacements'
        },
        value: 'hdfs://localhost:8020/apps/accumulo/data hdfs://' + nameServiceId + '/apps/accumulo/data'
      },
      {
        config: {
          name: 'dfs.journalnode.edits.dir'
        },
        value: '/hadoop/hdfs/journalnode123'
      },
      {
        config: {
          name: 'hawq_dfs_url',
          filename: 'hawq-site'
        },
        value: nameServiceId + '/hawq_data'
      },
      {
        config: {
          name: 'xasecure.audit.destination.hdfs.dir',
          filename: 'ranger-env'
        },
        value: 'hdfs://' + nameServiceId + '/ranger/audit'
      }
    ]).forEach(function (test) {
      describe(test.config.name, function () {
        var configs;
        beforeEach(function () {
          test.config.displayName = test.config.name;
          configs = controller.tweakServiceConfigs([test.config]);
        });

        it('value is ' + test.value, function () {
          expect(configs[0].value).to.equal(test.value);
        });
        it('recommendedValue is ' + test.value, function () {
          expect(configs[0].recommendedValue).to.equal(test.value);
        });

        if(test.name) {
          it('name is ' + test.name, function () {
            expect(configs[0].name).to.equal(test.name);
          });
          it('displayName is' + test.name, function () {
            expect(configs[0].displayName).to.equal(test.name);
          });
        }
      });
    });

    it('should set isOverridable=false for each config', function () {
      var configs = [
        {name: 'prop1'}, {name: 'prop2'}
      ];
      configs = controller.tweakServiceConfigs(configs);
      expect(configs.everyProperty('isOverridable', false)).to.be.true;
    });

  });

  describe('#onLoadConfigsTags', function () {

    var data = {Clusters: {desired_configs: {
      'hdfs-site': {tag: 'v1'},
      'core-site': {tag: 'v2'},
      'zoo.cfg': {tag: 'v3'},
      'hbase-site': {tag: 'v4'},
      'accumulo-site': {tag: 'v5'},
      'ams-hbase-site': {tag: 'v6'},
      'hawq-site': {tag: 'v7'},
      'hdfs-client': {tag: 'v8'},
      'ranger-env': {tag: 'v9'}
    }}};

    beforeEach(function () {
      sinon.stub(App.Service, 'find', function () {
        return [
          Em.Object.create({serviceName: 'HBASE'}),
          Em.Object.create({serviceName: 'ACCUMULO'}),
          Em.Object.create({serviceName: 'AMBARI_METRICS'}),
          Em.Object.create({serviceName: 'HAWQ'}),
          Em.Object.create({serviceName: 'RANGER'})
        ];
      });
      controller.onLoadConfigsTags(data);
      this.args = testHelpers.findAjaxRequest('name', 'admin.get.all_configurations');
    });

    afterEach(function () {
      App.Service.find.restore();
    });

    it('urlParams are valid', function () {
      expect(this.args[0].data.urlParams).to.be.equal('(type=hdfs-site&tag=v1)|(type=core-site&tag=v2)|(type=zoo.cfg&tag=v3)|(type=hbase-site&tag=v4)|(type=accumulo-site&tag=v5)|(type=ams-hbase-site&tag=v6)|(type=hawq-site&tag=v7)|(type=hdfs-client&tag=v8)|(type=ranger-env&tag=v9)');
    });

  });

});


});

require.register("test/controllers/main/admin/highAvailability/nameNode/step4_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.HighAvailabilityWizardStep4Controller', function() {
  
  describe('#checkNnCheckPointStatus', function() {
    beforeEach(function() {
      this.controller = App.HighAvailabilityWizardStep4Controller.create();
      this.clock = sinon.useFakeTimers();
      sinon.stub(this.controller, 'pullCheckPointStatus');
    });

    afterEach(function() {
      this.clock.restore();
      this.controller.pullCheckPointStatus.restore();
    });

    var tests = [
      {
        responseData: {
          HostRoles: { desired_state: 'STARTED' }
        },
        m: 'NameNode started, Safemode off, no journal node transaction. Polling should be performed and isNameNodeStarted should be true',
        e: {
          isPollingCalled: true,
          isNameNodeStarted: true,
          isNextEnabled: false
        }
      },
      {
        responseData: {
          HostRoles: { desired_state: 'STARTED' },
          metrics: { dfs: { namenode: {
            Safemode: 'ON',
            JournalTransactionInfo: "{\"LastAppliedOrWrittenTxId\":\"4\",\"MostRecentCheckpointTxId\":\"2\"}"
          }}}
        },
        m: 'NameNode started, Safemode on, journal node transaction invalid. Polling should be performed and isNameNodeStarted should be true',
        e: {
          isPollingCalled: true,
          isNameNodeStarted: true,
          isNextEnabled: false
        }
      },
      {
        responseData: {
          HostRoles: { desired_state: 'INSTALLED' },
          metrics: { dfs: { namenode: {
            Safemode: 'ON',
            JournalTransactionInfo: "{\"LastAppliedOrWrittenTxId\":\"15\",\"MostRecentCheckpointTxId\":\"14\"}"
          }}}
        },
        m: 'NameNode not started, Safemode on, journal node transaction present. Polling should not be performed and isNameNodeStarted should be false',
        e: {
          isPollingCalled: false,
          isNameNodeStarted: false,
          isNextEnabled: true
        }
      },
      {
        responseData: {
          HostRoles: { desired_state: 'STARTED' },
          metrics: { dfs: { namenode: {
            Safemode: "",
            JournalTransactionInfo: "{\"LastAppliedOrWrittenTxId\":\"15\",\"MostRecentCheckpointTxId\":\"14\"}"
          }}}
        },
        m: 'NameNode started, Safemode off, journal node transaction present. Polling should not be performed and isNameNodeStarted should be true',
        e: {
          isPollingCalled: true,
          isNameNodeStarted: true,
          isNextEnabled: false
        }
      }
    ];

    tests.forEach(function(test) {
      describe(test.m, function() {

        beforeEach(function () {
          this.controller.set('isNameNodeStarted', !test.e.isNameNodeStarted);
          this.controller.checkNnCheckPointStatus(test.responseData);
          this.clock.tick(this.controller.get('POLL_INTERVAL'));
        });
        it('isNameNodeStarted is ' + test.e.isNameNodeStarted, function () {
          expect(this.controller.get('isNameNodeStarted')).to.be.equal(test.e.isNameNodeStarted);
        });
        it('isNextEnabled is ' + test.e.isNextEnabled, function () {
          expect(this.controller.get('isNextEnabled')).to.be.equal(test.e.isNextEnabled);
        });
        it('pullCheckPointStatus is ' + (test.e.isPollingCalled ? '' : 'not') + ' called', function () {
          expect(this.controller.pullCheckPointStatus.called).to.be.equal(test.e.isPollingCalled);
        });
      });
    });
  });
});


});

require.register("test/controllers/main/admin/highAvailability/progress_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/highAvailability_controller');
require('models/host_component');
require('models/host');
require('utils/ajax/ajax');

describe('App.HighAvailabilityProgressPageController', function () {

  var controller = App.HighAvailabilityProgressPageController.create();

  describe('#reconfigureSites()', function () {
    var tests = [
      {
        siteNames: ["site1", "site2"],
        data: {
          items: [
            {
              type: "site1",
              properties: {
                site1_property1: "site1_property1_value",
                site1_property2: "site1_property2_value"
              },
              properties_attributes: {
                final: {
                  site1_property1: "true"
                }
              }
            },
            {
              type: "site2",
              properties: {
                site2_property1: "site2_property1_value",
                site2_property2: "site2_property2_value"
              }
            },
            {
              type: "site3",
              properties: {
                site3_property: "site3_property_value"
              }
            }
          ]
        },
        note: 'note1',
        result: [
          {
            type: "site1",
            tag: "version1",
            properties: {
              site1_property1: "site1_property1_value",
              site1_property2: "site1_property2_value"
            },
            service_config_version_note: 'note1',
            properties_attributes: {
              final: {
                site1_property1: "true"
              }
            }
          },
          {
            type: "site2",
            tag: "version1",
            properties: {
              site2_property1: "site2_property1_value",
              site2_property2: "site2_property2_value"
            },
            service_config_version_note: 'note1'
          }
        ]
      },
      {
        siteNames: ["site1"],
        data: {
          items: [
            {
              type: "site1",
              properties: {
                site1_property1: "site1_property1_value",
                site1_property2: "site1_property2_value"
              },
              properties_attributes: {
                final: {
                  site1_property1: "true"
                }
              }
            }
          ]
        },
        note: 'note2',
        result: [
          {
            type: "site1",
            tag: "version1",
            properties: {
              site1_property1: "site1_property1_value",
              site1_property2: "site1_property2_value"
            },
            service_config_version_note: 'note2',
            properties_attributes: {
              final: {
                site1_property1: "true"
              }
            }
          }
        ]
      }];

    beforeEach(function () {
      sinon.stub(Date.prototype, 'getTime').returns(1);
    });

    afterEach(function () {
      Date.prototype.getTime.restore();
    });

    tests.forEach(function(t, index) {
      it("reconfigures configs after HA #" + (index + 1), function() {
        controller.set('content', t.content);
        expect(controller.reconfigureSites(t.siteNames, t.data, t.note)).to.eql(t.result);
      });
    });
  });

});

});

require.register("test/controllers/main/admin/highAvailability/progress_popup_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('controllers/main/admin/highAvailability/progress_popup_controller');
var testHelpers = require('test/helpers');

describe('App.HighAvailabilityProgressPopupController', function () {

  var controller;

  beforeEach(function () {
    controller = App.HighAvailabilityProgressPopupController.create();
  });

  after(function () {
    controller.destroy();
  });

  describe('#startTaskPolling', function () {

    describe('should start task polling', function () {

      beforeEach(function () {
        controller.startTaskPolling(1, 2);
      });

      it('isTaskPolling = true', function () {
        expect(controller.get('isTaskPolling')).to.be.true;
      });

      it('taskInfo.id = 2', function () {
        expect(controller.get('taskInfo.id')).to.be.equal(2);
      });

      it('taskInfo.requestId = 1', function () {
        expect(controller.get('taskInfo.requestId')).to.be.equal(1);
      });

      it('App.updater.run is called once', function () {
        expect(App.updater.run.calledOnce).to.be.true;
      });

      it('App.updater.immediateRun is called once', function () {
        expect(App.updater.immediateRun.calledOnce).to.be.true;
      });

    });

  });

  describe('#stopTaskPolling', function () {

    it('should stop task polling', function () {
      controller.stopTaskPolling();
      expect(controller.get('isTaskPolling')).to.be.false;
    });

  });

  describe('#updateTask', function () {

    it('should send polling request', function () {
      controller.updateTask();
      var args = testHelpers.findAjaxRequest('name', 'background_operations.get_by_task');
      expect(args).to.exists;
    });

  });

  describe('#updateTaskSuccessCallback', function () {

    beforeEach(function () {
      controller.reopen({
        taskInfo: {}
      });
    });

    var cases = [
        {
          status: 'FAILED',
          isTaskPolling: false
        },
        {
          status: 'COMPLETED',
          isTaskPolling: false
        },
        {
          status: 'TIMEDOUT',
          isTaskPolling: false
        },
        {
          status: 'ABORTED',
          isTaskPolling: false
        },
        {
          status: 'QUEUED',
          isTaskPolling: true
        },
        {
          status: 'IN_PROGRESS',
          isTaskPolling: true
        }
      ],
      tasks = {
        stderr: 'error',
        stdout: 'output',
        output_log: 'output-log.txt',
        error_log: 'error-log.txt'
      },
      title = '{0}polling task if it\'s status is {1}';

    cases.forEach(function (item) {
      var message = title.format(item.isTaskPolling ? '' : 'not ', item.status);
      describe(message, function () {

        beforeEach(function () {
          controller.updateTaskSuccessCallback({
            Tasks: $.extend(tasks, {
              status: item.status
            })
          });
        });

        it('stderr is valid', function () {
          expect(controller.get('taskInfo.stderr')).to.equal('error');
        });

        it('stdout is valid', function () {
          expect(controller.get('taskInfo.stdout')).to.equal('output');
        });

        it('outputLog is valid', function () {
          expect(controller.get('taskInfo.outputLog')).to.equal('output-log.txt');
        });

        it('errorLog is valid', function () {
          expect(controller.get('taskInfo.errorLog')).to.equal('error-log.txt');
        });

        it('isTaskPolling is valid', function () {
          expect(controller.get('isTaskPolling')).to.equal(item.isTaskPolling);
        });

      });
    });

  });

  describe('#getHosts', function () {

    var cases = [
      {
        name: 'background_operations.get_by_request',
        success: 'onGetHostsSuccess',
        title: 'default background operation polling'
      },
      {
        stageId: 0,
        name: 'common.request.polling',
        stageIdPassed: '0',
        successCallback: 's',
        success: 's',
        title: 'polling by stage, stageId = 0'
      },
      {
        stageId: 1,
        name: 'common.request.polling',
        stageIdPassed: 1,
        successCallback: null,
        success: 'onGetHostsSuccess',
        title: 'polling by stage'
      }
    ];

    cases.forEach(function (item) {
      describe(item.title, function () {

        beforeEach(function () {
          controller.setProperties({
            requestIds: [1, 2],
            stageId: item.stageId
          });
          controller.getHosts(item.successCallback);
          this.bgArgs = testHelpers.filterAjaxRequests('name', 'background_operations.get_by_request');
          this.pollingArgs = testHelpers.filterAjaxRequests('name', 'common.request.polling');
          this.args = item.name === 'background_operations.get_by_request' ? this.bgArgs : this.pollingArgs;
        });

        it('two requests are sent', function () {
          expect(this.args.length).to.be.equal(2);
        });

        it('1st call name is valid', function () {
          expect(this.args[0][0].name).to.equal(item.name);
        });

        it('2nd call name is valid', function () {
          expect(this.args[1][0].name).to.equal(item.name);
        });

        it('1st stageId is valid', function () {
          expect(this.args[0][0].data.stageId).to.eql(item.stageIdPassed);
        });

        it('2nd stageId is valid', function () {
          expect(this.args[1][0].data.stageId).to.eql(item.stageIdPassed);
        });

        it('success callback for first request', function () {
          expect(this.args[0][0].success).to.equal(item.success);
        });

        it('success callback for second request', function () {
          expect(this.args[1][0].success).to.equal(item.success);
        });

      });
    });

  });

  describe("#initPopup()", function () {

    beforeEach(function() {
      sinon.stub(App.ModalPopup, 'show');
      sinon.stub(controller, 'getHosts');
      sinon.stub(controller, 'setProperties');
    });

    afterEach(function() {
      App.ModalPopup.show.restore();
      controller.getHosts.restore();
      controller.setProperties.restore();
    });

    it("App.ModalPopup.show should be called", function() {
      controller.initPopup(null, null, null, true, null);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });

    it("setProperties should be called", function() {
      controller.initPopup('popupTitle', [], {}, false, 1);
      expect(controller.setProperties.calledWith({
        progressController: {},
        popupTitle: 'popupTitle',
        requestIds: [],
        hostsData: [],
        stageId: 1
      })).to.be.true;
    });

    it("getHosts should be called", function() {
      controller.initPopup(null, null, null, false, null);
      expect(controller.getHosts.calledOnce).to.be.true;
    });
  });

  describe("#onGetHostsSuccess()", function () {
    var spinner = Em.Object.create({
      hide: Em.K
    });

    beforeEach(function() {
      sinon.stub(controller, 'calculateHostsData');
      sinon.stub(App.HostPopup, 'initPopup');
      sinon.stub(controller, 'isRequestRunning').returns(true);
      sinon.stub(controller, 'addObserver');
      sinon.stub(controller, 'doPolling');
      sinon.stub(spinner, 'hide');
      controller.setProperties({
        requestIds: [1],
        hostsData: [],
        popupTitle: 'popupTitle',
        spinnerPopup: spinner,
        progressController: {
          name: 'mainAdminStackAndUpgradeController'
        }
      });
      controller.onGetHostsSuccess({});
    });

    afterEach(function() {
      controller.calculateHostsData.restore();
      App.HostPopup.initPopup.restore();
      controller.isRequestRunning.restore();
      controller.addObserver.restore();
      controller.doPolling.restore();
      spinner.hide.restore();
    });

    it("calculateHostsData should be called", function() {
      expect(controller.calculateHostsData.calledWith([{}])).to.be.true;
    });

    it("App.HostPopup.initPopup should be called", function() {
      expect(App.HostPopup.initPopup.calledWith('popupTitle', controller)).to.be.true;
    });

    it("addObserver should be called", function() {
      expect(controller.addObserver.calledWith('progressController.logs.length', controller, 'getDataFromProgressController')).to.be.true;
    });

    it("spinnerPopup.hide should be called", function() {
      expect(spinner.hide.calledOnce).to.be.true;
    });

    it("doPolling should be called", function() {
      expect(controller.doPolling.calledOnce).to.be.true;
    });
  });

  describe("#calculateHostsData()", function () {

    beforeEach(function() {
      sinon.stub(App, 'dateTime').returns('dateTime');
      sinon.stub(controller, 'isRequestRunning').returns(false);
      sinon.stub(controller, 'removeObserver');
    });

    afterEach(function() {
      App.dateTime.restore();
      controller.isRequestRunning.restore();
      controller.removeObserver.restore();
    });

    it("calculate data", function() {
      var data = [
        {
          tasks: [
            {
              Tasks: {
                name: 't1',
                host_name: 'host1'
              }
            },
            {
              Tasks: {
                name: 't2',
                host_name: 'host1'
              }
            }
          ]
        }
      ];
      controller.setProperties({
        popupTitle: 'popupTitle'
      });
      controller.calculateHostsData(data);
      expect(controller.get('services')).to.be.eql([
        {
          "name": "popupTitle",
          "hosts": [
            {
              "name": "host1",
              "publicName": "host1",
              "logTasks": [
                {
                  "Tasks": {
                    "name": "t1",
                    "host_name": "host1"
                  }
                },
                {
                  "Tasks": {
                    "name": "t2",
                    "host_name": "host1"
                  }
                }
              ]
            }
          ]
        }
      ]);
      expect(controller.get('serviceTimestamp')).to.be.equal('dateTime');
      expect(controller.removeObserver.calledWith('progressController.logs.length', controller, 'getDataFromProgressController')).to.be.true;
    });
  });

  describe("#getDataFromProgressController()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'calculateHostsData');
    });

    afterEach(function() {
      controller.calculateHostsData.restore();
    });

    it("empty logs", function() {
      controller.set('progressController', Em.Object.create({
        logs: []
      }));
      controller.getDataFromProgressController();
      expect(controller.calculateHostsData.calledOnce).to.be.false;
    });

    it("filtered logs", function() {
      controller.setProperties({
        progressController: Em.Object.create({
          logs: [
            {
              Tasks: {
                stage_id: 1,
                request_id: 1
              }
            }
          ]
        }),
        stageId: 1,
        hostsData: [
          {
            Requests: {
              id: 1
            }
          }
        ]
      });
      controller.getDataFromProgressController();
      expect(controller.calculateHostsData.calledWith([
        {
          Requests: {
            id: 1
          },
          tasks: [
            {
              Tasks: {
                stage_id: 1,
                request_id: 1
              }
            }
          ]
        }
      ])).to.be.true;
    });
  });

  describe("#isRequestRunning()", function () {
    var testCases = [
      {
        data: [
          {
            Requests: {
              task_count: 1,
              aborted_task_count: 1,
              completed_task_count: 0,
              failed_task_count: 0,
              timed_out_task_count: 0,
              queued_task_count: 0
            }
          }
        ],
        expected: false
      },
      {
        data: [
          {
            Requests: {
              task_count: 1,
              aborted_task_count: 0,
              completed_task_count: 1,
              failed_task_count: 0,
              timed_out_task_count: 0,
              queued_task_count: 0
            }
          }
        ],
        expected: false
      },
      {
        data: [
          {
            Requests: {
              task_count: 1,
              aborted_task_count: 0,
              completed_task_count: 0,
              failed_task_count: 1,
              timed_out_task_count: 0,
              queued_task_count: 0
            }
          }
        ],
        expected: false
      },
      {
        data: [
          {
            Requests: {
              task_count: 1,
              aborted_task_count: 0,
              completed_task_count: 0,
              failed_task_count: 0,
              timed_out_task_count: 1,
              queued_task_count: 0
            }
          }
        ],
        expected: false
      },
      {
        data: [
          {
            Requests: {
              task_count: 1,
              aborted_task_count: 0,
              completed_task_count: 0,
              failed_task_count: 0,
              timed_out_task_count: 0,
              queued_task_count: 1
            }
          }
        ],
        expected: true
      },
      {
        data: [
          {
            Requests: {
              task_count: 1,
              aborted_task_count: 0,
              completed_task_count: 0,
              failed_task_count: 0,
              timed_out_task_count: 0,
              queued_task_count: 0
            }
          }
        ],
        expected: true
      }
    ];

    testCases.forEach(function(test) {
      it("request: " + JSON.stringify(test.data), function() {
        expect(controller.isRequestRunning(test.data)).to.be.equal(test.expected);
      });
    });
  });

});

});

require.register("test/controllers/main/admin/highAvailability/rangerAdmin/step3_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/highAvailability/rangerAdmin/step3_controller');
require('controllers/main/admin/highAvailability/rangerAdmin/wizard_controller');
require('controllers/main');

describe('App.RAHighAvailabilityWizardStep3Controller', function () {

  var controller;

  beforeEach(function () {
    controller = App.RAHighAvailabilityWizardStep3Controller.create();
  });

  describe('#loadStep', function () {

    var dfd,
      testCases = [
        {
          path: 'isLoaded',
          result: true
        },
        {
          path: 'selectedService.configs.length',
          result: 1,
          massage: 'configs length'
        },
        {
          path: 'selectedService.configs.firstObject.name',
          result: 'policymgr_external_url',
          message: 'property name'
        },
        {
          path: 'selectedService.configs.firstObject.category',
          result: 'RANGER',
          message: 'config category'
        },
        {
          path: 'selectedService.configs.firstObject.value',
          result: 'http://localhost:1111',
          message: 'property value'
        }
      ],
      service = Em.Object.create({
        serviceName: 'RANGER',
        displayName: 'Ranger'
      });

    beforeEach(function () {
      dfd = $.Deferred();
      sinon.stub(App.get('router.mainController'), 'isLoading').returns(dfd);
      sinon.stub(App.Service, 'find').returns([service]);
      sinon.stub(App.config, 'get').withArgs('serviceByConfigTypeMap').returns({
        'admin-properties': service
      });
      sinon.stub(App.configsCollection, 'getConfigByName').returns({
        name: 'policymgr_external_url'
      });
      controller.setProperties({
        wizardController: App.get('router.rAHighAvailabilityWizardController'),
        content: {
          loadBalancerURL: 'http://localhost:1111'
        }
      });
      controller.loadStep();
      dfd.resolve();
    });

    afterEach(function () {
      App.get('router.mainController.isLoading').restore();
      App.Service.find.restore();
      App.config.get.restore();
      App.configsCollection.getConfigByName.restore();
    });

    testCases.forEach(function (testCase) {

      it(testCase.message || testCase.path, function () {
        expect(controller.get(testCase.path)).to.equal(testCase.result);
      });

    });

  });

});
});

require.register("test/controllers/main/admin/highAvailability/resourceManager/step3_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/admin/highAvailability/resourceManager/step3_controller');
var testHelpers = require('test/helpers');

describe('App.RMHighAvailabilityWizardStep3Controller', function () {

  describe('#isSubmitDisabled', function () {

    var controller = App.RMHighAvailabilityWizardStep3Controller.create({
        content: Em.Object.create({})
      }),
      cases = [
        {
          isLoaded: false,
          isSubmitDisabled: true,
          title: 'wizard step content not loaded'
        },
        {
          isLoaded: true,
          isSubmitDisabled: false,
          title: 'wizard step content loaded'
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('isLoaded', item.isLoaded);
        expect(controller.get('isSubmitDisabled')).to.equal(item.isSubmitDisabled);
      });
    });

  });

  describe('#loadConfigTagsSuccessCallback', function () {

    var controller = App.RMHighAvailabilityWizardStep3Controller.create({
      content: Em.Object.create({})
    });

    it('should send proper ajax request', function () {
      controller.loadConfigTagsSuccessCallback({
        'Clusters': {
          'desired_configs': {
            'zoo.cfg': {
              'tag': 1
            },
            'yarn-site': {
              'tag': 1
            },
            'yarn-env': {
              'tag': 1
            }
          }
        }
      }, {}, {
        'serviceConfig': {}
      });
      var data = testHelpers.findAjaxRequest('name', 'reassign.load_configs')[0].data;
      expect(data.urlParams).to.equal('(type=zoo.cfg&tag=1)|(type=yarn-site&tag=1)|(type=yarn-env&tag=1)');
      expect(data.serviceConfig).to.eql({});
    });

  });

  describe('#loadConfigsSuccessCallback', function () {

    var controller = App.RMHighAvailabilityWizardStep3Controller.create({
        content: Em.Object.create({})
      }),
      cases = [
        {
          'items': [],
          'params': {
            'serviceConfig': {}
          },
          'port': '2181',
          'webAddressPort' : ':8088',
          'httpsWebAddressPort' : ':8090',
          'title': 'empty response'
        },
        {
          'items': [
            {
              'type': 'zoo.cfg'
            },
            {
              'type': 'yarn-site'
            }
          ],
          'params': {
            'serviceConfig': {}
          },
          'port': '2181',
          'webAddressPort' : ':8088',
          'httpsWebAddressPort' : ':8090',
          'title': 'no zoo.cfg properties received'
        },
        {
          'items': [
            {
              'type': 'zoo.cfg',
              'properties': {
                'n': 'v'
              }
            },
            {
              'type': 'yarn-site',
              'properties': {
                'n': 'v'
              }
            }
          ],
          'params': {
            'serviceConfig': {}
          },
          'port': '2181',
          'webAddressPort' : ':8088',
          'httpsWebAddressPort' : ':8090',
          'title': 'no clientPort property received'
        },
        {
          'items': [
            {
              'type': 'zoo.cfg',
              'properties': {
                'clientPort': '2182'
              }
            },
            {
              'type': 'yarn-site',
              'properties': {
                'yarn.resourcemanager.webapp.address' : 'c6402.ambari.apache.org:7777',
                'yarn.resourcemanager.webapp.https.address' : 'c6402.ambari.apache.org:8888'
              }
            }
          ],
          'params': {
            'serviceConfig': {}
          },
          'port': '2182',
          'webAddressPort' : ':7777',
          'httpsWebAddressPort' : ':8888',
          'title': 'clientPort property received'
        }
      ];

    beforeEach(function () {
      sinon.stub(controller, 'setDynamicConfigValues', Em.K);
    });

    afterEach(function () {
      controller.setDynamicConfigValues.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.loadConfigsSuccessCallback({
          items: item.items
        }, {}, item.params);
        expect(controller.get('selectedService')).to.eql({});
        expect(controller.get('isLoaded')).to.be.true;
      });
    });

  });

  describe('#loadConfigsSuccessCallback=loadConfigsErrorCallback(we have one callback for bouth cases)', function () {

    var controller = App.RMHighAvailabilityWizardStep3Controller.create({
      content: Em.Object.create({})
    });

    beforeEach(function () {
      sinon.stub(controller, 'setDynamicConfigValues', Em.K);
    });

    afterEach(function () {
      controller.setDynamicConfigValues.restore();
    });

    it('should proceed with default value', function () {
      controller.loadConfigsSuccessCallback({}, {}, {}, {}, {
        serviceConfig: {}
      });
      expect(controller.get('selectedService')).to.eql({});
      expect(controller.get('isLoaded')).to.be.true;
    });

  });

  describe('#setDynamicConfigValues', function () {

    var data = {
      items: [
        {
          type: 'zoo.cfg',
          properties: {
            clientPort: 2222
          }
        },
        {
          type: 'yarn-env',
          properties: {
            yarn_user: 'yarn'
          }
        },
        {
          type: 'yarn-site',
          properties: {
            'yarn.resourcemanager.webapp.address': 'lclhst:1234',
            'yarn.resourcemanager.webapp.https.address': 'lclhst:4321'
          }
        }
      ]
    };

    var controller = App.RMHighAvailabilityWizardStep3Controller.create({
        content: Em.Object.create({
          masterComponentHosts: [
            {component: 'RESOURCEMANAGER', hostName: 'h0', isInstalled: true},
            {component: 'RESOURCEMANAGER', hostName: 'h1', isInstalled: false},
            {component: 'ZOOKEEPER_SERVER', hostName: 'h2', isInstalled: true},
            {component: 'ZOOKEEPER_SERVER', hostName: 'h3', isInstalled: true}
          ],
          slaveComponentHosts: [],
          hosts: {},
          rmHosts: {
            currentRM: 'h0',
            additionalRM: 'h1'
          }
        })
      }),
      configs = {
        configs: [
          Em.Object.create({
            name: 'yarn.resourcemanager.hostname.rm1'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.hostname.rm2'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.zk-address'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.webapp.address.rm1'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.webapp.address.rm2'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.webapp.https.address.rm1'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.webapp.https.address.rm2'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.ha'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.scheduler.ha'
          }),
          Em.Object.create({
            name: 'hadoop.proxyuser.yarn.hosts'
          })
        ]
      };

    beforeEach(function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          Em.Object.create({
            componentName: 'ZOOKEEPER_SERVER',
              hostName: 'h2'
          }),
          Em.Object.create({
            componentName: 'ZOOKEEPER_SERVER',
              hostName: 'h3'
          }),
          Em.Object.create({
            componentName: 'RESOURCEMANAGER',
              hostName: 'h4'
          })
        ];
      });
      controller.setDynamicConfigValues(configs, data);
    });

    afterEach(function () {
      App.HostComponent.find.restore();
    });

    it('yarn.resourcemanager.hostname.rm1 value', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.hostname.rm1').get('value')).to.equal('h0');
    });
    it('yarn.resourcemanager.hostname.rm1 recommendedValue', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.hostname.rm1').get('recommendedValue')).to.equal('h0');
    });
    it('yarn.resourcemanager.hostname.rm2 value', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.hostname.rm2').get('value')).to.equal('h1');
    });
    it('yarn.resourcemanager.hostname.rm2 recommendedValue', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.hostname.rm2').get('recommendedValue')).to.equal('h1');
    });
    it('yarn.resourcemanager.webapp.address.rm1 value', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.address.rm1').get('value')).to.equal('h0:1234');
    });
    it('yarn.resourcemanager.webapp.address.rm1 recommendedValue', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.address.rm1').get('recommendedValue')).to.equal('h0:1234');
    });
    it('yarn.resourcemanager.webapp.address.rm2 value', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.address.rm2').get('value')).to.equal('h1:1234');
    });
    it('yarn.resourcemanager.webapp.address.rm2 recommendedValue', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.address.rm2').get('recommendedValue')).to.equal('h1:1234');
    });
    it('yarn.resourcemanager.webapp.https.address.rm1 value', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.https.address.rm1').get('value')).to.equal('h0:4321');
    });
    it('yarn.resourcemanager.webapp.https.address.rm1 recommendedValue', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.https.address.rm1').get('recommendedValue')).to.equal('h0:4321');
    });
    it('yarn.resourcemanager.webapp.https.address.rm2 value', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.https.address.rm2').get('value')).to.equal('h1:4321');
    });
    it('yarn.resourcemanager.webapp.https.address.rm2 recommendedValue', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.https.address.rm2').get('recommendedValue')).to.equal('h1:4321');
    });
    it('yarn.resourcemanager.zk-address value', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.zk-address').get('value')).to.equal('h2:2222,h3:2222');
    });
    it('yarn.resourcemanager.zk-address recommendedValue', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.zk-address').get('recommendedValue')).to.equal('h2:2222,h3:2222');
    });
    it('yarn.resourcemanager.ha value', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.ha').get('value')).to.equal('h0:8032,h1:8032');
    });
    it('yarn.resourcemanager.ha recommendedValue', function () {
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.scheduler.ha').get('recommendedValue')).to.equal('h0:8030,h1:8030');
    });

    it('hadoop.proxyuser.yarn.hosts value', function () {
      expect(configs.configs.findProperty('name', 'hadoop.proxyuser.yarn.hosts').get('value')).to.equal('h0,h1');
    });

    it('hadoop.proxyuser.yarn.hosts recommendedValue', function () {
      expect(configs.configs.findProperty('name', 'hadoop.proxyuser.yarn.hosts').get('recommendedValue')).to.equal('h0,h1');
    });

  });

});

});

require.register("test/controllers/main/admin/highAvailability_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/highAvailability_controller');
require('models/host_component');
require('models/host');
require('utils/ajax/ajax');

describe('App.MainAdminHighAvailabilityController', function () {

  var controller = App.MainAdminHighAvailabilityController.create();

  describe('#enableHighAvailability()', function () {

    var hostComponents = [];

    beforeEach(function () {
      sinon.stub(App.router, 'transitionTo', Em.K);
      sinon.stub(App.HostComponent, 'find', function(){
        return hostComponents;
      });
      sinon.spy(controller, "showErrorPopup");
    });

    afterEach(function () {
      App.router.transitionTo.restore();
      controller.showErrorPopup.restore();
      App.HostComponent.find.restore();
      App.router.get.restore();
    });

    describe('NAMENODE in INSTALLED state', function () {
      beforeEach(function () {
        hostComponents = [
          Em.Object.create({
            componentName: 'NAMENODE',
            workStatus: 'INSTALLED'
          }),
          Em.Object.create({
            componentName: 'ZOOKEEPER_SERVER',
            workStatus: 'INSTALLED'
          }),
          Em.Object.create({
            componentName: 'ZOOKEEPER_SERVER',
            workStatus: 'INSTALLED'
          }),
          Em.Object.create({
            componentName: 'ZOOKEEPER_SERVER',
            workStatus: 'INSTALLED'
          })
        ];
        sinon.stub(App.router, 'get', function() {
          return 3;
        });
        this.result = controller.enableHighAvailability();
      });

      it('enableHighAvailability result is false', function () {
        expect(this.result).to.be.false;
      });

      it('showErrorPopup is called once', function () {
        expect(controller.showErrorPopup.calledOnce).to.be.true;
      });

    });

    describe('Cluster has less than 3 ZOOKEPER_SERVER components', function () {
      hostComponents = [
        Em.Object.create({
          componentName: 'NAMENODE',
          workStatus: 'STARTED'
        })
      ];

      beforeEach(function () {
        sinon.stub(App.router, 'get', function(){
          return 3;
        });
        this.result = controller.enableHighAvailability();
      });

      it('enableHighAvailability result is false', function () {
        expect(this.result).to.be.false;
      });

      it('showErrorPopup is called', function () {
        expect(controller.showErrorPopup.called).to.be.true;
      });

    });

    describe('total hosts number less than 3', function () {
      hostComponents = [
        Em.Object.create({
          componentName: 'NAMENODE',
          workStatus: 'STARTED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        })
      ];

      beforeEach(function () {
        sinon.stub(App.router, 'get', function () {
          return 1;
        });
        this.result = controller.enableHighAvailability();
      });

      it('enableHighAvailability result is false', function () {
        expect(this.result).to.be.false;
      });

      it('showErrorPopup is called once', function () {
        expect(controller.showErrorPopup.calledOnce).to.be.true;
      });

    });

    describe('All checks passed', function () {
      beforeEach(function () {
        hostComponents = [
          Em.Object.create({
            componentName: 'NAMENODE',
            workStatus: 'STARTED'
          }),
          Em.Object.create({
            componentName: 'ZOOKEEPER_SERVER',
            workStatus: 'INSTALLED'
          }),
          Em.Object.create({
            componentName: 'ZOOKEEPER_SERVER',
            workStatus: 'INSTALLED'
          }),
          Em.Object.create({
            componentName: 'ZOOKEEPER_SERVER',
            workStatus: 'INSTALLED'
          })
        ];
        sinon.stub(App.router, 'get', function() {
          return 3;
        });
        this.result = controller.enableHighAvailability();
      });

      it('enableHighAvailability result is true', function () {
        expect(this.result).to.be.true;
      });

      it('user is moved to enable HA', function () {
        expect(App.router.transitionTo.calledWith('main.services.enableHighAvailability')).to.be.true;
      });

      it('showErrorPopup is not called', function () {
        expect(controller.showErrorPopup.calledOnce).to.be.false;
      });

    });
  });

  describe('#joinMessage()', function () {
    it('message is empty', function () {
      var message = [];
      expect(controller.joinMessage(message)).to.be.empty;
    });
    it('message is array from two strings', function () {
      var message = ['yes', 'no'];
      expect(controller.joinMessage(message)).to.equal('yes<br/>no');
    });
    it('message is string', function () {
      var message = 'hello';
      expect(controller.joinMessage(message)).to.equal('<p>hello</p>');
    });
  });

  describe('#manageJournalNode()', function () {

    beforeEach(function () {
      this.mock = sinon.stub(App.HostComponent, 'find');
      sinon.stub(App.router, 'transitionTo', Em.K);
      sinon.spy(controller, "showErrorPopup");
    });

    afterEach(function () {
      App.router.transitionTo.restore();
      controller.showErrorPopup.restore();
      App.HostComponent.find.restore();
    });

    it('should show error popup if there is no NNs', function () {
      this.mock.returns([]);
      var result = controller.manageJournalNode();
      expect(result).to.be.false;
      expect(controller.showErrorPopup.calledOnce).to.be.true;
    });

    it('should show error popup if there is no NNs', function () {
      this.mock.returns([
        Em.Object.create({
          componentName: 'NAMENODE',
          displayNameAdvanced: 'Active NameNode'
        }),
        Em.Object.create({
          componentName: 'NAMENODE'
        })
      ]);
      var result = controller.manageJournalNode();
      expect(result).to.be.false;
      expect(controller.showErrorPopup.calledOnce).to.be.true;
    });

    it('should call transition to wizard if we have both standby and active NNs', function () {
      this.mock.returns([
        Em.Object.create({
          componentName: 'NAMENODE',
          displayNameAdvanced: 'Active NameNode'
        }),
        Em.Object.create({
          componentName: 'NAMENODE',
          displayNameAdvanced: 'Standby NameNode'
        })
      ]);
      var result = controller.manageJournalNode();
      expect(result).to.be.true;
      expect(App.router.transitionTo.calledOnce).to.be.true;
    });
  });

});

});

require.register("test/controllers/main/admin/kerberos/disable_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');


describe('App.KerberosDisableController', function() {
  var controller;

  beforeEach(function() {
    controller = App.KerberosDisableController.create();
  });

  describe("#loadStep()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'loadTasksStatuses');
      sinon.stub(controller, 'loadTasksRequestIds');
      sinon.stub(controller, 'loadRequestIds');
      controller.loadStep();
    });

    afterEach(function() {
      controller.loadTasksStatuses.restore();
      controller.loadTasksRequestIds.restore();
      controller.loadRequestIds.restore();
    });

    it("controllerName should be set", function() {
      expect(controller.get('content.controllerName')).to.be.equal('kerberosDisableController');
    });

    it("loadTasksStatuses should be called", function() {
      expect(controller.loadTasksStatuses.calledOnce).to.be.true;
    });

    it("loadTasksRequestIds should be called", function() {
      expect(controller.loadTasksRequestIds.calledOnce).to.be.true;
    });

    it("loadRequestIds should be called", function() {
      expect(controller.loadRequestIds.calledOnce).to.be.true;
    });
  });

  describe("#unkerberize()", function () {

    it("App.ajax.send should be called", function() {
      controller.unkerberize();
      var args = testHelpers.findAjaxRequest('name', 'admin.unkerberize.cluster');
      expect(args[0]).to.be.eql({
        name: 'admin.unkerberize.cluster',
        sender: controller,
        success: 'startPolling',
        error: 'onTaskErrorWithSkip'
      });
    });
  });

  describe("#skipTask()", function () {

    it("App.ajax.send should be called", function() {
      controller.skipTask();
      var args = testHelpers.findAjaxRequest('name', 'admin.unkerberize.cluster.skip');
      expect(args[0]).to.be.eql({
        name: 'admin.unkerberize.cluster.skip',
        sender: controller,
        success: 'startPolling',
        error: 'onTaskError'
      });
    });
  });

  describe("#deleteKerberos()", function () {

    it("App.ajax.send should be called", function() {
      controller.deleteKerberos();
      var args = testHelpers.findAjaxRequest('name', 'common.delete.service');
      expect(args[0]).to.be.eql({
        name: 'common.delete.service',
        sender: controller,
        data: {
          serviceName: 'KERBEROS'
        },
        success: 'onTaskCompleted',
        error: 'onTaskCompleted'
      });
    });
  });

  describe("#startAllServices()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'startServices');
    });

    afterEach(function() {
      controller.startServices.restore();
    });

    it("startServices should be called", function() {
      controller.startAllServices();
      expect(controller.startServices.calledOnce).to.be.true;
    });
  });
});

});

require.register("test/controllers/main/admin/kerberos/kerberos_wizard_controler_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');

describe('App.KerberosWizardController', function() {
  var controller;

  beforeEach(function() {
    controller = App.KerberosWizardController.create({});
  });

  describe('#warnBeforeExitPopup()', function () {
    beforeEach(function () {
      sinon.stub(App, "showConfirmationPopup", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });
    it('should open warning confirmation popup', function () {
      var f = Em.K;
      controller.warnBeforeExitPopup(f, false);
      expect(App.showConfirmationPopup.calledWith(f, Em.I18n.t('admin.kerberos.wizard.exit.warning.msg'), null, null, Em.I18n.t('common.exitAnyway'), false)).to.be.true;
    });

    it('should open critical confirmation popup', function () {
      var f = Em.K;
      controller.warnBeforeExitPopup(f, true);
      expect(App.showConfirmationPopup.calledWith(f, Em.I18n.t('admin.kerberos.wizard.exit.critical.msg'), null, null, Em.I18n.t('common.exitAnyway'), true)).to.be.true;
    });
  });

  describe("#skipClientInstall", function () {

    it("kerberosOption is null", function() {
      controller.set('content.kerberosOption', null);
      controller.propertyDidChange('skipClientInstall');
      expect(controller.get('skipClientInstall')).to.be.false;
    });

    it("kerberosOption is 'opt1'", function() {
      controller.set('content.kerberosOption', 'opt1');
      controller.propertyDidChange('skipClientInstall');
      expect(controller.get('skipClientInstall')).to.be.false;
    });

    it("kerberosOption is manual", function() {
      controller.set('content.kerberosOption', Em.I18n.t('admin.kerberos.wizard.step1.option.manual'));
      controller.propertyDidChange('skipClientInstall');
      expect(controller.get('skipClientInstall')).to.be.true;
    });
  });

  describe("#setCurrentStep()", function () {

    beforeEach(function() {
      sinon.stub(App.clusterStatus, 'setClusterStatus');
    });

    afterEach(function() {
      App.clusterStatus.setClusterStatus.restore();
    });

    it("skipStateSave is true", function() {
      controller.setCurrentStep("", true, true);
      expect(App.clusterStatus.setClusterStatus.called).to.be.false;
    });

    it("skipStateSave is false", function() {
      controller.setCurrentStep("", true, false);
      expect(App.clusterStatus.setClusterStatus.calledOnce).to.be.true;
    });
  });

  describe("#getCluster()", function () {

    it("jQuery.extend should be called", function() {
      App.set('clusterName', 'c1');
      controller.set('clusterStatusTemplate', {});
      expect(controller.getCluster()).to.be.eql({name: 'c1'});
    });
  });

  describe("#updateClusterEnvData()", function () {

    it("configs should be set", function() {
      var configs = {};
      controller.set('kerberosDescriptorConfigs', {
        properties: {
          realm: 'realm'
        }
      });
      controller.updateClusterEnvData(configs);
      expect(configs).to.be.eql({
        security_enabled: true,
        kerberos_domain: 'realm'
      });
    });
  });

  describe("#saveClusterStatus()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'save');
    });

    afterEach(function() {
      controller.save.restore();
    });

    it("save should be called", function() {
      controller.set('content.cluster', {});
      controller.saveClusterStatus({});
      expect(controller.save.calledWith('cluster')).to.be.true;
    });

    it("new requestId should be pushed", function() {
      controller.set('content.cluster', {});
      controller.saveClusterStatus({requestId: [1], oldRequestsId: []});
      expect(controller.get('content.cluster')).to.be.eql({
        oldRequestsId: [1],
        requestId: [1]
      });
    });

    it("new requestId should not be pushed", function() {
      controller.set('content.cluster', {});
      controller.saveClusterStatus({requestId: [1], oldRequestsId: [1]});
      expect(controller.get('content.cluster')).to.be.eql({
        oldRequestsId: [1],
        requestId: [1]
      });
    });
  });

  describe("#saveConfigTag()", function () {
    var tag = {
      name: 'n1',
      value: 'v1'
    };

    beforeEach(function() {
      sinon.stub(App.db, 'setKerberosWizardConfigTag');
      controller.saveConfigTag(tag);
    });

    afterEach(function() {
      App.db.setKerberosWizardConfigTag.restore();
    });

    it("App.db.setKerberosWizardConfigTag should be called", function() {
      expect(App.db.setKerberosWizardConfigTag.calledWith(tag)).to.be.true;
    });

    it("content property should be set", function() {
      expect(controller.get('content.n1')).to.be.equal('v1');
    });
  });

  describe("#saveKerberosOption()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'setDBProperty');
      controller.saveKerberosOption(Em.Object.create({selectedItem: "selectedItem"}));
    });

    afterEach(function() {
      controller.setDBProperty.restore();
    });

    it("setDBProperty should be called", function() {
      expect(controller.setDBProperty.calledWith('kerberosOption', "selectedItem")).to.be.true;
    });

    it("kerberosOption should be set", function() {
      expect(controller.get('content.kerberosOption')).to.be.equal('selectedItem');
    });
  });

  describe("#loadKerberosDescriptorConfigs()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'getDBProperty').returns({});
    });

    afterEach(function() {
      controller.getDBProperty.restore();
    });

    it("kerberosDescriptorConfigs should be set", function() {
      controller.loadKerberosDescriptorConfigs();
      expect(controller.get('kerberosDescriptorConfigs')).to.be.eql({});
    });
  });

  describe("#overrideVisibility()", function () {

    it("empty object", function() {
      var itemsArray = [
        {}
      ];
      controller.overrideVisibility(itemsArray, true, []);
      expect(itemsArray[0]).to.be.empty;
    });

    it("override in exception", function() {
      var itemsArray = [
        {
          category: 'c1',
          name: 'n1',
          isVisible: false
        }
      ];
      controller.overrideVisibility(itemsArray, true, [{c1: 'n1'}]);
      expect(itemsArray[0].isVisible).to.be.false;
    });

    it("override should be set to visible", function() {
      var itemsArray = [
        {
          category: 'c1',
          name: 'n1',
          isVisible: false
        }
      ];
      controller.overrideVisibility(itemsArray, true, []);
      expect(itemsArray[0].isVisible).to.be.true;
    });
  });

  describe("#loadKerberosOption()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'getDBProperty').returns('kerberosOption');
    });

    afterEach(function() {
      controller.getDBProperty.restore();
    });

    it("kerberosOption should be set", function() {
      controller.loadKerberosOption();
      expect(controller.get('content.kerberosOption')).to.be.equal('kerberosOption');
    });
  });

  describe("#saveKerberosDescriptorConfigs()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'setDBProperty');
      controller.saveKerberosDescriptorConfigs([]);
    });

    afterEach(function() {
      controller.setDBProperty.restore();
    });

    it("setDBProperty should be called", function() {
      expect(controller.setDBProperty.calledWith('kerberosDescriptorConfigs', [])).to.be.true;
    });

    it("kerberosDescriptorConfigs should be set", function() {
      expect(controller.get('kerberosDescriptorConfigs')).to.be.eql([]);
    });
  });

  describe("#createKerberosResources()", function () {
    var mock = {
      callback: Em.K
    };

    beforeEach(function() {
      sinon.stub(mock, 'callback');
      sinon.stub(controller, 'createKerberosService').returns({
        done: Em.clb
      });
      sinon.stub(controller, 'updateAndCreateServiceComponent').returns({
        done: Em.clb
      });
      sinon.stub(controller, 'createKerberosHostComponents').returns({
        done: Em.clb
      });
      controller.createKerberosResources(mock.callback);
    });

    afterEach(function() {
      controller.createKerberosHostComponents.restore();
      controller.updateAndCreateServiceComponent.restore();
      controller.createKerberosService.restore();
      mock.callback.restore();
    });

    it("createKerberosService should be called", function() {
      expect(controller.createKerberosService.calledOnce).to.be.true;
    });

    it("updateAndCreateServiceComponent should be called", function() {
      expect(controller.updateAndCreateServiceComponent.calledWith('KERBEROS_CLIENT')).to.be.true;
    });

    it("createKerberosHostComponents should be called", function() {
      expect(controller.createKerberosHostComponents.calledOnce).to.be.true;
    });

    it("callback should be called", function() {
      expect(mock.callback.calledOnce).to.be.true;
    });
  });

  describe("#createKerberosService()", function () {

    it("App.ajax.send should be called", function() {
      App.set('clusterName', 'c1');
      controller.createKerberosService();
      var args = testHelpers.findAjaxRequest('name', 'wizard.step8.create_selected_services');
      expect(args[0]).to.be.eql({
        name: 'wizard.step8.create_selected_services',
        sender: controller,
        data: {
          data: '{"ServiceInfo": { "service_name": "KERBEROS"}}',
          cluster: 'c1'
        }
      });
    });
  });

  describe("#deleteKerberosService()", function () {

    beforeEach(function() {
      App.cache.services = [{
        ServiceInfo: {
          service_name: 'KERBEROS'
        }
      }];
      sinon.stub(App.serviceMapper, 'deleteRecord');
      sinon.stub(App.Service, 'find').returns(Em.Object.create({
        isLoaded: true
      }));
      controller.deleteKerberosService();
    });

    afterEach(function() {
      App.serviceMapper.deleteRecord.restore();
      App.Service.find.restore();
    });

    it("App.cache.services should be empty", function() {
      expect(App.cache.services).to.be.empty;
    });

    it("App.serviceMapper.deleteRecord should be called", function () {
      expect(App.serviceMapper.deleteRecord.calledWith(Em.Object.create({
        isLoaded: true
      }))).to.be.true;
    });

    it("App.ajax.send should be called", function() {
      var args = testHelpers.findAjaxRequest('name', 'common.delete.service');
      expect(args[0]).to.be.eql({
        name: 'common.delete.service',
        sender: controller,
        data: {
          serviceName: 'KERBEROS'
        }
      });
    });
  });

  describe("#unkerberize()", function () {

    it("App.ajax.send should be called", function() {
      controller.unkerberize();
      var args = testHelpers.findAjaxRequest('name', 'admin.unkerberize.cluster');
      expect(args[0]).to.be.eql({
        name: 'admin.unkerberize.cluster',
        sender: controller
      });
    });
  });

  describe("#createKerberosHostComponents()", function () {

    it("App.ajax.send should be called", function() {
      App.set('clusterName', 'c1');
      App.set('allHostNames', ['host1']);
      controller.createKerberosHostComponents();
      var args = testHelpers.findAjaxRequest('name', 'wizard.step8.register_host_to_component');
      expect(args[0]).to.be.exists;
    });
  });

  describe("#clearAllSteps()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'clearInstallOptions');
      sinon.stub(controller, 'getCluster').returns({});
      controller.clearAllSteps();
    });

    afterEach(function() {
      controller.clearInstallOptions.restore();
      controller.getCluster.restore();
    });

    it("clearInstallOptions should be called", function() {
      expect(controller.clearInstallOptions.calledOnce).to.be.true;
    });

    it("content.cluster should be set", function() {
      expect(controller.get('content.cluster')).to.be.eql({});
    });
  });

  describe("#clearTasksData()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'saveTasksStatuses');
      sinon.stub(controller, 'saveRequestIds');
      sinon.stub(controller, 'saveTasksRequestIds');
      controller.clearTasksData();
    });

    afterEach(function() {
      controller.saveTasksRequestIds.restore();
      controller.saveTasksStatuses.restore();
      controller.saveRequestIds.restore();
    });

    it("saveTasksRequestIds should be called", function() {
      expect(controller.saveTasksRequestIds.calledWith(undefined)).to.be.true;
    });

    it("saveRequestIds should be called", function() {
      expect(controller.saveRequestIds.calledWith(undefined)).to.be.true;
    });

    it("saveTasksStatuses should be called", function() {
      expect(controller.saveTasksStatuses.calledWith(undefined)).to.be.true;
    });
  });

  describe("#warnBeforeExitPopup()", function () {

    beforeEach(function() {
      sinon.stub(App, 'showConfirmationPopup');
    });

    afterEach(function() {
      App.showConfirmationPopup.restore();
    });

    it("isCritical is true", function() {
      controller.warnBeforeExitPopup(Em.K, true);
      expect(App.showConfirmationPopup.calledWith(Em.K, Em.I18n.t('admin.kerberos.wizard.exit.critical.msg'), null, null, Em.I18n.t('common.exitAnyway'), true)).to.be.true;
    });

    it("isCritical is false", function() {
      controller.warnBeforeExitPopup(Em.K, false);
      expect(App.showConfirmationPopup.calledWith(Em.K, Em.I18n.t('admin.kerberos.wizard.exit.warning.msg'), null, null, Em.I18n.t('common.exitAnyway'), false)).to.be.true;
    });
  });

  describe("#finish()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'setCurrentStep');
      sinon.stub(controller, 'resetDbNamespace');
      controller.finish();
    });

    afterEach(function() {
      controller.setCurrentStep.restore();
      controller.resetDbNamespace.restore();
    });

    it("setCurrentStep should be called", function() {
      expect(controller.setCurrentStep.calledWith('1', false, true)).to.be.true;
    });

    it("resetDbNamespace should be called", function() {
      expect(controller.resetDbNamespace.calledOnce).to.be.true;
    });
  });

  describe("#discardChanges()", function () {
    var mock = {
      onResolve: Em.K
    };

    beforeEach(function() {
      sinon.stub(controller, 'unkerberize').returns({always: Em.clb});
      sinon.stub(controller, 'deleteKerberosService').returns({always: Em.clb});
      sinon.stub(mock, 'onResolve');
      controller.discardChanges().done(mock.onResolve);
    });

    afterEach(function() {
      controller.unkerberize.restore();
      controller.deleteKerberosService.restore();
      mock.onResolve.restore();
    });

    it("unkerberize should be called", function() {
      expect(controller.unkerberize.calledOnce).to.be.true;
    });

    it("deleteKerberosService should be called", function() {
      expect(controller.deleteKerberosService.calledOnce).to.be.true;
    });

    it("onResolve should be called", function() {
      expect(mock.onResolve.calledOnce).to.be.true;
    });
  });


});



});

require.register("test/controllers/main/admin/kerberos/step1_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

function getController() {
  return App.KerberosWizardStep1Controller.create({});
}

describe('App.KerberosWizardStep1Controller', function() {
  var controller;

  beforeEach(function() {
    controller = getController();
  });
  
  describe("#selectedOption", function () {
  	 
    it("test", function() {
      var options=controller.get('options');
      controller.propertyDidChange('selectedOption');
      var option = options.findProperty('value', controller.get('selectedItem'));
      expect(option.preConditions.everyProperty('checked', false)).to.be.true;
    });
    
  });

  describe("#loadStep()", function () {

    beforeEach(function() {
      controller.set('options', []);
    });

    it("enableIpa is true", function() {
      App.set('supports.enableIpa', true);
      controller.loadStep();
      expect(controller.get('selectedItem')).to.be.equal(Em.I18n.t('admin.kerberos.wizard.step1.option.kdc'));
      expect(controller.get('options')).to.not.be.empty;
    });

    it("enableIpa is false", function() {
      App.set('supports.enableIpa', false);
      controller.loadStep();
      expect(controller.get('selectedItem')).to.be.equal(Em.I18n.t('admin.kerberos.wizard.step1.option.kdc'));
      expect(controller.get('options')).to.be.empty;
    });
    
    it("on load selected item should not change", function() {
      controller.set('selectedItem',Em.I18n.t('admin.kerberos.wizard.step3.option.kdc'));	
      controller.loadStep();
      expect(controller.get('selectedItem')).to.be.equal(Em.I18n.t('admin.kerberos.wizard.step3.option.kdc'));
    });
  });

  describe("#submit()", function () {

    beforeEach(function() {
      sinon.stub(App.router, 'send');
    });

    afterEach(function() {
      App.router.send.restore();
    });

    it("App.router.send should be called", function() {
      controller.reopen({
        'isSubmitDisabled': false
      });
      controller.submit();
      expect(App.router.send.calledOnce).to.be.true;
    });

    it("App.router.send should not be called", function() {
      controller.reopen({
        'isSubmitDisabled': true
      });
      controller.submit();
      expect(App.router.send.called).to.be.false;
    });
  });

});

});

require.register("test/controllers/main/admin/kerberos/step2_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var setups = require('test/init_model_test');
var testHelpers = require('test/helpers');

function getController() {
  return App.KerberosWizardStep2Controller.create({
    wizardController: Em.Object.create({
      deleteKerberosService: Em.K
    }),
    controllers: Em.Object.create(),
    content: Em.Object.create()
  });
}

describe('App.KerberosWizardStep2Controller', function() {
  var controller;

  beforeEach(function() {
    controller = getController();
  });

  App.TestAliases.testAsComputedOr(getController(), 'isBackBtnDisabled', ['testConnectionInProgress', 'App.router.nextBtnClickInProgress'], 'boolean');

  App.TestAliases.testAsComputedAlias(getController(), 'hostNames', 'App.allHostNames', 'array');

  App.TestAliases.testAsComputedAlias(getController(), 'isConfigsLoaded', 'wizardController.stackConfigsLoaded', 'boolean');

  describe('#createKerberosSiteObj', function() {

    beforeEach(function() {
      setups.setupStackVersion(this, 'HDP-2.3');
      sinon.stub(controller, 'tweakKdcTypeValue', Em.K);
      sinon.stub(controller, 'tweakManualKdcProperties', Em.K);
    });

    after(function() {
      setups.restoreStackVersion(this);
      controller.tweakKdcTypeValue.restore();
      controller.tweakManualKdcProperties.restore();
    });

    var _createProperty = function(name, value, displayType) {
      var preDefProp = App.config.get('preDefinedSiteProperties').findProperty('name', name);
      if (preDefProp) {
        return App.ServiceConfigProperty.create(
          $.extend(true, {}, preDefProp, {
            value: value, filename: 'some-site.xml',
            'displayType': displayType,
            isRequiredByAgent: preDefProp.isRequiredByAgent === undefined ? true : preDefProp.isRequiredByAgent
          }));
      }
      return App.ServiceConfigProperty.create({name: name, value: value, isRequiredByAgent: true, filename: 'some-site.xml'});
    };

    var tests = [
      {
        stepConfigs: [
          ['realm', ' SPACES ', 'host'],
          ['admin_server_host', ' space_left', 'host'],
          ['kdc_hosts', ' space_left_and_right ', 'host'],
          ['ldap_url', 'space_right ', 'host']
        ],
        e: {
          realm: 'SPACES',
          admin_server_host: 'space_left',
          kdc_hosts: 'space_left_and_right',
          ldap_url: 'space_right'
        }
      }
    ];

    tests.forEach(function(test) {
      describe('Should trim values for properties ' + Em.keys(test.e).join(','), function() {
        var result;

        beforeEach(function () {
          sinon.stub(App.StackService, 'find').returns([Em.Object.create({serviceName: 'KERBEROS'})]);
          controller.set('stepConfigs', [
            App.ServiceConfig.create({
              configs: test.stepConfigs.map(function(item) { return _createProperty(item[0], item[1], item[2]); })
            })
          ]);
          result = controller.createKerberosSiteObj('some-site', 'random-tag');
        });

        afterEach(function () {
          App.StackService.find.restore();
        });

        Em.keys(test.e).forEach(function(propertyName) {
          it(propertyName, function () {
            expect(result.properties[propertyName]).to.be.eql(test.e[propertyName]);
          });
        });
      });
    });
  });

  describe("#isSubmitDisabled", function () {
    var testCases = [
      {
        title: 'stepConfigs is empty',
        data: {
          stepConfigs: []
        },
        expected: true
      },
      {
        title: 'testConnectionInProgress is true',
        data: {
          stepConfigs: [{}],
          testConnectionInProgress: true
        },
        expected: true
      },
      {
        title: 'submitButtonClicked is true',
        data: {
          stepConfigs: [{}],
          testConnectionInProgress: false,
          submitButtonClicked: true
        },
        expected: true
      },
      {
        title: 'configs has errors',
        data: {
          stepConfigs: [{showConfig: true, errorCount: 1}],
          testConnectionInProgress: false,
          submitButtonClicked: false
        },
        expected: true
      },
      {
        title: 'miscModalVisible is true',
        data: {
          stepConfigs: [{showConfig: true, errorCount: 0}],
          testConnectionInProgress: false,
          submitButtonClicked: false,
          miscModalVisible: true
        },
        expected: true
      },
      {
        title: 'miscModalVisible is false',
        data: {
          stepConfigs: [{showConfig: true, errorCount: 0}],
          testConnectionInProgress: false,
          submitButtonClicked: false,
          miscModalVisible: false
        },
        expected: false
      }
    ];

    testCases.forEach(function(test) {
      it(test.title, function() {
        controller.setProperties(test.data);
        controller.propertyDidChange('isSubmitDisabled');
        expect(controller.get('isSubmitDisabled')).to.be.equal(test.expected);
      });
    });
  });

  describe("#clearStep()", function () {

    beforeEach(function() {
      controller.setProperties({
        configs: [{}],
        serviceConfigTags: [{}],
        servicesInstalled: true
      });
      controller.clearStep();
    });

    it("configs should be empty", function() {
      expect(controller.get('configs')).to.be.empty;
    });

    it("serviceConfigTags should be empty", function() {
      expect(controller.get('serviceConfigTags')).to.be.empty;
    });

    it("servicesInstalled should be false", function() {
      expect(controller.get('servicesInstalled')).to.be.false;
    });
  });

  describe("#loadStep()", function () {

    beforeEach(function() {
      this.mockStackService = sinon.stub(App.StackService, 'find').returns([{
        serviceName: 'KERBEROS'
      }]);
      sinon.stub(controller, 'clearStep');
      sinon.stub(App.config, 'setPreDefinedServiceConfigs');
      sinon.stub(App.config, 'mergeStoredValue');
      sinon.stub(controller, 'filterConfigs');
      sinon.stub(controller, 'getKerberosConfigs');
      sinon.stub(controller, 'initializeKDCStoreProperties');
      sinon.stub(controller, 'applyServicesConfigs');
      sinon.stub(controller, 'updateKDCStoreProperties');
      controller.reopen({
        isConfigsLoaded: true,
        stepConfigs: [Em.Object.create({serviceName: 'KERBEROS'})],
        content: Em.Object.create({
          serviceConfigProperties: [{}]
        }),
        wizardController: {
          skipClientInstall: true
        }
      });
    });

    afterEach(function() {
      this.mockStackService.restore();
      controller.clearStep.restore();
      App.config.setPreDefinedServiceConfigs.restore();
      App.config.mergeStoredValue.restore();
      controller.filterConfigs.restore();
      controller.getKerberosConfigs.restore();
      controller.initializeKDCStoreProperties.restore();
      controller.applyServicesConfigs.restore();
      controller.updateKDCStoreProperties.restore();
    });

    it("KERBEROS service absent", function() {
      this.mockStackService.returns([]);
      expect(controller.loadStep()).to.be.false;
    });

    it("configs not loaded", function() {
      controller.set('isConfigsLoaded', false);
      expect(controller.loadStep()).to.be.false;
    });

    it("clearStep should be called", function() {
      controller.loadStep();
      expect(controller.clearStep.calledOnce).to.be.true;
    });

    it("App.config.setPreDefinedServiceConfigs should be called", function() {
      controller.loadStep();
      expect(App.config.setPreDefinedServiceConfigs.calledOnce).to.be.true;
    });

    it("getKerberosConfigs should be called", function() {
      controller.set('content.serviceConfigProperties', null);
      controller.loadStep();
      expect(controller.getKerberosConfigs.calledOnce).to.be.true;
    });

    it("filterConfigs should be called", function() {
      controller.loadStep();
      expect(controller.filterConfigs.calledOnce).to.be.true;
    });

    it("initializeKDCStoreProperties should be called", function() {
      controller.set('wizardController.skipClientInstall', false);
      controller.loadStep();
      expect(controller.initializeKDCStoreProperties.calledOnce).to.be.true;
    });

    it("applyServicesConfigs should be called", function() {
      controller.loadStep();
      expect(controller.applyServicesConfigs.calledOnce).to.be.true;
    });

    it("updateKDCStoreProperties should be called", function() {
      controller.set('wizardController.skipClientInstall', false);
      controller.loadStep();
      expect(controller.updateKDCStoreProperties.calledOnce).to.be.true;
    });
  });

  describe("#getKerberosConfigs()", function () {

    beforeEach(function() {
      this.mock = sinon.stub(App.configsCollection, 'getAll');
      sinon.stub(App.config, 'getConfigTagFromFileName').returns('t1');
      sinon.stub(App.config, 'get').returns([
        Em.Object.create({
          serviceName: 'KERBEROS',
          configTypes: {
            't1': {}
          }
        })
      ]);
    });

    afterEach(function() {
      this.mock .restore();
      App.config.getConfigTagFromFileName.restore();
      App.config.get.restore();
    });

    it("fileName not specified (serviceName S1)", function() {
      this.mock.returns([
        {
          serviceName: 'S1'
        }
      ]);
      expect(controller.getKerberosConfigs()).to.be.empty;
    });

    it("fileName not specified (serviceName KERBEROS)", function() {
      this.mock.returns([
        {
          serviceName: 'KERBEROS'
        }
      ]);
      expect(controller.getKerberosConfigs()).to.be.eql([
        {
          serviceName: 'KERBEROS'
        }
      ]);
    });

    it("incorrect service", function() {
      this.mock.returns([
        {
          fileName: 'f1',
          serviceName: 'S1'
        }
      ]);
      expect(controller.getKerberosConfigs()).to.be.eql([
        {
          fileName: 'f1',
          serviceName: 'S1'
        }
      ]);
    });

    it("fileName and service correct", function() {
      this.mock.returns([
        {
          fileName: 'f1',
          serviceName: 'KERBEROS'
        }
      ]);
      expect(controller.getKerberosConfigs()).to.be.eql([
        {
          fileName: 'f1',
          serviceName: 'KERBEROS'
        }
      ]);
    });
  });

  describe("#filterConfigs()", function () {
    var configs = [
      Em.Object.create({
        serviceName: 'KERBEROS',
        isVisible: false
      }),
      Em.Object.create({
        serviceName: 'S1',
        isVisible: false
      })
    ];

    beforeEach(function() {
      controller.set('controllers', {
        kerberosWizardController: Em.Object.create({
          skipClientInstall: false,
          overrideVisibility: Em.K
        })
      });
      controller.set('content', Em.Object.create({
        kerberosOption: null
      }));
      sinon.stub(controller.get('controllers.kerberosWizardController'), 'overrideVisibility');
      sinon.stub(controller, 'setKDCTypeProperty');
      sinon.stub(controller, 'setConfigVisibility');
    });

    afterEach(function() {
      controller.setKDCTypeProperty.restore();
      controller.setConfigVisibility.restore();
      controller.get('controllers.kerberosWizardController').overrideVisibility.restore();
    });

    it("KERBEROS config should be visible", function() {
      controller.filterConfigs(configs);
      expect(configs.mapProperty('isVisible')).to.be.eql([true, false]);
    });

    it("setKDCTypeProperty should be called", function() {
      controller.filterConfigs(configs);
      expect(controller.setKDCTypeProperty.calledOnce).to.be.true;
    });

    it("setConfigVisibility should not be called", function() {
      controller.set('content.kerberosOption', Em.I18n.t('admin.kerberos.wizard.step1.option.manual'));
      controller.filterConfigs(configs);
      expect(controller.setConfigVisibility.called).to.be.false;
    });

    it("overrideVisibility should be called", function() {
      controller.set('content.kerberosOption', Em.I18n.t('admin.kerberos.wizard.step1.option.manual'));
      controller.set('controllers.kerberosWizardController.skipClientInstall', true);
      controller.filterConfigs(configs);
      expect(controller.get('controllers.kerberosWizardController').overrideVisibility.calledOnce).to.be.true;
    });

    it("overrideVisibility results are valid", function() {
      configs = [{
        name: 'manage_identities'
      }];
      controller.filterConfigs(configs);
      expect(configs[0].isVisible).to.be.false;
      expect(configs[0].value).to.be.equal('true');
    });

    it("setConfigVisibility should be called", function() {
      controller.filterConfigs(configs);
      expect(controller.setConfigVisibility.calledThrice).to.be.true;
    });
  });

  describe("#setConfigVisibility()", function () {

    it("ad type configs", function() {
      var configs = [{name: 'ldap_url'}];
      controller.setConfigVisibility('ad', configs, Em.I18n.t('admin.kerberos.wizard.step1.option.ad'));
      expect(configs[0].isVisible).to.be.true;
    });

    it("mit type configs", function() {
      var configs = [{name: 'kdc_create_attributes'}];
      controller.setConfigVisibility('mit', configs, Em.I18n.t('admin.kerberos.wizard.step1.option.kdc'));
      expect(configs[0].isVisible).to.be.true;
    });

    it("ipa type configs", function() {
      var configs = [{name: 'group'}];
      controller.setConfigVisibility('ipa', configs, Em.I18n.t('admin.kerberos.wizard.step1.option.ipa'));
      expect(configs[0].isVisible).to.be.true;
    });
  });

  describe("#submit()", function () {

    beforeEach(function() {
      sinon.stub(controller.get('wizardController'), 'deleteKerberosService').returns({
        always: Em.clb
      });
      sinon.stub(controller, 'configureKerberos');
      controller.reopen({
        isSubmitDisabled: false
      });
    });

    afterEach(function() {
      controller.get('wizardController').deleteKerberosService.restore();
      controller.configureKerberos.restore();
    });

    it("deleteKerberosService should not be called", function() {
      controller.set('isSubmitDisabled', true);
      expect(controller.submit()).to.be.false;
      expect(controller.get('wizardController').deleteKerberosService.called).to.be.false;
    });

    it("deleteKerberosService should be called", function() {
      controller.submit();
      expect(controller.get('wizardController').deleteKerberosService.called).to.be.true;
    });

    it("configureKerberos should be called", function() {
      controller.submit();
      expect(controller.configureKerberos.calledOnce).to.be.true;
    });
  });

  describe("#configureKerberos()", function () {
    var mock = Em.Object.create({
      createKerberosResources: Em.K
    });

    beforeEach(function() {
      sinon.stub(App.router, 'get').returns(mock);
      sinon.stub(controller, 'createConfigurations').returns({
        done: Em.clb
      });
      sinon.stub(controller, 'createKerberosAdminSession').returns({
        done: Em.clb
      });
      sinon.stub(App.router, 'send');
      sinon.stub(mock, 'createKerberosResources');
    });

    afterEach(function() {
      App.router.get.restore();
      controller.createConfigurations.restore();
      controller.createKerberosAdminSession.restore();
      App.router.send.restore();
      mock.createKerberosResources.restore();
    });

    it("createConfigurations should be called", function() {
      mock.set('skipClientInstall', true);
      controller.configureKerberos();
      expect(controller.createConfigurations.calledOnce).to.be.true;
    });

    it("createKerberosAdminSession should be called", function() {
      mock.set('skipClientInstall', true);
      controller.configureKerberos();
      expect(controller.createKerberosAdminSession.calledOnce).to.be.true;
    });

    it("App.router.send should be called", function() {
      mock.set('skipClientInstall', true);
      controller.configureKerberos();
      expect(App.router.send.calledWith('next')).to.be.true;
    });

    it("createKerberosResources should be called", function() {
      mock.set('skipClientInstall', false);
      controller.configureKerberos();
      expect(mock.createKerberosResources.calledOnce).to.be.true;
    });
  });

  describe("#createConfigurations()", function () {

    beforeEach(function() {
      sinon.stub(App.StackService, 'find').returns([
        Em.Object.create({
          serviceName: 'KERBEROS',
          configTypes: {
            t1: {},
            t3: {}
          },
          configTypesRendered: {
            t1: {},
            t2: {}
          }
        })
      ]);
      sinon.stub(controller, 'createKerberosSiteObj').returns({
        type: 't1'
      });
    });

    afterEach(function() {
      App.StackService.find.restore();
      controller.createKerberosSiteObj.restore();
    });

    it("App.ajax.send should be called", function() {
      controller.createConfigurations();
      var args = testHelpers.findAjaxRequest('name', 'common.across.services.configurations');
      expect(args[0]).to.be.eql({
        name: 'common.across.services.configurations',
        sender: controller,
        data: {
          data: '[' + JSON.stringify({
            Clusters: {
              desired_config: [
                {
                  type: 't1',
                  service_config_version_note: Em.I18n.t('admin.kerberos.wizard.configuration.note')
                }
              ]
            }
          }).toString() + ']'
        }
      });
    });
  });

  describe("#createKerberosSiteObj()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'tweakKdcTypeValue');
      sinon.stub(controller, 'tweakManualKdcProperties');
      sinon.stub(controller, 'tweakIpaKdcProperties');
      sinon.stub(App.config, 'trimProperty', function(arg) {
        return arg;
      });
      controller.set('stepConfigs', [Em.Object.create({
        configs: []
      })]);
    });

    afterEach(function() {
      controller.tweakKdcTypeValue.restore();
      controller.tweakManualKdcProperties.restore();
      controller.tweakIpaKdcProperties.restore();
      App.config.trimProperty.restore();
    });

    it("tweakKdcTypeValue should be called", function() {
      controller.createKerberosSiteObj();
      expect(controller.tweakKdcTypeValue.calledWith({})).to.be.true;
    });

    it("tweakManualKdcProperties should be called", function() {
      controller.createKerberosSiteObj();
      expect(controller.tweakManualKdcProperties.calledWith({})).to.be.true;
    });

    it("tweakIpaKdcProperties should be called", function() {
      controller.createKerberosSiteObj();
      expect(controller.tweakIpaKdcProperties.calledWith({})).to.be.true;
    });

    it("properties should be empty", function() {
      controller.set('stepConfigs', [Em.Object.create({
        configs: [{
          isRequiredByAgent: false,
          filename: 'site.xml'
        }]
      })]);
      expect(controller.createKerberosSiteObj('site', 'tag')).to.be.eql({
        "type": 'site',
        "tag": 'tag',
        "properties": {}
      });
    });

    it("properties should contain kdc_hosts", function() {
      controller.set('stepConfigs', [Em.Object.create({
        configs: [{
          name: 'kdc_hosts',
          value: 'v1',
          filename: 'site.xml'
        }]
      })]);
      expect(controller.createKerberosSiteObj('site', 'tag')).to.be.eql({
        "type": 'site',
        "tag": 'tag',
        "properties": {
          'kdc_hosts': {
            displayType: 'host',
            value: 'v1'
          }
        }
      });
    });

    it("properties should contain n1", function() {
      controller.set('stepConfigs', [Em.Object.create({
        configs: [{
          name: 'n1',
          value: 'v1',
          filename: 'site.xml'
        }]
      })]);
      expect(controller.createKerberosSiteObj('site', 'tag')).to.be.eql({
        "type": 'site',
        "tag": 'tag',
        "properties": {
          'n1': {
            name: 'n1',
            value: 'v1',
            filename: 'site.xml'
          }
        }
      });
    });
  });

  describe("#tweakKdcTypeValue()", function () {

    beforeEach(function() {
      sinon.stub(App.router, 'get').returns({
        'k1': 'p1'
      });
    });

    afterEach(function() {
      App.router.get.restore();
    });

    it("kdc_type should be p2", function() {
      var properties = {'kdc_type': 'p2'};
      controller.tweakKdcTypeValue(properties);
      expect(properties.kdc_type).to.be.equal('p2')
    });

    it("kdc_type should be k1", function() {
      var properties = {'kdc_type': 'p1'};
      controller.tweakKdcTypeValue(properties);
      expect(properties.kdc_type).to.be.equal('k1')
    });
  });

  describe("#tweakManualKdcProperties()", function () {

    it("properties shouldn't be changed", function() {
      var properties = {
        'kdc_type': 'p1'
      };
      controller.set('controllers.kerberosWizardController', Em.Object.create({
        skipClientInstall: false
      }));
      controller.tweakManualKdcProperties(properties);
      expect(properties).to.be.eql({
        'kdc_type': 'p1'
      });
    });

    it("kdc_type is none", function() {
      var properties = {
        'kdc_type': 'none',
        'manage_identities': 'true'
      };
      controller.set('controllers.kerberosWizardController', Em.Object.create({
        skipClientInstall: false
      }));
      controller.tweakManualKdcProperties(properties);
      expect(properties).to.be.eql({
        'kdc_type': 'none',
        'manage_identities': 'false'
      });
    });

    it("skipClientInstall is true", function() {
      var properties = {
        'kdc_type': 'p1',
        'manage_identities': 'true',
        'install_packages': 'true',
        'manage_krb5_conf': 'true'
      };
      controller.set('controllers.kerberosWizardController', Em.Object.create({
        skipClientInstall: true
      }));
      controller.tweakManualKdcProperties(properties);
      expect(properties).to.be.eql({
        'kdc_type': 'p1',
        'manage_identities': 'false',
        'install_packages': 'false',
        'manage_krb5_conf': 'false'
      });
    });
  });

  describe("#tweakIpaKdcProperties()", function () {

    beforeEach(function() {
      sinon.stub(App.router, 'get').returns({'ipa': 'p1'});
    });

    afterEach(function() {
      App.router.get.restore();
    });

    it("properties should be empty, kdc_type undefined", function() {
      var properties = {};
      controller.tweakIpaKdcProperties(properties);
      expect(properties).to.be.empty;
    });

    it("properties should not be empty", function() {
      var properties = {
        kdc_type: 'p1'
      };
      controller.set('content.kerberosOption', 'p2');
      controller.tweakIpaKdcProperties(properties);
      expect(properties).to.be.eql({
        kdc_type: 'p1'
      });
    });

    it("properties should set config values", function() {
      var properties = {
        'kdc_type': 'p1',
        'install_packages': 'true',
        'manage_krb5_conf': 'true'
      };
      controller.set('content.kerberosOption', 'p1');
      controller.tweakIpaKdcProperties(properties);
      expect(properties).to.be.eql({
        'kdc_type': 'p1',
        'install_packages': 'false',
        'manage_krb5_conf': 'false'
      });
    });
  });

  describe("#createKerberosAdminSession()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'createKDCCredentials');
    });

    afterEach(function() {
      controller.createKDCCredentials.restore();
    });

    it("createKDCCredentials should be called", function() {
      controller.set('wizardController.skipClientInstall', false);
      controller.createKerberosAdminSession([]);
      expect(controller.createKDCCredentials.calledWith([])).to.be.true;
    });

    it("createKDCCredentials should be called, with non-empty configs", function() {
      controller.set('stepConfigs', [Em.Object.create({configs: [{}]})]);
      controller.set('wizardController.skipClientInstall', false);
      controller.createKerberosAdminSession();
      expect(controller.createKDCCredentials.calledWith([{}])).to.be.true;
    });

    it("App.ajax.send should be called", function() {
      App.set('clusterName', 'c1');
      var configs = [
        {
          name: 'admin_principal',
          value: 'v1'
        },
        {
          name: 'admin_password',
          value: 'v2'
        }
      ];
      controller.set('wizardController.skipClientInstall', true);

      controller.createKerberosAdminSession(configs);
      var args = testHelpers.findAjaxRequest('name', 'common.cluster.update');
      expect(args[0]).to.be.eql({
        name: 'common.cluster.update',
        sender: controller,
        data: {
          clusterName: 'c1',
          data: [{
            session_attributes: {
              kerberos_admin: {principal: 'v1', password: 'v2'}
            }
          }]
        }
      });
    });
  });

  describe("#showConnectionInProgressPopup()", function () {

    beforeEach(function() {
      sinon.stub(App, 'showConfirmationPopup');
    });

    afterEach(function() {
      App.showConfirmationPopup.restore();
    });

    it("App.showConfirmationPopup should be called", function() {
      var primary = Em.K;
      controller.showConnectionInProgressPopup(primary);
      expect(App.showConfirmationPopup.calledWith(primary, Em.I18n.t('services.service.config.connection.exitPopup.msg'), null, null, Em.I18n.t('common.exitAnyway'))).to.be.true;
    });
  });


  describe("#setKDCTypeProperty()", function () {

    beforeEach(function() {
      sinon.stub(App.router, 'get').returns({
        'k1': 'p1'
      });
    });

    afterEach(function() {
      App.router.get.restore();
    });

    it("kdcTypeProperty should be set", function() {
      var configs = [{
        filename: 'kerberos-env.xml',
        name: 'kdc_type'
      }];
      controller.set('content.kerberosOption', 'p1');
      controller.setKDCTypeProperty(configs);
      expect(configs[0].value).to.be.equal('p1');
    });
  });
});

});

require.register("test/controllers/main/admin/kerberos/step3_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');

describe('App.KerberosWizardStep3Controller', function() {
  var controller;

  beforeEach(function() {
    controller = App.KerberosWizardStep3Controller.create({});
  });

  describe('#onTestKerberosError', function() {

    beforeEach(function(){
      sinon.stub(App.ajax, 'defaultErrorHandler', Em.K);
      sinon.stub(controller, 'onTaskError', Em.K);
    });

    afterEach(function(){
      App.ajax.defaultErrorHandler.restore();
      controller.onTaskError.restore();
    });

    it('should call App.ajax.defaultErrorHandler and onTaskError', function () {
      controller.onTestKerberosError({status: 3}, null, null, {url: 1, type: 2});
      expect(App.ajax.defaultErrorHandler.calledWith({status: 3}, 1, 2, 3)).to.be.true;
      expect(controller.onTaskError.calledOnce).to.be.true;
    });
  });

  describe("#loadStep()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'enableDisablePreviousSteps');
    });

    afterEach(function() {
      controller.enableDisablePreviousSteps.restore();
    });

    it("enableDisablePreviousSteps should be called", function() {
      controller.loadStep();
      expect(controller.enableDisablePreviousSteps.calledOnce).to.be.true;
    });
  });

  describe("#installKerberos()", function () {

    beforeEach(function() {
      this.mock = sinon.stub(controller, 'getKerberosClientState');
      sinon.stub(controller, 'updateComponent');
    });

    afterEach(function() {
      this.mock.restore();
      controller.updateComponent.restore();
    });

    it("not INIT state", function() {
      this.mock.returns({
        done: function(callback) {
          callback({ServiceComponentInfo: {
            state: ""
          }});
        }
      });
      App.set('allHostNames', ['host1']);
      controller.installKerberos();
      expect(controller.updateComponent.calledWith('KERBEROS_CLIENT', ['host1'], "KERBEROS", "Install")).to.be.true;
    });

    it("INIT state", function() {
      this.mock.returns({
        done: function(callback) {
          callback({ServiceComponentInfo: {
            state: "INIT"
          }});
        }
      });
      controller.installKerberos();
      var args = testHelpers.findAjaxRequest('name', 'common.services.update');
      expect(args[0]).to.be.eql({
        name: 'common.services.update',
        sender: controller,
        data: {
          context: Em.I18n.t('requestInfo.kerberosService'),
          ServiceInfo: {"state": "INSTALLED"},
          urlParams: "ServiceInfo/state=INSTALLED&ServiceInfo/service_name=KERBEROS"
        },
        success: 'startPolling',
        error: 'onTaskError'
      });
    });
  });

  describe("#getKerberosClientState()", function () {

    it("App.ajax.send should be called", function() {
      controller.setProperties({
        serviceName: 'S1',
        componentName: 'C1'
      });
      controller.getKerberosClientState();
      var args = testHelpers.findAjaxRequest('name', 'common.service_component.info');
      expect(args[0]).to.be.eql({
        name: 'common.service_component.info',
        sender: controller,
        data: {
          serviceName: 'S1',
          componentName: 'C1',
          urlParams: "fields=ServiceComponentInfo/state"
        }
      });
    });
  });

  describe("#testKerberos()", function () {

    it("App.ajax.send should be called", function() {
      controller.testKerberos();
      var args = testHelpers.findAjaxRequest('name', 'service.item.smoke');
      expect(args[0]).to.exists;
    });
  });

  describe("#onTestKerberosError()", function () {

    beforeEach(function() {
      sinon.stub(App.ajax, 'defaultErrorHandler');
      sinon.stub(controller, 'onTaskError');
      controller.onTestKerberosError({status: 's1'}, {}, "error", {type: 't1', url: 'u1'});
    });

    afterEach(function() {
      App.ajax.defaultErrorHandler.restore();
      controller.onTaskError.restore();
    });

    it("App.ajax.defaultErrorHandler should be called", function() {
      expect(App.ajax.defaultErrorHandler.calledWith({status: 's1'}, 'u1', 't1', 's1')).to.be.true;
    });

    it("onTaskError should be called", function() {
      expect(controller.onTaskError.calledWith({status: 's1'}, {}, "error", {type: 't1', url: 'u1'})).to.be.true;
    });
  });

  describe("#enableDisablePreviousSteps()", function () {
    var mock = {
      setStepsEnable: Em.K,
      setLowerStepsDisable: Em.K
    };

    beforeEach(function() {
      sinon.stub(App.router, 'get').returns(mock);
      sinon.stub(mock, 'setStepsEnable');
      sinon.stub(mock, 'setLowerStepsDisable');
    });

    afterEach(function() {
      App.router.get.restore();
      mock.setStepsEnable.restore();
      mock.setLowerStepsDisable.restore();
    });

    it("setLowerStepsDisable should be called", function() {
      controller.set('tasks', [{
        status: 'COMPLETED'
      }]);
      controller.enableDisablePreviousSteps();
      expect(mock.setLowerStepsDisable.calledWith(3)).to.be.true;
    });

    it("setStepsEnable should be called", function() {
      controller.set('tasks', [{
        status: 'FAILED'
      }]);
      controller.enableDisablePreviousSteps();
      expect(mock.setStepsEnable.called).to.be.true;
    });
  });

  describe("#ignoreAndProceed()", function () {

    it("isSubmitDisabled should be true", function() {
      controller.setProperties({
        showIgnore: true,
        ignore: false
      });
      controller.ignoreAndProceed();
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });

    it("isSubmitDisabled should be false", function() {
      controller.setProperties({
        showIgnore: true,
        ignore: true
      });
      controller.ignoreAndProceed();
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });

    it("isSubmitDisabled should not be changed", function() {
      controller.setProperties({
        showIgnore: false,
        ignore: true,
        isSubmitDisabled: false
      });
      controller.ignoreAndProceed();
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });

  });

  describe('#statusDidChange', function() {
    var cases;
    beforeEach(function() {
      controller.set('status', 'PENDING');
      controller.set('tasks', [
        Em.Object.create({
          id: 0,
          status: 'COMPLETED'
        }),
        Em.Object.create({
          id: 1,
          status: 'COMPLETED'
        })
      ]);
      this.getHeartbeatLostHostsStub = sinon.stub(controller, 'getHeartbeatLostHosts');
    });
    afterEach(function() {
      controller.getHeartbeatLostHosts.restore();
    });

    cases = [
      {
        m: 'Heartbeat lost host during kerberization',
        heartBeatHosts: ['host1'],
        getHeartbeatLostHostsResponse: {
          items: [
            {
              Hosts: {
                host_name: 'host1'
              }
            }
          ]
        },
        expected: {
          heartbeatHosts: ['host1'],
          installClientsTaskStatus: ['FAILED']
        }
      },
      {
        m: 'All hosts in HEALTHY state',
        heartBeatHosts: [],
        getHeartbeatLostHostsResponse: {
          items: []
        },
        expected: {
          heartbeatHosts: [],
          installClientsTaskStatus: ['COMPLETED']
        }
      }
    ];

    cases.forEach(function(test) {
      it(test.m, function() {
        this.getHeartbeatLostHostsStub.returns($.Deferred().resolve(test.getHeartbeatLostHostsResponse).promise());
        controller.set('status', 'COMPLETED');
        controller.propertyDidChange('status');
        assert.sameMembers(controller.get('heartBeatLostHosts'), test.expected.heartbeatHosts, 'heartbeat lost host stored in controller');
        assert.equal(controller.get('tasks').objectAt(0).get('status'), test.expected.installClientsTaskStatus, 'Install Clients task status')
      });
    });
  });
});

});

require.register("test/controllers/main/admin/kerberos/step4_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');

function getController() {
  return App.KerberosWizardStep4Controller.create({
    wizardController: Em.Object.create({
      name: ''
    })
  });
}

describe('App.KerberosWizardStep4Controller', function() {
  var c;

  beforeEach(function() {
    c = getController();
  });

  App.TestAliases.testAsComputedEqual(getController(), 'isWithinAddService', 'wizardController.name', 'addServiceController');

  describe("#clearStep()", function () {

    beforeEach(function() {
      c.clearStep();
    });

    it("isRecommendedLoaded should be set to false", function() {
      expect(c.get('isRecommendedLoaded')).to.be.false;
    });

    it("selectedService should be set to null", function() {
      expect(c.get('selectedService')).to.be.null;
    });

    it("stepConfigs should be set to false", function() {
      expect(c.get('stepConfigs')).to.be.empty;
    });
  });

  describe('#isSubmitDisabled', function() {
    var controller, configs;
    beforeEach(function() {
      controller = App.KerberosWizardStep4Controller.create({});
      configs = Em.A([
        App.ServiceConfigProperty.create({
          name: 'prop1',
          value: 'someVal1',
          identityType: 'user',
          category: 'Ambari Principals',
          serviceName: 'Cluster'
        })
      ]);
      controller.set('stepConfigs', controller.createServiceConfig(configs));
    });

    it('configuration errors are absent, submit should be not disabled', function() {
      expect(controller.get('stepConfigs')[0].get('errorCount')).to.be.equal(0);
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });

    it('config has invalid value, submit should be disabled', function() {
      var serviceConfig = controller.get('stepConfigs')[0];
      serviceConfig.get('configs').findProperty('name', 'prop1').set('value', '');
      serviceConfig.setActivePropertiesOnce();
      serviceConfig.setConfigsWithErrorsOnce();
      expect(serviceConfig.get('errorCount')).to.be.equal(1);
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
  });

  describe('#createServiceConfig', function() {
    var controller = App.KerberosWizardStep4Controller.create({});
    it('should create instance of App.ServiceConfig', function() {
      var configs = controller.createServiceConfig([], []);
      expect(configs).to.have.property('length').equal(2);
      expect(configs[0]).to.be.instanceof(App.ServiceConfig);
      expect(configs[1]).to.be.instanceof(App.ServiceConfig);
    });
  });

  describe('#prepareConfigProperties', function() {

    var properties = Em.A([
      Em.Object.create({ name: 'realm', value: '', serviceName: 'Cluster' }),
      Em.Object.create({ name: 'spnego_keytab', value: 'spnego_keytab_value', serviceName: 'Cluster' }),
      Em.Object.create({ name: 'hdfs_keytab', value: '', serviceName: 'HDFS', identityType: 'user', observesValueFrom: 'spnego_keytab' }),
      Em.Object.create({ name: 'falcon_keytab', value: 'falcon_keytab_value', serviceName: 'FALCON' }),
      Em.Object.create({ name: 'mapreduce_keytab', value: 'mapreduce_keytab_value', serviceName: 'MAPREDUCE2' }),
      Em.Object.create({ name: 'hdfs_principal', value: 'hdfs_principal_value', identityType: 'user', serviceName: 'HDFS' }),
      Em.Object.create({ name: 'hadoop.security.auth_to_local', serviceName: 'HDFS' }),
      App.ServiceConfigProperty.create({ name: 'null_value', serviceName: 'HDFS', value: null, isVisible: true }),
      App.ServiceConfigProperty.create({ name: 'null_value_observed_value_ok', serviceName: 'HDFS', value: null, isVisible: false, observesValueFrom: 'spnego_keytab' })
    ]);

    var propertyValidationCases = [
      {
        property: 'spnego_keytab',
        e: [
          { key: 'category', value: 'Global' },
          { key: 'observesValueFrom', absent: true }
        ]
      },
      {
        property: 'realm',
        e: [
          { key: 'category', value: 'Global' },
          { key: 'value', value: 'realm_value' }
        ]
      },
      {
        property: 'hdfs_keytab',
        e: [
          { key: 'category', value: 'Ambari Principals' },
          { key: 'value', value: 'spnego_keytab_value' },
          { key: 'observesValueFrom', value: 'spnego_keytab' }
        ]
      },
      {
        property: 'hadoop.security.auth_to_local',
        e: [
          { key: 'displayType', value: 'multiLine' }
        ]
      },
      {
        property: 'null_value',
        e: [
          { key: 'isVisible', value: false }
        ]
      },
      {
        property: 'null_value_observed_value_ok',
        e: [
          { key: 'isVisible', value: true }
        ]
      }
    ];

    var absentPropertiesTest = ['falcon_keytab', 'mapreduce_keytab'];

    before(function() {
      var controller = App.KerberosWizardStep4Controller.create({
        wizardController: {
          content: {
            serviceConfigProperties: Em.A([
              Em.Object.create({ name: 'realm', value: 'realm_value' })
            ])
          },
          loadCachedStepConfigValues: function() {
            return null;
          }
        }
      });
      sinon.stub(App.Service, 'find').returns(Em.A([
        { serviceName: 'HDFS' }
      ]));
      sinon.stub(App.configsCollection, 'getAll').returns([
        {
          name: 'hadoop.security.auth_to_local',
          displayType: 'multiLine'
        }
      ]);
      sinon.stub(App.router, 'get').withArgs('mainAdminKerberosController.isManualKerberos').returns(false);
      this.result = controller.prepareConfigProperties(properties);
    });

    after(function() {
      App.Service.find.restore();
      App.configsCollection.getAll.restore();
      App.router.get.restore();
    });

    it('should contains properties only for installed services', function() {
      expect(this.result.mapProperty('serviceName').uniq()).to.be.eql(['Cluster', 'HDFS']);
    });

    absentPropertiesTest.forEach(function(item) {
      it('property `{0}` should be absent'.format(item), function() {
        expect(this.result.findProperty('name', item)).to.be.undefined;
      });
    }, this);

    propertyValidationCases.forEach(function(test) {
      it('property {0} should be created'.format(test.property), function() {
        expect(this.result.findProperty('name', test.property)).to.be.ok;
      });
      test.e.forEach(function(expected) {
        it('property `{0}` should have `{1}` with value `{2}`'.format(test.property, expected.key, expected.value), function() {
          if (!!expected.absent) {
            expect(this.result.findProperty('name', test.property)).to.not.have.deep.property(expected.key);
          } else {
            expect(this.result.findProperty('name', test.property)).to.have.deep.property(expected.key, expected.value);
          }
        }, this);
      }, this);
    });
  });

  describe('#setStepConfigs', function() {
    describe('Add Service Wizard', function() {

      var properties = Em.A([
        Em.Object.create({ name: 'realm', value: '', serviceName: 'Cluster' }),
        Em.Object.create({ name: 'spnego_keytab', value: 'spnego_keytab_value', serviceName: 'Cluster', isEditable: true }),
        Em.Object.create({ name: 'hdfs_keytab', value: '', serviceName: 'HDFS', observesValueFrom: 'spnego_keytab', isEditable: true }),
        Em.Object.create({ name: 'falcon_keytab', value: 'falcon_keytab_value', serviceName: 'FALCON', isEditable: true }),
        Em.Object.create({ name: 'mapreduce_keytab', value: 'mapreduce_keytab_value', serviceName: 'MAPREDUCE2', isEditable: true })
      ]);

      var res;
      var controller;
      before(function() {
        sinon.stub(App.StackService, 'find').returns([
          Em.Object.create({
            serviceName: 'KERBEROS',
            configCategories: [],
            configTypeList: []
          }),
          Em.Object.create({
            serviceName: 'HDFS',
            configCategories: [],
            configTypeList: []
          }),
          Em.Object.create({
            serviceName: 'MAPREDUCE2',
            configTypeList: []
          })
        ]);
        sinon.stub(App.Service, 'find').returns([
          Em.Object.create({
            serviceName: 'HDFS'
          }),
          Em.Object.create({
            serviceName: 'KERBEROS'
          })
        ]);
        controller = App.KerberosWizardStep4Controller.create({
          selectedServiceNames: ['FALCON', 'MAPREDUCE2'],
          installedServiceNames: ['HDFS', 'KERBEROS'],
          wizardController: Em.Object.create({
            name: 'addServiceController',
            getDBProperty: function() {
              return Em.A([
                Em.Object.create({ name: 'realm', value: 'realm_value' })
              ]);
            },
            loadCachedStepConfigValues : function() {
              return null;
            }
          })
        });
        sinon.stub(App.router, 'get').withArgs('mainAdminKerberosController.isManualKerberos').returns(false);
        var stepConfigs = controller.setStepConfigs(properties);
        res = stepConfigs[0].get('configs').concat(stepConfigs[1].get('configs'));
      });

      Em.A([
        { name: 'spnego_keytab', e: false },
        { name: 'falcon_keytab', e: true },
        { name: 'hdfs_keytab', e: false },
        { name: 'mapreduce_keytab', e: true }
      ]).forEach(function(test) {
        it('Add Service: property `{0}` should be {1} editable'.format(test.name, !!test.e ? '' : 'not '), function() {
          expect(res.findProperty('name', test.name).get('isEditable')).to.eql(test.e);
        });
      });

      after(function() {
        controller.destroy();
        controller = null;
        App.StackService.find.restore();
        App.Service.find.restore();
        App.router.get.restore();
      });
    });
  });

  describe("#createCategoryForServices()", function() {
    var controller = App.KerberosWizardStep4Controller.create({
      wizardController: {
        name: 'addServiceController'
      }
    });
    beforeEach(function() {
      sinon.stub(App.Service, 'find').returns([
        Em.Object.create({
          serviceName: 'HDFS',
          displayName: 'HDFS'
        })
      ]);
      sinon.stub(App.StackService, 'find').returns([
        Em.Object.create({
          serviceName: 'HDFS',
          displayName: 'HDFS',
          isInstalled: true
        }),
        Em.Object.create({
          serviceName: 'MAPREDUCE2',
          displayName: 'MapReduce 2',
          isInstalled: false,
          isSelected: true
        })
      ]);
    });

    afterEach(function() {
      App.Service.find.restore();
      App.StackService.find.restore();
    });

    it('for add service', function() {
      expect(controller.createCategoryForServices()).to.eql([App.ServiceConfigCategory.create({ name: 'HDFS', displayName: 'HDFS', collapsedByDefault: true}),
        App.ServiceConfigCategory.create({ name: 'MAPREDUCE2', displayName: 'MapReduce 2', collapsedByDefault: true})]);
    });

    it('for kerberos wizard', function() {
      controller.set('wizardController.name', 'KerberosWizard');
      expect(controller.createCategoryForServices()).to.eql([App.ServiceConfigCategory.create({ name: 'HDFS', displayName: 'HDFS', collapsedByDefault: true})]);
    });
  });

  describe('#loadStep', function() {
    var controller;
    describe('skip "Configure Identities" step. ', function() {
      beforeEach(function() {
        controller = App.KerberosWizardStep4Controller.create({});
        this.wizardController = App.AddServiceController.create({});
        controller.set('wizardController', this.wizardController);
        sinon.stub(controller, 'clearStep').returns(true);
        sinon.stub(controller, 'getDescriptor').returns({ then: function() { return { always: function() {}}}});
        sinon.stub(controller, 'setStepConfigs').returns(true);
        sinon.stub(App.router, 'send').withArgs('next');
      });

      afterEach(function() {
        controller.clearStep.restore();

        controller.setStepConfigs.restore();
        App.router.send.restore();
      });

      var tests = [
        {
          securityEnabled: true,
          stepSkipped: false
        },
        {
          securityEnabled: false,
          stepSkipped: true
        }
      ];

      tests.forEach(function(test) {
        var message = 'Security {0} configure identities step should be {1}'.format(!!test.securityEnabled ? 'enabled' : 'disabled', !!test.stepSkipped ? 'skipped' : 'not skipped');
        describe(message, function() {

          beforeEach(function () {
            sinon.stub(App, 'get').withArgs('isKerberosEnabled').returns(test.securityEnabled);
            this.wizardController.checkSecurityStatus();
            controller.loadStep();
          });

          afterEach(function () {
            App.get.restore();
          });

          it('`send` is ' + (test.stepSkipped ? '' : 'not') + ' called with `next`', function () {
            expect(App.router.send.calledWith('next')).to.be.eql(test.stepSkipped);
          });

        });
      }, this);

      it('step should not be disabled for Add Kerberos wizard', function() {
        controller.set('wizardController', App.KerberosWizardController.create({}));
        controller.loadStep();
        expect(App.router.send.calledWith('next')).to.be.false;
      });
    });
  });

  describe('#mergeDescriptorToConfigurations', function() {
    var genAppConfigProperty = function(name, fileName, value) {
      return App.ServiceConfigProperty.create({
        name: name,
        filename: fileName,
        value: value
      });
    };

    var genPropertyCollection = function(configsList) {
      return configsList.map(function(i) {
        return genAppConfigProperty.apply(undefined, i);
      });
    };

    var genConfigType = function(fileName, properties) {
      var configTypeObj = {};
      configTypeObj.type = fileName;
      configTypeObj.properties = properties.reduce(function(p, _c) {
        p[_c[0]] = _c[1];
        return p;
      }, {});
      return configTypeObj;
    };

    var genConfigTypeCollection = function(coll) {
      return coll.map(function(i) {
        return genConfigType(i[0], i[1]);
      });
    };

    var cases = [
      {
        kerberosDescriptor: genPropertyCollection([]),
        configurations: [],
        e: [],
        m: 'should return empty array'
      },
      {
        kerberosDescriptor: genPropertyCollection([
          ['hadoop.proxy.group', 'hadoop-env', 'val1']
        ]),
        configurations: genConfigTypeCollection([
          ['hadoop-env', [
           ['hadoop.proxy.group', 'change_me'],
           ['hadoop.proxy', 'val2']
          ]],
          ['core-site', [
            ['hadoop.proxyuser.hcat.groups', '*']
          ]]
        ]),
        e: [
          {
            type: 'hadoop-env',
            properties: {
              'hadoop.proxy.group': 'val1',
              'hadoop.proxy': 'val2'
            }
          },
          {
            type: 'core-site',
            properties: {
              'hadoop.proxyuser.hcat.groups': '*'
            }
          }
        ],
        m: 'should change value of `hadoop.proxy.group`, rest object should not be changed.'
      },
      {
        kerberosDescriptor: genPropertyCollection([
          ['hadoop.proxy.group', 'hadoop-env', 'val1'],
          ['new_site_prop', 'core-site', 'new_val']
        ]),
        configurations: genConfigTypeCollection([
          ['hadoop-env', [
            ['hadoop.proxy.group', 'val1'],
            ['hadoop.proxy', 'val2']
          ]],
          ['core-site', [
            ['hadoop.proxyuser.hcat.groups', '*']
          ]]
        ]),
        e: [
          {
            type: 'hadoop-env',
            properties: {
              'hadoop.proxy.group': 'val1',
              'hadoop.proxy': 'val2'
            }
          },
          {
            type: 'core-site',
            properties: {
              'hadoop.proxyuser.hcat.groups': '*',
              'new_site_prop': 'new_val'
            }
          }
        ],
        m: 'should add property `new_site_prop` value to `core-site` file type, rest object should not be changed.'
      }
    ];

    cases.forEach(function(test) {
      it(test.m, function() {
        var toObj = function(res) {
          return JSON.parse(JSON.stringify(res));
        };
        expect(toObj(c.mergeDescriptorToConfigurations(test.configurations, test.kerberosDescriptor))).to.be.eql(test.e);
      });
    });
  });

  describe('#groupRecommendationProperties', function() {
    var cases, controller;
    beforeEach(function() {
      controller = App.KerberosWizardStep4Controller.create({});
    });

    afterEach(function() {
      controller.destroy();
      controller = null;
    });

    cases = [
      {
        recommendedConfigurations: {},
        servicesConfigurations: [],
        allConfigs: [],
        m: 'empty objects should not fail the code',
        e: {
          add: {},
          update: {},
          delete: {}
        }
      },
      {
        recommendedConfigurations: {
          'some-site': {
            properties: {
              // property absent from servicesConfigurations and allConfigs
              // should be added
              'new_prop1': 'val1',
              // property present in servicesConfigurations but absent in  allConfigs
              // should be skipped
              'new_prop2': 'val2',
              'existing-prop': 'updated_val2'
            },
            property_attributes: {
              'delete_prop1': {
                'delete': true
              }
            }
          }
        },
        servicesConfigurations: [
          {
            type: 'some-site',
            properties: {
              'existing-prop': 'val2',
              'new_prop2': 'val2'
            }
          }
        ],
        allConfigs: [
          Em.Object.create({ name: 'existing-prop', value: 'val3', filename: 'some-site'}),
          Em.Object.create({ name: 'delete_prop1', value: 'val', filename: 'some-site'})
        ],
        m: 'should add "new_prop1", remove "delete_prop1", skip adding "new_prop2" and update value for "existing-prop"',
        e: {
          update: {
            'some-site': {
              'existing-prop': 'updated_val2'
            }
          },
          add: {
            'some-site': {
              'new_prop1': 'val1'
            }
          },
          delete: {
            'some-site': {
              'delete_prop1': ''
            }
          }
        }
      }
    ];

    cases.forEach(function(test) {
      it(test.m, function() {
        expect(controller.groupRecommendationProperties(test.recommendedConfigurations, test.servicesConfigurations, test.allConfigs))
          .to.be.eql(test.e);
      });
    });
  });

  describe("#getDescriptor()", function () {
    var mock = {
      then: Em.K
    };

    beforeEach(function() {
      c.reopen({
        isWithinAddService: true,
        selectedServiceNames: []
      });
      sinon.stub(c, 'storeClusterDescriptorStatus');
      sinon.stub(c, 'loadClusterDescriptorConfigs').returns(mock);
      sinon.stub(mock, 'then');
    });

    afterEach(function() {
      c.loadClusterDescriptorConfigs.restore();
      c.storeClusterDescriptorStatus.restore();
      mock.then.restore();
    });

    it("App.ajax.send should be called", function() {
      c.getDescriptor();
      var args = testHelpers.findAjaxRequest('name', 'admin.kerberize.cluster_descriptor_artifact');
      expect(args[0]).to.be.eql({
        sender: c,
        name: 'admin.kerberize.cluster_descriptor_artifact'
      });
    });

    it("storeClusterDescriptorStatus should be called", function() {
      c.getDescriptor();
      expect(c.storeClusterDescriptorStatus.calledOnce).to.be.true;
    });

    it("loadClusterDescriptorConfigs should be called", function() {
      c.getDescriptor();
      expect(c.loadClusterDescriptorConfigs.calledOnce).to.be.true;
    });

    it("then should be called", function() {
      c.getDescriptor();
      expect(mock.then.calledOnce).to.be.true;
    });

    it("then should be called, isWithinAddService is false", function() {
      c.set('isWithinAddService', false);
      c.getDescriptor();
      expect(mock.then.calledOnce).to.be.true;
    });
  });

  describe("#tweakConfigProperty()", function () {

    beforeEach(function() {
      this.mock = sinon.stub(App.HostComponent, 'find');
    });

    afterEach(function() {
      this.mock.restore();
    });

    it("config value should not be set", function() {
      this.mock.returns([
        Em.Object.create({
          componentName: 'HIVE_METASTORE',
          hostName: 'host1'
        })
      ]);
      var config = Em.Object.create({
        name: 'templeton.hive.properties',
        value: 'thrift://host1:9000\,,',
        recommendedValue: ''
      });
      c.tweakConfigProperty(config);
      expect(config.get('value')).to.be.equal('thrift://host1:9000\,,');
      expect(config.get('recommendedValue')).to.be.equal('');
    });

    it("config value should be set", function() {
      this.mock.returns([
        Em.Object.create({
          componentName: 'HIVE_METASTORE',
          hostName: 'host1'
        }),
        Em.Object.create({
          componentName: 'HIVE_METASTORE',
          hostName: 'host2'
        })
      ]);
      var config = Em.Object.create({
        name: 'templeton.hive.properties',
        value: 'thrift://host1:9000\,,'
      });
      c.tweakConfigProperty(config);
      expect(config.get('value')).to.be.equal("thrift://host1:9000\\,thrift://host2:9000,,");
      expect(config.get('recommendedValue')).to.be.equal("thrift://host1:9000\\,thrift://host2:9000,,");
    });
  });

  describe("#spnegoPropertiesObserver()", function () {

    beforeEach(function() {
      sinon.stub(Em.run, 'once', function(context, callback) {
        callback();
      });
    });

    afterEach(function() {
      Em.run.once.restore();
    });

    it("value should not be changed", function() {
      var configProperty = Em.Object.create({
        name: 'n1',
        value: 'new',
        recommendedValue: 'new'
      });
      var config = Em.Object.create({
        observesValueFrom: 'n2',
        value: '',
        recommendedValue: ''
      });
      c.set('stepConfigs', [Em.Object.create({
        name: 'ADVANCED',
        configs: [config]
      })]);
      c.spnegoPropertiesObserver(configProperty);
      expect(config.get('value')).to.be.empty;
      expect(config.get('recommendedValue')).to.be.empty;
    });

    it("value should be changed", function() {
      var configProperty = Em.Object.create({
        name: 'n1',
        value: 'new',
        recommendedValue: 'new'
      });
      var config = Em.Object.create({
        observesValueFrom: 'n1',
        value: '',
        recommendedValue: ''
      });
      c.set('stepConfigs', [Em.Object.create({
        name: 'ADVANCED',
        configs: [config]
      })]);
      c.spnegoPropertiesObserver(configProperty);
      expect(config.get('value')).to.be.equal('new');
      expect(config.get('recommendedValue')).to.be.equal('new');
    });
  });

  describe("#submit()", function () {

    beforeEach(function() {
      sinon.stub(c, 'saveConfigurations');
      sinon.stub(App.router, 'send');
    });

    afterEach(function() {
      c.saveConfigurations.restore();
      App.router.send.restore();
    });

    it("saveConfigurations should be called", function() {
      c.submit();
      expect(c.saveConfigurations.calledOnce).to.be.true;
    });

    it("App.router.send should be called", function() {
      c.submit();
      expect(App.router.send.calledWith('next')).to.be.true;
    });
  });

  describe("#saveConfigurations()", function () {
    var mock = {
      saveKerberosDescriptorConfigs: Em.K
    };

    beforeEach(function() {
      sinon.stub(c, 'updateKerberosDescriptor');
      sinon.stub(App, 'get').returns(mock);
      sinon.spy(mock, 'saveKerberosDescriptorConfigs');
      c.set('kerberosDescriptor', {});
      c.set('stepConfigs', [
        Em.Object.create({
          configs: [{}]
        }),
        Em.Object.create({
          configs: [{}]
        })
      ]);
      c.saveConfigurations();
    });

    afterEach(function() {
      c.updateKerberosDescriptor.restore();
      App.get.restore();
      mock.saveKerberosDescriptorConfigs.restore();
    });

    it("updateKerberosDescriptor should be called", function() {
      expect(c.updateKerberosDescriptor.calledWith({}, [{}, {}])).to.be.true;
    });

    it("saveKerberosDescriptorConfigs should be called", function() {
      expect(mock.saveKerberosDescriptorConfigs.calledWith({})).to.be.true;
    });
  });

  describe("#loadServerSideConfigsRecommendations()", function () {

    it("App.ajax.send should be called", function() {
      c.loadServerSideConfigsRecommendations([]);
      var args = testHelpers.findAjaxRequest('name', 'config.recommendations');
      expect(args[0]).to.be.exists;
    });
  });

  describe("#applyServiceConfigs()", function () {

    it("isRecommendedLoaded should be true", function() {
      c.applyServiceConfigs([Em.Object.create({configGroups: []})]);
      expect(c.get('isRecommendedLoaded')).to.be.true;
    });

    it("selectedService should be set", function() {
      c.applyServiceConfigs([Em.Object.create({configGroups: []})]);
      expect(c.get('selectedService')).to.be.eql(Em.Object.create({configGroups: []}));
    });
  });

  describe("#bootstrapRecommendationPayload()", function () {

    beforeEach(function() {
      sinon.stub(c, 'getServicesConfigurations').returns({
        then: function(callback) {
          callback([{}]);
        }
      });
      sinon.stub(c, 'getBlueprintPayloadObject').returns({blueprint: {
        configurations: []
      }});
      c.bootstrapRecommendationPayload({});
    });

    afterEach(function() {
      c.getServicesConfigurations.restore();
      c.getBlueprintPayloadObject.restore();
    });

    it("getServicesConfigurations should be called", function() {
      expect(c.getServicesConfigurations.calledOnce).to.be.true;
    });

    it("getBlueprintPayloadObject should be called", function() {
      expect(c.getBlueprintPayloadObject.calledWith([{}], {})).to.be.true;
    });

    it("servicesConfigurations should be set", function() {
      expect(c.get('servicesConfigurations')).to.be.eql([{}]);
    });

    it("initialConfigValues should be set", function() {
      expect(c.get('initialConfigValues')).to.be.eql([]);
    });
  });

  describe("#getBlueprintPayloadObject()", function () {

    beforeEach(function() {
      sinon.stub(c, 'mergeDescriptorToConfigurations').returns([{
        type: 't1',
        properties: []
      }]);
      sinon.stub(c, 'createServicesStackDescriptorConfigs');
    });

    afterEach(function() {
      c.createServicesStackDescriptorConfigs.restore();
      c.mergeDescriptorToConfigurations.restore();
    });

    it("should return recommendations", function () {
      c.reopen({
        hostGroups: {
          blueprint: {
            configurations: []
          }
        }
      });
      expect(c.getBlueprintPayloadObject([], {})).to.be.eql({
        "blueprint": {
          "host_groups": [],
          "configurations": {
            "t1": {
              "properties": []
            }
          }
        },
        "blueprint_cluster_binding": {
          "host_groups": []
        }
      });
    });
  });

  describe("#getServicesConfigObject()", function () {

    it("should return ADVANCED step config", function() {
      c.set('stepConfigs', [{name: 'ADVANCED'}]);
      expect(c.getServicesConfigObject()).to.be.eql({name: 'ADVANCED'});
    });
  });

  describe("#getServiceByFilename()", function () {

    beforeEach(function() {
      this.mockService = sinon.stub(App.Service, 'find');
      sinon.stub(App.StackService, 'find').returns([
        Em.Object.create({
          serviceName: 'S1',
          configTypes: {
            site1: {}
          }
        })
      ]);
    });

    afterEach(function() {
      this.mockService.restore();
      App.StackService.find.restore();
    });

    it("should return 'HDFS' ", function() {
      this.mockService.returns([{serviceName: 'HDFS'}]);
      expect(c.getServiceByFilename('core-site')).to.be.equal('HDFS');
    });

    it("should return 'S1' ", function() {
      expect(c.getServiceByFilename('site1')).to.be.equal('S1');
    });

    it("should return empty", function() {
      expect(c.getServiceByFilename('site2')).to.be.empty;
    });
  });
});

});

require.register("test/controllers/main/admin/kerberos/step5_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');
var stringUtils = require('utils/string_utils');
var fileUtils = require('utils/file_utils');

describe('App.KerberosWizardStep5Controller', function() {
  var c;
  beforeEach(function () {
    c = App.KerberosWizardStep5Controller.create({});
  });

  describe('#prepareCSVData', function () {

    it('should split data', function () {
      var data = [
        'a,b,c',
        'd,e',
        '1,2,3,4'
      ];

      var result = c.prepareCSVData(data);
      expect(result).to.be.eql([['a', 'b', 'c'], ['d', 'e'], ['1', '2', '3', '4']]);
    });
  });

  describe("#submit()", function () {

    beforeEach(function() {
      sinon.stub(App.router, 'send');
    });

    afterEach(function() {
      App.router.send.restore();
    });

    it("App.router.send should be called", function() {
      c.submit();
      expect(App.router.send.calledWith('next')).to.be.true;
    });
  });

  describe("#getCSVData()", function () {

    it("App.ajax.send should be called", function() {
      c.getCSVData(true);
      var args = testHelpers.findAjaxRequest('name', 'admin.kerberos.cluster.csv');
      expect(args[0]).to.be.eql({
        name: 'admin.kerberos.cluster.csv',
        sender: c,
        data: {
          'skipDownload': true
        },
        success: 'getCSVDataSuccessCallback',
        error: 'getCSVDataSuccessCallback'
      });
    });
  });

  describe("#getCSVDataSuccessCallback()", function () {

    beforeEach(function() {
      sinon.stub(fileUtils, 'downloadTextFile');
      sinon.stub(stringUtils, 'arrayToCSV').returns('arrayToCSV');
      sinon.stub(c, 'prepareCSVData').returns('csvData');
      c.getCSVDataSuccessCallback("a\nb", {}, {skipDownload: false});
    });

    afterEach(function() {
      fileUtils.downloadTextFile.restore();
      stringUtils.arrayToCSV.restore();
      c.prepareCSVData.restore();
    });

    it("csvData should be set", function() {
      expect(c.get('csvData')).to.be.equal('csvData');
    });

    it("fileUtils.downloadTextFile should be called", function() {
      expect(fileUtils.downloadTextFile.calledWith('arrayToCSV', 'csv', 'kerberos.csv')).to.be.true;
    });
  });

  describe("#postKerberosDescriptor()", function () {

    it("App.ajax.send should be called", function() {
      c.postKerberosDescriptor('kerberosDescriptor');
      var args = testHelpers.findAjaxRequest('name', 'admin.kerberos.cluster.artifact.create');
      expect(args[0]).to.be.eql({
        name: 'admin.kerberos.cluster.artifact.create',
        sender: c,
        data: {
          artifactName: 'kerberos_descriptor',
          data: {
            artifact_data: 'kerberosDescriptor'
          }
        }
      });
    });
  });

  describe("#putKerberosDescriptor()", function () {

    it("App.ajax.send should be called", function() {
      c.putKerberosDescriptor('kerberosDescriptor');
      var args = testHelpers.findAjaxRequest('name', 'admin.kerberos.cluster.artifact.update');
      expect(args[0]).to.be.eql({
        name: 'admin.kerberos.cluster.artifact.update',
        sender: c,
        data: {
          artifactName: 'kerberos_descriptor',
          data: {
            artifact_data: 'kerberosDescriptor'
          }
        },
        success: 'unkerberizeCluster',
        error: 'unkerberizeCluster'
      });
    });
  });

  describe("#unkerberizeCluster()", function () {

    it("App.ajax.send should be called", function() {
      c.unkerberizeCluster();
      var args = testHelpers.findAjaxRequest('name', 'admin.unkerberize.cluster');
      expect(args[0]).to.be.eql({
        name: 'admin.unkerberize.cluster',
        sender: c,
        success: 'goToNextStep',
        error: 'goToNextStep'
      });
    });
  });

  describe("#goToNextStep()", function () {

    beforeEach(function() {
      sinon.stub(c, 'clearStage');
      sinon.stub(App.router, 'transitionTo');
      c.goToNextStep();
    });

    afterEach(function() {
      c.clearStage.restore();
      App.router.transitionTo.restore();
    });

    it("clearStage should be called", function() {
      expect(c.clearStage.calledOnce).to.be.true;
    });

    it("App.router.transitionTo should be called", function() {
      expect(App.router.transitionTo.calledWith('step5')).to.be.true;
    });
  });

  describe("#confirmProperties", function () {

    beforeEach(function() {
      this.mock = sinon.stub(App.router, 'get');
    });

    afterEach(function() {
      this.mock.restore();
    });

    it("should return properties", function() {
      this.mock.returns(Em.Object.create({
        content: {
          kerberosOption: Em.I18n.t('admin.kerberos.wizard.step1.option.kdc'),
          serviceConfigProperties: [{name: 'kdc_type'}]
        }
      }));
      c.propertyDidChange('confirmProperties');
      expect(c.get('confirmProperties')).to.be.eql([
        {
          name: 'kdc_type',
          label: Em.I18n.t('admin.kerberos.wizard.step5.kdc_type.label')
        }
      ]);
    });

    it("should return empty properties", function() {
      this.mock.returns(Em.Object.create({
        content: {
          kerberosOption: null,
          serviceConfigProperties: [{name: 'kdc_type'}]
        }
      }));
      c.propertyDidChange('confirmProperties');
      expect(c.get('confirmProperties')).to.be.empty;
    });
  });
});
});

require.register("test/controllers/main/admin/kerberos/step6_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');

describe('App.KerberosWizardStep6Controller', function() {
  var controller;

  beforeEach(function() {
    controller = App.KerberosWizardStep6Controller.create({ commands: ['stopServices'] });
  });


  describe('#checkComponentsRemoval', function() {

    afterEach(function () {
      Em.tryInvoke(App.get, 'restore');
      Em.tryInvoke(App.Service.find, 'restore');
      Em.tryInvoke(App.HostComponent.find, 'restore');
    });

    var tests = [
      { yarnInstalled: true, doesATSSupportKerberos: false, commands: ['stopServices', 'deleteATS'], ATSInstalled: true},
      { yarnInstalled: false, doesATSSupportKerberos: true, commands: ['stopServices'], ATSInstalled: true},
      { yarnInstalled: false, doesATSSupportKerberos: false, commands: ['stopServices'], ATSInstalled: true},
      { yarnInstalled: true, doesATSSupportKerberos: true, commands: ['stopServices'], ATSInstalled: false},
      { yarnInstalled: true, doesATSSupportKerberos: true, commands: ['stopServices'], ATSInstalled: true}
    ];

    tests.forEach(function(test) {
      var message = 'YARN installed: {0}, ATS supported: {1} list of commands should be {2}'.format(test.yarnInstalled, test.doesATSSupportKerberos, test.commands.toString());
      describe(message, function () {
        beforeEach(function () {
          sinon.stub(App, 'get').withArgs('doesATSSupportKerberos').returns(test.doesATSSupportKerberos);
          sinon.stub(App.Service, 'find').returns(test.yarnInstalled ? [Em.Object.create({serviceName: 'YARN'})] : []);
          sinon.stub(App.HostComponent, 'find').returns(test.ATSInstalled ? [Em.Object.create({componentName: 'APP_TIMELINE_SERVER'})] : []);
          controller.checkComponentsRemoval();
        });

        it('commands are valid', function () {
          expect(controller.get('commands').toArray()).to.eql(test.commands);
        });

      });
    });
  });


  describe("#stopServices()", function () {

    it("App.ajax.send should be called", function() {
      controller.stopServices();
      var args = testHelpers.findAjaxRequest('name', 'common.services.update');
      expect(args[0]).to.be.eql({
        name: 'common.services.update',
        data: {
          context: "Stop services",
          "ServiceInfo": {
            "state": "INSTALLED"
          }
        },
        sender: controller,
        success: 'startPolling',
        error: 'onTaskError'
      });
    });
  });

  describe("#loadStep()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'checkComponentsRemoval');
    });

    afterEach(function() {
      controller.checkComponentsRemoval.restore();
    });

    it("loadStep should be called", function() {
      controller.loadStep();
      expect(controller.checkComponentsRemoval.calledOnce).to.be.true;
    });
  });

  describe("#deleteATS()", function () {

    beforeEach(function() {
      sinon.stub(App.HostComponent, 'find').returns([Em.Object.create({
        componentName: 'APP_TIMELINE_SERVER',
        hostName: 'host1'
      })]);
    });

    afterEach(function() {
      App.HostComponent.find.restore();
    });

    it("deleteATS should be called", function() {
      controller.deleteATS();
      var args = testHelpers.findAjaxRequest('name', 'common.delete.host_component');
      expect(args[0]).to.be.eql({
        name: 'common.delete.host_component',
        sender: controller,
        data: {
          componentName: 'APP_TIMELINE_SERVER',
          hostName: 'host1'
        },
        success: 'onDeleteATSSuccess',
        error: 'onDeleteATSError'
      });
    });
  });

  describe("#onDeleteATSSuccess", function () {

    beforeEach(function() {
      sinon.stub(controller, 'onTaskCompleted');
    });

    afterEach(function() {
      controller.onTaskCompleted.restore();
    });

    it("onDeleteATSSuccess should be called", function() {
      controller.onDeleteATSSuccess();
      expect(controller.onTaskCompleted.calledOnce).to.be.true;
    });
  });

  describe("#onDeleteATSError()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'onDeleteATSSuccess');
    });

    afterEach(function() {
      controller.onDeleteATSSuccess.restore();
    });

    it("onDeleteATSSuccess should not be called", function() {
      controller.onDeleteATSError({responseText: ""});
      expect(controller.onDeleteATSSuccess.called).to.be.false;
    });

    it("onDeleteATSSuccess should be called", function() {
      controller.onDeleteATSError({responseText: "org.apache.ambari.server.controller.spi.NoSuchResourceException"});
      expect(controller.onDeleteATSSuccess.calledOnce).to.be.true;
    });
  });

});

});

require.register("test/controllers/main/admin/kerberos/step7_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');

function getController() {
  return App.KerberosWizardStep7Controller.create({});
}

describe('App.KerberosWizardStep7Controller', function () {
  var controller;

  beforeEach(function () {
    controller = getController();
  });

  describe("#setRequest()", function () {

    beforeEach(function () {
      sinon.stub(controller, 'clearStage');
      sinon.stub(controller, 'loadStep');
    });

    afterEach(function () {
      controller.clearStage.restore();
      controller.loadStep.restore();
    });

    it("request should be set", function () {
      controller.setRequest(true);
      expect(controller.get('request')).to.be.eql({
        name: 'KERBERIZE_CLUSTER',
        ajaxName: 'admin.kerberize.cluster.force'
      });
    });

    it("clearStage should be called", function () {
      controller.setRequest(true);
      expect(controller.clearStage.calledOnce).to.be.true;
    });

    it("loadStep should be called", function () {
      controller.setRequest(true);
      expect(controller.loadStep.calledOnce).to.be.true;
    });

    it("kerberize request should be set", function () {
      controller.setRequest(false);
      expect(controller.get('request')).to.be.eql({
        name: 'KERBERIZE_CLUSTER',
        ajaxName: 'admin.kerberize.cluster',
        ajaxData: {
          data: {
            Clusters: {
              security_type: "KERBEROS"
            }
          }
        }
      });
    });
  });

  describe("#unkerberizeCluster()", function () {

    it("App.ajax.send should be called", function () {
      controller.unkerberizeCluster();
      var args = testHelpers.findAjaxRequest('name', 'admin.unkerberize.cluster');
      expect(args[0]).to.be.eql({
        name: 'admin.unkerberize.cluster',
        sender: controller,
        success: 'goToNextStep',
        error: 'goToNextStep'
      });
    });
  });

  describe("#goToNextStep()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'clearStage');
      sinon.stub(App.router, 'transitionTo');
      controller.goToNextStep();
    });

    afterEach(function() {
      controller.clearStage.restore();
      App.router.transitionTo.restore();
    });

    it("clearStage should be called", function() {
      expect(controller.clearStage.calledOnce).to.be.true;
    });

    it("App.router.transitionTo should be called", function() {
      expect(App.router.transitionTo.calledWith('step7')).to.be.true;
    });
  });

  describe("#postKerberosDescriptor()", function () {

    it("App.ajax.send should be called", function () {
      controller.postKerberosDescriptor(true);
      var args = testHelpers.findAjaxRequest('name', 'admin.kerberos.cluster.artifact.create');
      expect(args[0]).to.be.eql({
        name: 'admin.kerberos.cluster.artifact.create',
        sender: controller,
        data: {
          artifactName: 'kerberos_descriptor',
          data: {
            artifact_data: true
          }
        }
      });
    });
  });

  describe("#putKerberosDescriptor()", function () {

    it("App.ajax.send should be called", function () {
      controller.putKerberosDescriptor(true);
      var args = testHelpers.findAjaxRequest('name', 'admin.kerberos.cluster.artifact.update');
      expect(args[0]).to.be.eql({
        name: 'admin.kerberos.cluster.artifact.update',
        sender: controller,
        data: {
          artifactName: 'kerberos_descriptor',
          data: {
            artifact_data: true
          }
        },
        success: 'unkerberizeCluster',
        error: 'unkerberizeCluster'
      });
    });
  });

  describe("#retry()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'removeObserver');
      sinon.stub(controller, 'setRequest');
      controller.set('tasks', [Em.Object.create()]);
      controller.retry();
    });

    afterEach(function() {
      controller.removeObserver.restore();
      controller.setRequest.restore();
    });

    it("showRetry should be false", function() {
      expect(controller.get('showRetry')).to.be.false;
    });

    it("removeObserver should be called", function() {
      expect(controller.removeObserver.calledWith('tasks.@each.status', controller, 'onTaskStatusChange')).to.be.true;
    });

    it("status should be IN_PROGRESS", function() {
      expect(controller.get('status')).to.be.equal('IN_PROGRESS');
    });

    it("tasks status should be PENDING", function() {
      expect(controller.get('tasks').mapProperty('status')).to.be.eql(['PENDING']);
    });

    it("setRequest should be called", function() {
      expect(controller.setRequest.calledWith(true)).to.be.true;
    });
  });

  describe("#enableDisablePreviousSteps()", function () {
    var mock = {
      enableStep: Em.K,
      setLowerStepsDisable: Em.K
    };

    beforeEach(function() {
      sinon.stub(App.router, 'get').returns(mock);
      sinon.stub(mock, 'setLowerStepsDisable');
      sinon.stub(mock, 'enableStep');
    });

    afterEach(function() {
      App.router.get.restore();
      mock.enableStep.restore();
      mock.setLowerStepsDisable.restore();
    });

    it("FAILED tasks", function() {
      controller.set('tasks', [{status: 'FAILED'}]);
      controller.enableDisablePreviousSteps();
      expect(controller.get('isBackButtonDisabled')).to.be.false;
      expect(mock.enableStep.calledWith(4)).to.be.true;
    });

    it("COMPLETED tasks", function() {
      controller.set('tasks', [{status: 'COMPLETED'}]);
      controller.enableDisablePreviousSteps();
      expect(controller.get('isBackButtonDisabled')).to.be.true;
      expect(mock.setLowerStepsDisable.calledWith(6)).to.be.true;
    });
  });
});

});

require.register("test/controllers/main/admin/kerberos/step8_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');

function getController() {
  return App.KerberosWizardStep8Controller.create({});
}

describe('App.KerberosWizardStep8Controller', function() {
  var controller;

  beforeEach(function() {
    controller = getController();
  });

  describe("#startServices()", function () {

    beforeEach(function() {
      sinon.stub(App.router, 'get').returns({
        "skip.service.checks": "true"
      });
    });

    afterEach(function() {
      App.router.get.restore();
    });

    it("App.ajax.send should be called", function() {
      controller.startServices();
      var args = testHelpers.findAjaxRequest('name', 'common.services.update');
      expect(args[0]).to.be.eql({
        name: 'common.services.update',
        sender: controller,
        data: {
          "context": "Start services",
          "ServiceInfo": {
            "state": "STARTED"
          },
          urlParams: "params/run_smoke_test=false"
        },
        success: 'startPolling',
        error: 'startServicesErrorCallback'
      });
    });
  });

});

});

require.register("test/controllers/main/admin/kerberos_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');

describe('App.MainAdminKerberosController', function() {

  var controller = App.MainAdminKerberosController.create({});

  App.TestAliases.testAsComputedEqual(controller, 'isManualKerberos', 'kdc_type', 'none');

  App.TestAliases.testAsComputedSomeBy(controller, 'isPropertiesChanged', 'stepConfigs', 'isPropertiesChanged', true);

  App.TestAliases.testAsComputedOr(controller, 'isSaveButtonDisabled', ['isSubmitDisabled', '!isPropertiesChanged']);

  describe('#prepareConfigProperties', function() {
    beforeEach(function() {
      sinon.stub(App.Service, 'find').returns([
        Em.Object.create({ serviceName: 'KERBEROS'}),
        Em.Object.create({ serviceName: 'HDFS' })
      ]);
      this.result = controller.prepareConfigProperties([
        Em.Object.create({ name: 'prop1', isEditable: true, serviceName: 'SERVICE1'}),
        Em.Object.create({ name: 'prop2', isEditable: true, serviceName: 'KERBEROS'}),
        Em.Object.create({ name: 'prop3', isEditable: true, serviceName: 'HDFS'}),
        Em.Object.create({ name: 'prop4', isEditable: true, serviceName: 'Cluster'}),
        Em.Object.create({ name: 'prop5', isEditable: true, serviceName: 'SERVICE1'})
      ]);
    });

    afterEach(function() {
      App.Service.find.restore();
    });

    ['prop1', 'prop5'].forEach(function(item) {
      it('property `{0}` should be absent'.format(item), function() {
        expect(this.result.findProperty('name', item)).to.be.undefined;
      });
    });

    ['prop2', 'prop3', 'prop4'].forEach(function(item) {
      it('property `{0}` should be present and not editable'.format(item), function() {
        var prop = this.result.findProperty('name', item);
        expect(prop).to.be.ok;
        expect(prop.get('isEditable')).to.be.false;
      });
    });

    describe('should take displayType from predefinedSiteProperties', function () {

      beforeEach(function () {
        sinon.stub(App.configsCollection, 'getAll').returns([
          {
            name: 'hadoop.security.auth_to_local',
            displayType: 'multiLine'
          }
        ]);
      });

      afterEach(function () {
        App.configsCollection.getAll.restore();
      });

      it('displayType is valid', function () {
        expect(controller.prepareConfigProperties([
          Em.Object.create({
            name: 'hadoop.security.auth_to_local',
            serviceName: 'HDFS'
          })
        ])[0].get('displayType')).to.equal('multiLine');
      });

    });
  });

  describe("#runSecurityCheckSuccess()", function () {
    beforeEach(function () {
      sinon.stub(App, 'showClusterCheckPopup', Em.K);
      sinon.stub(controller, 'startKerberosWizard', Em.K);
    });
    afterEach(function () {
      App.showClusterCheckPopup.restore();
      controller.startKerberosWizard.restore();
    });
    it("shows popup", function () {
      var check = { items: [{
        UpgradeChecks: {
          "check": "Work-preserving RM/NM restart is enabled in YARN configs",
          "status": "FAIL",
          "reason": "FAIL",
          "failed_on": [],
          "check_type": "SERVICE"
        }
      }]};
      controller.runSecurityCheckSuccess(check,null,{label: "name"});
      expect(controller.startKerberosWizard.called).to.be.false;
      expect(App.showClusterCheckPopup.called).to.be.true;
    });
    it("runs startKerberosWizard", function () {
      var check = { items: [{
        UpgradeChecks: {
          "check": "Work-preserving RM/NM restart is enabled in YARN configs",
          "status": "PASS",
          "reason": "OK",
          "failed_on": [],
          "check_type": "SERVICE"
        }
      }]};
      controller.runSecurityCheckSuccess(check,null,{label: "name"});
      expect(controller.startKerberosWizard.called).to.be.true;
      expect(App.showClusterCheckPopup.called).to.be.false;
    });
  });

  describe('#regenerateKeytabs()', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, "show");
      sinon.spy(controller, 'restartServicesAfterRegenerate');
      sinon.spy(controller, 'restartAllServices');
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
      controller.restartServicesAfterRegenerate.restore();
      controller.restartAllServices.restore();
    });

    it('both confirmation popups should be displayed', function () {
      var popup = controller.regenerateKeytabs();
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.restartServicesAfterRegenerate.calledOnce).to.be.true;
      expect(App.ModalPopup.show.calledTwice).to.be.true;
    });

    it('user checked regeneration only for missing host/components', function () {
      var popup = controller.regenerateKeytabs();
      popup.set('regenerateKeytabsOnlyForMissing', true);

      var popup2 = popup.onPrimary();
      popup2.set('restartComponents', true)
      popup2.onPrimary();
      var args = testHelpers.findAjaxRequest('name', 'admin.kerberos_security.regenerate_keytabs');
      expect(args[0].data.type).to.be.equal('missing');
    });

    it('user didn\'t check regeneration only for missing host/components', function () {
      var popup = controller.regenerateKeytabs();
      popup.set('regenerateKeytabsOnlyForMissing', false);

      var popup2 = popup.onPrimary();
      popup2.set('restartComponents', true)
      popup2.onPrimary();

      var args = testHelpers.findAjaxRequest('name', 'admin.kerberos_security.regenerate_keytabs');
      expect(args[0].data.type).to.be.equal('all');
    });

    it('user checked restart services automatically', function () {
      var popup = controller.regenerateKeytabs();
      popup.set('regenerateKeytabsOnlyForMissing', true);

      var popup2 = popup.onPrimary();
      popup2.set('restartComponents', true)
      popup2.onPrimary();

      var args = testHelpers.findAjaxRequest('name', 'admin.kerberos_security.regenerate_keytabs');
      expect(args[0].data.withAutoRestart).to.be.true;
    });

    it('user didn\'t check restart services automatically', function () {
      var popup = controller.regenerateKeytabs();
      popup.set('regenerateKeytabsOnlyForMissing', true);

      var popup2 = popup.onPrimary();
      popup2.set('restartComponents', false)
      popup2.onPrimary();

      var args = testHelpers.findAjaxRequest('name', 'admin.kerberos_security.regenerate_keytabs');
      expect(args[0].data.withAutoRestart).to.be.false;
    });
  });

  describe('#getKDCSessionState()', function () {

    var mock = {callback: Em.K};

    beforeEach(function () {
      sinon.spy(mock, 'callback');
      sinon.stub(controller, 'getSecurityType', function (c) {
        c();
      });
    });

    afterEach(function () {
      mock.callback.restore();
      controller.getSecurityType.restore();
      Em.tryInvoke(App.get, 'restore');
    });

    [
      {
        m: 'Skip request, as securityEnabled and isKerberosEnabled are false',
        securityEnabled: false,
        isKerberosEnabled: false,
        kdc_type: 'not_none',
        result: false
      },
      {
        m: 'Skip request, as isManualKerberos is true',
        securityEnabled: true,
        isKerberosEnabled: true,
        kdc_type: 'none',
        result: false
      },
      {
        m: 'Make request',
        securityEnabled: true,
        isKerberosEnabled: true,
        kdc_type: 'not_none',
        result: true
      }
    ].forEach(function (test) {
          describe(test.m, function () {

            beforeEach(function () {
              sinon.stub(App, 'get').returns(test.isKerberosEnabled);
              controller.set('securityEnabled', test.securityEnabled);
              controller.set('kdc_type', test.kdc_type);
              controller.getKDCSessionState(mock.callback);
              this.args = testHelpers.findAjaxRequest('name', 'kerberos.session.state');
            });


            if (test.result) {
              it('callback is not called', function () {
                expect(mock.callback.calledOnce).to.be.false;
              });
              it('1 request is sent', function () {
                expect(this.args).to.exists;
              });
            }
            else {
              it('callback is called once', function () {
                expect(mock.callback.calledOnce).to.be.true;
              });
              it('no request is sent', function () {
                expect(this.args).to.not.exists;
              });
            }
          });
        });
  });

  describe('#getSecurityType()', function () {

    var mock = {callback: Em.K};

    beforeEach(function () {
      sinon.spy(mock, 'callback');
    });

    afterEach(function () {
      mock.callback.restore();
      Em.tryInvoke(App.get, 'restore');
    });

    [
      {
        m: 'Skip request, as securityEnabled and isKerberosEnabled are false',
        securityEnabled: false,
        isKerberosEnabled: false,
        kdc_type: '',
        result: false
      },
      {
        m: 'Skip request, as kdc_type exists',
        securityEnabled: true,
        isKerberosEnabled: true,
        kdc_type: 'none',
        result: false
      },
      {
        m: 'Make request',
        securityEnabled: true,
        isKerberosEnabled: true,
        kdc_type: '',
        result: true
      }
    ].forEach(function (test) {
          describe(test.m, function () {

            beforeEach(function () {
              sinon.stub(App, 'get').returns(test.isKerberosEnabled);
              controller.set('securityEnabled', test.securityEnabled);
              controller.set('kdc_type', test.kdc_type);
              controller.getSecurityType(mock.callback);
              this.args = testHelpers.findAjaxRequest('name', 'admin.security.cluster_configs.kerberos');
            });

            if (test.result) {
              it('callback os not called', function () {
                expect(mock.callback.calledOnce).to.be.false;
              });
              it('1 request is sent', function () {
                expect(this.args).to.exists;
              });
            } else {
              it('callback is called once', function () {
                expect(mock.callback.calledOnce).to.be.true;
              });
              it('no request is sent', function () {
                expect(this.args).to.not.exists;
              });
            }
          });
        });
  });

  describe('#getSecurityTypeSuccess', function() {
    [
      {
        data: { },
        e: 'none'
      },
      {
        data: {
          items: []
        },
        e: 'none'
      },
      {
        data: {
          items: [
            {
              configurations: []
            }
          ]
        },
        e: 'none'
      },
      {
        data: {
          items: [
            {
              configurations: [
                {
                  type: 'krb-conf',
                  properties: {
                    'kdc_type': 'mit'
                  }
                }
              ]
            }
          ]
        },
        e: 'none'
      },
      {
        data: {
          items: [
            {
              configurations: [
                {
                  type: 'kerberos-env',
                  properties: {
                    'kdc_type': 'mit'
                  }
                }
              ]
            }
          ]
        },
        e: 'mit'
      },
      {
        data: {
          items: [
            {
              configurations: [
                {
                  type: 'kerberos-env',
                  properties: {
                    'kdc_type': 'none'
                  }
                }
              ]
            }
          ]
        },
        e: 'none'
      }
    ].forEach(function(test) {
      it('json is ' + JSON.stringify(test.data) + ' kdc type should be ' + test.e, function() {
        controller.set('isManualKerberos', undefined);
        controller.getSecurityTypeSuccess(test.data, {}, {});
        expect(controller.get('kdc_type')).to.eql(test.e);
      });
    });
  });
});

});

require.register("test/controllers/main/admin/serviceAccounts_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/serviceAccounts_controller');


describe('App.MainAdminServiceAccountsController', function () {

  var controller = App.MainAdminServiceAccountsController.create();

  describe('#sortByOrder()', function () {
    var testCases = [
      {
        title: 'sortOrder is null',
        content: {
          sortOrder: null,
          arrayToSort: [
            {
              name: 'one',
              displayName: 'one'
            }
          ]
        },
        result: ['one']
      },
      {
        title: 'sortOrder is empty',
        content: {
          sortOrder: [],
          arrayToSort: [
            {
              name: 'one',
              displayName: 'one'
            }
          ]
        },
        result: ['one']
      },
      {
        title: 'sortOrder items don\'t match items of array',
        content: {
          sortOrder: ['one'],
          arrayToSort: [
            {name: 'two'}
          ]
        },
        result: []
      },
      {
        title: 'sort items in reverse order',
        content: {
          sortOrder: ['two', 'one'],
          arrayToSort: [
            Em.Object.create({
              name: 'one',
              displayName: 'one'
            }),
            Em.Object.create({
              name: 'two',
              displayName: 'two'
            })
          ]
        },
        result: ['two', 'one']
      },
      {
        title: 'sort items in correct order',
        content: {
          sortOrder: ['one', 'two'],
          arrayToSort: [
            Em.Object.create({
              name: 'one',
              displayName: 'one'
            }),
            Em.Object.create({
              name: 'two',
              displayName: 'two'
            })
          ]
        },
        result: ['one', 'two']
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.sortByOrder(test.content.sortOrder, test.content.arrayToSort).mapProperty('displayName')).to.eql(test.result);
      });
    });
  });
});

});

require.register("test/controllers/main/admin/stack_and_upgrade_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/stack_and_upgrade_controller');
require('utils/string_utils');
var testHelpers = require('test/helpers');

describe('App.MainAdminStackAndUpgradeController', function() {

  var controller = App.MainAdminStackAndUpgradeController.create({
    getDBProperty: Em.K,
    setDBProperty: Em.K,
    setDBProperties: Em.K,
    getDBProperties: Em.K
  });

  controller.removeObserver('App.upgradeState', controller, 'finish');


  describe("#realRepoUrl", function() {
    before(function () {
      this.mock = sinon.stub(App, 'get');
      this.mock.withArgs('apiPrefix').returns('apiPrefix');
    });
    after(function () {
      this.mock.restore();
    });
    it("should be valid", function() {
      var expected = 'apiPrefix/stacks?fields=versions/repository_versions/RepositoryVersions,' +
        'versions/repository_versions/operating_systems/*,versions/repository_versions/operating_systems/repositories/*';
      controller.propertyDidChange('realRepoUrl');
      expect(controller.get('realRepoUrl')).to.equal(expected);
    });
  });

  describe("#realStackUrl", function() {
    before(function () {
      this.mock = sinon.stub(App, 'get');
      this.mock.withArgs('apiPrefix').returns('apiPrefix')
        .withArgs('clusterName').returns('clusterName');
    });
    after(function () {
      this.mock.restore();
    });
    it("should be valid", function() {
      controller.propertyDidChange('realStackUrl');
      expect(controller.get('realStackUrl')).to.equal('apiPrefix/clusters/clusterName/stack_versions?fields=*,repository_versions/*,repository_versions/operating_systems/OperatingSystems/*,repository_versions/operating_systems/repositories/*');
    });
  });

  describe("#realUpdateUrl", function() {
    before(function () {
      this.mock = sinon.stub(App, 'get');
      this.mock.withArgs('apiPrefix').returns('apiPrefix')
        .withArgs('clusterName').returns('clusterName');
    });
    after(function () {
      this.mock.restore();
    });
    it("realUpdateUrl is valid", function() {
      controller.propertyDidChange('realUpdateUrl');
      expect(controller.get('realUpdateUrl')).to.equal('apiPrefix/clusters/clusterName/stack_versions?fields=ClusterStackVersions/*');
    });
  });

  describe("#requestStatus", function() {

    beforeEach(function() {
      this.mock = sinon.stub(App, 'get');
    });
    afterEach(function() {
      this.mock.restore();
    });

    it("App.upgradeSuspended is true", function() {
      this.mock.returns(true);
      controller.set('upgradeData', { Upgrade: {request_status: 'ABORTED'}});
      controller.propertyDidChange('requestStatus');
      expect(controller.get('requestStatus')).to.equal('SUSPENDED');
    });

    it("state not ABORTED", function() {
      this.mock.returns(false);
      controller.set('upgradeData', { Upgrade: {request_status: 'INIT'}});
      controller.propertyDidChange('requestStatus');
      expect(controller.get('requestStatus')).to.equal('INIT');
    });

    it("upgradeData is null", function() {
      this.mock.returns(false);
      controller.set('upgradeData', null);
      controller.propertyDidChange('requestStatus');
      expect(controller.get('requestStatus')).to.be.empty;
    });
  });

  describe("#load()", function() {
    beforeEach(function(){
      sinon.stub(controller, 'loadUpgradeData').returns({
        done: Em.clb
      });
      sinon.stub(controller, 'loadStackVersionsToModel').returns({
        done: Em.clb
      });
      sinon.stub(controller, 'loadRepoVersionsToModel').returns({
        done: Em.clb
      });
      sinon.stub(controller, 'loadCompatibleVersions').returns({
        done: Em.clb
      });
      sinon.stub(App.StackVersion, 'find').returns([Em.Object.create({
        state: 'CURRENT',
        repositoryVersion: {
          repositoryVersion: '2.2',
          displayName: 'HDP-2.2'
        }
      })]);
      controller.load();
    });
    afterEach(function(){
      controller.loadUpgradeData.restore();
      controller.loadStackVersionsToModel.restore();
      controller.loadRepoVersionsToModel.restore();
      controller.loadCompatibleVersions.restore();
      App.StackVersion.find.restore();
    });
    it("loadUpgradeData called with valid arguments", function() {
      expect(controller.loadUpgradeData.calledWith(true)).to.be.true;
    });
    it('loadStackVersionsToModel called with valid arguments', function () {
      expect(controller.loadStackVersionsToModel.calledWith(true)).to.be.true;
    });
    it('loadRepoVersionsToModel called once', function () {
      expect(controller.loadRepoVersionsToModel.calledOnce).to.be.true;
    });
    it('loadCompatibleVersions called once', function () {
      expect(controller.loadCompatibleVersions.calledOnce).to.be.true;
    });
    it('currentVersion is corrent', function () {
      expect(controller.get('currentVersion')).to.eql({
        "repository_version": "2.2",
        "repository_name": "HDP-2.2"
      });
    });
  });

  describe("#loadUpgradeData()", function() {

    it("get entire data", function() {
      controller.set('upgradeId', 1);
      controller.loadUpgradeData();
      var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.data');
      expect(args[0]).to.exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        id: 1
      });
    });
    it("get only state", function() {
      controller.set('upgradeId', 1);
      controller.loadUpgradeData(true);
      var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.state');
      expect(args[0]).to.exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        id: 1
      });
    });
    it("upgrade id is null", function() {
      controller.set('upgradeId', null);
      controller.loadUpgradeData();
      var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.state');
      var args2 = testHelpers.findAjaxRequest('name', 'admin.upgrade.data');
      expect(args).to.not.exists;
      expect(args2).to.not.exists;
    });
  });

  describe("#loadUpgradeDataSuccessCallback()", function() {
    var retryCases = [
      {
        isRetryPendingInitial: true,
        status: 'ABORTED',
        isRetryPending: true,
        requestInProgress: true,
        title: 'retry request not yet applied'
      },
      {
        isRetryPendingInitial: true,
        status: 'UPGRADING',
        isRetryPending: false,
        requestInProgress: false,
        title: 'retry request applied'
      },
      {
        isRetryPendingInitial: false,
        status: 'ABORTED',
        isRetryPending: false,
        requestInProgress: true,
        title: 'no retry request sent'
      },
      {
        isRetryPendingInitial: false,
        status: 'UPGRADING',
        isRetryPending: false,
        requestInProgress: true,
        title: 'upgrade wasn\'t aborted'
      }
    ];
    beforeEach(function () {
      sinon.stub(controller, 'updateUpgradeData', Em.K);
      sinon.stub(controller, 'setDBProperty', Em.K);
      sinon.stub(controller, 'finish');
    });
    afterEach(function () {
      controller.updateUpgradeData.restore();
      controller.setDBProperty.restore();
      controller.finish.restore();
      App.set('upgradeState', 'INIT');
    });

    it("correct data", function() {
      var data = {
        "Upgrade": {
          "request_status": "UPGRADED"
        },
        "upgrade_groups": [
          {
            "UpgradeGroup": {
              "id": 1
            },
            "upgrade_items": []
          }
        ]};
      controller.loadUpgradeDataSuccessCallback(data);
      expect(App.get('upgradeState')).to.equal('UPGRADED');
      expect(controller.updateUpgradeData.calledOnce).to.be.true;
      expect(controller.setDBProperty.calledWith('upgradeState', 'UPGRADED')).to.be.true;
    });

    it("data is null", function() {
      var data = null;
      controller.loadUpgradeDataSuccessCallback(data);
      expect(controller.updateUpgradeData.called).to.be.false;
      expect(controller.setDBProperty.called).to.be.false;
    });

    it("finish should be called", function() {
      var data = {
        "Upgrade": {
          "request_status": "COMPLETED"
        }
      };
      controller.loadUpgradeDataSuccessCallback(data);
      expect(controller.finish.calledOnce).to.be.true;
    });

    retryCases.forEach(function (item) {
      it(item.title, function () {
        var data = {
          "Upgrade": {
            "request_status": item.status
          }
        };
        controller.setProperties({
          isRetryPending: item.isRetryPendingInitial,
          requestInProgress: true
        });
        controller.loadUpgradeDataSuccessCallback(data);
        expect(controller.getProperties(['isRetryPending', 'requestInProgress'])).to.eql({
          isRetryPending: item.isRetryPending,
          requestInProgress: item.requestInProgress
        });
      });
    });
  });

  describe("#getUpgradeItem()", function() {

    it("default callback", function() {
      var item = Em.Object.create({
        request_id: 1,
        group_id: 2,
        stage_id: 3
      });
      controller.getUpgradeItem(item);
      var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.upgrade_item');
      expect(args[0]).to.exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].success).to.be.equal('getUpgradeItemSuccessCallback');
      expect(args[0].data).to.be.eql({
        upgradeId: 1,
        groupId: 2,
        stageId: 3
      });
    });
    it("custom callback", function() {
      var item = Em.Object.create({
        request_id: 1,
        group_id: 2,
        stage_id: 3
      });
      controller.getUpgradeItem(item, 'customCallback');
      var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.upgrade_item');
      expect(args[0]).to.exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].success).to.be.equal('customCallback');
      expect(args[0].data).to.be.eql({
        upgradeId: 1,
        groupId: 2,
        stageId: 3
      });
    });
  });

  describe("#openUpgradeDialog()", function () {
    var mock = {
      observer: Em.K
    };
    beforeEach(function () {
      sinon.stub(App.router, 'transitionTo', Em.K);
      sinon.spy(mock, 'observer');
      this.mockAuthorized = sinon.stub(App, 'isAuthorized');
      Em.addObserver(App, 'upgradeSuspended', mock, 'observer');
    });
    afterEach(function () {
      App.router.transitionTo.restore();
      mock.observer.restore();
      this.mockAuthorized.restore();
      Em.removeObserver(App, 'upgradeSuspended', mock, 'observer');
    });

    it('should open dialog', function () {
      this.mockAuthorized.returns(true);
      controller.openUpgradeDialog();
      expect(App.router.transitionTo.calledWith('admin.stackUpgrade')).to.be.true;
    });

    it('upgradeSuspended should receive actual value', function () {
      this.mockAuthorized.returns(true);
      controller.openUpgradeDialog();
      expect(mock.observer.calledOnce).to.be.true;
    });

    it('should not open dialog', function () {
      this.mockAuthorized.returns(false);
      controller.openUpgradeDialog();
      expect(App.router.transitionTo.called).to.be.false;
    });

    it('should not open dialog, isWizardRestricted=true', function () {
      this.mockAuthorized.returns(true);
      controller.set('isWizardRestricted', true);
      controller.openUpgradeDialog();
      expect(App.router.transitionTo.called).to.be.false;
    });

    it('upgradeSuspended should not receive value', function () {
      this.mockAuthorized.returns(false);
      controller.openUpgradeDialog();
      expect(mock.observer.called).to.be.false;
    });

    it('upgradeSuspended should not receive value, isWizardRestricted=true', function () {
      this.mockAuthorized.returns(true);
      controller.set('isWizardRestricted', true);
      controller.openUpgradeDialog();
      expect(mock.observer.called).to.be.false;
    });
  });

  describe("#runPreUpgradeCheck()", function() {
    it("make ajax call", function() {
      controller.runPreUpgradeCheck(Em.Object.create({
        repositoryVersion: '2.2',
        displayName: 'HDP-2.2',
        upgradeType: 'ROLLING',
        skipComponentFailures: false,
        skipSCFailures: false
      }));
      var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.pre_upgrade_check');
      expect(args[0]).to.exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        value: '2.2',
        label: 'HDP-2.2',
        type: 'ROLLING',
        skipComponentFailures: 'false',
        skipSCFailures: 'false'
      });
    });
  });

  describe("#runPreUpgradeCheckSuccess()", function () {
    var cases = [
      {
        check: {
          "check": "Work-preserving RM/NM restart is enabled in YARN configs",
          "status": "FAIL",
          "reason": "FAIL",
          "failed_on": [],
          "check_type": "SERVICE"
        },
        showClusterCheckPopupCalledCount: 1,
        upgradeCalledCount: 0,
        title: 'popup is displayed if fails are present'
      },
      {
        check: {
          "check": "Configuration Merge Check",
          "status": "WARNING",
          "reason": "Conflict",
          "failed_on": [],
          "failed_detail": [
            {
              type: 't0',
              property: 'p0',
              current: 'c0',
              new_stack_value: 'n0',
              result_value: 'n0'
            },
            {
              type: 't1',
              property: 'p1',
              current: 'c1',
              new_stack_value: null,
              result_value: 'c1'
            },
            {
              type: 't2',
              property: 'p2',
              current: 'c2',
              new_stack_value: null,
              result_value: null
            }
          ],
          "check_type": "CLUSTER",
          "id": "CONFIG_MERGE"
        },
        showClusterCheckPopupCalledCount: 1,
        upgradeCalledCount: 0,
        configs: [
          {
            type: 't0',
            name: 'p0',
            currentValue: 'c0',
            recommendedValue: 'n0',
            resultingValue: 'n0',
            isDeprecated: false,
            wasModified: false,
            willBeRemoved: false
          },
          {
            type: 't1',
            name: 'p1',
            currentValue: 'c1',
            recommendedValue: Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.deprecated'),
            resultingValue: 'c1',
            isDeprecated: true,
            wasModified: false,
            willBeRemoved: false
          },
          {
            type: 't2',
            name: 'p2',
            currentValue: 'c2',
            recommendedValue: Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.deprecated'),
            resultingValue: Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.willBeRemoved'),
            isDeprecated: true,
            wasModified: false,
            willBeRemoved: true
          }
        ],
        title: 'popup is displayed if warnings are present; configs merge conflicts'
      },
      {
        check: {
          "check": "Work-preserving RM/NM restart is enabled in YARN configs",
          "status": "PASS",
          "reason": "OK",
          "failed_on": [],
          "check_type": "SERVICE"
        },
        showClusterCheckPopupCalledCount: 0,
        upgradeCalledCount: 1,
        title: 'upgrade is started if fails and warnings are absent'
      }
    ];
    beforeEach(function () {
      sinon.stub(App, 'showClusterCheckPopup', Em.K);
      sinon.stub(controller, 'upgrade', Em.K);
    });
    afterEach(function () {
      App.showClusterCheckPopup.restore();
      controller.upgrade.restore();
    });
    cases.forEach(function (item) {
      it(item.title, function () {
        controller.runPreUpgradeCheckSuccess(
          {
            items: [
              {
                UpgradeChecks: item.check
              }
            ]
          }, null, {
            label: 'name'
          }
        );
        expect(controller.upgrade.callCount).to.equal(item.upgradeCalledCount);
        expect(App.showClusterCheckPopup.callCount).to.equal(item.showClusterCheckPopupCalledCount);
        if (item.check.id === 'CONFIG_MERGE') {
          expect(App.showClusterCheckPopup.firstCall.args[2]).to.eql(item.configs);
        }
      });
    });
  });

  describe("#initDBProperties()", function() {
    before(function () {
      this.mock = sinon.stub(controller, 'getDBProperties');
    });
    after(function () {
      this.mock.restore();
    });
    it("set string properties", function () {
      this.mock.returns({prop: 'string'});
      controller.initDBProperties();
      expect(controller.get('prop')).to.equal('string');
    });
    it("set number properties", function () {
      this.mock.returns({prop: 0});
      controller.initDBProperties();
      expect(controller.get('prop')).to.equal(0);
    });
    it("set boolean properties", function () {
      this.mock.returns({prop: false});
      controller.initDBProperties();
      expect(controller.get('prop')).to.be.false;
    });
    it("set undefined properties", function () {
      this.mock.returns({prop: undefined});
      controller.set('prop', 'value');
      controller.initDBProperties();
      expect(controller.get('prop')).to.equal('value');
    });
    it("set null properties", function () {
      this.mock.returns({prop: null});
      controller.set('prop', 'value');
      controller.initDBProperties();
      expect(controller.get('prop')).to.equal('value');
    });
  });

  describe("#init()", function() {
    before(function () {
      sinon.stub(controller, 'initDBProperties', Em.K);
    });
    after(function () {
      controller.initDBProperties.restore();
    });
    it("call initDBProperties", function () {
      controller.init();
      expect(controller.initDBProperties.calledOnce).to.be.true;
    });
  });

  describe("#upgrade()", function() {
    var callArgs;

    beforeEach(function () {
      sinon.stub(controller, 'setDBProperty', Em.K);
      controller.set('currentVersion', {
        repository_version: '2.2'
      });
      controller.upgrade({
        value: '2.2',
        label: 'HDP-2.2'
      });
      callArgs = testHelpers.findAjaxRequest('name', 'admin.upgrade.start')[0];
    });

    afterEach(function () {
      controller.setDBProperty.restore();
    });

    it("request-data is valid", function() {
      expect(callArgs.data).to.eql({"value": '2.2', "label": 'HDP-2.2'});
    });
    it('request-name is valid', function () {
      expect(callArgs.name).to.equal('admin.upgrade.start');
    });
    it('request-sender is valid', function () {
      expect(callArgs.sender).to.eql(controller);
    });
    it('callback is valid', function () {
      expect(callArgs.success).to.equal('upgradeSuccessCallback');
    });
    it('callback is called', function () {
      expect(callArgs.callback).to.be.called;
    });
    it('setDBProperty is called with valid data', function () {
      expect(controller.setDBProperty.calledWith('currentVersion', {
        repository_version: '2.2'
      })).to.be.true;
    });
  });

  describe("#upgradeSuccessCallback()", function() {

    beforeEach(function () {
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
      sinon.stub(controller, 'openUpgradeDialog', Em.K);
      sinon.stub(controller, 'setDBProperties', Em.K);
      sinon.stub(controller, 'load', Em.K);
      var data = {
        resources: [
          {
            Upgrade: {
              request_id: 1
            }
          }
        ]
      };
      controller.upgradeSuccessCallback(data, {}, {label: 'HDP-2.2.1', isDowngrade: true});
    });

    afterEach(function () {
      App.clusterStatus.setClusterStatus.restore();
      controller.openUpgradeDialog.restore();
      controller.setDBProperties.restore();
      controller.load.restore();
    });

    it('load is called ocne', function() {
      expect(controller.load.calledOnce).to.be.true;
    });
    it('upgradeVersion is HDP-2.2.1', function() {
      expect(controller.get('upgradeVersion')).to.equal('HDP-2.2.1');
    });
    it('upgradeData is null', function() {
      expect(controller.get('upgradeData')).to.be.null;
    });
    it('isDowngrade is true', function() {
      expect(controller.get('isDowngrade')).to.be.true;
    });
    it('App.clusterStatus.setClusterStatus is called once', function() {
      expect(App.clusterStatus.setClusterStatus.calledOnce).to.be.true;
    });
    it('controller.openUpgradeDialog is called once', function() {
      expect(controller.openUpgradeDialog.calledOnce).to.be.true;
    });
  });

  describe("#updateUpgradeData()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'initUpgradeData', Em.K);
    });
    afterEach(function () {
      controller.initUpgradeData.restore();
    });
    it("data loaded first time", function() {
      controller.set('upgradeData', null);
      controller.updateUpgradeData({});
      expect(controller.initUpgradeData.calledWith({})).to.be.true;
    });

    describe('upgradeData exists', function () {

      var groups;

      beforeEach(function() {
        var oldData = Em.Object.create({
          upgradeGroups: [
            Em.Object.create({
              group_id: 1,
              upgradeItems: [
                Em.Object.create({
                  stage_id: 1
                })
              ]
            }),
            Em.Object.create({
              group_id: 2,
              upgradeItems: [
                Em.Object.create({
                  stage_id: 2
                }),
                Em.Object.create({
                  stage_id: 3
                })
              ]
            })
          ]
        });
        var newData = {
          Upgrade: {
            request_id: 1
          },
          upgrade_groups: [
            {
              UpgradeGroup: {
                group_id: 1,
                status: 'COMPLETED',
                display_status: 'COMPLETED',
                progress_percent: 100,
                completed_task_count: 3
              },
              upgrade_items: [
                {
                  UpgradeItem: {
                    stage_id: 1,
                    status: 'COMPLETED',
                    display_status: 'COMPLETED',
                    progress_percent: 100
                  }
                }
              ]
            },
            {
              UpgradeGroup: {
                group_id: 2,
                status: 'ABORTED',
                display_status: 'ABORTED',
                progress_percent: 50,
                completed_task_count: 1
              },
              upgrade_items: [
                {
                  UpgradeItem: {
                    stage_id: 2,
                    status: 'ABORTED',
                    display_status: 'ABORTED',
                    progress_percent: 99
                  }
                },
                {
                  UpgradeItem: {
                    stage_id: 3,
                    status: 'PENDING',
                    display_status: 'PENDING',
                    progress_percent: 0
                  }
                }
              ]
            }
          ]
        };
        controller.set('upgradeData', oldData);
        controller.updateUpgradeData(newData);
        groups = controller.get('upgradeData.upgradeGroups');
      });

      describe("checking 1st group", function() {
        it('status is COMPLETED', function () {
          expect(groups[0].get('status')).to.equal('COMPLETED');
        });
        it('display_status is COMPLETED', function () {
          expect(groups[0].get('display_status')).to.equal('COMPLETED');
        });
        it('progress_percent is 100', function () {
          expect(groups[0].get('progress_percent')).to.equal(100);
        });
        it('completed_task_count = 3', function () {
          expect(groups[0].get('completed_task_count')).to.equal(3);
        });
        it('upgradeItems.0.status is COMPLETED', function () {
          expect(groups[0].get('upgradeItems')[0].get('status')).to.equal('COMPLETED');
        });
        it('upgradeItems.0.display_status is COMPLETED', function () {
          expect(groups[0].get('upgradeItems')[0].get('display_status')).to.equal('COMPLETED');
        });
        it('upgradeItems.0.progress_percent is 100', function () {
          expect(groups[0].get('upgradeItems')[0].get('progress_percent')).to.equal(100);
        });
        it('hasExpandableItems is true', function () {
          expect(groups[0].get('hasExpandableItems')).to.be.true;
        });
      });

      describe('checking 2nd group', function () {
        it('status is ABORTED', function () {
          expect(groups[1].get('status')).to.equal('ABORTED');
        });
        it('display_status is ABORTED', function () {
          expect(groups[1].get('display_status')).to.equal('ABORTED');
        });
        it('progress_percent is 50', function () {
          expect(groups[1].get('progress_percent')).to.equal(50);
        });
        it('completed_task_count = 1', function () {
          expect(groups[1].get('completed_task_count')).to.equal(1);
        });
        it('upgradeItems.[].status = ["ABORTED", "PENDING"]', function () {
          expect(groups[1].get('upgradeItems').mapProperty('status')).to.eql(['ABORTED', 'PENDING']);
        });
        it('upgradeItems.[].display_status = ["ABORTED", "PENDING"]', function () {
          expect(groups[1].get('upgradeItems').mapProperty('display_status')).to.eql(['ABORTED', 'PENDING']);
        });
        it('upgradeItems.[].progress_percent = [99, 0]', function () {
          expect(groups[1].get('upgradeItems').mapProperty('progress_percent')).to.eql([99, 0]);
        });
        it('hasExpandableItems is false', function () {
          expect(groups[1].get('hasExpandableItems')).to.be.false;
        });
      });

    });
  });

  describe("#initUpgradeData()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'setDBProperty');
      sinon.stub(controller, 'formatMessages');
      var newData = {
        Upgrade: {
          request_id: 1,
          downgrade_allowed: false
        },
        upgrade_groups: [
          {
            UpgradeGroup: {
              group_id: 1
            },
            upgrade_items: [
              {
                UpgradeItem: {
                  stage_id: 1,
                  status: 'IN_PROGRESS'
                }
              },
              {
                UpgradeItem: {
                  stage_id: 2
                }
              }
            ]
          },
          {
            UpgradeGroup: {
              group_id: 2
            },
            upgrade_items: []
          },
          {
            UpgradeGroup: {
              group_id: 3
            },
            upgrade_items: [
              {
                UpgradeItem: {
                  stage_id: 3,
                  status: 'ABORTED'
                }
              },
              {
                UpgradeItem: {
                  stage_id: 4,
                  status: 'PENDING'
                }
              }
            ]
          }
        ]
      };
      controller.initUpgradeData(newData);
    });
    afterEach(function () {
      controller.setDBProperty.restore();
      controller.formatMessages.restore();
    });
    it("setDBProperty called with valid arguments", function() {
      expect(controller.setDBProperty.calledWith('downgradeAllowed', false)).to.be.true;
    });
    it('downgradeAllowed is false', function () {
      expect(controller.get('downgradeAllowed')).to.be.false;
    });
    it('upgradeData.Upgrade.request_id is 1', function () {
      expect(controller.get('upgradeData.Upgrade.request_id')).to.equal(1);
    });
    it('upgradeData.upgradeGroups contain valid data', function () {
      var groups = controller.get('upgradeData.upgradeGroups');
      expect(groups.mapProperty('group_id')).to.eql([3,2,1]);
      expect(groups[2].get('upgradeItems').mapProperty('stage_id')).to.eql([2,1]);
      expect(groups.mapProperty('hasExpandableItems')).to.eql([false, false, true]);
    });
  });

  describe.skip("#finish()", function() {
    before(function () {
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
      sinon.stub(controller, 'setDBProperty', Em.K);
    });
    after(function () {
      App.clusterStatus.setClusterStatus.restore();
      controller.setDBProperty.restore();
    });
    it("upgradeState is not COMPLETED", function() {
      App.set('upgradeState', 'UPGRADING');
      controller.finish();
      expect(App.clusterStatus.setClusterStatus.called).to.be.false;
    });
    it("upgradeState is COMPLETED", function() {
      App.set('upgradeState', 'COMPLETED');
      controller.finish();
      expect(controller.setDBProperty.calledWith('upgradeId', undefined)).to.be.true;
      expect(controller.setDBProperty.calledWith('upgradeVersion', undefined)).to.be.true;
      expect(controller.setDBProperty.calledWith('upgradeState', 'INIT')).to.be.true;
      expect(controller.setDBProperty.calledWith('currentVersion', undefined)).to.be.true;
      expect(App.get('upgradeState')).to.equal('INIT');
      expect(App.clusterStatus.setClusterStatus.calledOnce).to.be.true;
    });
  });

  describe("#confirmDowngrade()", function() {

    before(function () {
      sinon.spy(App, 'showConfirmationPopup');
      sinon.stub(controller, 'downgrade', Em.K);
    });

    after(function () {
      App.showConfirmationPopup.restore();
      controller.downgrade.restore();
    });

    it("show confirmation popup", function() {
      controller.set('currentVersion', Em.Object.create({
        repository_version: '2.2',
        repository_name: 'HDP-2.2'
      }));
      var popup = controller.confirmDowngrade();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.downgrade.calledWith(Em.Object.create({
        repository_version: '2.2',
        repository_name: 'HDP-2.2'
      }))).to.be.true;
    });
  });

  describe("#upgradeOptions()", function() {
    var version = Em.Object.create({displayName: 'HDP-2.2'});
    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
      sinon.spy(App, 'showConfirmationFeedBackPopup');
      sinon.stub(controller, 'getSupportedUpgradeTypes').returns({
        done: function (callback) {
          callback([1]);
          return {
            always: function (alwaysCallback) {
              alwaysCallback();
              return {};
            }
          };
        }
      });
      sinon.stub(controller, 'runPreUpgradeCheck', Em.K);
      sinon.stub(App.RepositoryVersion, 'find').returns([
        Em.Object.create({
          status: 'CURRENT'
        })
      ]);
      controller.get('runningCheckRequests').clear();
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
      App.showConfirmationFeedBackPopup.restore();
      controller.runPreUpgradeCheck.restore();
      controller.getSupportedUpgradeTypes.restore();
      controller.get('upgradeMethods').setEach('selected', false);
      App.RepositoryVersion.find.restore();
    });

    describe("show confirmation popup", function() {

      beforeEach(function () {
        controller.set('isDowngrade', false);
        this.popup = controller.upgradeOptions(false, version);
      });

      it('popup is shown', function () {
        expect(App.ModalPopup.show.calledOnce).to.be.true;
      });

      it('all upgradeMethods have isCheckRequestInProgress = true', function () {
        expect(controller.get('upgradeMethods').everyProperty('isCheckRequestInProgress')).to.be.true;
      });

      it('upgradeMethods no one is selected', function () {
        expect(controller.get('upgradeMethods').someProperty('selected')).to.be.false;
      });

      describe('#popup.onPrimary', function () {

        beforeEach(function () {
          controller.get('upgradeMethods')[0].set('selected', true);
          this.confirmPopup = this.popup.onPrimary();
        });

        it('showConfirmationFeedBackPopup is called once', function () {
          expect(App.showConfirmationFeedBackPopup.calledOnce).to.be.true;
        });

        describe('#confirmPopup.onPrimary', function () {
          beforeEach(function () {
            this.confirmPopup.onPrimary();
          });

          it('runPreUpgradeCheck is called with correct version', function () {
            expect(controller.runPreUpgradeCheck.calledWith(version)).to.be.true;
          });

          it('runningCheckRequests has 1 item', function () {
            expect(controller.get('runningCheckRequests')).to.have.length(1);
          });

        });

      });

      describe('#popup.disablePrimary', function () {

        beforeEach(function() {
          this.mock = sinon.stub(App, 'get');
        });

        afterEach(function() {
          App.get.restore();
        });

        it('should be disabled if no method is selected', function () {
          expect(this.popup.get('disablePrimary')).to.be.true;
        });

        it('should be disabled if preupgradecheck is supproted and isPrecheckFailed is true', function () {
          this.mock.returns(true);
          this.popup.set('selectedMethod', Em.Object.create({
            selected: true,
            isPrecheckFailed: true,
            isCheckRequestInProgress: false
          }));

          expect(this.popup.get('disablePrimary')).to.be.true;
        });

        it('should be disabled if preupgradecheck is supproted and isCheckRequestInProgress is true', function () {
          this.popup.set('selectedMethod', Em.Object.create({
            selected: true,
            isPrecheckFailed: false,
            isCheckRequestInProgress: true
          }));
          this.mock.returns(true);
          expect(this.popup.get('disablePrimary')).to.be.true;
        });

        it('should be enabled with preupgrade check', function () {
          this.popup.set('selectedMethod', Em.Object.create({
            selected: true,
            isPrecheckFailed: false,
            isCheckRequestInProgress: false
          }));
          this.mock.returns(true);
          expect(this.popup.get('disablePrimary')).to.be.false;
        });

        it('should be enabled without preupgrade check', function () {
          this.popup.set('selectedMethod', Em.Object.create({
            selected: true
          }));
          this.mock.returns(false);
          expect(this.popup.get('disablePrimary')).to.be.false;
        });

      });

    });

    describe("NOT show confirmation popup on Downgrade", function() {
      beforeEach(function () {
        controller.set('isDowngrade', true);
        controller.upgradeOptions(false, version);
      });

      it('runningCheckRequests has 1 item', function () {
        expect( controller.get('runningCheckRequests')).to.have.length(1);
      });

    });
  });

  describe("#confirmUpgrade()", function() {
    before(function () {
      sinon.stub(controller, 'upgradeOptions', Em.K);
    });
    after(function () {
      controller.upgradeOptions.restore();
    });
    it("show show upgrade options popup window", function() {
      var version = Em.Object.create({displayName: 'HDP-2.2'});
      controller.confirmUpgrade(version);
      expect(controller.upgradeOptions.calledWith(false, version)).to.be.true;
    });
  });

  describe("#downgrade", function() {
    beforeEach(function () {
      sinon.stub(controller, 'abortUpgrade').returns({
        done: function(callback) {callback()}
      });
      sinon.stub(controller, 'startDowngrade');
      controller.downgrade('versionInfo');
    });

    afterEach(function () {
      controller.abortUpgrade.restore();
      controller.startDowngrade.restore();
    });

    it('should run abortUpgrade', function() {
      expect(controller.abortUpgrade.calledOnce).to.be.true;
    });

  });

  describe("#startDowngrade()", function() {
    beforeEach(function () {
      sinon.stub(App.RepositoryVersion, 'find').returns([
        Em.Object.create({
          displayName: 'HDP-2.3',
          repositoryVersion: '2.3'
        })
      ]);
      controller.set('upgradeVersion', 'HDP-2.3');
      controller.set('upgradeType', 'NON_ROLLING');
      controller.startDowngrade(Em.Object.create({
        repository_version: '2.2',
        repository_name: 'HDP-2.2'
      }));
      this.callArgs = testHelpers.findAjaxRequest('name', 'admin.downgrade.start')[0];
    });

    afterEach(function () {
      App.RepositoryVersion.find.restore();
    });

    it('request-data is valid', function () {
      expect(this.callArgs.data).to.eql({
        from: '2.3',
        value: '2.2',
        label: 'HDP-2.2',
        isDowngrade: true,
        upgradeType: "NON_ROLLING"
      });
    });
    it('request-name is valid', function () {
      expect(this.callArgs.name).to.be.equal('admin.downgrade.start');
    });
    it('request-sender is valid', function () {
      expect(this.callArgs.sender).to.be.eql(controller);
    });
    it('callback is valid', function () {
      expect(this.callArgs.success).to.be.equal('upgradeSuccessCallback');
    });
    it('callback is called', function () {
      expect(this.callArgs.callback).to.be.called;
    });
  });

  describe("#installRepoVersionConfirmation()", function () {
    before(function () {
      sinon.stub(controller, 'installRepoVersion', Em.K);
    });
    after(function () {
      controller.installRepoVersion.restore();
    });
    it("show popup", function () {
      var repo = Em.Object.create({'displayName': 'HDP-2.2'});
      var popup = controller.installRepoVersionConfirmation(repo);
      popup.onPrimary();
      expect(controller.installRepoVersion.calledWith(repo)).to.be.true;
    });
  });

  describe("#installRepoVersion()", function () {

    it("make ajax call", function () {
      var repo = Em.Object.create({
        stackVersionType: 'HDP',
        stackVersionNumber: '2.2',
        repositoryVersion: '2.2.1',
        repoId: 1
      });
      controller.installRepoVersion(repo);
      var args = testHelpers.findAjaxRequest('name', 'admin.stack_version.install.repo_version');
      expect(args).to.exists;
    });
  });

  describe("#installRepoVersionSuccess()", function() {
    var mock = Em.Object.create({
      id: 1,
      defaultStatus: 'INIT',
      stackVersion: {}
    });
    beforeEach(function () {
      sinon.spy(mock, 'set');
      sinon.stub(App.db, 'set', Em.K);
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
      sinon.stub(App.RepositoryVersion, 'find').returns(mock);
      sinon.stub(App, 'showAlertPopup');
    });
    afterEach(function () {
      App.db.set.restore();
      App.clusterStatus.setClusterStatus.restore();
      App.RepositoryVersion.find.restore();
      mock.set.restore();
      App.showAlertPopup.restore();
    });

    it("App.showAlertPopup should be called", function() {
      expect(controller.installRepoVersionSuccess({statusText: 'timeout'}, {}, {id: 1})).to.be.false;
      expect(App.showAlertPopup.calledWith(
        Em.I18n.t('admin.stackVersions.upgrade.installPackage.fail.title'),
        Em.I18n.t('admin.stackVersions.upgrade.installPackage.fail.timeout')
      )).to.be.true;
    });

    it("data sdtored to the local db", function() {
      controller.installRepoVersionSuccess({Requests: {id: 1}}, {}, {id: 1});
      expect(App.db.set.calledWith('repoVersionInstall', 'id', [1])).to.be.true;
    });

    it('clusterStatus is updated', function () {
      controller.installRepoVersionSuccess({Requests: {id: 1}}, {}, {id: 1});
      expect(App.clusterStatus.setClusterStatus.calledOnce).to.be.true;
    });

    it('App.RepositoryVersion models have valid states', function () {
      controller.installRepoVersionSuccess({Requests: {id: 1}}, {}, {id: 1});
      expect(App.RepositoryVersion.find.calledWith(1)).to.be.true;
      expect(App.RepositoryVersion.find(1).get('defaultStatus')).to.equal('INSTALLING');
      expect(App.RepositoryVersion.find(1).get('stackVersion.state')).to.equal('INSTALLING');
    });
  });

  describe("#setUpgradeItemStatus()", function () {
    var item;
    beforeEach(function () {
      item = Em.Object.create({
        request_id: 1,
        stage_id: 1,
        group_id: 1
      });
      controller.setUpgradeItemStatus(item, 'PENDING');
      this.callArgs = testHelpers.findAjaxRequest('name', 'admin.upgrade.upgradeItem.setState')[0];
    });

    it('request-data is valid', function () {
      expect(this.callArgs.data).to.be.eql({upgradeId: 1, itemId: 1, groupId: 1, status: 'PENDING'});
    });
    it('request-name is valid', function () {
      expect(this.callArgs.name).to.be.equal('admin.upgrade.upgradeItem.setState');
    });
    it('request-sendeer is valid', function () {
      expect(this.callArgs.sender).to.be.eql(controller);
    });
    it('callback is called', function () {
      expect(this.callArgs.callback).to.be.called;
    });
    it('item.status is PENDING', function () {
      expect(item.get('status')).to.equal('PENDING');
    });
  });

  describe("#prepareRepoForSaving()", function () {
    it("prepare date for saving", function () {
      var repo = Em.Object.create({
        operatingSystems: [
          Em.Object.create({
            osType: "redhat6",
            isDisabled: Em.computed.not('isSelected'),
            repositories: [Em.Object.create({
                "baseUrl": "111121",
                "repoId": "HDP-2.2",
                "repoName": "HDP",
                hasError: false
            }),
              Em.Object.create({
                "baseUrl": "1",
                "repoId": "HDP-UTILS-1.1.0.20",
                "repoName": "HDP-UTILS",
                hasError: false
              })]
           })
        ]
      });
      var result = {
        "operating_systems": [
          {
            "OperatingSystems": {
              "os_type": "redhat6",
              "ambari_managed_repositories": true
            },
            "repositories": [
              {
                "Repositories": {
                  "base_url": "111121",
                  "repo_id": "HDP-2.2",
                  "repo_name": "HDP"
                }
              },
              {
                "Repositories": {
                  "base_url": "1",
                  "repo_id": "HDP-UTILS-1.1.0.20",
                  "repo_name": "HDP-UTILS"
                }
              }
            ]
          }
        ]};
      expect(controller.prepareRepoForSaving(repo)).to.eql(result);
    });
  });

  describe("#getStackVersionNumber()", function(){
    it("get stack version number", function(){
      var repo = Em.Object.create({
        "stackVersionType": 'HDP',
        "stackVersion": '2.3',
        "repositoryVersion": '2.2.1'
      });

      var stackVersion = controller.getStackVersionNumber(repo);
      expect(stackVersion).to.equal('2.3');
    });

    it("get default stack version number", function(){
      App.set('currentStackVersion', '1.2.3');
      var repo = Em.Object.create({
        "stackVersionType": 'HDP',
        "repositoryVersion": '2.2.1'
      });

      var stackVersion = controller.getStackVersionNumber(repo);
      expect(stackVersion).to.equal('1.2.3');
    });
  });

  describe("#saveRepoOS()", function() {
    before(function(){
      this.mock = sinon.stub(controller, 'validateRepoVersions');
      sinon.stub(controller, 'prepareRepoForSaving', Em.K);
    });
    after(function(){
      this.mock.restore();
      controller.prepareRepoForSaving.restore();
    });
    describe("validation errors present", function() {

      beforeEach(function () {
        this.mock.returns({
          done: function(callback) {callback([1]);}
        });
        controller.saveRepoOS(Em.Object.create({repoVersionId: 1}), true);
        this.args = testHelpers.findAjaxRequest('name', 'admin.stack_versions.edit.repo');
      });

      it('validateRepoVersions is called with valid arguments', function () {
        expect(controller.validateRepoVersions.calledWith(Em.Object.create({repoVersionId: 1}), true)).to.be.true;
      });

      it('prepareRepoForSaving is not called', function () {
        expect(controller.prepareRepoForSaving.called).to.be.false;
      });

      it('no requests are sent', function () {
        expect(this.args).to.not.exists;
      });
    });

    describe("no validation errors", function() {

      beforeEach(function () {
        this.mock.returns({
          done: function(callback) {callback([]);}
        });
        controller.saveRepoOS(Em.Object.create({repoVersionId: 1}), true);
      });
      it('validateRepoVersions is called with valid arguments', function () {
        expect(controller.validateRepoVersions.calledWith(Em.Object.create({repoVersionId: 1}), true)).to.be.true;
      });
      it('prepareRepoForSaving is called with valid arguments', function () {
        expect(controller.prepareRepoForSaving.calledWith(Em.Object.create({repoVersionId: 1}))).to.be.true;
      });
    });
  });

  describe("#validateRepoVersions()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'validationCall').returns({
        success: function() {
          return {error: Em.K}
        }
      });
      sinon.stub(controller, 'getStackVersionNumber').returns('v1')
    });

    afterEach(function() {
      controller.validationCall.restore();
      controller.getStackVersionNumber.restore();
    });


    it("validationCall should not be called", function () {
      controller.validateRepoVersions(Em.Object.create({repoVersionId: 1}), true);
      expect(controller.validationCall.called).to.be.false;
    });
    it("validationCall should be called", function () {
      var os = Em.Object.create({
        isSelected: true,
        repositories: [
          Em.Object.create()
        ]
      });
      var repo = Em.Object.create({
        repoVersionId: 1,
        operatingSystems: [ os ]
      });
      controller.validateRepoVersions(repo, false);
      expect(controller.validationCall.calledOnce).to.be.true;
    });
  });

  describe("#validationCall()", function () {

    it("App.ajax.send should be called", function() {
      controller.validationCall(Em.Object.create(), Em.Object.create(), 'v1');
      var args = testHelpers.findAjaxRequest('name', 'admin.stack_versions.validate.repo');
      expect(args[0]).to.exists;
    });
  });

  describe("#getUrl()", function() {
    beforeEach(function(){
      controller.reopen({
        realStackUrl: 'realStackUrl',
        realRepoUrl: 'realRepoUrl',
        realUpdateUrl: 'realUpdateUrl'
      });
    });

    it("full load is true, stack is null", function() {
      expect(controller.getUrl(null, true)).to.equal('realRepoUrl');
    });
    it("full load is true, stack is valid", function() {
      expect(controller.getUrl({}, true)).to.equal('realStackUrl');
    });
    it("full load is false, stack is valid", function() {
      expect(controller.getUrl({}, false)).to.equal('realUpdateUrl');
    });
  });

  describe("#loadStackVersionsToModel()", function () {
    before(function () {
      sinon.stub(App.HttpClient, 'get');
    });
    after(function () {
      App.HttpClient.get.restore();
    });
    it("HttpClient did get-request", function () {
      controller.loadStackVersionsToModel();
      expect(App.HttpClient.get.calledOnce).to.be.true;
    });
  });

  describe("#loadRepoVersionsToModel()", function () {
    before(function () {
      sinon.stub(App.HttpClient, 'get');
    });
    after(function () {
      App.HttpClient.get.restore();
    });
    it("HttpClient did get-request", function () {
      controller.loadRepoVersionsToModel();
      expect(App.HttpClient.get.calledOnce).to.be.true;
    });
  });

  describe('#currentVersionObserver()', function () {

    var cases = [
      {
        stackVersionType: 'HDP',
        repoVersion: '2.2.1.1.0-1',
        isStormMetricsSupported: false,
        title: 'HDP < 2.2.2'
      },
      {
        stackVersionType: 'HDP',
        repoVersion: '2.2.2.1.0-1',
        isStormMetricsSupported: true,
        title: 'HDP 2.2.2'
      },
      {
        stackVersionType: 'HDP',
        repoVersion: '2.2.3.1.0-1',
        isStormMetricsSupported: true,
        title: 'HDP > 2.2.2'
      },
      {
        stackVersionType: 'BIGTOP',
        repoVersion: '0.8.1.1.0-1',
        isStormMetricsSupported: true,
        title: 'not HDP'
      }
    ];

    afterEach(function () {
      App.RepositoryVersion.find.restore();
    });

    cases.forEach(function (item) {
      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(App.RepositoryVersion, 'find').returns([
            Em.Object.create({
              status: 'CURRENT',
              stackVersionType: item.stackVersionType
            })
          ]);
          controller.set('currentVersion', {
            repository_version: item.repoVersion
          });
        });

        it('isStormMetricsSupported is ' + (item.isStormMetricsSupported ? '' : 'not') + ' supported', function () {
          expect(App.get('isStormMetricsSupported')).to.equal(item.isStormMetricsSupported);
        });

      });
    });

  });

  describe('#updateFinalize', function () {

    beforeEach(function() {
      controller.set('isFinalizeItem', true);
      this.stub = sinon.stub(App, 'get');
    });

    afterEach(function () {
      this.stub.restore();
    });

    describe('should do ajax-request', function () {

      beforeEach(function () {
        this.stub.withArgs('upgradeState').returns('HOLDING');
        controller.updateFinalize();
        this.args = testHelpers.findAjaxRequest('name', 'admin.upgrade.finalizeContext');
      });

      it('request is sent', function () {
        expect(this.args[0]).to.exists;
      });

    });

    describe('shouldn\'t do ajax-request', function () {

      beforeEach(function () {
        this.stub.withArgs('upgradeState').returns('HOLDING_TIMEDOUT');
        controller.updateFinalize();
        this.args = testHelpers.findAjaxRequest('name', 'admin.upgrade.finalizeContext');
      });

      it('request is not sent', function () {
        expect(this.args).to.not.exists;
      });

      it('isFinalizeItem is false', function () {
        expect(controller.get('isFinalizeItem')).to.be.false;
      });

    });

  });

  describe('#updateFinalizeSuccessCallback', function () {

    it('data exists and Finalize should be true', function() {
      var data = {
        items: [
          {
            upgrade_groups: [
              {
                upgrade_items: [
                  {
                    UpgradeItem: {
                      context: controller.get('finalizeContext'),
                      status: "HOLDING"
                    }
                  }
                ]
              }
            ]
          }
        ]
      };
      controller.set('isFinalizeItem', false);
      controller.updateFinalizeSuccessCallback(data);
      expect(controller.get('isFinalizeItem')).to.be.true;
    });

    it('data exists and Finalize should be false', function() {
      var data = {
        upgrade_groups: [
          {
            upgrade_items: [
              {
                UpgradeItem: {
                  context: '!@#$%^&',
                  status: "HOLDING"
                }
              }
            ]
          }
        ]
      };
      controller.set('isFinalizeItem', true);
      controller.updateFinalizeSuccessCallback(data);
      expect(controller.get('isFinalizeItem')).to.be.false;
    });

    it('data doesn\'t exist', function() {
      var data = null;
      controller.set('isFinalizeItem', true);
      controller.updateFinalizeSuccessCallback(data);
      expect(controller.get('isFinalizeItem')).to.be.false;
    });

  });

  describe('#updateFinalizeErrorCallback', function () {

    it('should set isFinalizeItem to false', function () {
      controller.set('isFinalizeItem', true);
      controller.updateFinalizeErrorCallback();
      expect(controller.get('isFinalizeItem')).to.be.false;
    });

  });

  describe("#suspendUpgrade()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'abortUpgradeWithSuspend').returns({
        done: Em.clb
      });
      sinon.stub(controller, 'setDBProperty', Em.K);
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
      controller.suspendUpgrade();
    });
    afterEach(function () {
      controller.abortUpgradeWithSuspend.restore();
      controller.setDBProperty.restore();
      App.clusterStatus.setClusterStatus.restore();
    });
    it("upgrade aborted", function() {
      expect(controller.abortUpgradeWithSuspend.calledOnce).to.be.true;
    });
    it('App.upgradeState is ABORTED', function () {
      expect(App.get('upgradeState')).to.equal('ABORTED');
    });
    it('new upgradeState is saved to the localDB', function () {
      expect(controller.setDBProperty.calledWith('upgradeState', 'ABORTED')).to.be.true;
    });
    it('clusterStatus is updated', function () {
      expect(App.clusterStatus.setClusterStatus.calledOnce).to.be.true;
    });
  });

  describe("#resumeUpgrade()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'retryUpgrade').returns({
        done: Em.clb
      });
      sinon.stub(controller, 'setDBProperty', Em.K);
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
      controller.resumeUpgrade();
    });
    afterEach(function () {
      controller.retryUpgrade.restore();
      controller.setDBProperty.restore();
      App.clusterStatus.setClusterStatus.restore();
    });
    it("Upgrade is retrying", function() {
      expect(controller.retryUpgrade.calledOnce).to.be.true;
    });
    it('App.upgradeState is PENDING', function () {
      expect(App.get('upgradeState')).to.equal('PENDING');
    });
    it('new upgradeState is saved to the localDB', function () {
      expect(controller.setDBProperty.calledWith('upgradeState', 'PENDING')).to.be.true;
    });
    it('clusterStatus is updated', function () {
      expect(App.clusterStatus.setClusterStatus.calledOnce).to.be.true;
    });
  });

  describe("#runUpgradeMethodChecks()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'runPreUpgradeCheckOnly');
    });
    afterEach(function () {
      controller.runPreUpgradeCheckOnly.restore();
      controller.get('upgradeMethods').setEach('allowed', true);
    });
    it("no allowed upgrade methods", function () {
      controller.get('upgradeMethods').setEach('allowed', false);
      controller.runUpgradeMethodChecks();
      expect(controller.runPreUpgradeCheckOnly.called).to.be.false;
    });
    it("Rolling method allowed", function () {
      controller.get('upgradeMethods').setEach('allowed', true);
      controller.runUpgradeMethodChecks(Em.Object.create({
        repositoryVersion: 'v1',
        displayName: 'V1'
      }));
      expect(controller.runPreUpgradeCheckOnly.calledWith({
        value: 'v1',
        label: 'V1',
        type: 'ROLLING'
      })).to.be.true;
    });
  });

  describe("#restoreLastUpgrade()", function () {

    var data = {
      Upgrade: {
        request_id: 1,
        direction: 'UPGRADE',
        request_status: 'PENDING',
        upgrade_type: 'ROLLING',
        downgrade_allowed: true,
        skip_failures: true,
        skip_service_check_failures: true,
        to_version: '1'
      }
    };

    beforeEach(function () {
      sinon.stub(App.RepositoryVersion, 'find').returns([Em.Object.create({
        repositoryVersion: '1',
        displayName: 'HDP-1'
      })]);
      sinon.stub(controller, 'setDBProperties');
      sinon.stub(controller, 'loadRepoVersionsToModel', function () {
        return {
          done: function (callback) {
            callback();
          }
        }
      });
      sinon.stub(controller, 'setDBProperty');
      sinon.stub(controller, 'initDBProperties');
      sinon.stub(controller, 'loadUpgradeData');
      controller.restoreLastUpgrade(data);
    });
    afterEach(function () {
      App.RepositoryVersion.find.restore();
      controller.setDBProperties.restore();
      controller.loadRepoVersionsToModel.restore();
      controller.setDBProperty.restore();
      controller.initDBProperties.restore();
      controller.loadUpgradeData.restore();
    });
    it('proper data is saved to the localDB', function () {
      expect(controller.setDBProperties.getCall(0).args[0]).to.eql({
        upgradeId: 1,
        isDowngrade: false,
        upgradeState: 'PENDING',
        upgradeType: "ROLLING",
        isWizardRestricted: false,
        downgradeAllowed: true,
        upgradeTypeDisplayName: Em.I18n.t('admin.stackVersions.version.upgrade.upgradeOptions.RU.title'),
        failuresTolerance: Em.Object.create({
          skipComponentFailures: true,
          skipSCFailures: true
        })
      });
    });
    it('models are saved', function () {
      expect(controller.loadRepoVersionsToModel.calledOnce).to.be.true;
    });
    it('correct upgradeVersion is saved to the DB', function () {
      expect(controller.setDBProperty.calledWith('upgradeVersion', 'HDP-1')).to.be.true;
    });
    it('initDBProperties is called', function () {
      expect(controller.initDBProperties.calledOnce).to.be.true;
    });
    it('loadUpgradeData called with valid arguments', function () {
      expect(controller.loadUpgradeData.calledWith(true)).to.be.true;
    });
  });

  describe("#getServiceCheckItemSuccessCallback()", function() {
    var testCases = [
      {
        title: 'no tasks',
        data: {
          tasks: []
        },
        expected: {
          slaveComponentStructuredInfo: null,
          serviceCheckFailuresServicenames: []
        }
      },
      {
        title: 'no structured_out property',
        data: {
          tasks: [
            {
              Tasks: {}
            }
          ]
        },
        expected: {
          slaveComponentStructuredInfo: null,
          serviceCheckFailuresServicenames: []
        }
      },
      {
        title: 'no failures',
        data: {
          tasks: [
            {
              Tasks: {
                structured_out: {}
              }
            }
          ]
        },
        expected: {
          slaveComponentStructuredInfo: null,
          serviceCheckFailuresServicenames: []
        }
      },
      {
        title: 'service check failures',
        data: {
          tasks: [
            {
              Tasks: {
                structured_out: {
                  failures: {
                    service_check: ['HDSF', 'YARN']
                  }
                }
              }
            }
          ]
        },
        expected: {
          slaveComponentStructuredInfo: {
            hosts: [],
            host_detail: {}
          },
          serviceCheckFailuresServicenames: ['HDSF', 'YARN']
        }
      },
      {
        title: 'host-component failures',
        data: {
          tasks: [
            {
              Tasks: {
                structured_out: {
                  failures: {
                    service_check: ['HDSF'],
                    host_component: {
                      "host1": [
                        {
                          component: "DATANODE",
                          service: 'HDFS'
                        }
                      ]
                    }
                  }
                }
              }
            }
          ]
        },
        expected: {
          slaveComponentStructuredInfo: {
            hosts: ['host1'],
            host_detail: {
              "host1": [
                {
                  component: "DATANODE",
                  service: 'HDFS'
                }
              ]
            }
          },
          serviceCheckFailuresServicenames: ['HDSF']
        }
      }
    ];

    testCases.forEach(function(test) {
      it(test.title, function() {
        controller.set('slaveComponentStructuredInfo', null);
        controller.set('serviceCheckFailuresServicenames', []);
        controller.getServiceCheckItemSuccessCallback(test.data);
        expect(controller.get('serviceCheckFailuresServicenames')).eql(test.expected.serviceCheckFailuresServicenames);
        expect(controller.get('slaveComponentStructuredInfo')).eql(test.expected.slaveComponentStructuredInfo);
      });
    });
  });

  describe("#getSlaveComponentItemSuccessCallback()", function () {
    var testCases = [
      {
        title: 'no tasks',
        data: {
          tasks: []
        },
        expected: {
          slaveComponentStructuredInfo: null
        }
      },
      {
        title: 'structured_out property absent',
        data: {
          tasks: [
            {
              Tasks: {}
            }
          ]
        },
        expected: {
          slaveComponentStructuredInfo: null
        }
      },
      {
        title: 'structured_out property present',
        data: {
          tasks: [
            {
              Tasks: {
                "structured_out" : {
                  "hosts" : [
                    "host1"
                  ],
                  "host_detail" : {
                    "host1" : [
                      {
                        "service" : "FLUME",
                        "component" : "FLUME_HANDLER"
                      }
                    ]
                  }
                }
              }
            }
          ]
        },
        expected: {
          slaveComponentStructuredInfo: {
            "hosts" : [
              "host1"
            ],
            "host_detail" : {
              "host1" : [
                {
                  "service" : "FLUME",
                  "component" : "FLUME_HANDLER"
                }
              ]
            }
          }
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('slaveComponentStructuredInfo', null);
        controller.getSlaveComponentItemSuccessCallback(test.data);
        expect(controller.get('slaveComponentStructuredInfo')).eql(test.expected.slaveComponentStructuredInfo);
      });
    });
  });

  describe('#getConfigsWarnings', function () {

    var cases = [
      {
        configs: [],
        title: 'no warning'
      },
      {
        configsMergeWarning: {},
        configs: [],
        title: 'empty data'
      },
      {
        configsMergeWarning: {
          UpgradeChecks: {}
        },
        configs: [],
        title: 'incomplete data'
      },
      {
        configsMergeWarning: {
          UpgradeChecks: {
            failed_detail: {}
          }
        },
        configs: [],
        title: 'invalid data'
      },
      {
        configsMergeWarning: {
          UpgradeChecks: {
            failed_detail: []
          }
        },
        configs: [],
        title: 'empty configs array'
      },
      {
        configsMergeWarning: {
          UpgradeChecks: {
            status: 'FAIL',
            failed_detail: [
              {
                type: 't0',
                property: 'p0',
                current: 'c0',
                new_stack_value: 'n0',
                result_value: 'r0'
              },
              {
                type: 't1',
                property: 'p1',
                current: 'c1',
                new_stack_value: 'n1'
              },
              {
                type: 't2',
                property: 'p2',
                current: 'c2',
                result_value: 'r2'
              }
            ]
          }
        },
        configs: [],
        title: 'not a warning'
      },
      {
        configsMergeWarning: {
          UpgradeChecks: {
            status: 'WARNING',
            failed_detail: [
              {
                type: 't0',
                property: 'p0',
                current: 'c0',
                new_stack_value: 'n0',
                result_value: 'r0'
              },
              {
                type: 't1',
                property: 'p1',
                current: 'c1',
                new_stack_value: 'n1'
              },
              {
                type: 't2',
                property: 'p2',
                current: 'c2',
                result_value: 'r2'
              }
            ]
          }
        },
        configs: [
          {
            type: 't0',
            name: 'p0',
            currentValue: 'c0',
            recommendedValue: 'n0',
            isDeprecated: false,
            resultingValue: 'r0',
            wasModified: false,
            willBeRemoved: false
          },
          {
            type: 't1',
            name: 'p1',
            currentValue: 'c1',
            recommendedValue: 'n1',
            isDeprecated: false,
            resultingValue: Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.willBeRemoved'),
            wasModified: false,
            willBeRemoved: true
          },
          {
            type: 't2',
            name: 'p2',
            currentValue: 'c2',
            recommendedValue: Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.deprecated'),
            isDeprecated: true,
            resultingValue: 'r2',
            wasModified: false,
            willBeRemoved: false
          }
        ],
        title: 'normal case'
      },
      {
        configsMergeWarning: {
          UpgradeChecks: {
            status: 'WARNING',
            failed_detail: [
              {
                type: 't0',
                property: 'p0',
                current: 'c0',
                new_stack_value: 'n0',
                result_value: 'r0'
              },
              {
                type: 't1',
                property: 'p1',
                current: 'c1',
                new_stack_value: 'n1'
              },
              {
                type: 't2',
                property: 'p2',
                current: 'c2',
                result_value: 'r2'
              },
              {
                type: 't3',
                property: 'p3',
                current: 'c3',
                new_stack_value: 'c2',
                result_value: 'c3'
              }
            ]
          }
        },
        configs: [
          {
            type: 't0',
            name: 'p0',
            currentValue: 'c0',
            recommendedValue: 'n0',
            isDeprecated: false,
            resultingValue: 'r0',
            wasModified: false,
            willBeRemoved: false
          },
          {
            type: 't1',
            name: 'p1',
            currentValue: 'c1',
            recommendedValue: 'n1',
            isDeprecated: false,
            resultingValue: Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.willBeRemoved'),
            wasModified: false,
            willBeRemoved: true
          },
          {
            type: 't2',
            name: 'p2',
            currentValue: 'c2',
            recommendedValue: Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.deprecated'),
            isDeprecated: true,
            resultingValue: 'r2',
            wasModified: false,
            willBeRemoved: false
          },
          {
            "currentValue": "c3",
            "isDeprecated": false,
            "name": "p3",
            "recommendedValue": "c2",
            "resultingValue": "c3",
            "type": "t3",
            "wasModified": true,
            "willBeRemoved": false
          }
        ],
        title: 'should skip warning when current and result_value are the same'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(controller.getConfigsWarnings(item.configsMergeWarning)).to.eql(item.configs);
      });
    });

  });

  describe('#runPreUpgradeCheckOnly', function () {

    var appGetMock,
      upgradeMethods = controller.get('upgradeMethods'),
      cases = [
      {
        supportsPreUpgradeCheck: false,
        ru: {
          isCheckComplete: true,
          isCheckRequestInProgress: false,
          action: 'a'
        },
        eu: {
          isCheckComplete: true,
          isCheckRequestInProgress: false,
          action: 'a'
        },
        ajaxCallCount: 0,
        runningCheckRequestsLength: 0,
        title: 'pre-upgrade checks not supported'
      },
      {
        supportsPreUpgradeCheck: true,
        ru: {
          isCheckComplete: false,
          isCheckRequestInProgress: true,
          action: ''
        },
        eu: {
          isCheckComplete: true,
          isCheckRequestInProgress: false,
          action: 'a'
        },
        ajaxCallCount: 1,
        type: 'ROLLING',
        runningCheckRequestsLength: 1,
        title: 'rolling upgrade'
      },
      {
        supportsPreUpgradeCheck: true,
        ru: {
          isCheckComplete: true,
          isCheckRequestInProgress: false,
          action: 'a'
        },
        eu: {
          isCheckComplete: false,
          isCheckRequestInProgress: true,
          action: ''
        },
        ajaxCallCount: 1,
        type: 'NON_ROLLING',
        runningCheckRequestsLength: 1,
        title: 'express upgrade'
      }
    ];

    beforeEach(function () {
      appGetMock = sinon.stub(App, 'get');
      controller.get('runningCheckRequests').clear();
      upgradeMethods.forEach(function (method) {
        method.setProperties({
          isCheckComplete: true,
          isCheckRequestInProgress: false,
          action: 'a'
        });
      });
      App.ajax.send.restore();
      sinon.stub(App.ajax, 'send').returns({});
    });

    afterEach(function () {
      appGetMock.restore();
    });

    cases.forEach(function (item) {
      describe(item.title, function () {
        var runningCheckRequests;
        beforeEach(function () {
          runningCheckRequests = controller.get('runningCheckRequests');
          appGetMock.returns(item.supportsPreUpgradeCheck);
          controller.runPreUpgradeCheckOnly({
            type: item.type
          });
          this.ajaxCalls = testHelpers.filterAjaxRequests('name', 'admin.upgrade.pre_upgrade_check');
        });

        it('ROLLING properties', function () {
          expect(upgradeMethods.findProperty('type', 'ROLLING').getProperties('isCheckComplete', 'isCheckRequestInProgress', 'action')).to.eql(item.ru);
        });

        it('NON_ROLLING properties', function () {
          expect(upgradeMethods.findProperty('type', 'NON_ROLLING').getProperties('isCheckComplete', 'isCheckRequestInProgress', 'action')).to.eql(item.eu);
        });

        it(item.ajaxCallCount + ' requests sent', function () {
          expect(this.ajaxCalls.length).to.be.equal(item.ajaxCallCount);
        });

        it('runningCheckRequests length is ' + item.runningCheckRequestsLength, function () {
          expect(runningCheckRequests).to.have.length(item.runningCheckRequestsLength);
        });

        if (item.runningCheckRequestsLength) {
          it('runningCheckRequests.type is ' + item.type, function () {
            expect(runningCheckRequests[0].type).to.equal(item.type);
          });
        }

      });
    });

  });


  describe("#openConfigsInNewWindow()", function () {

    var mock = {
      document: {
        write: function () {}
      },
      focus: function () {}
    };

    beforeEach(function(){
      sinon.stub(window, 'open', function () {
        return mock;
      });
      sinon.spy(mock.document, 'write');
      sinon.spy(mock, 'focus');
      controller.openConfigsInNewWindow({
        context: [
          {
            type: 'type1',
            name: 'name1',
            currentValue: 'currentValue1',
            recommendedValue: 'recommendedValue1',
            resultingValue: 'resultingValue1'
          },
          {
            type: 'type2',
            name: 'name2',
            currentValue: 'currentValue2',
            recommendedValue: 'recommendedValue2',
            resultingValue: 'resultingValue2'
          }
        ]
      });
    });

    afterEach(function(){
      window.open.restore();
      mock.document.write.restore();
      mock.focus.restore();
    });

    it('new window is open', function () {
      expect(window.open.calledOnce).to.be.true;
    });

    it('new window content is valid', function () {
      /*eslint-disable no-useless-concat */
      expect(mock.document.write.calledWith('<table style="text-align: left;"><thead><tr>' +
        '<th>' + Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.configType') + '</th>' +
        '<th>' + Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.propertyName') + '</th>' +
        '<th>' + Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.currentValue') + '</th>' +
        '<th>' + Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.recommendedValue') + '</th>' +
        '<th>' + Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.resultingValue') + '</th>' +
        '</tr></thead><tbody>' +
        '<tr>' +
        '<td>' + 'type1' + '</td>' +
        '<td>' + 'name1' + '</td>' +
        '<td>' + 'currentValue1' + '</td>' +
        '<td>' + 'recommendedValue1' + '</td>' +
        '<td>' + 'resultingValue1' + '</td>' +
        '</tr>' +
        '<tr>' +
        '<td>' + 'type2' + '</td>' +
        '<td>' + 'name2' + '</td>' +
        '<td>' + 'currentValue2' + '</td>' +
        '<td>' + 'recommendedValue2' + '</td>' +
        '<td>' + 'resultingValue2' + '</td>' +
        '</tr></tbody></table>')).to.be.true;
      /*eslint-enable no-useless-concat */
    });

    it('document.focus is called once', function () {
      expect(mock.focus.calledOnce).to.be.true;
    });
  });

  describe("#formatMessages()", function () {

    it("item with malformed text", function() {
      var item = Em.Object.create({
        text: null
      });
      controller.formatMessages(item);
      expect(item.get('messages')).to.be.empty;
      expect(item.get('text')).to.be.null;
    });

    it("item with correct text", function() {
      var item = Em.Object.create({
        text: '[{"message":"msg1"},{"message":"msg2"}]'
      });
      controller.formatMessages(item);
      expect(item.get('messages')).to.be.eql(['msg1', 'msg2']);
      expect(item.get('text')).to.be.equal('msg1 msg2');
    });
  });

  describe("#getUpgradeItemSuccessCallback()", function () {

    beforeEach(function() {
      controller.set('upgradeData', Em.Object.create({
        upgradeGroups: [
          Em.Object.create({
            group_id: 'g1',
            upgradeItems: [Em.Object.create({
              stage_id: 'i1',
              tasks: [],
              isTasksLoaded: false
            })]
          })
        ]
      }));
    });

    it("group has different id", function() {
      var data = {UpgradeItem: {group_id: 'g2'}};
      controller.getUpgradeItemSuccessCallback(data);
      expect(controller.get('upgradeData.upgradeGroups')[0].get('upgradeItems')[0].get('isTasksLoaded')).to.be.false;
    });

    it("item has different id", function() {
      var data = {UpgradeItem: {group_id: 'g1', stage_id: 'i2'}};
      controller.getUpgradeItemSuccessCallback(data);
      expect(controller.get('upgradeData.upgradeGroups')[0].get('upgradeItems')[0].get('isTasksLoaded')).to.be.false;
    });

    it("item has no tasks", function() {
      var data = {
        UpgradeItem: {
          group_id: 'g1',
          stage_id: 'i1'
        },
        tasks: [
          {
            Tasks: {id: 't1'}
          }
        ]
      };
      controller.getUpgradeItemSuccessCallback(data);
      expect(controller.get('upgradeData.upgradeGroups')[0].get('upgradeItems')[0].get('isTasksLoaded')).to.be.true;
      expect(controller.get('upgradeData.upgradeGroups')[0].get('upgradeItems')[0].get('tasks')).to.not.be.empty;
    });

    it("item has tasks", function() {
      controller.get('upgradeData.upgradeGroups')[0].get('upgradeItems')[0].set('tasks', [
        Em.Object.create({
          id: 't1',
          status: 'OLD'
        })
      ]);
      var data = {
        UpgradeItem: {
          group_id: 'g1',
          stage_id: 'i1'
        },
        tasks: [
          {
            Tasks: {
              id: 't1',
              status: 'NEW'
            }
          }
        ]
      };
      controller.getUpgradeItemSuccessCallback(data);
      expect(controller.get('upgradeData.upgradeGroups')[0].get('upgradeItems')[0].get('isTasksLoaded')).to.be.true;
      expect(controller.get('upgradeData.upgradeGroups')[0].get('upgradeItems')[0].get('tasks')[0].get('status')).to.be.equal('NEW');
    });
  });

  describe("#abortUpgrade()", function () {

    it("isDowngrade is true", function() {
      controller.set('isDowngrade', true);
      controller.set('upgradeId', 1);
      controller.abortUpgrade();
      var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.abort');
      expect(args[0]).to.be.eql({
        name: 'admin.upgrade.abort',
        sender: controller,
        data: {
          upgradeId: 1,
          isDowngrade: true
        },
        error: 'abortDowngradeErrorCallback'
      });
    });

    it("isDowngrade is false", function() {
      controller.set('isDowngrade', false);
      controller.set('upgradeId', 1);
      controller.abortUpgrade();
      var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.abort');
      expect(args[0]).to.be.eql({
        name: 'admin.upgrade.abort',
        sender: controller,
        data: {
          upgradeId: 1,
          isDowngrade: false
        },
        error: 'abortUpgradeErrorCallback'
      });
    });
  });

  describe("#abortUpgradeWithSuspend()", function () {

    it("isDowngrade is true", function() {
      controller.set('isDowngrade', true);
      controller.set('upgradeId', 1);
      controller.abortUpgradeWithSuspend();
      var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.suspend');
      expect(args[0]).to.be.eql({
        name: 'admin.upgrade.suspend',
        sender: controller,
        data: {
          upgradeId: 1,
          isDowngrade: true
        },
        error: 'abortDowngradeErrorCallback'
      });
    });

    it("isDowngrade is false", function() {
      controller.set('isDowngrade', false);
      controller.set('upgradeId', 1);
      controller.abortUpgradeWithSuspend();
      var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.suspend');
      expect(args[0]).to.be.eql({
        name: 'admin.upgrade.suspend',
        sender: controller,
        data: {
          upgradeId: 1,
          isDowngrade: false
        },
        error: 'abortUpgradeErrorCallback'
      });
    });
  });

  describe("#abortUpgradeErrorCallback()", function () {
    var header = Em.I18n.t('admin.stackUpgrade.state.paused.fail.header');
    var body = Em.I18n.t('admin.stackUpgrade.state.paused.fail.body');

    beforeEach(function() {
      sinon.stub(App, 'showAlertPopup');
    });

    afterEach(function() {
      App.showAlertPopup.restore();
    });

    it("data is null", function() {
      controller.abortUpgradeErrorCallback(null);
      expect(App.showAlertPopup.calledWith(header, body)).to.be.true;
    });

    it("data.responseText is null", function() {
      controller.abortUpgradeErrorCallback({responseText: null});
      expect(App.showAlertPopup.calledWith(header, body)).to.be.true;
    });

    it("data.responseText is incorrect", function() {
      controller.abortUpgradeErrorCallback({responseText: "//"});
      expect(App.showAlertPopup.calledWith(header, body)).to.be.true;
    });

    it("data.responseText is correct", function() {
      controller.abortUpgradeErrorCallback({responseText: '{"message": "msg"}'});
      expect(App.showAlertPopup.calledWith(header, body + ' msg')).to.be.true;
    });
  });

  describe("#abortDowngradeErrorCallback()", function () {
    var header = Em.I18n.t('admin.stackDowngrade.state.paused.fail.header');
    var body = Em.I18n.t('admin.stackDowngrade.state.paused.fail.body');

    beforeEach(function() {
      sinon.stub(App, 'showAlertPopup');
    });

    afterEach(function() {
      App.showAlertPopup.restore();
    });

    it("data is null", function() {
      controller.abortDowngradeErrorCallback(null);
      expect(App.showAlertPopup.calledWith(header, body)).to.be.true;
    });

    it("data.responseText is null", function() {
      controller.abortDowngradeErrorCallback({responseText: null});
      expect(App.showAlertPopup.calledWith(header, body)).to.be.true;
    });

    it("data.responseText is incorrect", function() {
      controller.abortDowngradeErrorCallback({responseText: "//"});
      expect(App.showAlertPopup.calledWith(header, body)).to.be.true;
    });

    it("data.responseText is correct", function() {
      controller.abortDowngradeErrorCallback({responseText: '{"message": "msg"}'});
      expect(App.showAlertPopup.calledWith(header, body + ' msg')).to.be.true;
    });
  });

  describe("#retryUpgrade()", function () {

    it("requestInProgress should be true", function() {
      controller.retryUpgrade();
      expect(controller.get('requestInProgress')).to.be.true;
    });

    it("isRetryPending should be true", function() {
      controller.retryUpgrade();
      expect(controller.get('isRetryPending')).to.be.true;
    });

    it("App.ajax.send should be called", function() {
      controller.set('upgradeId', 1);
      controller.retryUpgrade();
      var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.retry');
      expect(args[0]).to.be.eql({
        name: 'admin.upgrade.retry',
        sender: controller,
        data: {
          upgradeId: 1
        }
      });
    });
  });

  describe("#upgradeErrorCallback()", function () {
    var header = Em.I18n.t('admin.stackVersions.upgrade.start.fail.title');
    var body = "";

    beforeEach(function() {
      sinon.stub(App, 'showAlertPopup');
    });

    afterEach(function() {
      App.showAlertPopup.restore();
    });

    it("data is null", function() {
      controller.upgradeErrorCallback(null);
      expect(App.showAlertPopup.calledWith(header, body)).to.be.true;
    });

    it("data.responseText is null", function() {
      controller.upgradeErrorCallback({responseText: null});
      expect(App.showAlertPopup.calledWith(header, body)).to.be.true;
    });

    it("data.responseText is incorrect", function() {
      controller.upgradeErrorCallback({responseText: "//"});
      expect(App.showAlertPopup.calledWith(header, body)).to.be.true;
    });

    it("data.responseText is correct", function() {
      controller.upgradeErrorCallback({responseText: '{"message": "msg"}'});
      expect(App.showAlertPopup.calledWith(header, 'msg')).to.be.true;
    });
  });

  describe("#updateOptionsSuccessCallback()", function () {

    it("skipComponentFailures: true, skipSCFailures: true", function() {
      var params = {
        skipComponentFailures: 'true',
        skipSCFailures: 'true'
      };
      controller.updateOptionsSuccessCallback({}, {}, params);
      expect(controller.get('failuresTolerance')).to.be.eql(Em.Object.create({
        skipComponentFailures: true,
        skipSCFailures: true
      }));
    });

    it("skipComponentFailures: false, skipSCFailures: false", function() {
      var params = {
        skipComponentFailures: 'false',
        skipSCFailures: 'false'
      };
      controller.updateOptionsSuccessCallback({}, {}, params);
      expect(controller.get('failuresTolerance')).to.be.eql(Em.Object.create({
        skipComponentFailures: false,
        skipSCFailures: false
      }));
    });
  });

  describe("#openUpgradeOptions()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'upgradeOptions');
    });

    afterEach(function() {
      controller.upgradeOptions.restore();
    });

    it("upgradeOptions should not be called", function() {
      controller.set('isDowngrade', true);
      controller.openUpgradeOptions();
      expect(controller.upgradeOptions.called).to.be.false;
    });

    it("upgradeOptions should be called", function() {
      controller.set('isDowngrade', false);
      controller.openUpgradeOptions();
      expect(controller.upgradeOptions.calledWith(true, null)).to.be.true;
    });
  });

  describe("#getSupportedUpgradeTypes()", function () {

    it("App.ajax.send should be called", function() {
      controller.getSupportedUpgradeTypes({});
      var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.get_supported_upgradeTypes');
      expect(args[0]).to.be.eql({
        name: "admin.upgrade.get_supported_upgradeTypes",
        sender: controller,
        data: {},
        success: "getSupportedUpgradeTypesSuccess"
      });
    });
  });

  describe("#getSupportedUpgradeTypesSuccess()", function () {
    var testCases = [
      {
        data: {
          items: []
        },
        expected: false
      },
      {
        data: {
          items: [{
            CompatibleRepositoryVersions: {}
          }]
        },
        expected: false
      },
      {
        data: {
          items: [{
            CompatibleRepositoryVersions: {
              upgrade_types: []
            }
          }]
        },
        expected: false
      },
      {
        data: {
          items: [{
            CompatibleRepositoryVersions: {
              upgrade_types: ['t1']
            }
          }]
        },
        expected: true
      }
    ];

    testCases.forEach(function(test) {
      it("data: " + JSON.stringify(test.data), function() {
        controller.set('upgradeMethods', [Em.Object.create({
          type: 't1',
          allowed: true
        })]);
        controller.getSupportedUpgradeTypesSuccess(test.data);
        expect(controller.get('upgradeMethods')[0].get('allowed')).to.be.equal(test.expected);
      });
    });
  });

  describe("#runPreUpgradeCheckOnlySuccess()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'formatPreCheckMessage').returns({precheckResultsMessage: 'formatted'});
      sinon.stub(controller, 'updateSelectedMethod');
      sinon.stub(controller, 'addPrecheckMessageTooltip');
      controller.set('upgradeMethods', [Em.Object.create({
        type: 'ROLLING'
      })]);
    });

    afterEach(function() {
      controller.formatPreCheckMessage.restore();
      controller.updateSelectedMethod.restore();
      controller.addPrecheckMessageTooltip.restore();
    });

    it("failed check", function() {
      var data = {
        items: [
          {
            UpgradeChecks: {
              status: 'FAIL'
            }
          }
        ]
      };
      var properties = {
        precheckResultsTitle: Em.I18n.t('admin.stackVersions.version.upgrade.upgradeOptions.preCheck.msg.title'),
        precheckResultsData: data,
        isCheckComplete: true,
        action: 'openMessage',
        precheckResultsMessage: '',
        recheckResultsMessageClass: 'GREEN',
        isPrecheckFailed: false,
        precheckResultsMessageIconClass: 'icon-ok',
        bypassedFailures: false
      };
      controller.runPreUpgradeCheckOnlySuccess(data, {}, {type: 'ROLLING'});
      expect(controller.formatPreCheckMessage.calledWith('FAIL', data, properties)).to.be.true;
      var msg = controller.get('upgradeMethods').findProperty('type', 'ROLLING').get('precheckResultsMessage');
      expect(msg).to.be.equal('formatted');
    });

    it("success check", function() {
      var data = {
        items: []
      };
      controller.runPreUpgradeCheckOnlySuccess(data, {}, {type: 'ROLLING'});
      var msg = controller.get('upgradeMethods').findProperty('type', 'ROLLING').get('precheckResultsMessage');
      expect(msg).to.be.equal(Em.I18n.t('admin.stackVersions.version.upgrade.upgradeOptions.preCheck.allPassed'));
    });

    it("updateSelectedMethod should be called", function() {
      var data = {
        items: []
      };
      controller.runPreUpgradeCheckOnlySuccess(data, {}, {type: 'ROLLING'});
      expect(controller.updateSelectedMethod.calledWith(false)).to.be.true;
    });

    it("addPrecheckMessageTooltip should be called", function() {
      var data = {
        items: []
      };
      controller.runPreUpgradeCheckOnlySuccess(data, {}, {type: 'ROLLING'});
      expect(controller.addPrecheckMessageTooltip.calledOnce).to.be.true;
    });
  });

  describe("#formatPreCheckMessage()", function () {

    it("should return formatted message", function() {
      var data = {
        items: [{
          UpgradeChecks: {
            status: 'FAIL'
          }
        }]
      };
      expect(controller.formatPreCheckMessage('FAIL', data, {precheckResultsMessage: 'pre'})).to.be.eql({
        "precheckResultsMessage": "1 Required pre",
        "precheckResultsMessageClass": "RED",
        "isPrecheckFailed": true,
        "precheckResultsMessageIconClass": "icon-remove"
      });
    });
  });

  describe("#addPrecheckMessageTooltip()", function () {

    beforeEach(function() {
      sinon.stub(Em.run, 'later', function(ctx, callback) {
        callback();
      });
      sinon.stub(App, 'tooltip');
    });

    afterEach(function() {
      Em.run.later.restore();
      App.tooltip.restore();
    });

    it("App.tooltip should be called", function() {
      controller.addPrecheckMessageTooltip();
      expect(App.tooltip.calledOnce).to.be.true;
    });
  });

  describe("#runPreUpgradeCheckOnlyError()", function () {

    it("upgradeMethod should be updated", function() {
      controller.set('upgradeMethods', [Em.Object.create({
        type: 'ROLLING'
      })]);
      controller.runPreUpgradeCheckOnlyError({}, {}, '', {}, {type: 'ROLLING'});
      expect(JSON.stringify(controller.get('upgradeMethods').findProperty('type', 'ROLLING'))).to.be.equal(JSON.stringify({
        "type": "ROLLING",
        "precheckResultsMessage": Em.I18n.t('admin.stackVersions.version.upgrade.upgradeOptions.preCheck.msg.failed.link'),
        "precheckResultsTitle": Em.I18n.t('admin.stackVersions.version.upgrade.upgradeOptions.preCheck.msg.failed.title'),
        "precheckResultsMessageClass": "RED",
        "isPrecheckFailed": true,
        "precheckResultsMessageIconClass": "icon-warning-sign",
        "action": "rerunCheck"
      }));
    });
  });

  describe("#updateSelectedMethod()", function () {

    beforeEach(function() {
      controller.set('upgradeMethods', [
        Em.Object.create({
          type: 'ROLLING',
          isPrecheckFailed: false,
          selected: true
        }),
        Em.Object.create({
          type: 'NON_ROLLING',
          isPrecheckFailed: false,
          selected: true
        })
      ]);
    });

    it("should select upgrade method", function() {
      controller.set('upgradeType', 'ROLLING');
      controller.updateSelectedMethod(true);
      expect(controller.get('upgradeMethods').findProperty('type', 'ROLLING').get('selected')).to.be.true;
    });

    it("isPrecheckFailed true for ROLLING and NON_ROLLING", function() {
      controller.updateSelectedMethod(false);
      expect(controller.get('upgradeMethods').findProperty('type', 'ROLLING').get('selected')).to.be.true;
      expect(controller.get('upgradeMethods').findProperty('type', 'NON_ROLLING').get('selected')).to.be.true;
    });

    it("isPrecheckFailed false for ROLLING and NON_ROLLING", function() {
      controller.get('upgradeMethods').setEach('isPrecheckFailed', true);
      controller.updateSelectedMethod(false);
      expect(controller.get('upgradeMethods').findProperty('type', 'ROLLING').get('selected')).to.be.false;
      expect(controller.get('upgradeMethods').findProperty('type', 'NON_ROLLING').get('selected')).to.be.false;
    });
  });

  describe("#runPreUpgradeCheckError()", function () {

    it("requestInProgress should be false", function() {
      controller.runPreUpgradeCheckError();
      expect(controller.get('requestInProgress')).to.be.false;
    });
  });

  describe("#confirmRetryUpgrade()", function () {

    beforeEach(function() {
      sinon.spy(App, 'showConfirmationPopup');
      sinon.stub(controller, 'retryUpgrade');
    });

    afterEach(function() {
      App.showConfirmationPopup.restore();
      controller.retryUpgrade.restore();
    });

    it("App.showConfirmationPopup should be called", function() {
      var popup = controller.confirmRetryUpgrade(Em.Object.create());
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.retryUpgrade.calledOnce).to.be.true;
    });
  });

  describe("#confirmRetryDowngrade()", function () {

    beforeEach(function() {
      sinon.spy(App, 'showConfirmationPopup');
      sinon.stub(controller, 'retryUpgrade');
    });

    afterEach(function() {
      App.showConfirmationPopup.restore();
      controller.retryUpgrade.restore();
    });

    it("App.showConfirmationPopup should be called", function() {
      var popup = controller.confirmRetryDowngrade(Em.Object.create());
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.retryUpgrade.calledOnce).to.be.true;
    });
  });

  describe("#installRepoVersionError()", function () {
    var header = Em.I18n.t('admin.stackVersions.upgrade.installPackage.fail.title');

    beforeEach(function() {
      sinon.stub(App, 'showAlertPopup');
    });

    afterEach(function() {
      App.showAlertPopup.restore();
    });

    it("responseText is incorrect", function() {
      var data = {
        responseText: null
      };
      controller.installRepoVersionError(data);
      expect(App.showAlertPopup.calledWith(header, "")).to.be.true;
    });

    it("statusText is timeout", function() {
      var data = {
        responseText: '',
        statusText: 'timeout'
      };
      controller.installRepoVersionError(data);
      expect(App.showAlertPopup.calledWith(header, Em.I18n.t('admin.stackVersions.upgrade.installPackage.fail.timeout'))).to.be.true;
    });

    it("responseText is correct", function() {
      var data = {
        responseText: '{"message":"msg"}'
      };
      controller.installRepoVersionError(data);
      expect(App.showAlertPopup.calledWith(header, 'msg')).to.be.true;
    });
  });

  describe("#showProgressPopup()", function () {
    var mock = {
      initPopup: Em.K
    };

    beforeEach(function() {
      sinon.stub(App.router, 'get').withArgs('highAvailabilityProgressPopupController').returns(mock);
      sinon.stub(mock, 'initPopup');
      sinon.stub(App.db, 'get').returns([1]);
    });

    afterEach(function() {
      App.router.get.restore();
      mock.initPopup.restore();
      App.db.get.restore();
    });

    it("initPopup should be called", function() {
      controller.showProgressPopup(Em.Object.create({displayName: 'v1'}));
      expect(mock.initPopup.calledWith(
        Em.I18n.t('admin.stackVersions.details.install.hosts.popup.title').format('v1'),
        [1],
        controller
      )).to.be.true;
    });
  });

  describe("#finish()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'setDBProperties', Em.K);
      sinon.stub(App.clusterStatus, 'setClusterStatus');
      App.set('upgradeState', 'COMPLETED');
      controller.set('upgradeVersion', '');
    });

    afterEach(function() {
      controller.setDBProperties.restore();
      App.clusterStatus.setClusterStatus.restore();
    });

    it("setDBProperties should be called", function() {
      controller.finish();
      expect(controller.setDBProperties.calledWith({
        upgradeId: undefined,
        upgradeState: 'INIT',
        upgradeVersion: undefined,
        currentVersion: undefined,
        upgradeTypeDisplayName: undefined,
        upgradeType: undefined,
        isWizardRestricted: false,
        failuresTolerance: undefined,
        isDowngrade: undefined,
        downgradeAllowed: undefined
      })).to.be.true;
    });

    it("App.clusterStatus.setClusterStatus should be called", function() {
      controller.finish();
      expect(App.clusterStatus.setClusterStatus.calledOnce).to.be.true;
    });

    it("upgradeState should be INIT", function() {
      controller.finish();
      expect(App.get('upgradeState')).to.be.equal('INIT');
    });

    it("currentStackVersion should be set", function() {
      controller.set('upgradeVersion', 'HDP-2.2');
      controller.finish();
      expect(controller.get('upgradeVersion')).to.be.equal('HDP-2.2');
    });
  });

  describe("#loadRepositories()", function () {

    beforeEach(function() {
      sinon.stub(App.router, 'get').withArgs('clusterController.isLoaded').returns(true);
    });

    afterEach(function() {
      App.router.get.restore();
    });

    it("App.ajax.send should be called", function() {
      App.set('currentStackVersion', 'HDP-2.2');
      controller.loadRepositories();
      var args = testHelpers.findAjaxRequest('name', 'cluster.load_repositories');
      expect(args[0]).to.be.eql({
        name: 'cluster.load_repositories',
        sender: controller,
        data: {
          stackName: 'HDP',
          stackVersion: '2.2'
        },
        success: 'loadRepositoriesSuccessCallback',
        error: 'loadRepositoriesErrorCallback'
      });
    });
  });

  describe("#loadRepositoriesSuccessCallback()", function () {

    it("allRepos should be set", function() {
      var data = {
        items: [
          {
            repositories: [
              {
                Repositories: {
                  os_type: 'redhat',
                  base_url: 'base_url',
                  repo_id: 'repo_id',
                  repo_name: 'repo_name',
                  stack_name: 'stack_name',
                  stack_version: 'stack_version'
                }
              }
            ]
          }
        ]
      };
      controller.loadRepositoriesSuccessCallback(data);
      expect(controller.get('allRepos')[0].name).to.be.equal('redhat');
      expect(JSON.stringify(controller.get('allRepos')[0].repositories[0])).to.be.equal(JSON.stringify({
        "baseUrl": "base_url",
        "osType": "redhat",
        "repoId": "repo_id",
        "repoName": "repo_name",
        "stackName": "stack_name",
        "stackVersion": "stack_version",
        "isFirst": true
      }));
    });
  });

  describe("#loadServiceVersionFromVersionDefinitions()", function () {

    it("App.ajax.send should be called", function() {
      App.set('clusterName', 'c1');
      controller.loadServiceVersionFromVersionDefinitions();
      var args = testHelpers.findAjaxRequest('name', 'cluster.load_current_repo_stack_services');
      expect(args[0]).to.be.eql({
        name: 'cluster.load_current_repo_stack_services',
        sender: controller,
        data: {
          clusterName: App.get('clusterName')
        },
        success: 'loadServiceVersionFromVersionDefinitionsSuccessCallback',
        error: 'loadServiceVersionFromVersionDefinitionsErrorCallback'
      });
    });
  });

  describe("#loadServiceVersionFromVersionDefinitionsSuccessCallback()", function () {
    var cases;
    beforeEach(function() {
      this.appGetStub = sinon.stub(App, 'get');
    });

    afterEach(function() {
      App.get.restore();
      controller.set('serviceVersionsMap', {});
    });
    cases = [
      {
        jsonData: {
          items: [
            {
              ClusterStackVersions: {
                version: '2.3',
                stack: 'HDP',
                state: 'INIT'
              },
              repository_versions: [
                {
                  RepositoryVersions: {
                    stack_services: [
                      { name: 'S3', versions: ['v3']}
                    ]
                  }
                }
              ]
            },
            {
              ClusterStackVersions: {
                version: '2.2',
                stack: 'HDP',
                state: 'INIT'
              },
              repository_versions: [
                {
                  RepositoryVersions: {
                    stack_services: [
                      { name: 'S2', versions: ['v2']}
                    ]
                  }
                }
              ]
            }
          ]
        },
        currentStackData: {
          currentStackVersionNumber: '2.2',
          currentStackName: 'HDP'
        },
        m: 'should add stack services from stack version by current stack name and version number',
        e: { "S2": "v2"}
      }
    ];

    cases.forEach(function(test) {
      it(test.m, function() {
        this.appGetStub.withArgs('currentStackName').returns(test.currentStackData.currentStackName)
          .withArgs('currentStackVersionNumber').returns(test.currentStackData.currentStackVersionNumber);
        controller.loadServiceVersionFromVersionDefinitionsSuccessCallback(test.jsonData);
        expect(controller.get('serviceVersionsMap')).to.be.eql(test.e);
      })
    });
  });

  describe("#loadCompatibleVersions()", function () {

    beforeEach(function() {
      sinon.stub(App, 'get').returns('stack');
    });

    afterEach(function() {
      App.get.restore();
    });

    it("App.ajax.send should be called", function() {
      controller.loadCompatibleVersions();
      var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.get_compatible_versions');
      expect(args[0]).to.be.eql({
        name: 'admin.upgrade.get_compatible_versions',
        sender: controller,
        data: {
          stackName: 'stack',
          stackVersion: 'stack'
        },
        success: 'loadCompatibleVersionsSuccessCallback'
      });
    });
  });

  describe("#loadCompatibleVersionsSuccessCallback()", function () {
    var mock = [
      Em.Object.create({
        repositoryVersion: 'HDP-1',
        isCompatible: false
      }),
      Em.Object.create({
        repositoryVersion: 'HDP-2',
        isCompatible: false
      })
    ];

    beforeEach(function() {
      sinon.stub(App.RepositoryVersion, 'find').returns(mock);
    });

    afterEach(function() {
      App.RepositoryVersion.find.restore();
    });

    it("should set isCompatible property", function() {
      var data = {
        items: [
          {
            CompatibleRepositoryVersions: {
              repository_version: 'HDP-2'
            }
          }
        ]
      };
      controller.loadCompatibleVersionsSuccessCallback(data);
      expect(mock.mapProperty('isCompatible')).to.be.eql([false, true])
    });
  });

});

});

require.register("test/controllers/main/admin/stack_upgrade_history_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/stack_upgrade_history_controller');
require('utils/string_utils');
var testHelpers = require('test/helpers');
describe('App.MainAdminStackUpgradeHistoryController', function() {

  var controller = App.MainAdminStackUpgradeHistoryController.create({

  });

  describe("#upgradeHistoryUrl", function() {
    before(function () {
      this.mock = sinon.stub(App, 'get');
      this.mock.withArgs('apiPrefix').returns('apiPrefix')
        .withArgs('clusterName').returns('clusterName');
    });
    after(function () {
      this.mock.restore();
    });
    it("should be valid", function() {
      controller.propertyDidChange('upgradeHistoryUrl');
      expect(controller.get('upgradeHistoryUrl')).to.equal('apiPrefix/clusters/clusterName/upgrades?fields=Upgrade');
    });
  });

  describe("#requestStatus", function() {
    beforeEach(function() {
      this.mock = sinon.stub(App, 'get');
    });
    afterEach(function() {
      this.mock.restore();
    });
    it("state should be what the record states", function() {
      this.mock.returns(false);
      controller.set('upgradeData', { Upgrade: {request_status: 'COMPLETED'}});
      controller.propertyDidChange('requestStatus');
      expect(controller.get('requestStatus')).to.equal('COMPLETED');
    });

    it("upgradeData is null", function() {
      this.mock.returns(false);
      controller.set('upgradeData', null);
      controller.propertyDidChange('requestStatus');
      expect(controller.get('requestStatus')).to.be.empty;
    });
  });

  describe("#loadStackUpgradeRecord()", function() {
    it("get upgrade record data", function() {
      controller.set('currentUpgradeRecord', Em.Object.create({'requestId':1, 'direction':'DOWNGRADE'}));
      controller.loadStackUpgradeRecord();
      var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.data');
      expect(args[0]).to.exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        id: 1
      });
    });
  });

  describe("#loadUpgradeRecordSuccessCallback()", function() {
    it("correct data", function() {
      var data = {
        "Upgrade": {
          "request_status": "COMPLETED"
        },
        "upgrade_groups": [
          {
            "UpgradeGroup": {
              "id": 1
            },
            "upgrade_items": []
          }
        ]};
      controller.loadUpgradeRecordSuccessCallback(data);
      expect(controller.get('upgradeData') == null).to.be.false;
    });

    it("data is null", function() {
      var data = null;
      controller.set('upgradeData', null)
      controller.loadUpgradeRecordSuccessCallback(data);
      expect(controller.get('upgradeData') == null).to.be.true;
    });
  });

  describe("#getUpgradeItem()", function() {
    it("default callback", function() {
      var item = Em.Object.create({
        request_id: 1,
        group_id: 2,
        stage_id: 3
      });
      controller.getUpgradeItem(item);
      var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.upgrade_item');
      expect(args[0]).to.exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].success).to.be.equal('getUpgradeItemSuccessCallback');
      expect(args[0].data).to.be.eql({
        upgradeId: 1,
        groupId: 2,
        stageId: 3
      });
    });
  });
});

});

require.register("test/controllers/main/admin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('models/service');
require('models/host_component');
require('controllers/main/admin');

describe('MainAdminController', function () {

  var controller = App.MainAdminController.create();

  describe('#isAccessAvailable()', function () {

    beforeEach(function () {
      Em.propertyDidChange(controller, 'isAccessAvailable');
    });

    it('Services do not match dependencies', function () {
      App.Service.find().clear();
      App.store.safeLoad(App.Service, {
        id: 'HDFS',
        service_name: 'HDFS'
      });
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('APP_TIMELINE_SERVER is absent', function () {
      App.Service.find().clear();
      App.HostComponent.find().clear();
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('Only one YARN service installed', function () {
      App.store.safeLoad(App.Service, {
        id: 'YARN',
        service_name: 'YARN'
      });
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('TEZ and YARN services installed', function () {
      App.store.safeLoad(App.Service, {
        id: 'TEZ',
        service_name: 'TEZ'
      });
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('TEZ and YARN services, APP_TIMELINE_SERVER component installed', function () {
      App.store.safeLoad(App.HostComponent, {
        id: 'APP_TIMELINE_SERVER_host1',
        component_name: 'APP_TIMELINE_SERVER'
      });
      expect(controller.get("isAccessAvailable")).to.be.true;
    });
  });
});

});

require.register("test/controllers/main/alert_definitions_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('controllers/main/alert_definitions_controller');
require('models/alerts/alert_definition');
var testHelpers = require('test/helpers');

var controller;
describe('App.MainAlertDefinitionsController', function() {

  beforeEach(function() {

    controller = App.MainAlertDefinitionsController.create();

  });

  describe('#toggleDefinitionState', function() {

    beforeEach(function() {
      controller.reopen({
        content: [
          App.AlertDefinition.createRecord({id: 1, enabled: true})
        ]
      });
    });

    it('should do ajax-request', function() {
      var alertDefinition = controller.get('content')[0];
      controller.toggleDefinitionState(alertDefinition);
      var args = testHelpers.findAjaxRequest('name', 'alerts.update_alert_definition');
      expect(args).to.exists;
    });

  });

  describe('#isCriticalAlerts', function () {

    beforeEach(function () {
      controller.set('content', Em.A([
        Em.Object.create({summary: {CRITICAL: {count: 0}}}),
        Em.Object.create({summary: {CRITICAL: {}}})
      ]));
    });

    it('if summary is undefined, 0 should be used', function () {
      expect(controller.get('isCriticalAlerts')).to.be.false;
    });

    it('should be true, if some CRITICAL count is greater than 0', function () {
      controller.get('content').pushObject(Em.Object.create({summary: {CRITICAL: {count: 1}}}));
      expect(controller.get('isCriticalAlerts')).to.be.true;
    });

  });

  describe("#toggleState()", function() {

    beforeEach(function() {
      sinon.stub(App, 'showConfirmationFeedBackPopup', Em.clb);
      sinon.stub(controller, 'toggleDefinitionState');
    });
    afterEach(function() {
      App.showConfirmationFeedBackPopup.restore();
      controller.toggleDefinitionState.restore();
    });

    it("toggleDefinitionState should be called", function() {
      var def = Em.Object.create();
      controller.toggleState({context: def});
      expect(App.showConfirmationFeedBackPopup.calledOnce).to.be.true;
      expect(controller.toggleDefinitionState.calledWith(def)).to.be.true;
    });
  });

});

});

require.register("test/controllers/main/alerts/add_alert_definition/add_alert_definition_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/alerts/add_alert_definition/add_alert_definition_controller');
var testHelpers = require('test/helpers');
var controller;

describe('App.AddAlertDefinitionController', function () {

  beforeEach(function () {
    controller = App.AddAlertDefinitionController.create();
  });

  describe("#createNewAlertDefinition()", function () {
    it("valid request is sent", function () {
      controller.createNewAlertDefinition('data');
      var args = testHelpers.findAjaxRequest('name', 'alerts.create_alert_definition');
      expect(args[0]).to.exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({data: 'data'});
    });
  });

  describe("#finish()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'clear', Em.K);
    });
    afterEach(function () {
      controller.clear.restore();
    });

    it("clear is called", function () {
      controller.finish();
      expect(controller.clear.calledOnce).to.be.true;
    });
  });
});
});

require.register("test/controllers/main/alerts/add_alert_definition/step1_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/alerts/add_alert_definition/step1_controller');

var controller;

describe('App.AddAlertDefinitionStep1Controller', function () {

  beforeEach(function () {
    controller = App.AddAlertDefinitionStep1Controller.create({content: {}});
  });

  describe('#selectType', function() {

    beforeEach(function () {
      controller.get('alertDefinitionsTypes').setEach('isActive', false);
    });

    it('should set isActive for selected type', function () {
      var e = {context: {value: 'PORT'}};
      controller.selectType(e);
      expect(controller.get('alertDefinitionsTypes').findProperty('value', 'PORT').get('isActive')).to.be.true;
    });

  });

  describe('#loadStep', function () {

    beforeEach(function () {
      controller.set('content.selectedType', 'PORT');

    });

    it('should set predefined type', function () {
      controller.loadStep();
      expect(controller.get('alertDefinitionsTypes').findProperty('value', 'PORT').get('isActive')).to.be.true;
    });

  });

  describe('#isSubmitDisabled', function () {

    beforeEach(function () {
      controller.get('alertDefinitionsTypes').setEach('isActive', false);
    });

    it('should be based on isActive', function () {

      expect(controller.get('isSubmitDisabled')).to.be.true;
      controller.get('alertDefinitionsTypes').objectAt(0).set('isActive', true);
      expect(controller.get('isSubmitDisabled')).to.be.false;

    });

  });

});
});

require.register("test/controllers/main/alerts/alert_definitions_actions_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var controller;

describe('App.MainAlertDefinitionActionsController', function () {

  beforeEach(function () {
    controller = App.MainAlertDefinitionActionsController.create({});
  });

  describe('#actionHandler', function () {

    beforeEach(function () {
      sinon.stub(controller, 'createNewAlertDefinition', Em.K);
      sinon.stub(controller, 'manageAlertGroups', Em.K);
      sinon.stub(controller, 'manageNotifications', Em.K);
    });

    afterEach(function () {
      controller.createNewAlertDefinition.restore();
      controller.manageAlertGroups.restore();
      controller.manageNotifications.restore();
    });

    it('should call proper methods', function () {

      controller.actionHandler({context: {action: 'createNewAlertDefinition'}});
      controller.actionHandler({context: {action: 'manageAlertGroups'}});
      controller.actionHandler({context: {action: 'manageNotifications'}});
      expect(controller.createNewAlertDefinition.calledOnce).to.be.ok;
      expect(controller.manageAlertGroups.calledOnce).to.be.ok;
      expect(controller.manageNotifications.calledOnce).to.be.ok;

    });

  });

  describe('#manageAlertGroups', function () {

    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show', Em.K);
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('should show modal popup', function () {
      controller.manageAlertGroups();
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });

  });

  describe('#createNewAlertDefinition', function () {

    beforeEach(function () {
      sinon.stub(App.router, 'transitionTo', Em.K);
    });

    afterEach(function () {
      App.router.transitionTo.restore();
    });

    it('should navigate to wizard', function () {

      controller.createNewAlertDefinition();
      expect(App.router.transitionTo.calledWith('alertAdd')).to.be.true;

    });

  });

});
});

require.register("test/controllers/main/alerts/alert_instances_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');

var controller;

describe('App.MainAlertInstancesController', function () {

  beforeEach(function () {
    controller = App.MainAlertInstancesController.create({});
  });

  afterEach(function () {
    clearTimeout(controller.get('updateTimer'));
  });

  describe('#fetchAlertInstances', function () {

    describe('loading instances from correct endpoint', function () {

      it('should load by Host name', function () {

        controller.loadAlertInstancesByHost('host');
        var callArgs = testHelpers.findAjaxRequest('name', 'alerts.instances.by_host')[0];
        expect(callArgs.name).to.equal('alerts.instances.by_host');
        expect(callArgs.data.hostName).to.equal('host');

      });

      it('should load by AlertDefinition id', function () {

        controller.loadAlertInstancesByAlertDefinition('1');
        var callArgs = testHelpers.findAjaxRequest('name', 'alerts.instances.by_definition')[0];
        expect(callArgs.name).to.equal('alerts.instances.by_definition');
        expect(callArgs.data.definitionId).to.equal('1');

      });

      it('should load all', function () {
        controller.loadAlertInstances();
        var callArgs = testHelpers.findAjaxRequest('name', 'alerts.instances')[0];
        expect(callArgs).to.exists;

      });

    });

  });


  describe('#showPopup', function () {

    describe('#bodyClass', function () {

      var bodyView;

      beforeEach(function () {
        controller.reopen({unhealthyAlertInstances: [
          App.AlertInstance.createRecord({state: 'CRITICAL'}),
          App.AlertInstance.createRecord({state: 'WARNING'}),
          App.AlertInstance.createRecord({state: 'WARNING'}),
          App.AlertInstance.createRecord({state: 'CRITICAL'})
        ]});
        bodyView = controller.showPopup().get('bodyClass').create();
      });

      it('#content', function () {
        expect(bodyView.get('content.length')).to.equal(4);
      });

      it('#isLoaded', function () {
        expect(bodyView.get('isLoaded')).to.be.true;
      });

      it('#isAlertEmptyList', function () {
        expect(bodyView.get('isAlertEmptyList')).to.be.false;
      });

    });

  });

});
});

require.register("test/controllers/main/alerts/definitions_configs_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');
var controller;

function getController() {
  return App.MainAlertDefinitionConfigsController.create({
    allServices: ['service1', 'service2', 'service3'],
    allComponents: ['component1', 'component2', 'component3'],
    aggregateAlertNames: ['alertDefinitionName', 'alertDefinitionName2', 'alertDefinitionName3']
  });
}

function getEmptyArray() {
  return [];
}

describe('App.MainAlertDefinitionConfigsController', function () {

  beforeEach(function () {
    controller = getController();
  });

  App.TestAliases.testAsComputedOr(getController(), 'hasErrors', ['someConfigIsInvalid', 'hasThresholdsError']);

  describe('#renderConfigs()', function () {

    beforeEach(function () {
      controller.set('content', Em.Object.create({}));
      sinon.stub(controller, 'renderPortConfigs', getEmptyArray);
      sinon.stub(controller, 'renderMetricConfigs', getEmptyArray);
      sinon.stub(controller, 'renderWebConfigs', getEmptyArray);
      sinon.stub(controller, 'renderScriptConfigs', getEmptyArray);
      sinon.stub(controller, 'renderAggregateConfigs', getEmptyArray);
    });

    afterEach(function () {
      controller.renderPortConfigs.restore();
      controller.renderMetricConfigs.restore();
      controller.renderWebConfigs.restore();
      controller.renderScriptConfigs.restore();
      controller.renderAggregateConfigs.restore();
    });

    it('should call renderPortConfigs method', function () {
      controller.set('alertDefinitionType', 'PORT');
      controller.renderConfigs();
      expect(controller.renderPortConfigs.calledOnce).to.be.true;
    });

    it('should call renderMetricConfigs method', function () {
      controller.set('alertDefinitionType', 'METRIC');
      controller.renderConfigs();
      expect(controller.renderMetricConfigs.calledOnce).to.be.true;
    });

    it('should call renderWebConfigs method', function () {
      controller.set('alertDefinitionType', 'WEB');
      controller.renderConfigs();
      expect(controller.renderWebConfigs.calledOnce).to.be.true;
    });

    it('should call renderScriptConfigs method', function () {
      controller.set('alertDefinitionType', 'SCRIPT');
      controller.renderConfigs();
      expect(controller.renderScriptConfigs.calledOnce).to.be.true;
    });

    it('should call renderAggregateConfigs method', function () {
      controller.set('alertDefinitionType', 'AGGREGATE');
      controller.renderConfigs();
      expect(controller.renderAggregateConfigs.calledOnce).to.be.true;
    });

  });

  describe('#renderPortConfigs()', function () {

    beforeEach(function () {
      controller.set('content', Em.Object.create({
        name: 'alertDefinitionName',
        service: {displayName: 'alertDefinitionService'},
        componentName: 'component1',
        scope: 'HOST',
        description: 'alertDefinitionDescription',
        interval: 60,
        reporting: [
          Em.Object.create({
            type: 'warning',
            value: 10
          }),
          Em.Object.create({
            type: 'critical',
            value: 20
          }),
          Em.Object.create({
            type: 'ok',
            value: 30
          })
        ],
        uri: 'alertDefinitionUri',
        defaultPort: '777'
      }));
    });

    it('isWizard = true', function () {
      controller.set('isWizard', true);
      var result = controller.renderPortConfigs();
      expect(result.length).to.equal(11);
    });

    it('isWizard = false', function () {
      controller.set('isWizard', false);
      var result = controller.renderPortConfigs();
      expect(result.length).to.equal(5);
    });

  });

  describe('#renderMetricConfigs()', function () {

    beforeEach(function () {
      controller.set('content', Em.Object.create({
        name: 'alertDefinitionName',
        service: {displayName: 'alertDefinitionService'},
        componentName: 'component1',
        scope: 'HOST',
        description: 'alertDefinitionDescription',
        interval: 60,
        reporting: [
          Em.Object.create({
            type: 'warning',
            value: 10
          }),
          Em.Object.create({
            type: 'critical',
            value: 20
          }),
          Em.Object.create({
            type: 'ok',
            value: 30
          })
        ],
        uri: {
          "http": "{{mapred-site/mapreduce.jobhistory.webapp.address}}",
          "https": "{{mapred-site/mapreduce.jobhistory.webapp.https.address}}",
          "https_property": "{{mapred-site/mapreduce.jobhistory.http.policy}}",
          "https_property_value": "HTTPS_ONLY",
          "default_port": 0.0,
          "connection_timeout": 123
        },
        jmx: {
          propertyList: ['property1', 'property2'],
          value: 'jmxValue'
        },
        ganglia: {
          propertyList: null,
          value: null
        }
      }));
    });

    it('isWizard = true', function () {
      controller.set('isWizard', true);
      var result = controller.renderMetricConfigs();
      expect(result.length).to.equal(12);
    });

    it('isWizard = false', function () {
      controller.set('isWizard', false);
      var result = controller.renderMetricConfigs();
      expect(result.length).to.equal(6);
    });

  });

  describe('#renderWebConfigs()', function () {

    beforeEach(function () {
      controller.set('content', Em.Object.create({
        name: 'alertDefinitionName',
        service: {displayName: 'alertDefinitionService'},
        componentName: 'component1',
        scope: 'HOST',
        description: 'alertDefinitionDescription',
        interval: 60,
        reporting: [
          Em.Object.create({
            type: 'warning',
            value: 10
          }),
          Em.Object.create({
            type: 'critical',
            value: 20
          }),
          Em.Object.create({
            type: 'ok',
            value: 30
          })
        ],
        uri: {
          "http": "{{mapred-site/mapreduce.jobhistory.webapp.address}}",
          "https": "{{mapred-site/mapreduce.jobhistory.webapp.https.address}}",
          "https_property": "{{mapred-site/mapreduce.jobhistory.http.policy}}",
          "https_property_value": "HTTPS_ONLY",
          "default_port": 0.0,
          "connection_timeout": 123
        }
      }));
    });

    it('isWizard = true', function () {
      controller.set('isWizard', true);
      var result = controller.renderWebConfigs();
      expect(result.length).to.equal(12);
    });

    it('isWizard = false', function () {
      controller.set('isWizard', false);
      var result = controller.renderWebConfigs();
      expect(result.length).to.equal(6);
    });

  });

  describe('#renderScriptConfigs()', function () {

    beforeEach(function () {
      controller.set('content', Em.Object.create({
        name: 'alertDefinitionName',
        service: {displayName: 'alertDefinitionService'},
        componentName: 'component1',
        scope: 'HOST',
        description: 'alertDefinitionDescription',
        interval: 60,
        parameters: [
          Em.Object.create({}),
          Em.Object.create({}),
        ],
        reporting: [
          Em.Object.create({
            type: 'warning',
            value: 10
          }),
          Em.Object.create({
            type: 'critical',
            value: 20
          }),
          Em.Object.create({
            type: 'ok',
            value: 30
          })
        ],
        location: 'path to script'
      }));
    });

    it('isWizard = true', function () {
      controller.set('isWizard', true);
      var result = controller.renderScriptConfigs();
      expect(result.length).to.equal(10);
    });

    it('isWizard = false', function () {
      controller.set('isWizard', false);
      var result = controller.renderScriptConfigs();
      expect(result.length).to.equal(4);
    });

  });

  describe('#renderAggregateConfigs()', function () {

    it('should render array of configs with correct values', function () {

      controller.set('content', Em.Object.create({
        name: 'alertDefinitionName',
        description: 'alertDefinitionDescription',
        interval: 60,
        reporting: [
          Em.Object.create({
            type: 'warning',
            value: 10
          }),
          Em.Object.create({
            type: 'critical',
            value: 20
          }),
          Em.Object.create({
            type: 'ok',
            value: 30
          })
        ]
      }));

      var result = controller.renderAggregateConfigs();

      expect(result.length).to.equal(5);
    });

  });

  describe('#editConfigs()', function () {

    beforeEach(function () {
      controller.set('configs', [
        Em.Object.create({value: 'value1', previousValue: '', isDisabled: true}),
        Em.Object.create({value: 'value2', previousValue: '', isDisabled: true}),
        Em.Object.create({value: 'value3', previousValue: '', isDisabled: true})
      ]);
      controller.set('canEdit', false);
      controller.editConfigs();
    });

    it('should set previousValue', function () {
      expect(controller.get('configs').mapProperty('previousValue')).to.eql(['value1', 'value2', 'value3']);
    });
    it('should set isDisabled for each config', function () {
      expect(controller.get('configs').someProperty('isDisabled', true)).to.be.false;
    });
    it('should change canEdit flag', function () {
      expect(controller.get('canEdit')).to.be.true;
    });

  });

  describe('#cancelEditConfigs()', function () {

    beforeEach(function () {
      controller.set('configs', [
        Em.Object.create({value: '', previousValue: 'value1', isDisabled: false}),
        Em.Object.create({value: '', previousValue: 'value2', isDisabled: false}),
        Em.Object.create({value: '', previousValue: 'value3', isDisabled: false})
      ]);
      controller.set('canEdit', true);
      controller.cancelEditConfigs();
    });

    it('should set previousValue', function () {
      expect(controller.get('configs').mapProperty('value')).to.eql(['value1', 'value2', 'value3']);
    });
    it('should set isDisabled for each config', function () {
      expect(controller.get('configs').someProperty('isDisabled', false)).to.be.false;
    });
    it('should change canEdit flag', function () {
      expect(controller.get('canEdit')).to.be.false;
    });

  });

  describe('#saveConfigs()', function () {

    beforeEach(function () {
      controller.set('configs', [
        Em.Object.create({isDisabled: true}),
        Em.Object.create({isDisabled: true}),
        Em.Object.create({isDisabled: true})
      ]);
      controller.set('canEdit', true);
      controller.saveConfigs();
    });

    it('should set isDisabled for each config', function () {
      expect(controller.get('configs').someProperty('isDisabled', false)).to.be.false;
    });
    it('should change canEdit flag', function () {
      expect(controller.get('canEdit')).to.be.false;
    });
    it('should sent 1 request', function () {
      var args = testHelpers.findAjaxRequest('name', 'alerts.update_alert_definition');
      expect(args[0]).to.exists;
    });

  });

  describe('#getPropertiesToUpdate()', function () {

    beforeEach(function () {
      controller.set('content', {
        rawSourceData: {
          path1: 'value',
          path2: {
            path3: 'value'
          }
        }
      });
    });

    var testCases = [
      {
        m: 'should ignore configs with wasChanged false',
        configs: [
          Em.Object.create({
            wasChanged: false,
            apiProperty: 'name1',
            apiFormattedValue: 'test1'
          }),
          Em.Object.create({
            wasChanged: true,
            apiProperty: 'name2',
            apiFormattedValue: 'test2'
          }),
          Em.Object.create({
            wasChanged: false,
            apiProperty: 'name3',
            apiFormattedValue: 'test3'
          })
        ],
        result: {
          'AlertDefinition/name2': 'test2'
        }
      },
      {
        m: 'should correctly map deep source properties',
        configs: [
          Em.Object.create({
            wasChanged: true,
            apiProperty: 'name1',
            apiFormattedValue: 'test1'
          }),
          Em.Object.create({
            wasChanged: true,
            apiProperty: 'source.path1',
            apiFormattedValue: 'value1'
          }),
          Em.Object.create({
            wasChanged: true,
            apiProperty: 'source.path2.path3',
            apiFormattedValue: 'value2'
          })
        ],
        result: {
          'AlertDefinition/name1': 'test1',
          'AlertDefinition/source': {
            path1: 'value1',
            path2: {
              path3: 'value2'
            }
          }
        }
      },
      {
        m: 'should correctly multiple apiProperties',
        configs: [
          Em.Object.create({
            wasChanged: true,
            apiProperty: ['name1', 'name2'],
            apiFormattedValue: ['value1', 'value2']
          })
        ],
        result: {
          'AlertDefinition/name1': 'value1',
          'AlertDefinition/name2': 'value2'
        }
      }
    ];

    testCases.forEach(function (testCase) {

      it(testCase.m, function () {

        controller.set('configs', testCase.configs);
        var result = controller.getPropertiesToUpdate(true);

        expect(result).to.eql(testCase.result);
      });
    });

    describe('Some fields should be removed', function () {

      beforeEach(function () {
        controller.set('content', Em.Object.create({
          rawSourceData: {
            uri: {
              id: 123
            }
          }
        }));
        controller.set('configs', [
          Em.Object.create({
            apiProperty: 'source.uri.connection_timeout',
            apiFormattedValue: 123,
            wasChanged: true
          })
        ]);
        this.result = controller.getPropertiesToUpdate();
      });

      it('`AlertDefinition/source.uri.id`', function () {
        expect(this.result).to.not.have.deep.property('AlertDefinition/source.uri.id');
      });

    });

    describe('`source/parameters` for SCRIPT configs', function () {

      beforeEach(function () {
        controller.set('content', Em.Object.create({
          parameters: [
            Em.Object.create({name: 'p1', value: 'v1'}),
            Em.Object.create({name: 'p2', value: 'v2'}),
            Em.Object.create({name: 'p3', value: 'v3'}),
            Em.Object.create({name: 'p4', value: 'v4'})
          ],
          rawSourceData: {
            parameters: [
              {name: 'p1', value: 'v1'},
              {name: 'p2', value: 'v2'},
              {name: 'p3', value: 'v3'},
              {name: 'p4', value: 'v4'}
            ]
          }
        }));
        controller.set('configs', [
          Em.Object.create({apiProperty:'p1', apiFormattedValue: 'v11', wasChanged: true, name: 'parameter'}),
          Em.Object.create({apiProperty:'p2', apiFormattedValue: 'v21', wasChanged: true, name: 'parameter'}),
          Em.Object.create({apiProperty:'p3', apiFormattedValue: 'v31', wasChanged: true, name: 'parameter'}),
          Em.Object.create({apiProperty:'p4', apiFormattedValue: 'v41', wasChanged: true, name: 'parameter'})
        ]);
        this.result = controller.getPropertiesToUpdate();
      });

      it('should update parameters', function () {
        expect(this.result['AlertDefinition/source'].parameters).to.have.property('length').equal(4);
        expect(this.result['AlertDefinition/source'].parameters.mapProperty('value')).to.be.eql(['v11', 'v21', 'v31', 'v41']);
      });

    });

  });

  describe('#changeType()', function () {

    beforeEach(function () {
      controller.set('allServices', ['service1', 'service2']);
      controller.set('allScopes', ['scope1', 'scope2']);

      controller.set('configs', [
        Em.Object.create({name: 'service', isDisabled: false}),
        Em.Object.create({name: 'component', isDisabled: false}),
        Em.Object.create({name: 'scope', isDisabled: false})
      ]);
    });

    describe('Host Alert Definition', function () {

      beforeEach(function () {
        controller.changeType('Host Alert Definition');
      });

      it('all configs are disabled', function () {
        expect(controller.get('configs').everyProperty('isDisabled', true)).to.be.true;
      });
      it('service.options = ["Ambari"]', function () {
        expect(controller.get('configs').findProperty('name', 'service').get('options')).to.eql(['Ambari']);
      });
      it('service.value = "Ambari"', function () {
        expect(controller.get('configs').findProperty('name', 'service').get('value')).to.equal('Ambari');
      });
      it('component.value = "Ambari Agent"', function () {
        expect(controller.get('configs').findProperty('name', 'component').get('value')).to.equal('Ambari Agent');
      });
      it('scope.options = ["Host"]', function () {
        expect(controller.get('configs').findProperty('name', 'scope').get('options')).to.eql(['Host']);
      });
      it('isDisabled.value = "Host"', function () {
        expect(controller.get('configs').findProperty('name', 'scope').get('value')).to.equal('Host');
      });
    });

    describe('alert_type_service', function () {

      beforeEach(function () {
        controller.changeType('alert_type_service');
      });
      it('all configs are not disabled', function () {
        expect(controller.get('configs').everyProperty('isDisabled', false)).to.be.true;
      });
      it('service.options = ["service1", "service2"]', function () {
        expect(controller.get('configs').findProperty('name', 'service').get('options')).to.eql(['service1', 'service2']);
      });
      it('service.value = "service1"', function () {
        expect(controller.get('configs').findProperty('name', 'service').get('value')).to.equal('service1');
      });
      it('component.value = "No component"', function () {
        expect(controller.get('configs').findProperty('name', 'component').get('value')).to.equal('No component');
      });
      it('scope.options = ["scope1", "scope2"]', function () {
        expect(controller.get('configs').findProperty('name', 'scope').get('options')).to.eql(['scope1', 'scope2']);
      });
      it('scope.value = "scope1"', function () {
        expect(controller.get('configs').findProperty('name', 'scope').get('value')).to.equal('scope1');
      });
    });

  });

  describe('#renderCommonWizardConfigs()', function () {

    it('should return correct number of configs', function () {

      var result = controller.renderCommonWizardConfigs();

      expect(result.length).to.equal(6);

    });

  });

  describe('#getConfigsValues()', function () {

    it('should create key-value map from configs', function () {

      controller.set('configs', [
        Em.Object.create({name: 'name1', value: 'value1'}),
        Em.Object.create({name: 'name2', value: 'value2'}),
        Em.Object.create({name: 'name3', value: 'value3'})
      ]);

      var result = controller.getConfigsValues();

      expect(result).to.eql([
        {name: 'name1', value: 'value1'},
        {name: 'name2', value: 'value2'},
        {name: 'name3', value: 'value3'}
      ]);

    });

  });

});

});

require.register("test/controllers/main/alerts/definitions_details_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var controller;

function getController() {
  return App.MainAlertDefinitionDetailsController.create({
    content: Em.Object.create({
      label: 'label'
    })
  });
}

describe('App.MainAlertDefinitionDetailsController', function () {

  beforeEach(function () {
    controller = getController();
  });

  App.TestAliases.testAsComputedMapBy(getController(), 'groupsList', 'content.groups', 'displayName');

  App.TestAliases.testAsComputedOr(getController(), 'isEditing', ['editing.label.isEditing', 'App.router.mainAlertDefinitionConfigsController.canEdit']);

  describe('#showSavePopup', function () {
    App.TestAliases.testAsComputedOr(getController().showSavePopup(), 'disablePrimary', ['App.router.mainAlertDefinitionDetailsController.editing.label.isError', 'App.router.mainAlertDefinitionConfigsController.hasErrors']);
  });

  describe('#labelValidation()', function () {

    it('should set editing.label.isError to true', function () {
      controller.set('editing.label.value', ' ');
      expect(controller.get('editing.label.isError')).to.be.true;
    });

  });

  describe('#edit()', function () {

    it('should change value of value, originalValue and isEditing properties', function () {
      controller.set('editing.label.value', 'test');
      controller.set('editing.label.originalValue', 'test');
      controller.set('editing.label.isEditing', false);

      controller.edit({context: controller.get('editing.label')});

      expect(controller.get('editing.label.value')).to.equal('label');
      expect(controller.get('editing.label.originalValue')).to.equal('label');
      expect(controller.get('editing.label.isEditing')).to.be.true;
    });

  });

  describe('#saveEdit()', function () {

    it('should change values of content.label and isEditing properties', function () {
      controller.set('editing.label.value', 'test');
      controller.set('editing.label.isEditing', true);

      controller.saveEdit({context: controller.get('editing.label')});

      expect(controller.get('content.label')).to.equal('test');
      expect(controller.get('editing.label.isEditing')).to.be.false;
    });

  });

  describe("#deleteAlertDefinition()", function () {
    beforeEach(function () {
      sinon.stub(App.get('router'), 'transitionTo', Em.K);
    });
    afterEach(function () {
      App.get('router').transitionTo.restore();
    });
    it("deleteAlertDefinitionSuccess", function () {
      controller.deleteAlertDefinitionSuccess();
      expect(App.get('router').transitionTo.calledWith('main.alerts.index')).to.be.true;
    });
  });

  describe("#loadAlertInstancesHistory()", function () {
    it("should set lastDayAlertsCount = null", function () {
      controller.set('lastDayAlertsCount', 'test');
      controller.loadAlertInstancesHistory();
      expect(controller.get('lastDayAlertsCount')).to.equal(null);
    });

  });

  describe("#loadAlertInstancesHistorySuccess()", function () {

    it("should calculate alerts count in different hosts", function () {

      controller.set('lastDayAlertsCount', null);

      controller.loadAlertInstancesHistorySuccess({
        items: [
          {
            AlertHistory: {
              host_name: 'host1'
            }
          },
          {
            AlertHistory: {
              host_name: 'host2'
            }
          },
          {
            AlertHistory: {
              host_name: 'host1'
            }
          },
          {
            AlertHistory: {
              host_name: 'host3'
            }
          }
        ]
      });

      expect(controller.get('lastDayAlertsCount')).to.eql({
        host1: 2,
        host2: 1,
        host3: 1
      });
    });
  });

});

});

require.register("test/controllers/main/alerts/manage_alert_groups_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var manageAlertGroupsController;

function getController() {
  return App.ManageAlertGroupsController.create({});
}

describe('App.ManageAlertGroupsController', function () {

  beforeEach(function () {
    manageAlertGroupsController = getController();
  });

  App.TestAliases.testAsComputedFilterBy(getController(), 'alertGlobalNotifications', 'alertNotifications', 'global', true);

  describe('#duplicateAlertGroup', function () {
    beforeEach(function () {
      var group = Ember.Object.create({
        name: 'test'
      });

      manageAlertGroupsController.set('selectedAlertGroup', group);
      manageAlertGroupsController.duplicateAlertGroup();
    });

    describe("#validate", function () {
      it("should display no warning if user duplicate an existed group", function () {
        manageAlertGroupsController.addGroupPopup.set('alertGroupName', 'test Copy');

        expect(manageAlertGroupsController.addGroupPopup.warningMessage).to.be.empty;
      });
    });
  });

  describe('#deleteDefinitions', function () {
    var definitions = [
      Em.Object.create({
        name: 'def1',
        serviceName: 'HDFS',
        label: "Alert Definition 1",
        id: 1
      }),
      Em.Object.create({
        name: 'def2',
        serviceName: 'HDFS',
        label: "Alert Definition 2",
        id: 2
      }),
      Em.Object.create({
        name: 'def3',
        serviceName: 'HDFS',
        label: "Alert Definition 3",
        id: 3
      })
    ];

    beforeEach(function () {
      manageAlertGroupsController = App.ManageAlertGroupsController.create({});
    });

    var createAlertGroupMock = function (groupDefs) {
      return Em.Object.create({
        definitions: groupDefs,
        name: 'group'
      });
    };

    var tests = [
      {
        selectedDefinitions: definitions.slice(0, 1),
        selectedAlertGroup: createAlertGroupMock(definitions),
        e: definitions.slice(1)
      },
      {
        selectedDefinitions: definitions.slice(0, 2),
        selectedAlertGroup: createAlertGroupMock(definitions),
        e: definitions.slice(2)
      },
      {
        selectedDefinitions: definitions,
        selectedAlertGroup: createAlertGroupMock(definitions),
        e: []
      }
    ];

    tests.forEach(function (test) {
      it('delete definitions length {0} definitions'.format(test.selectedDefinitions.slice(0).length), function () {
        manageAlertGroupsController.reopen({
          selectedDefinitions: test.selectedDefinitions,
          selectedAlertGroup: test.selectedAlertGroup
        });
        manageAlertGroupsController.deleteDefinitions();
        expect(manageAlertGroupsController.get('selectedAlertGroup.definitions').toArray()).to.eql(test.e);
      });
    });

  });

  describe('#addDefinitionsCallback', function () {

    var definitions = [
      Em.Object.create({
        name: 'def1',
        serviceName: 'HDFS',
        label: "Alert Definition 1",
        id: 1
      }),
      Em.Object.create({
        name: 'def2',
        serviceName: 'HDFS',
        label: "Alert Definition 2",
        id: 2
      }),
      Em.Object.create({
        name: 'def3',
        serviceName: 'HDFS',
        label: "Alert Definition 3",
        id: 3
      })
    ];

    var definitionsToAdd = [
      Em.Object.create({
        name: 'def4',
        serviceName: 'HDFS',
        label: "Alert Definition 4",
        id: 4
      }),
      Em.Object.create({
        name: 'def5',
        serviceName: 'HDFS',
        label: "Alert Definition 5",
        id: 5
      }),
      Em.Object.create({
        name: 'def6',
        serviceName: 'HDFS',
        label: "Alert Definition 6",
        id: 6
      })
    ];

    beforeEach(function () {
      manageAlertGroupsController = App.ManageAlertGroupsController.create({});
    });

    var createAlertGroupMock = function (groupDefs) {
      return Em.Object.create({
        definitions: groupDefs,
        name: 'group'
      });
    };

    var result = function (originalDefs, addedDefs) {
      return originalDefs.concat(addedDefs);
    };

    var tests = [
      {
        selectedDefinitions: definitionsToAdd.slice(0, 1),
        selectedAlertGroup: createAlertGroupMock(definitions.slice(0, 1)),
        e: result(definitions.slice(0, 1), definitionsToAdd.slice(0, 1))
      },
      {
        selectedDefinitions: definitionsToAdd.slice(0, 2),
        selectedAlertGroup: createAlertGroupMock(definitions.slice(0, 2)),
        e: result(definitions.slice(0, 2), definitionsToAdd.slice(0, 2))
      },
      {
        selectedDefinitions: definitionsToAdd,
        selectedAlertGroup: createAlertGroupMock(definitions),
        e: result(definitions, definitionsToAdd)
      }
    ];

    tests.forEach(function (test) {
      it('add Definitions length {0} definitions'.format(test.selectedDefinitions.slice(0).length), function () {
        manageAlertGroupsController.set('selectedAlertGroup', test.selectedAlertGroup);
        manageAlertGroupsController.addDefinitionsCallback(test.selectedDefinitions);
        expect(manageAlertGroupsController.get('selectedAlertGroup.definitions').toArray()).to.eql(test.e);
      });
    });

  });

});


});

require.register("test/controllers/main/alerts/manage_alert_notifications_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var controller;
var helpers = require('test/helpers');
require('templates/main/alerts/alert_instance/status');


function getController() {
  return App.ManageAlertNotificationsController.create({});
}

function getInputFields() {
  return Em.Object.create({
    name: {
      value: ''
    },
    groups: {
      value: []
    },
    global: {
      value: false
    },
    allGroups: {
      value: false
    },
    method: {
      value: ''
    },
    email: {
      value: ''
    },
    severityFilter: {
      value: []
    },
    description: {
      value: ''
    },
    SMTPServer: {
      value: ''
    },
    SMTPPort: {
      value: ''
    },
    SMTPUseAuthentication: {
      value: ''
    },
    SMTPUsername: {
      value: ''
    },
    SMTPPassword: {
      value: ''
    },
    retypeSMTPPassword: {
      value: ''
    },
    SMTPSTARTTLS: {
      value: ''
    },
    emailFrom: {
      value: ''
    },
    version: {
      value: ''
    },
    OIDs: {
      value: ''
    },
    community: {
      value: ''
    },
    host: {
      value: ''
    },
    port: {
      value: ''
    }
  });
}

var createEditPopupView = getController().showCreateEditPopup();

describe('App.ManageAlertNotificationsController', function () {

  beforeEach(function () {
    controller = getController();
  });

  describe('#alertNotifications', function () {

    beforeEach(function () {
      sinon.stub(App.AlertNotification, 'find', function () {
        return [1, 2, 3];
      });
    });

    afterEach(function () {
      App.AlertNotification.find.restore();
    });

    it("should return all alert notifications if controller isLoaded", function () {

      controller.set('isLoaded', true);
      expect(controller.get('alertNotifications')).to.eql([1, 2, 3]);
    });

    it("should return [] if controller isLoaded=false", function () {

      controller.set('isLoaded', false);
      expect(controller.get('alertNotifications')).to.eql([]);
    });

  });

  describe('#loadAlertNotifications()', function () {

    it("should send ajax request and set isLoaded to false", function () {

      controller.set('isLoaded', true);
      controller.loadAlertNotifications();
      expect(controller.get('isLoaded')).to.be.false;
    });

  });

  describe('#getAlertNotificationsSuccessCallback()', function () {

    beforeEach(function () {
      sinon.spy(App.alertNotificationMapper, 'map');
    });

    afterEach(function () {
      App.alertNotificationMapper.map.restore();
    });

    it("should call mapper and set isLoaded to true", function () {

      controller.set('isLoaded', false);
      controller.getAlertNotificationsSuccessCallback('test');
      expect(controller.get('isLoaded')).to.be.true;
      expect(App.alertNotificationMapper.map.calledWith('test')).to.be.true;
    });

  });

  describe('#getAlertNotificationsErrorCallback()', function () {

    it("should set isLoaded to true", function () {

      controller.set('isLoaded', false);
      controller.getAlertNotificationsSuccessCallback('test');
      expect(controller.get('isLoaded')).to.be.true;
    });

  });

  describe('#addAlertNotification()', function () {

    var inputFields = Em.Object.create({
      a: {
        value: '',
        defaultValue: 'a'
      },
      b: {
        value: '',
        defaultValue: 'b'
      },
      c: {
        value: '',
        defaultValue: 'c'
      },
      severityFilter: {
        value: [],
        defaultValue: ['OK', 'WARNING', 'CRITICAL', 'UNKNOWN']
      },
      global: {
        value: false
      },
      allGroups: Em.Object.create({
        value: 'custom'
      })
    });

    beforeEach(function () {
      sinon.stub(controller, 'showCreateEditPopup');
      controller.set('inputFields', inputFields);
      controller.addAlertNotification();
    });

    afterEach(function () {
      controller.showCreateEditPopup.restore();
    });

    Object.keys(inputFields).forEach(function (key) {
      it(key, function () {
        expect(controller.get('inputFields.' + key + '.value')).to.be.eql(controller.get('inputFields.' + key + '.defaultValue'));
      });
    });

    it("should call showCreateEditPopup", function () {
      expect(controller.showCreateEditPopup.calledOnce).to.be.true;
    });

  });

  describe('#editAlertNotification()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'showCreateEditPopup', Em.K);
      sinon.stub(controller, 'fillEditCreateInputs', Em.K);
    });

    afterEach(function () {
      controller.showCreateEditPopup.restore();
      controller.fillEditCreateInputs.restore();
    });

    it("should call fillEditCreateInputs and showCreateEditPopup", function () {

      controller.editAlertNotification();

      expect(controller.fillEditCreateInputs.calledOnce).to.be.true;
      expect(controller.showCreateEditPopup.calledWith(true)).to.be.true;
    });

  });

  describe('#fillEditCreateInputs()', function () {

    it("should map properties from selectedAlertNotification to inputFields (ambari.dispatch.recipients ignored) - EMAIL", function () {

      controller.set('selectedAlertNotification', Em.Object.create({
        name: 'test_name',
        global: true,
        description: 'test_description',
        groups: ['test1', 'test2'],
        type: 'EMAIL',
        alertStates: ['OK', 'UNKNOWN'],
        properties: {
          'ambari.dispatch.recipients': [
            'test1@test.test',
            'test2@test.test'
          ],
          'customName': 'customValue',
          "mail.smtp.from" : "from",
          "ambari.dispatch.credential.username" : "user",
          "mail.smtp.host" : "s1",
          "mail.smtp.port" : "25",
          "mail.smtp.auth" : "true",
          "ambari.dispatch.credential.password" : "pass",
          "mail.smtp.starttls.enable" : "true"
        }
      }));

      controller.set('inputFields', Em.Object.create({
        name: {
          value: ''
        },
        groups: {
          value: []
        },
        global: {
          value: false
        },
        allGroups: {
          value: false
        },
        method: {
          value: ''
        },
        email: {
          value: ''
        },
        severityFilter: {
          value: []
        },
        description: {
          value: ''
        },
        SMTPServer: {
          value: ''
        },
        SMTPPort: {
          value: ''
        },
        SMTPUseAuthentication: {
          value: ''
        },
        SMTPUsername: {
          value: ''
        },
        SMTPPassword: {
          value: ''
        },
        retypeSMTPPassword: {
          value: ''
        },
        SMTPSTARTTLS: {
          value: ''
        },
        emailFrom: {
          value: ''
        },
        version: {
          value: ''
        },
        OIDs: {
          value: ''
        },
        community: {
          value: ''
        },
        host: {
          value: ''
        },
        port: {
          value: ''
        },
        customProperties: [
          {name: 'customName', value: 'customValue1', defaultValue: 'customValue1'},
          {name: 'customName2', value: 'customValue1', defaultValue: 'customValue1'}
        ]
      }));

      controller.fillEditCreateInputs();

      expect(JSON.stringify(controller.get('inputFields'))).to.equal(JSON.stringify({
        name: {
          value: 'test_name'
        },
        groups: {
          value: ['test1', 'test2']
        },
        global: {
          value: true,
          disabled: true
        },
        allGroups: {
          value: 'all'
        },
        method: {
          value: 'EMAIL'
        },
        email: {
          value: 'test1@test.test, test2@test.test'
        },
        severityFilter: {
          value: ['OK', 'UNKNOWN']
        },
        description: {
          value: 'test_description'
        },
        SMTPServer: {
          value: 's1'
        },
        SMTPPort: {
          value: '25'
        },
        SMTPUseAuthentication: {
          value: true
        },
        SMTPUsername: {
          value: 'user'
        },
        SMTPPassword: {
          value: 'pass'
        },
        retypeSMTPPassword: {
          value: 'pass'
        },
        SMTPSTARTTLS: {
          value: true
        },
        emailFrom: {
          value: 'from'
        },
        version: {},
        OIDs: {},
        community: {},
        host: {
          value: 'test1@test.test, test2@test.test'
        },
        port: {},
        customProperties: [
          {name: 'customName', value: 'customValue', defaultValue: 'customValue'}
        ]
      }));

    });

    it("should map properties from selectedAlertNotification to inputFields (ambari.dispatch.recipients ignored) - SNMP", function () {

      controller.set('selectedAlertNotification', Em.Object.create({
        name: 'test_SNMP_name',
        global: true,
        description: 'test_description',
        groups: ['test1', 'test2'],
        type: 'SNMP',
        alertStates: ['OK', 'UNKNOWN'],
        properties: {
          'ambari.dispatch.recipients': [
            'c6401.ambari.apache.org',
            'c6402.ambari.apache.org'
          ],
          'customName': 'customValue',
          'ambari.dispatch.snmp.version': 'SNMPv1',
          'ambari.dispatch.snmp.oids.trap': '1',
          'ambari.dispatch.snmp.community': 'snmp',
          'ambari.dispatch.snmp.port': 161

        }
      }));

      controller.set('inputFields', Em.Object.create({
        name: {
          value: ''
        },
        groups: {
          value: []
        },
        global: {
          value: false
        },
        allGroups: {
          value: false
        },
        method: {
          value: ''
        },
        email: {
          value: ''
        },
        severityFilter: {
          value: []
        },
        description: {
          value: ''
        },
        SMTPServer: {
          value: ''
        },
        SMTPPort: {
          value: ''
        },
        SMTPUseAuthentication: {
          value: ''
        },
        SMTPUsername: {
          value: ''
        },
        SMTPPassword: {
          value: ''
        },
        retypeSMTPPassword: {
          value: ''
        },
        SMTPSTARTTLS: {
          value: ''
        },
        emailFrom: {
          value: ''
        },
        version: {
          value: ''
        },
        OIDs: {
          value: ''
        },
        community: {
          value: ''
        },
        host: {
          value: ''
        },
        port: {
          value: ''
        },
        customProperties: [
          {name: 'customName', value: 'customValue1', defaultValue: 'customValue1'},
          {name: 'customName2', value: 'customValue1', defaultValue: 'customValue1'}
        ]
      }));

      controller.fillEditCreateInputs();

      expect(JSON.stringify(controller.get('inputFields'))).to.equal(JSON.stringify({
        name: {
          value: 'test_SNMP_name'
        },
        groups: {
          value: ['test1', 'test2']
        },
        global: {
          value: true,
          disabled: true
        },
        allGroups: {
          value: 'all'
        },
        method: {
          value: 'Custom SNMP'
        },
        email: {
          value: 'c6401.ambari.apache.org, c6402.ambari.apache.org'
        },
        severityFilter: {
          value: ['OK', 'UNKNOWN']
        },
        description: {
          value: 'test_description'
        },
        SMTPServer: {},
        SMTPPort: {},
        SMTPUseAuthentication: {
          value: true
        },
        SMTPUsername: {},
        SMTPPassword: {},
        retypeSMTPPassword: {},
        SMTPSTARTTLS: {
          value: true
        },
        emailFrom: {},
        version: {
          value:'SNMPv1'
        },
        OIDs: {
          value: '1'
        },
        community: {
          value: 'snmp'
        },
        host: {
          value: 'c6401.ambari.apache.org, c6402.ambari.apache.org'
        },
        port: {
          value: 161
        },
        customProperties: [
          {name: 'customName', value: 'customValue', defaultValue: 'customValue'}
        ]
      }));

    });

    it("should map properties from selectedAlertNotification to inputFields (ambari.dispatch.recipients ignored) - AMBARI_SNMP", function () {

      controller.set('selectedAlertNotification', Em.Object.create({
        name: 'AMBARI_SNMP_name',
        global: true,
        description: 'test_description',
        groups: ['test1', 'test2'],
        type: 'AMBARI_SNMP',
        alertStates: ['OK', 'UNKNOWN'],
        properties: {
          'ambari.dispatch.recipients': [
            'c6401.ambari.apache.org',
            'c6402.ambari.apache.org'
          ],
          'customName': 'customValue',
          'ambari.dispatch.snmp.version': 'SNMPv1',
          'ambari.dispatch.snmp.community': 'public',
          'ambari.dispatch.snmp.port': 161

        }
      }));

      controller.set('inputFields', Em.Object.create({
        name: {
          value: ''
        },
        groups: {
          value: []
        },
        global: {
          value: false
        },
        allGroups: {
          value: false
        },
        method: {
          value: ''
        },
        email: {
          value: ''
        },
        severityFilter: {
          value: []
        },
        description: {
          value: ''
        },
        SMTPServer: {
          value: ''
        },
        SMTPPort: {
          value: ''
        },
        SMTPUseAuthentication: {
          value: ''
        },
        SMTPUsername: {
          value: ''
        },
        SMTPPassword: {
          value: ''
        },
        retypeSMTPPassword: {
          value: ''
        },
        SMTPSTARTTLS: {
          value: ''
        },
        emailFrom: {
          value: ''
        },
        version: {
          value: ''
        },
        OIDs: {
          value: ''
        },
        community: {
          value: ''
        },
        host: {
          value: ''
        },
        port: {
          value: ''
        },
        customProperties: [
          {name: 'customName', value: 'customValue1', defaultValue: 'customValue1'},
          {name: 'customName2', value: 'customValue1', defaultValue: 'customValue1'}
        ]
      }));

      controller.fillEditCreateInputs();

      expect(JSON.stringify(controller.get('inputFields'))).to.equal(JSON.stringify({
        name: {
          value: 'AMBARI_SNMP_name'
        },
        groups: {
          value: ['test1', 'test2']
        },
        global: {
          value: true,
          disabled: true
        },
        allGroups: {
          value: 'all'
        },
        method: {
          value: 'SNMP'
        },
        email: {
          value: 'c6401.ambari.apache.org, c6402.ambari.apache.org'
        },
        severityFilter: {
          value: ['OK', 'UNKNOWN']
        },
        description: {
          value: 'test_description'
        },
        SMTPServer: {},
        SMTPPort: {},
        SMTPUseAuthentication: {
          value: true
        },
        SMTPUsername: {},
        SMTPPassword: {},
        retypeSMTPPassword: {},
        SMTPSTARTTLS: {
          value: true
        },
        emailFrom: {},
        version: {
          value:'SNMPv1'
        },
        OIDs: {},
        community: {
          value: 'public'
        },
        host: {
          value: 'c6401.ambari.apache.org, c6402.ambari.apache.org'
        },
        port: {
          value: 161
        },
        customProperties: [
          {name: 'customName', value: 'customValue', defaultValue: 'customValue'}
        ]
      }));
    })
  });

  describe("#showCreateEditPopup()", function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it("should open popup and set popup object to createEditPopup", function () {

      controller.showCreateEditPopup();
      expect(App.ModalPopup.show.calledOnce).to.be.true;

    });

    App.TestAliases.testAsComputedOr(getController().showCreateEditPopup(), 'disablePrimary', ['isSaving', 'hasErrors']);

    describe('#bodyClass', function () {
      function getBodyClass() {
        return createEditPopupView.get('bodyClass').create({
          controller: Em.Object.create({
            inputFields: {
              name: {},
              global: {},
              allGroups: {},
              SMTPUseAuthentication: {},
              SMTPUsername: {},
              SMTPPassword: {},
              retypeSMTPPassword: {},
              method: {}
            }
          }),
          groupSelect: Em.Object.create({
            selection: [],
            content: [{}, {}]
          }),
          parentView: Em.Object.create({
            hasErrors: false
          })
        });
      }

      var view;

      beforeEach(function () {
        view = getBodyClass();
      });

      App.TestAliases.testAsComputedOr(getBodyClass(), 'someErrorExists', ['nameError', 'emailToError', 'emailFromError', 'smtpPortError', 'hostError', 'portError', 'smtpUsernameError', 'smtpPasswordError', 'passwordError']);

      describe('#selectAllGroups', function () {

        it('should check inputFields.allGroups.value', function () {

          view.set('controller.inputFields.allGroups.value', 'all');
          view.selectAllGroups();
          expect(view.get('groupSelect.selection')).to.eql([]);

          view.set('controller.inputFields.allGroups.value', 'custom');
          view.selectAllGroups();
          expect(view.get('groupSelect.selection')).to.eql([{}, {}]);

        });

      });

      describe('#clearAllGroups', function () {

        it('should check inputFields.allGroups.value', function () {

          view.set('controller.inputFields.allGroups.value', 'custom');
          view.selectAllGroups();

          view.set('controller.inputFields.allGroups.value', 'all');
          view.clearAllGroups();
          expect(view.get('groupSelect.selection')).to.eql([{}, {}]);

          view.set('controller.inputFields.allGroups.value', 'custom');
          view.clearAllGroups();
          expect(view.get('groupSelect.selection')).to.eql([]);

        });

      });

      describe('#nameValidation', function () {

        it('should check inputFields.name.value', function () {
          view.set('controller.inputFields.name.value', '');
          expect(view.get('controller.inputFields.name.errorMsg')).to.equal(Em.I18n.t('alerts.actions.manage_alert_notifications_popup.error.name.empty'));
          expect(view.get('parentView.hasErrors')).to.be.true;
        });

        it('should check inputFields.name.value (2)', function () {
          view.set('controller.inputFields.name.errorMsg', 'error');
          view.set('controller.inputFields.name.value', 'test');
          expect(view.get('controller.inputFields.name.errorMsg')).to.equal('');
        });

        it('should check inputFields.name.value (3)', function () {
          view.set('isEdit', true);
          view.set('controller.inputFields.name.value', '');
          expect(view.get('controller.inputFields.name.errorMsg')).to.equal(Em.I18n.t('alerts.actions.manage_alert_notifications_popup.error.name.empty'));
          expect(view.get('parentView.hasErrors')).to.be.true;
        });

        it('should check inputFields.name.value (4)', function () {
          view.set('isEdit', true);
          view.set('controller.inputFields.name.errorMsg', 'error');
          view.set('controller.inputFields.name.value', 'test');
          expect(view.get('controller.inputFields.name.errorMsg')).to.equal('');
        });
        
        it('should check inputFields.name.value (5)', function () {
         view.set('isEdit', true);
         view.set('controller.inputFields.name.errorMsg', 'error');
         view.set('controller.inputFields.name.value', 'test%');
         expect(view.get('controller.inputFields.name.errorMsg')).to.equal(Em.I18n.t('form.validator.alertNotificationName'));
       });

      });

      describe('#smtpUsernameValidation', function () {

        beforeEach(function () {
          view.set('controller.inputFields', getInputFields());
          view.set('controller.inputFields.emailFrom.value', '1@2.com');
          view.set('controller.inputFields.method.value', 'EMAIL');
        });

        it('should check inputFields.SMTPUsername.value', function () {

          view.set('parentView.hasErrors', false);
          view.set('controller.inputFields.SMTPUsername.errorMsg', null);
          view.set('controller.inputFields.SMTPUseAuthentication.value', true);
          view.set('controller.inputFields.SMTPUsername.value', '');
          view.set('controller.inputFields.SMTPPassword.value', 'pass');
          view.set('controller.inputFields.retypeSMTPPassword.value', 'pass');
          expect(view.get('controller.inputFields.SMTPUsername.errorMsg')).to.equal(Em.I18n.t('alerts.notifications.error.SMTPUsername'));
          expect(view.get('smtpUsernameError')).to.be.true;

        });

        it('should check inputFields.SMTPUsername.value (2)', function () {

          view.set('parentView.hasErrors', true);
          view.set('controller.inputFields.SMTPUsername.errorMsg', 'error');
          view.set('controller.inputFields.SMTPUseAuthentication.value', true);
          view.set('controller.inputFields.SMTPUsername.value', 'test');
          view.set('controller.inputFields.SMTPPassword.value', 'pass');
          view.set('controller.inputFields.retypeSMTPPassword.value', 'pass');
          expect(view.get('controller.inputFields.SMTPUsername.errorMsg')).to.equal(null);
          expect(view.get('smtpUsernameError')).to.be.false;

        });

        it('should check inputFields.SMTPUsername.value (3)', function () {

          view.set('parentView.hasErrors', true);
          view.set('controller.inputFields.SMTPUsername.errorMsg', 'error');
          view.set('controller.inputFields.SMTPUseAuthentication.value', false);
          view.set('controller.inputFields.SMTPUsername.value', '');
          view.set('controller.inputFields.SMTPPassword.value', '');
          view.set('controller.inputFields.retypeSMTPPassword.value', '');
          expect(view.get('controller.inputFields.SMTPUsername.errorMsg')).to.equal(null);
          expect(view.get('smtpUsernameError')).to.be.false;

        });

      });

      describe('#smtpPasswordValidation', function () {

        beforeEach(function () {
          view.set('controller.inputFields', getInputFields());
          view.set('controller.inputFields.emailFrom.value', '1@2.com');
          view.set('controller.inputFields.method.value', 'EMAIL');
        });

        it('should check inputFields.SMTPPassword.value', function () {

          view.set('parentView.hasErrors', false);
          view.set('controller.inputFields.SMTPPassword.errorMsg', null);
          view.set('controller.inputFields.SMTPUseAuthentication.value', true);
          view.set('controller.inputFields.SMTPUsername.value', 'user');
          view.set('controller.inputFields.SMTPPassword.value', '');
          view.set('controller.inputFields.retypeSMTPPassword.value', '');
          expect(view.get('controller.inputFields.SMTPPassword.errorMsg')).to.equal(Em.I18n.t('alerts.notifications.error.SMTPPassword'));
          expect(view.get('smtpPasswordError')).to.be.true;

        });

        it('should check inputFields.SMTPPassword.value (2)', function () {

          view.set('parentView.hasErrors', true);
          view.set('controller.inputFields.SMTPPassword.errorMsg', 'error');
          view.set('controller.inputFields.SMTPUseAuthentication.value', true);
          view.set('controller.inputFields.SMTPUsername.value', 'user');
          view.set('controller.inputFields.SMTPPassword.value', 'test');
          view.set('controller.inputFields.retypeSMTPPassword.value', 'test');
          expect(view.get('controller.inputFields.SMTPPassword.errorMsg')).to.equal(null);
          expect(view.get('smtpPasswordError')).to.be.false;

        });

        it('should check inputFields.SMTPPassword.value (3)', function () {

          view.set('parentView.hasErrors', true);
          view.set('controller.inputFields.SMTPPassword.errorMsg', 'error');
          view.set('controller.inputFields.SMTPUseAuthentication.value', false);
          view.set('controller.inputFields.SMTPUsername.value', '');
          view.set('controller.inputFields.SMTPPassword.value', '');
          view.set('controller.inputFields.retypeSMTPPassword.value', '');
          expect(view.get('controller.inputFields.SMTPPassword.errorMsg')).to.equal(null);
          expect(view.get('smtpPasswordError')).to.be.false;

        });

      });

      describe('#retypePasswordValidation', function () {

        it('should check inputFields.retypeSMTPPassword.value', function () {

          view.set('controller.inputFields.retypeSMTPPassword.errorMsg', null);
          view.set('controller.inputFields.SMTPPassword.value', 'pass');
          view.set('controller.inputFields.retypeSMTPPassword.value', 'pas');

          expect(view.get('controller.inputFields.retypeSMTPPassword.errorMsg')).to.equal(Em.I18n.t('alerts.notifications.error.retypePassword'));
          expect(view.get('parentView.hasErrors')).to.be.true;

        });

        it('should check inputFields.retypeSMTPPassword.value (2)', function () {

          view.set('parentView.hasErrors', true);
          view.set('controller.inputFields.retypeSMTPPassword.errorMsg', 'error');
          view.set('controller.inputFields.SMTPPassword.value', 'pass');
          view.set('controller.inputFields.retypeSMTPPassword.value', 'pass');

          expect(view.get('controller.inputFields.retypeSMTPPassword.errorMsg')).to.equal(null);
          expect(view.get('parentView.hasErrors')).to.be.false;

        });

      });

      describe('#methodObserver', function () {

        var cases = [
            {
              method: 'EMAIL',
              errors: ['portError', 'hostError'],
              validators: ['emailToValidation', 'emailFromValidation', 'smtpPortValidation', 'smtpUsernameValidation', 'smtpPasswordValidation', 'retypePasswordValidation']
            },
            {
              method: 'SNMP',
              errors: ['emailToError', 'emailFromError', 'smtpPortError', 'smtpUsernameError', 'smtpPasswordError', 'passwordError'],
              validators: ['portValidation', 'hostsValidation']
            }
          ],
          validators = [];

        before(function () {
          cases.forEach(function (item) {
            validators.pushObjects(item.validators);
          });
        });

        beforeEach(function () {
          validators.forEach(function (item) {
            sinon.stub(view, item, Em.K);
          });
        });

        afterEach(function () {
          validators.forEach(function (item) {
            view.get(item).restore();
          });
        });

        cases.forEach(function (item) {
          describe(item.method, function () {

            beforeEach(function () {
              item.errors.forEach(function (errorName) {
                view.set(errorName, true);
              });
              view.set('controller.inputFields.method.value', item.method);
            });

            item.errors.forEach(function (errorName) {
              it(errorName + ' is false', function () {
                expect(view.get(errorName)).to.be.false;
              });

            });
            validators.forEach(function (validatorName) {
              var called = item.validators.contains(validatorName);
              it(validatorName + ' ' + (called ? '' : 'not') + ' called', function () {
                expect(view.get(validatorName).calledOnce).to.equal(called);
              });
            });
          });
        });

      });

    });

  });

  describe("#formatNotificationAPIObject()", function () {

    var inputFields = Em.Object.create({
      name: {
        value: 'test_name'
      },
      groups: {
        value: [{id: 1}, {id: 2}, {id: 3}]
      },
      allGroups: {
        value: 'custom'
      },
      global: {
        value: false
      },
      method: {
        value: 'EMAIL'
      },
      email: {
        value: 'test1@test.test, test2@test.test,test3@test.test , test4@test.test'
      },
      severityFilter: {
        value: ['OK', 'CRITICAL']
      },
      SMTPServer: {
        value: 's1'
      },
      SMTPPort: {
        value: '25'
      },
      SMTPUseAuthentication: {
        value: "true"
      },
      SMTPUsername: {
        value: 'user'
      },
      SMTPPassword: {
        value: 'pass'
      },
      SMTPSTARTTLS: {
        value: "true"
      },
      emailFrom: {
        value: 'from'
      },
      description: {
        value: 'test_description'
      },
      customProperties: [
        {name: 'n1', value: 'v1'},
        {name: 'n2', value: 'v2'}
      ]
    });

    it("should create object with properties from inputFields values", function () {

      controller.set('inputFields', inputFields);

      var result = controller.formatNotificationAPIObject();

      expect(JSON.stringify(result)).to.eql(JSON.stringify({
        AlertTarget: {
          name: 'test_name',
          description: 'test_description',
          global: false,
          notification_type: 'EMAIL',
          alert_states: ['OK', 'CRITICAL'],
          properties: {
            'ambari.dispatch.recipients': [
              'test1@test.test',
              'test2@test.test',
              'test3@test.test',
              'test4@test.test'
            ],
            "mail.smtp.host" : "s1",
            "mail.smtp.port" : "25",
            "mail.smtp.from" : "from",
            "mail.smtp.auth" : "true",
            "ambari.dispatch.credential.username" : "user",
            "ambari.dispatch.credential.password" : "pass",
            "mail.smtp.starttls.enable" : "true",
            'n1': 'v1',
            'n2': 'v2'
          },
          groups: [1,2,3]
        }
      }));
    });

    it('should ignore groups if global is true', function () {

      controller.set('inputFields', inputFields);
      controller.set('inputFields.allGroups.value', 'all');

      var result = controller.formatNotificationAPIObject();
      expect(Em.keys(result.AlertTarget)).to.not.contain('groups');

    });

  });

  describe('#createAlertNotification()', function () {

    it("should send ajax request", function () {

      controller.createAlertNotification();
      var args = helpers.findAjaxRequest('name', 'alerts.create_alert_notification');
      expect(args[0]).to.exists;
    });

  });

  describe('#createAlertNotificationSuccessCallback()', function () {

    beforeEach(function () {
      controller.set('createEditPopup', {
        hide: Em.K
      });
      sinon.stub(controller, 'loadAlertNotifications', Em.K);
      sinon.spy(controller.createEditPopup, 'hide');
    });

    afterEach(function () {
      controller.loadAlertNotifications.restore();
      controller.createEditPopup.hide.restore();
    });

    it("should call loadAlertNotifications and createEditPopup.hide", function () {

      controller.createAlertNotificationSuccessCallback();

      expect(controller.loadAlertNotifications.calledOnce).to.be.true;
      expect(controller.createEditPopup.hide.calledOnce).to.be.true;
    });

  });

  describe('#updateAlertNotification()', function () {

    it("should send ajax request", function () {

      controller.updateAlertNotification();
      var args = helpers.findAjaxRequest('name', 'alerts.update_alert_notification');
      expect(args[0]).to.exists;
    });

  });

  describe('#updateAlertNotificationSuccessCallback()', function () {

    beforeEach(function () {
      controller.set('createEditPopup', {
        hide: Em.K
      });
      sinon.stub(controller, 'loadAlertNotifications', Em.K);
      sinon.spy(controller.createEditPopup, 'hide');
    });

    afterEach(function () {
      controller.loadAlertNotifications.restore();
      controller.createEditPopup.hide.restore();
    });

    it("should call loadAlertNotifications and createEditPopup.hide", function () {

      controller.updateAlertNotificationSuccessCallback();

      expect(controller.loadAlertNotifications.calledOnce).to.be.true;
      expect(controller.createEditPopup.hide.calledOnce).to.be.true;
    });

  });

  describe('#deleteAlertNotification()', function () {

    beforeEach(function () {
      sinon.spy(App, 'showConfirmationPopup');
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it("should show popup and send request on confirmation", function () {

      var popup = controller.deleteAlertNotification();

      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      var args = helpers.findAjaxRequest('name', 'alerts.delete_alert_notification');
      expect(args[0]).to.exists;
    });

  });

  describe('#deleteAlertNotificationSuccessCallback()', function () {
    var mockSelectedAlertNotification;

    beforeEach(function () {
      mockSelectedAlertNotification = {
        deleteRecord: Em.K
      };
      controller.set('selectedAlertNotification', mockSelectedAlertNotification);
      sinon.stub(controller, 'loadAlertNotifications', Em.K);
      sinon.spy(mockSelectedAlertNotification, 'deleteRecord');
      controller.deleteAlertNotificationSuccessCallback();
    });

    afterEach(function () {
      controller.loadAlertNotifications.restore();
      mockSelectedAlertNotification.deleteRecord.restore();
    });

    it("should call loadAlertNotifications", function () {
      expect(controller.loadAlertNotifications.calledOnce).to.be.true;
    });

    it("should call selectedAlertNotification.deleteRecord", function () {
      expect(mockSelectedAlertNotification.deleteRecord.calledOnce).to.be.true;
    });

    it("should set null to selectedAlertNotification", function () {
      expect(controller.get('selectedAlertNotification')).to.equal(null);
    });

  });

  describe('#duplicateAlertNotification()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'fillEditCreateInputs', Em.K);
      sinon.stub(controller, 'showCreateEditPopup', Em.K);
    });

    afterEach(function () {
      controller.fillEditCreateInputs.restore();
      controller.showCreateEditPopup.restore();
    });

    it("should call fillEditCreateInputs and showCreateEditPopup", function () {

      controller.duplicateAlertNotification();

      expect(controller.fillEditCreateInputs.calledWith(true)).to.be.true;
      expect(controller.showCreateEditPopup.calledOnce).to.be.true;
    });

  });

  describe('#addCustomProperty', function () {

    beforeEach(function () {
      controller.set('inputFields.customProperties', []);
    });

    /*eslint-disable mocha-cleanup/asserts-limit */
    it('should add custom Property to customProperties', function () {
      controller.set('newCustomProperty', {name: 'n1', value: 'v1'});
      controller.addCustomProperty();
      helpers.nestedExpect([{name: 'n1', value: 'v1', defaultValue: 'v1'}], controller.get('inputFields.customProperties'));
    });
    /*eslint-enable mocha-cleanup/asserts-limit */

  });

  describe('#removeCustomPropertyHandler', function () {

    var c = {name: 'n2', value: 'v2', defaultValue: 'v2'};

    beforeEach(function () {
      controller.set('inputFields.customProperties', [
        {name: 'n1', value: 'v1', defaultValue: 'v1'},
        c,
        {name: 'n3', value: 'v3', defaultValue: 'v3'}
      ]);
    });

    /*eslint-disable mocha-cleanup/asserts-limit */
    it('should remove selected custom property', function () {
      controller.removeCustomPropertyHandler({context: c});
      helpers.nestedExpect(
        [
          {name: 'n1', value: 'v1', defaultValue: 'v1'},
          {name: 'n3', value: 'v3', defaultValue: 'v3'}
        ],
        controller.get('inputFields.customProperties')
      );
    });
    /*eslint-enable mocha-cleanup/asserts-limit */

  });

  describe('#addCustomPropertyHandler', function () {

    it('should clean up newCustomProperty on primary click', function () {

      controller.set('newCustomProperty', {name: 'n1', value: 'v1'});
      controller.addCustomPropertyHandler().onPrimary();
      expect(controller.get('newCustomProperty')).to.eql({name: '', value: ''});

    });

  });

});

});

require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
var date = require('utils/date/date');

describe('MainChartHeatmapMetric', function () {
  var mainChartHeatmapMetric = App.MainChartHeatmapMetric.create({});

  beforeEach(function () {
    mainChartHeatmapMetric = App.MainChartHeatmapMetric.create({});
  });

  describe('#formatLegendNumber', function () {
    var tests = [
      {m:'undefined to undefined',i:undefined,e:undefined},
      {m:'0 to 0',i:0,e:0},
      {m:'1 to 1',i:1,e:1},
      {m:'1.23 to 1.2',i:1.23,e:1.2}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(mainChartHeatmapMetric.formatLegendNumber(test.i)).to.equal(test.e);
      });
    });
    it('NaN to NaN', function () {
      expect(isNaN(mainChartHeatmapMetric.formatLegendNumber(NaN))).to.equal(true);
    });
  });


  describe('#slotDefinitions', function () {
    beforeEach(function () {
      sinon.stub(mainChartHeatmapMetric, 'generateSlot', Em.K);
      mainChartHeatmapMetric.set('maximumValue', 100);
      mainChartHeatmapMetric.set('minimumValue', 0);
    });
    afterEach(function () {
      mainChartHeatmapMetric.generateSlot.restore();
    });

    describe('one slot', function () {

      beforeEach(function () {
        mainChartHeatmapMetric.set('numberOfSlots', 1);
        mainChartHeatmapMetric.propertyDidChange('slotDefinitions');
        this.slotDefinitions = mainChartHeatmapMetric.get('slotDefinitions');
      });

      it('3 slotDefinitions', function () {
        expect(this.slotDefinitions.length).to.equal(3);
      });
      it('generateSlot is called 1 time', function () {
        expect(mainChartHeatmapMetric.generateSlot.callCount).to.be.equal(1);
      });
      it('generateSlot is called with correct arguments', function () {
        expect(mainChartHeatmapMetric.generateSlot.getCall(0).args).to.eql([0, 100, '', {r: 0, g: 204, b: 0}]);
      });

    });

    describe('two slots', function () {

      beforeEach(function () {
        mainChartHeatmapMetric.set('numberOfSlots', 2);
        mainChartHeatmapMetric.propertyDidChange('slotDefinitions');
        this.slotDefinitions = mainChartHeatmapMetric.get('slotDefinitions');
      });

      it('4 slotDefinitions', function () {
        expect(this.slotDefinitions.length).to.equal(4);
      });
      it('generateSlot is called 2 times', function () {
        expect(mainChartHeatmapMetric.generateSlot.callCount).to.be.equal(2);
      });
      it('generateSlot 1st call has valid arguments', function () {
        expect(mainChartHeatmapMetric.generateSlot.getCall(0).args).to.eql([0, 50, '', {r: 0, g: 204, b: 0}]);
      });
      it('generateSlot 2nd call has valid arguments', function () {
        expect(mainChartHeatmapMetric.generateSlot.getCall(1).args).to.eql([50, 100, '', {r: 159, g: 238, b: 0}]);
      });

    });
  });

  describe('#generateSlot()', function () {

    beforeEach(function () {
      sinon.stub(mainChartHeatmapMetric, 'formatLegendNumber').returns('val');
      sinon.stub(date, 'timingFormat').returns('time');
    });

    afterEach(function () {
      mainChartHeatmapMetric.formatLegendNumber.restore();
      date.timingFormat.restore();
    });

    describe('label suffix is empty', function () {

      beforeEach(function () {
        this.result = mainChartHeatmapMetric.generateSlot(0, 1, '', {r: 0, g: 0, b: 0});
      });

      it('generateSlot result is valid', function () {
        expect(this.result).to.eql(Em.Object.create({
          "from": "val",
          "to": "val",
          "label": "val - val",
          "cssStyle": "background-color:rgb(0,0,0)"
        }));
      });

      it('formatLegendNumber 1st call with valid arguments', function () {
        expect(mainChartHeatmapMetric.formatLegendNumber.getCall(0).args).to.eql([0]);
      });

      it('formatLegendNumber 2nd call with valid arguments', function () {
        expect(mainChartHeatmapMetric.formatLegendNumber.getCall(1).args).to.eql([1]);
      });
    });

    describe('label suffix is "ms"', function () {

      beforeEach(function () {
        this.result = mainChartHeatmapMetric.generateSlot(0, 1, 'ms', {r: 0, g: 0, b: 0});
      });

      it('generateSlot result is valid', function () {
        expect(this.result).to.eql(Em.Object.create({
          "from": "val",
          "to": "val",
          "label": "time - time",
          "cssStyle": "background-color:rgb(0,0,0)"
        }));
      });
      it('formatLegendNumber 1st call with valid arguments', function () {
        expect(mainChartHeatmapMetric.formatLegendNumber.getCall(0).args).to.eql([0]);
      });
      it('formatLegendNumber 2nd call with valid arguments', function () {
        expect(mainChartHeatmapMetric.formatLegendNumber.getCall(1).args).to.eql([1]);
      });
      it('timingFormat 1st call with valid arguments', function () {
        expect(date.timingFormat.getCall(0).args).to.eql(['val', 'zeroValid']);
      });
      it('timingFormat 2nd call with valid arguments', function () {
        expect(date.timingFormat.getCall(1).args).to.eql(['val', 'zeroValid']);
      });

    });

  });

  describe('#getHatchStyle()', function () {
    var testCases = [
      {
        title: 'unknown browser',
        data: {},
        result: 'background-color:rgb(135, 206, 250)'
      },
      {
        title: 'webkit browser',
        data: {
          webkit: true
        },
        result: 'background-image:-webkit-repeating-linear-gradient(-45deg, #FF1E10, #FF1E10 3px, #ff6c00 3px, #ff6c00 6px)'
      },
      {
        title: 'mozilla browser',
        data: {
          mozilla: true
        },
        result: 'background-image:repeating-linear-gradient(-45deg, #FF1E10, #FF1E10 3px, #ff6c00 3px, #ff6c00 6px)'
      },
      {
        title: 'IE version 9',
        data: {
          msie: true,
          version: '9.0'
        },
        result: 'background-color:rgb(135, 206, 250)'
      },
      {
        title: 'IE version 10',
        data: {
          msie: true,
          version: '10.0'
        },
        result: 'background-image:repeating-linear-gradient(-45deg, #FF1E10, #FF1E10 3px, #ff6c00 3px, #ff6c00 6px)'
      }
    ];

    testCases.forEach(function(test){
      it(test.title, function () {
        jQuery.browser = test.data;
        expect(mainChartHeatmapMetric.getHatchStyle()).to.equal(test.result);
      });
    });
  });

  describe('#hostToSlotMap', function () {

    beforeEach(function () {
      this.stub = sinon.stub(mainChartHeatmapMetric, 'calculateSlot');
    });

    afterEach(function () {
      this.stub.restore();
    });

    it('hostToValueMap is null', function () {
      mainChartHeatmapMetric.set('hostToValueMap', null);
      mainChartHeatmapMetric.set('hostNames', []);
      mainChartHeatmapMetric.propertyDidChange('hostToSlotMap');
      expect(mainChartHeatmapMetric.get('hostToSlotMap')).to.be.empty;
    });
    it('hostNames is null', function () {
      mainChartHeatmapMetric.set('hostToValueMap', {});
      mainChartHeatmapMetric.set('hostNames', null);
      mainChartHeatmapMetric.propertyDidChange('hostToSlotMap');
      expect(mainChartHeatmapMetric.get('hostToSlotMap')).to.be.empty;
    });
    it('slot greater than -1', function () {
      mainChartHeatmapMetric.set('hostToValueMap', {});
      mainChartHeatmapMetric.set('hostNames', ['host1']);
      this.stub.returns(0);
      mainChartHeatmapMetric.propertyDidChange('hostToSlotMap');
      expect(mainChartHeatmapMetric.get('hostToSlotMap')).to.eql({'host1': 0});
      expect(mainChartHeatmapMetric.calculateSlot.calledWith({}, 'host1')).to.be.true;
    });
    it('slot equal to -1', function () {
      mainChartHeatmapMetric.set('hostToValueMap', {});
      mainChartHeatmapMetric.set('hostNames', ['host1']);
      this.stub.returns('-1');
      mainChartHeatmapMetric.propertyDidChange('hostToSlotMap');
      expect(mainChartHeatmapMetric.get('hostToSlotMap')).to.be.empty;
      expect(mainChartHeatmapMetric.calculateSlot.calledWith({}, 'host1')).to.be.true;
    });
  });

  describe('#calculateSlot()', function () {
    var testCases = [
      {
        title: 'hostToValueMap is empty',
        data: {
          hostToValueMap: {},
          hostName: 'host1',
          slotDefinitions: []
        },
        result: -1
      },
      {
        title: 'host value is NaN',
        data: {
          hostToValueMap: {'host1': NaN},
          hostName: 'host1',
          slotDefinitions: []
        },
        result: -2
      },
      {
        title: 'host value correct but slotDefinitions does not contain host value',
        data: {
          hostToValueMap: {'host1': 1},
          hostName: 'host1',
          slotDefinitions: [{}, {}]
        },
        result: -1
      },
      {
        title: 'host value -1',
        data: {
          hostToValueMap: {'host1': -1},
          hostName: 'host1',
          slotDefinitions: [
            {
              from: 0,
              to: 10
            },
            {},
            {}
          ]
        },
        result: 0
      },
      {
        title: 'host value 11',
        data: {
          hostToValueMap: {'host1': 11},
          hostName: 'host1',
          slotDefinitions: [
            {
              from: 0,
              to: 10
            },
            {},
            {}
          ]
        },
        result: 0
      },
      {
        title: 'host value 5',
        data: {
          hostToValueMap: {'host1': 5},
          hostName: 'host1',
          slotDefinitions: [
            {},
            {
              from: 0,
              to: 10
            },
            {},
            {}
          ]
        },
        result: 1
      }
    ];

    testCases.forEach(function (test) {
      describe(test.title, function () {

        beforeEach(function () {
          sinon.stub(mainChartHeatmapMetric, 'get').withArgs('slotDefinitions').returns(test.data.slotDefinitions);
        });

        afterEach(function () {
          mainChartHeatmapMetric.get.restore();
        });

        it('calculateSlot result is valid', function () {
          expect(mainChartHeatmapMetric.calculateSlot(test.data.hostToValueMap, test.data.hostName)).to.equal(test.result);
        });

      });
    });
  });

});

});

require.register("test/controllers/main/charts/heatmap_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
var controller;
require('models/rack');
require('controllers/main/charts/heatmap');
var testHelpers = require('test/helpers');

function getController() {
  return App.MainChartsHeatmapController.create();
}

describe('MainChartsHeatmapController', function () {

  before(function () {
    controller = getController();
  });

  App.TestAliases.testAsComputedAlias(getController(), 'activeWidget', 'widgets.firstObject', 'object');

  App.TestAliases.testAsComputedAlias(getController(), 'hostToSlotMap', 'selectedMetric.hostToSlotMap', 'object');

  describe('#validation()', function () {

    beforeEach(function() {
      controller.setProperties({
        allMetrics: [],
        selectedMetric: Ember.Object.create({maximumValue: 100})
      });
    });

    it('should set maximumValue if inputMaximum consists only of digits', function () {
      controller.set("inputMaximum", 5);
      expect(controller.get('selectedMetric.maximumValue')).to.equal(5);
    });
    it('should not set maximumValue if inputMaximum consists not only of digits', function () {
      controller.set("inputMaximum", 'qwerty');
      expect(controller.get('selectedMetric.maximumValue')).to.equal(100);
    });
    it('should not set maximumValue if inputMaximum consists not only of digits (2)', function () {
      controller.set("inputMaximum", '100%');
      expect(controller.get('selectedMetric.maximumValue')).to.equal(100);
    });
    it('should set maximumValue if inputMaximum consists only of digits (2)', function () {
      controller.set("inputMaximum", 1000);
      expect(controller.get('selectedMetric.maximumValue')).to.equal(1000);
    })
  });

  describe('#showHeatMapMetric()', function () {
    beforeEach(function () {
      controller.setProperties({
        activeWidgetLayout: Em.Object.create({
          displayName: 'widget',
          id: '1',
          scope: 'CLUSTER',
          layoutName: 'defualt_layout',
          sectionName: 'default_section'
        })
      });
    });

    it('should call App.ajax', function () {
      controller.showHeatMapMetric({context:{id: 2}});
      var args = testHelpers.findAjaxRequest('name', 'widget.layout.edit');
      expect(args).to.exists;
    });
  });

  describe('#rackClass', function () {

    beforeEach(function () {
      controller.setProperties({
        allMetrics: [],
        racks: [1]
      });
    });

    it('should return "span12" for 1 cluster rack', function () {
      expect(controller.get('rackClass')).to.equal('span12');
    });
    it('should return "span6" for 2 cluster racks', function () {
      controller.set('racks', [1, 2]);
      expect(controller.get('rackClass')).to.equal('span6');
    });
    it('should return "span4" for 3 cluster racks', function () {
      controller.set('racks', [1, 2, 3]);
      expect(controller.get('rackClass')).to.equal('span4');
    });
  });

  describe("#loadHeatmapsUrlParams", function() {

    it("content.serviceName is null", function() {
      controller.set('content', Em.Object.create({serviceName: null}));
      expect(controller.get('loadHeatmapsUrlParams')).to.equal('WidgetInfo/widget_type=HEATMAP&WidgetInfo/scope=CLUSTER&fields=WidgetInfo/metrics');
    });

    it("content.serviceName is correct", function() {
      controller.set('content', Em.Object.create({serviceName: 'S1'}));
      expect(controller.get('loadHeatmapsUrlParams')).to.equal('WidgetInfo/widget_type=HEATMAP&WidgetInfo/scope=CLUSTER&WidgetInfo/metrics.matches(.*\"service_name\":\"S1\".*)&fields=WidgetInfo/metrics');
    });
  });

  describe("#loadPageData()", function() {
    var allHeatmapData = {
      items: [
        {
          WidgetInfo: 'info'
        }
      ]
    };

    beforeEach(function(){
      sinon.stub(controller, 'loadRacks').returns({
        always: function(callback) {
          callback();
        }
      });
      sinon.stub(controller, 'getAllHeatMaps').returns({
        done: function(callback) {
          callback(allHeatmapData);
        }
      });
      sinon.stub(controller, 'resetPageData');
      sinon.stub(controller, 'categorizeByServiceName').returns('categories');
      sinon.stub(controller, 'getActiveWidgetLayout');
      controller.get('allHeatmaps').clear();
      controller.loadPageData();
    });

    afterEach(function() {
      controller.loadRacks.restore();
      controller.resetPageData.restore();
      controller.getAllHeatMaps.restore();
      controller.categorizeByServiceName.restore();
      controller.getActiveWidgetLayout.restore();
    });

    it("loadRacks() should be called", function() {
      expect(controller.loadRacks.calledOnce).to.be.true;
      expect(controller.resetPageData.calledOnce).to.be.true;
    });

    it("getAllHeatMaps() should be called", function() {
      expect(controller.getAllHeatMaps.calledOnce).to.be.true;
      expect(controller.get('isLoaded')).to.be.true;
      expect(controller.get('allHeatmaps')[0]).to.equal('info')
    });

    it("categorizeByServiceName() should be called", function() {
      expect(controller.categorizeByServiceName.calledOnce).to.be.true;
      expect(controller.get('heatmapCategories')).to.equal('categories');
    });

    it("getActiveWidgetLayout() should be called", function() {
      expect(controller.getActiveWidgetLayout.calledOnce).to.be.true;
    });
  });

  describe("#categorizeByServiceName()", function() {

    beforeEach(function() {
      sinon.stub(App.format, 'role').returns('S1');
    });

    afterEach(function() {
      App.format.role.restore();
    });

    it("single category", function() {
      var allHeatmaps = [
        {
          metrics: JSON.stringify([{service_name: 'S1'}])
        }
      ];
      var categories = controller.categorizeByServiceName(allHeatmaps);
      expect(categories[0].get('serviceName')).to.equal('S1');
      expect(categories[0].get('displayName')).to.equal('S1');
      expect(categories[0].get('heatmaps')).to.eql(allHeatmaps);
    });

    describe("two categories", function() {
      var allHeatmaps;
      beforeEach(function () {
        allHeatmaps = [
          {
            metrics: JSON.stringify([{service_name: 'S1'}])
          },
          {
            metrics: JSON.stringify([{service_name: 'S1'}])
          }
        ];
        this.categories = controller.categorizeByServiceName(allHeatmaps);
      });

      it('serviceName is S1', function () {
        expect(this.categories[0].get('serviceName')).to.equal('S1');
      });
      it('displayName is S1', function () {
        expect(this.categories[0].get('displayName')).to.equal('S1');
      });
      it('heatmaps.0 is valid', function () {
        expect(this.categories[0].get('heatmaps')[0]).to.eql(allHeatmaps[0]);
      });
      it('heatmaps.1 is valid', function () {
        expect(this.categories[0].get('heatmaps')[1]).to.eql(allHeatmaps[1]);
      });
    });
  });

  describe("#resetPageData()", function() {

    it("should clean heatmapCategories and allHeatmaps", function() {
      controller.set('heatmapCategories', [{}]);
      controller.set('allHeatmaps', [{}]);
      controller.resetPageData();
      expect(controller.get('heatmapCategories')).to.be.empty;
      expect(controller.get('allHeatmaps')).to.be.empty;
    });
  });

  describe("#getAllHeatMaps()", function() {

    it("should call App.ajax.send", function() {
      controller.reopen({
        loadHeatmapsUrlParams: 'url',
        sectionName: 's1'
      });
      controller.getAllHeatMaps();
      var args = testHelpers.findAjaxRequest('name', 'widgets.get');
      expect(args[0]).to.exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        urlParams: 'url',
        sectionName: 's1'
      });
    });
  });

  describe("#loadRacks()", function() {

    it("should call App.ajax.send", function() {
      controller.reopen({
        loadRacksUrlParams: 'url'
      });
      controller.loadRacks();
      var args = testHelpers.findAjaxRequest('name', 'hosts.heatmaps');
      expect(args[0]).to.exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        urlParams: 'url'
      });
    });
  });

  describe("#loadRacksSuccessCallback()", function() {

    var data = {
      items: [
        {
          Hosts: {
            host_name: 'host1',
            public_host_name: 'host1',
            os_type: 'os1',
            ip: 'ip1',
            rack_info: 'info'
          },
          host_components: [
            {
              HostRoles: {
                component_name: 'c1'
              }
            }
          ]
        }
      ]
    };

    beforeEach(function() {
      sinon.stub(controller, 'indexByRackId').returns({rack: {}});
      sinon.stub(controller, 'toList').returns(['rack']);
      controller.loadRacksSuccessCallback(data);
    });

    afterEach(function(){
      controller.indexByRackId.restore();
      controller.toList.restore();
    });

    it("indexByRackId should be called", function() {
      expect(controller.indexByRackId.calledWith([{
        hostName: 'host1',
        publicHostName: 'host1',
        osType: 'os1',
        ip: 'ip1',
        rack: 'info',
        diskTotal: 0,
        diskFree: 0,
        cpuSystem: 0,
        cpuUser: 0,
        memTotal: 0,
        memFree: 0,
        hostComponents: ['c1']
      }])).to.be.true;
    });

    it("toList should be called", function() {
      expect(controller.toList.calledWith({rack: {}})).to.be.true;
      expect(controller.get('rackMap')).to.eql({rack: {}});
      expect(controller.get('racks')).to.eql(['rack']);
    });
  });

  describe("#indexByRackId()", function() {

    it("should return rack map", function() {
      var hosts = [
        {rack: 'r1'},
        {rack: 'r1'}
      ];
      var rackMap = controller.indexByRackId(hosts);
      expect(rackMap.r1.name).to.equal('r1');
      expect(rackMap.r1.rackId).to.equal('r1');
      expect(rackMap.r1.hosts).to.eql([{rack: 'r1'}, {rack: 'r1'}]);
    });
  });

  describe("#toList()", function() {
    var rackMap = {'r1': {
      name: 'r1',
      rackId: 'r1',
      hosts: [{rack: 'r1'}, {rack: 'r1'}]
    }};

    it('toList result is valid', function() {
      expect(controller.toList(rackMap)).to.eql([Em.Object.create(rackMap.r1, {
        isLoaded: false,
        index: 0
      })]);
    });
  });

  describe("#addRackView()", function() {

    beforeEach(function() {
      sinon.stub(controller, 'displayAllRacks');
    });

    afterEach(function() {
      controller.displayAllRacks.restore();
    });

    it("displayAllRacks should be called", function() {
      controller.set('racks', [{}]);
      controller.set('rackViews', []);
      controller.addRackView({});
      expect(controller.displayAllRacks.calledOnce).to.be.true;
    });
  });

  describe("#displayAllRacks", function() {
    var rackView = {
      displayHosts: Em.K
    };

    beforeEach(function() {
      sinon.spy(controller, 'displayAllRacks');
      sinon.spy(rackView, 'displayHosts');
    });

    afterEach(function() {
      controller.displayAllRacks.restore();
      rackView.displayHosts.restore();
    });

    it("displayAllRacks should be called again", function() {
      controller.set('rackViews', [rackView]);
      controller.displayAllRacks();
      expect(controller.displayAllRacks.calledTwice).to.be.true;
      expect(rackView.displayHosts.calledOnce).to.be.true;
    });

    it("displayAllRacks should not be called again", function() {
      controller.set('rackViews', []);
      controller.displayAllRacks();
      expect(controller.displayAllRacks.calledOnce).to.be.true;
    });
  });


});


});

require.register("test/controllers/main/dashboard/config_history_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
var testHelpers = require('test/helpers');
require('controllers/main/dashboard/config_history_controller');

describe('MainConfigHistoryController', function () {

  var controller;

  beforeEach(function () {
    controller = App.MainConfigHistoryController.create();
  });

  afterEach(function () {
    clearTimeout(controller.get('timeoutRef'));
    controller.destroy();
  });

  describe('#realUrl', function () {
    it('cluster name is empty', function () {
      App.set('clusterName', '');
      expect(controller.get('realUrl')).to.equal('/api/v1/clusters//configurations/service_config_versions?<parameters>fields=service_config_version,user,group_id,group_name,is_current,createtime,service_name,hosts,service_config_version_note,is_cluster_compatible,stack_id&minimal_response=true');
    });
    it('cluster name is "mycluster"', function () {
      App.set('clusterName', 'mycluster');
      expect(controller.get('realUrl')).to.equal('/api/v1/clusters/mycluster/configurations/service_config_versions?<parameters>fields=service_config_version,user,group_id,group_name,is_current,createtime,service_name,hosts,service_config_version_note,is_cluster_compatible,stack_id&minimal_response=true');
    });
  });
  describe('#load()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'updateTotalCounter', Em.K);
      sinon.stub(controller, 'loadConfigVersionsToModel').returns({done: Em.K});
      controller.load();
    });

    afterEach(function () {
      controller.updateTotalCounter.restore();
      controller.loadConfigVersionsToModel.restore();
    });

    it('updateTotalCounter is called once', function () {
      expect(controller.updateTotalCounter.calledOnce).to.be.true;
    });
  });
  describe('#loadConfigVersionsToModel()', function () {

    beforeEach(function () {
      sinon.stub(App.HttpClient, 'get', Em.K);
      sinon.stub(controller, 'getUrl', Em.K);
      sinon.stub(controller, 'getQueryParameters', function(){
        return [1];
      });
      controller.loadConfigVersionsToModel();
    });

    afterEach(function () {
      controller.getUrl.restore();
      controller.getQueryParameters.restore();
      App.HttpClient.get.restore();
    });

    it('HttpClient.get is called once', function () {
      expect(App.HttpClient.get.calledOnce).to.be.true;
    });

    it('getQueryParameters is called once', function () {
      expect(controller.getQueryParameters.calledOnce).to.be.true;
    });

    it('getUrl is called with correct data', function () {
      expect(controller.getUrl.calledWith([1])).to.be.true;
    });
  });

  describe('#updateTotalCounter()', function () {

    beforeEach(function () {
      controller.updateTotalCounter();
    });

    it('ajax-request is sent', function () {
      var args = testHelpers.findAjaxRequest('name', 'service.serviceConfigVersions.get.total');
      expect(args).to.exists;
    });
  });

  describe('#updateTotalCounterSuccess()', function () {
    it('totalCount is updated', function () {
      controller.updateTotalCounterSuccess({itemTotal: 1});
      expect(controller.get('totalCount')).to.equal(1);
    });
  });
  describe('#getUrl()', function () {
    beforeEach(function () {
      sinon.stub(App.router, 'get', function () {
        return {
          computeParameters: function () {
            return 'params'
          }
        }
      });
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it('query params is empty', function () {

      expect(controller.getUrl()).to.equal('/api/v1/clusters/mycluster/configurations/service_config_versions?fields=service_config_version,user,group_id,group_name,is_current,createtime,service_name,hosts,service_config_version_note,is_cluster_compatible,stack_id&minimal_response=true');
    });
    it('query params is correct', function () {
      expect(controller.getUrl({})).to.equal('/api/v1/clusters/mycluster/configurations/service_config_versions?params&fields=service_config_version,user,group_id,group_name,is_current,createtime,service_name,hosts,service_config_version_note,is_cluster_compatible,stack_id&minimal_response=true');
    });
  });

  describe('#doPolling()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'load', function(){
        return {done: Em.K};
      });
      this.clock = sinon.useFakeTimers();
    });
    afterEach(function () {
      this.clock.restore();
      controller.load.restore();
    });
    it('isPolling false', function () {
      controller.set('isPolling', false);
      controller.doPolling();
      this.clock.tick(App.componentsUpdateInterval);
      expect(controller.load.called).to.be.false;
    });
    it('isPolling true', function () {
      controller.set('isPolling', true);
      controller.doPolling();
      this.clock.tick(App.componentsUpdateInterval);
      expect(controller.load.calledOnce).to.be.true;
    });
  });
});


});

require.register("test/controllers/main/dashboard_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
});

;require.register("test/controllers/main/host/addHost/step4_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');

describe('App.AddHostStep4Controller', function() {
  var controller;

  before(function() {
    controller = App.AddHostStep4Controller.create();
  });

  describe("#loadConfigGroups()", function () {

    it("App.ajax.send should be called", function() {
      controller.loadConfigGroups();
      var args = testHelpers.filterAjaxRequests('name', 'config_groups.all_fields');
      expect(args[0][0]).to.eql({
        name: 'config_groups.all_fields',
        sender: controller,
        success: 'successLoadingConfigGroup',
        error: 'errorLoadingConfigGroup'
      });
    });
  });

  describe('#successLoadingConfigGroup()', function() {
    before(function() {
      controller.successLoadingConfigGroup({items: [{}]});
    });
    it('should set config groups on succeeded request', function() {
      expect(App.router.get('addHostController.content.configGroups')).to.eql([{}]);
    });
    it('should set `isConfigGroupLoaded` to true', function() {
      expect(controller.get('isConfigGroupLoaded')).to.true;
    });
  });
  
  describe('#errorLoadingConfigGroup()', function() {
    before(function() {
      controller.errorLoadingConfigGroup();
    });
    it('should set config groups on failed request', function() {
      expect(App.router.get('addHostController.content.configGroups')).to.eql([]);
    });
    it('should set `isConfigGroupLoaded` to true', function() {
      expect(controller.get('isConfigGroupLoaded')).to.true;
    });
  });
});

});

require.register("test/controllers/main/host/add_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/wizard');
require('controllers/main/host/add_controller');
require('models/host_component');
require('models/service');
require('mappers/server_data_mapper');
var testHelpers = require('test/helpers');

describe('App.AddHostController', function () {

  var controller = App.AddHostController.create({
    testDBHosts: null,
    getDBProperty: function () {
      return this.get('testDBHosts');
    },
    setDBProperty: function () {
    },
    loadClients: function () {
    }
  });

  describe('#removeHosts()', function () {
    var testCases = [
      {
        title: 'No hosts, db is empty',
        content: {
          hosts: [],
          dbHosts: {}
        },
        result: {}
      },
      {
        title: 'Host is passed, db is empty',
        content: {
          hosts: [
            {name: 'host1'}
          ],
          dbHosts: {}
        },
        result: {}
      },
      {
        title: 'Passed host different from hosts in db',
        content: {
          hosts: [
            {name: 'host1'}
          ],
          dbHosts: {
            'host2': {}
          }
        },
        result: {
          'host2': {}
        }
      },
      {
        title: 'Passed host match host in db',
        content: {
          hosts: [
            {name: 'host1'}
          ],
          dbHosts: {
            'host1': {}
          }
        },
        result: {}
      }
    ];
    beforeEach(function () {
      sinon.spy(controller, "setDBProperty");
    });
    afterEach(function () {
      controller.setDBProperty.restore();
    });
    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('testDBHosts', test.content.dbHosts);
        controller.removeHosts(test.content.hosts);
        expect(controller.setDBProperty.calledWith('hosts', test.result)).to.be.true;
      });
    });
  });

  describe('#sortServiceConfigGroups()', function () {
    var testCases = [
      {
        title: 'No selected services',
        selectedServices: [
          {configGroups: []}
        ],
        result: [
          {configGroups: []}
        ]
      },
      {
        title: 'Only one group is present',
        selectedServices: [
          {configGroups: [
            {configGroups: {group_name: 'b'}}
          ]}
        ],
        result: [
          {configGroups: [
            {configGroups: {group_name: 'b'}}
          ]}
        ]
      },
      {
        title: 'Reverse order of groups',
        selectedServices: [
          {configGroups: [
            {ConfigGroup: {group_name: 'b2'}},
            {ConfigGroup: {group_name: 'a1'}}
          ]}
        ],
        result: [
          {configGroups: [
            {ConfigGroup: {group_name: 'a1'}},
            {ConfigGroup: {group_name: 'b2'}}
          ]}
        ]
      },
      {
        title: 'Correct order of groups',
        selectedServices: [
          {configGroups: [
            {ConfigGroup: {group_name: 'a1'}},
            {ConfigGroup: {group_name: 'b2'}}
          ]}
        ],
        result: [
          {configGroups: [
            {ConfigGroup: {group_name: 'a1'}},
            {ConfigGroup: {group_name: 'b2'}}
          ]}
        ]
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.sortServiceConfigGroups(test.selectedServices);
        expect(test.selectedServices).to.eql(test.result);
      });
    });
  });

  describe('#loadServiceConfigGroupsBySlaves()', function () {
    var testCases = [
      {
        title: 'slaveComponentHosts is null',
        slaveComponentHosts: null,
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'slaveComponentHosts is empty',
        slaveComponentHosts: [],
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'Component does not have hosts',
        slaveComponentHosts: [
          {hosts: []}
        ],
        result: {
          output: true,
          selectedServices: []
        }
      },
      {
        title: 'Only client component is present',
        slaveComponentHosts: [
          {
            hosts: [
              {hostName: 'host1'}
            ],
            componentName: 'CLIENT'
          }
        ],
        result: {
          output: true,
          selectedServices: []
        }
      }
    ];

    controller.set('content.configGroups', [
      {
        ConfigGroup: {
          tag: 'HDFS',
          group_name: 'HDFS test'
        }
      }
    ]);
    testCases.forEach(function (test) {
      it(test.title, function () {
        var selectedServices = [];
        controller.set('content.slaveComponentHosts', test.slaveComponentHosts);
        expect(controller.loadServiceConfigGroupsBySlaves(selectedServices)).to.equal(test.result.output);
        expect(selectedServices).to.eql(test.result.selectedServices);
      });
    });
  });

  describe('#loadServiceConfigGroupsByClients()', function () {
    var testCases = [
      {
        title: 'slaveComponentHosts is null',
        content: {
          slaveComponentHosts: null,
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'slaveComponentHosts is empty',
        content: {
          slaveComponentHosts: [],
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'Client does not have hosts',
        content: {
          slaveComponentHosts: [
            {
              componentName: 'CLIENT',
              hosts: []
            }
          ],
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'Client has hosts, but clients is empty',
        content: {
          slaveComponentHosts: [
            {
              componentName: 'CLIENT',
              hosts: [
                {hostName: 'host1'}
              ]
            }
          ],
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('content.slaveComponentHosts', test.content.slaveComponentHosts);
        controller.set('content.clients', test.content.clients);
        expect(controller.loadServiceConfigGroupsByClients(test.content.selectedServices)).to.equal(test.result.output);
        expect(test.content.selectedServices).to.eql(test.result.selectedServices);
      });
    });
  });

  describe('#installServices()', function () {

    it('No hosts', function () {
      controller.set('content.cluster', {name: 'cl'});
      controller.set('testDBHosts', {});
      expect(controller.installServices()).to.be.false;
      var args = testHelpers.findAjaxRequest('name', 'common.host_components.update');
      expect(args).to.not.exists;
    });
    it('Cluster name is empty', function () {
      controller.set('content.cluster', {name: ''});
      controller.set('testDBHosts', {'host1': {}});
      expect(controller.installServices()).to.be.false;
      var args = testHelpers.findAjaxRequest('name', 'common.host_components.update');
      expect(args).to.not.exists;
    });
    it('Cluster name is correct and hosts are present', function () {
      controller.set('content.cluster', {name: 'cl'});
      controller.set('testDBHosts', {'host1': {isInstalled: false}});
      expect(controller.installServices()).to.be.true;
      var args = testHelpers.findAjaxRequest('name', 'common.host_components.update');
      expect(args).to.exists;
    });
  });

  describe('#getClientsToInstall', function () {
    var services = [
      Em.Object.create({
        serviceName: 'service1'
      }),
      Em.Object.create({
        serviceName: 'service2'
      })
    ];
    var components = [
      Em.Object.create({
        componentName: 'comp1',
        displayName: 'comp1',
        serviceName: 'service1',
        isClient: true
      }),
      Em.Object.create({
        componentName: 'comp2',
        displayName: 'comp2',
        serviceName: 'service1',
        isClient: true
      }),
      Em.Object.create({
        componentName: 'comp3',
        displayName: 'comp3',
        serviceName: 'service2',
        isClient: false
      }),
      Em.Object.create({
        componentName: 'comp4',
        displayName: 'comp4',
        serviceName: 'service3',
        isClient: true
      })
    ];
    var clients = [
      {
        component_name: 'comp1',
        display_name: 'comp1',
        isInstalled: false
      },
      {
        component_name: 'comp2',
        display_name: 'comp2',
        isInstalled: false
      }
    ];
    it("generatel list of clients to install", function () {
      expect(controller.getClientsToInstall(services, components)).to.eql(clients);
    })
  });

  describe("#setCurrentStep()", function () {
    before(function () {
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
      sinon.stub(App.db, 'setWizardCurrentStep', Em.K);
    });
    after(function () {
      App.clusterStatus.setClusterStatus.restore();
      App.db.setWizardCurrentStep.restore();
    });
    it("call App.clusterStatus.setClusterStatus()", function () {
      controller.setCurrentStep();
      expect(App.clusterStatus.setClusterStatus.getCall(0).args[0].wizardControllerName).to.be.equal('addHostController');
    });
  });

  describe("#getCluster()", function () {
    before(function () {
      sinon.stub(App.router, 'getClusterName').returns('c1');
    });
    after(function () {
      App.router.getClusterName.restore();
    });
    it("cluster data is valid", function () {
      controller.set('clusterStatusTemplate', {'prop': 'clusterStatusTemplate'});
      expect(controller.getCluster()).to.be.eql({
        prop: 'clusterStatusTemplate',
        name: 'c1'
      });
    });
  });

  /*describe("#loadServices", function () {
    var services = {
      db: null,
      stack: [],
      model: []
    };

    beforeEach(function () {
      sinon.stub(controller, 'getDBProperty', function () {
        return services.db;
      });
      sinon.stub(App.StackService, 'find', function () {
        return services.stack;
      });
      sinon.stub(App.Service, 'find', function () {
        return services.model;
      });
      sinon.stub(controller, 'setDBProperty', Em.K);
    });

    afterEach(function () {
      controller.getDBProperty.restore();
      App.StackService.find.restore();
      App.Service.find.restore();
      controller.setDBProperty.restore();
    });

    Em.A([
      {
        m: 'No services in db, no installed services',
        service: {
          db: null,
          stack: [Em.Object.create({
            serviceName: 'S1'
          })],
          model: []
        },
        e: {

          db: ['services',
            {
              selectedServices: [],
              installedServices: []
            }
          ],
          services: [
            Em.Object.create({
              serviceName: 'S1',
              isInstalled: false,
              isSelected: false
            })
          ]
        }
      },
      {
        m: 'No services in db, installed service present',
        service: {
          db: null,
          stack: [
            Em.Object.create({
              serviceName: 'S1'
            }),
            Em.Object.create({
              serviceName: 'S2'
            })
          ],
          model: [
            Em.Object.create({
              serviceName: 'S1'
            })
          ]
        },
        e: {
          db: ['services',
            {
              selectedServices: ['S1'],
              installedServices: ['S1']
            }
          ],
          services: [
            Em.Object.create({
              serviceName: 'S1',
              isInstalled: true,
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'S2',
              isInstalled: false,
              isSelected: false
            })
          ]
        }
      },
      {
        m: 'DB is empty',
        service: {
          db: {
            selectedServices: [],
            installedServices: []
          },
          stack: [Em.Object.create({
            serviceName: 'S1'
          })],
          model: []
        },
        e: {
          db: false,
          services: [
            Em.Object.create({
              serviceName: 'S1',
              isSelected: false,
              isInstalled: false
            })
          ]
        }
      },
      {
        m: 'DB has selected and installed services',
        service: {
          db: {
            selectedServices: ['S1'],
            installedServices: ['S2']
          },
          stack: [
            Em.Object.create({
              serviceName: 'S1'
            }),
            Em.Object.create({
              serviceName: 'S2'
            })
          ],
          model: []
        },
        e: {
          db: false,
          services: [
            Em.Object.create({
              serviceName: 'S1',
              isInstalled: false,
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'S2',
              isInstalled: true,
              isSelected: false
            })
          ]
        }
      }
    ]).forEach(function (test) {

      describe(test.m, function () {

        beforeEach(function () {
          services = test.service;
          controller.loadServices();
        });

        it('services are valid', function () {
          expect(controller.get('content.services')).to.be.eql(test.e.services);
        });

        if (test.e.db) {
          it('setDBProperty is called with valid arguments', function () {
            expect(controller.setDBProperty.getCall(0).args).to.eql(test.e.db);
          });
        }
        else {
          it('setDBProperty is not called', function () {
            expect(controller.setDBProperty.called).to.be.false;
          });
        }

      });

    });

  });
*/
  describe("#loadSlaveComponentHosts()", function () {

    var mock = {
      hosts: null,
      slaveComponentHosts: null
    };

    beforeEach(function () {
      sinon.stub(controller, 'getDBProperties', function (propsList) {
        var ret = {};
        propsList.forEach(function(k) {
          ret[k] = mock[k];
        });
        return ret;
      });
    });

    afterEach(function () {
      controller.getDBProperties.restore();
    });

    it("No slaveComponentHosts in db, null", function () {
      controller.loadSlaveComponentHosts();
      expect(controller.get('content.slaveComponentHosts')).to.be.empty;
    });

    it("No slaveComponentHosts in db", function () {
      mock.slaveComponentHosts = [];
      controller.loadSlaveComponentHosts();
      expect(controller.get('content.slaveComponentHosts')).to.be.empty;
    });

    it("One slaveComponent without hosts", function () {
      mock.slaveComponentHosts = [
        {hosts: []}
      ];
      mock.hosts = {};
      controller.loadSlaveComponentHosts();
      expect(controller.get('content.slaveComponentHosts')).to.be.eql([
        {hosts: []}
      ]);
    });

    it("One slaveComponent with host", function () {
      mock.slaveComponentHosts = [
        {hosts: [
          {host_id: 1}
        ]}
      ];
      mock.hosts = {'host1': {id: 1}};
      controller.loadSlaveComponentHosts();
      expect(controller.get('content.slaveComponentHosts')).to.be.eql([
        {hosts: [
          {
            host_id: 1,
            hostName: 'host1'
          }
        ]}
      ]);
    });

  });

  describe("#saveClients()", function () {
    beforeEach(function () {
      sinon.stub(App.StackServiceComponent, 'find').returns('StackServiceComponent');
      sinon.stub(controller, 'getClientsToInstall').returns(['client']);
      sinon.stub(controller, 'setDBProperty', Em.K);
      controller.set('content.services', [Em.Object.create({'isSelected': true, 'isInstallable': true})]);
      controller.saveClients();
    });
    afterEach(function () {
      controller.setDBProperty.restore();
      App.StackServiceComponent.find.restore();
      controller.getClientsToInstall.restore();
    });
    it("getClientsToInstall called with valid arguments", function () {
      expect(controller.getClientsToInstall.calledWith(
        [Em.Object.create({'isSelected': true, 'isInstallable': true})],
        'StackServiceComponent'
      )).to.be.true;
    });
    it('setDBProperty called with valid arguments', function () {
      expect(controller.setDBProperty.calledWith('clientInfo', ['client'])).to.be.true;
    });
    it('content.clients are valid', function () {
      expect(controller.get('content.clients')).to.be.eql(['client']);
    });
  });

  describe("#getClientsToInstall()", function () {
    var testCases = [
      {
        title: 'No services',
        data: {
          services: [],
          components: []
        },
        result: []
      },
      {
        title: 'No components',
        data: {
          services: [
            {}
          ],
          components: []
        },
        result: []
      },
      {
        title: 'Component is not client',
        data: {
          services: [Em.Object.create({serviceName: 'S1'})],
          components: [Em.Object.create({serviceName: 'S1'})]
        },
        result: []
      },
      {
        title: 'Component is not client',
        data: {
          services: [Em.Object.create({serviceName: 'S1'})],
          components: [Em.Object.create({serviceName: 'S1', isClient: false})]
        },
        result: []
      },
      {
        title: 'Component is client',
        data: {
          services: [Em.Object.create({serviceName: 'S1'})],
          components: [Em.Object.create({
            serviceName: 'S1',
            isClient: true,
            componentName: 'C1',
            displayName: 'C1'
          })]
        },
        result: [
          {
            component_name: 'C1',
            display_name: 'C1',
            isInstalled: false
          }
        ]
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.getClientsToInstall(test.data.services, test.data.components)).to.eql(test.result);
      });
    });
  });

  describe("#applyConfigGroup()", function () {

    it("No config groups", function () {
      controller.set('content.configGroups', []);
      controller.applyConfigGroup();
      var args = testHelpers.findAjaxRequest('name', 'config_groups.update_config_group');
      expect(args).to.not.exists;
    });
    it("selectedConfigGroup absent", function () {
      controller.set('content.configGroups', [
        {
          configGroups: [],
          selectedConfigGroup: ''
        }
      ]);
      controller.applyConfigGroup();
      var args = testHelpers.findAjaxRequest('name', 'config_groups.update_config_group');
      expect(args).to.not.exists;
    });
    it("selectedConfigGroup present", function () {
      controller.set('content.configGroups', [
        {
          configGroups: [
            {
              ConfigGroup: {
                id: 1,
                group_name: 'G1',
                hosts: []
              }
            }
          ],
          selectedConfigGroup: 'G1',
          hosts: ['host1']
        }
      ]);
      controller.applyConfigGroup();
      var args = testHelpers.findAjaxRequest('name', 'config_groups.update_config_group');
      expect(args[0]).to.exists;
      expect(args[0].data).to.be.eql({
        "id": 1,
        "configGroup": {
          "ConfigGroup": {
            "id": 1,
            "group_name": "G1",
            "hosts": [
              {
                "host_name": "host1"
              }
            ]
          }
        }
      });
    });
  });

  describe("#getServiceConfigGroups()", function () {
    before(function () {
      sinon.stub(controller, 'getDBProperty').withArgs('serviceConfigGroups').returns(['serviceConfigGroup']);
    });
    after(function () {
      controller.getDBProperty.restore();
    });
    it("content.configGroups are valid", function () {
      controller.getServiceConfigGroups();
      expect(controller.get('content.configGroups')).to.eql(['serviceConfigGroup']);
    });
  });

  describe("#saveServiceConfigGroups()", function () {
    before(function () {
      sinon.stub(controller, 'setDBProperty', Em.K);
    });
    after(function () {
      controller.setDBProperty.restore();
    });
    it("call setDBProperty()", function () {
      controller.set('content.configGroups', [
        {}
      ]);
      controller.saveServiceConfigGroups();
      expect(controller.setDBProperty.calledWith('serviceConfigGroups', [
        {}
      ])).to.be.true;
    });
  });

  describe("#loadServiceConfigGroups()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'loadServiceConfigGroupsBySlaves', Em.K);
      sinon.stub(controller, 'loadServiceConfigGroupsByClients', Em.K);
      sinon.stub(controller, 'sortServiceConfigGroups', Em.K);
      controller.loadServiceConfigGroups();
    });
    afterEach(function () {
      controller.loadServiceConfigGroupsBySlaves.restore();
      controller.loadServiceConfigGroupsByClients.restore();
      controller.sortServiceConfigGroups.restore();
    });
    it("loadServiceConfigGroupsByClients called with []", function () {
      expect(controller.loadServiceConfigGroupsByClients.calledWith([])).to.be.true;
    });
    it('loadServiceConfigGroupsBySlaves called with []', function () {
      expect(controller.loadServiceConfigGroupsBySlaves.calledWith([])).to.be.true;
    });
    it('sortServiceConfigGroups called with []', function () {
      expect(controller.sortServiceConfigGroups.calledWith([])).to.be.true;
    });
    it('content.configGroups are empty', function () {
      expect(controller.get('content.configGroups')).to.eql([]);
    })
  });

  describe("#sortServiceConfigGroups", function () {
    var testCases = [
      {
        title: 'sorted',
        selectedServices: [
          {
            configGroups: [
              {
                ConfigGroup: {
                  group_name: 'a'
                }
              },
              {
                ConfigGroup: {
                  group_name: 'b'
                }
              }
            ]
          }
        ],
        result: ['a', 'b']
      },
      {
        title: 'not sorted',
        selectedServices: [
          {
            configGroups: [
              {
                ConfigGroup: {
                  group_name: 'b'
                }
              },
              {
                ConfigGroup: {
                  group_name: 'a'
                }
              }
            ]
          }
        ],
        result: ['a', 'b']
      },
      {
        title: 'sort equal',
        selectedServices: [
          {
            configGroups: [
              {
                ConfigGroup: {
                  group_name: 'a'
                }
              },
              {
                ConfigGroup: {
                  group_name: 'a'
                }
              }
            ]
          }
        ],
        result: ['a', 'a']
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.sortServiceConfigGroups(test.selectedServices);
        expect(test.selectedServices[0].configGroups.mapProperty('ConfigGroup.group_name')).to.eql(test.result);
      });
    });
  });

  describe("#loadServiceConfigGroupsBySlaves()", function () {
    beforeEach(function () {
      sinon.stub(App.StackServiceComponent, 'find').returns(Em.Object.create({
        stackService: Em.Object.create({
          serviceName: 'S1',
          displayName: 's1'
        })
      }));
      controller.set('content.configGroups', [
        {
          ConfigGroup: {
            tag: 'S1',
            group_name: 'G1'
          }
        }
      ]);
    });
    afterEach(function () {
      App.StackServiceComponent.find.restore();
    });
    it("slaveComponentHosts is empty", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', []);
      expect(controller.loadServiceConfigGroupsBySlaves(selectedServices)).to.be.false;
      expect(selectedServices).to.be.empty;
    });
    it("slaveComponentHosts has ho hosts", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', [
        {hosts: []}
      ]);
      expect(controller.loadServiceConfigGroupsBySlaves(selectedServices)).to.be.true;
      expect(selectedServices).to.be.empty;
    });
    it("slaveComponentHosts is CLIENT", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', [
        {
          hosts: [
            {hostName: 'host1'}
          ],
          componentName: 'CLIENT'
        }
      ]);
      expect(controller.loadServiceConfigGroupsBySlaves(selectedServices)).to.be.true;
      expect(selectedServices).to.be.empty;
    });
    it("slaveComponentHosts is slave", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', [
        {
          hosts: [
            {hostName: 'host1'}
          ],
          componentName: 'C1'
        },
        {
          hosts: [
            {hostName: 'host2'}
          ],
          componentName: 'C2'
        }
      ]);
      expect(controller.loadServiceConfigGroupsBySlaves(selectedServices)).to.be.true;
      expect(selectedServices.toArray()).to.eql([
        {
          "serviceId": "S1",
          "displayName": "s1",
          "hosts": [
            "host1",
            "host2"
          ],
          "configGroupsNames": [
            "Default",
            "G1"
          ],
          "configGroups": [
            {
              "ConfigGroup": {
                "tag": "S1",
                "group_name": "G1"
              }
            }
          ],
          "selectedConfigGroup": "Default"
        }
      ]);
    });
  });

  describe("#loadServiceConfigGroupsByClients()", function () {
    beforeEach(function () {
      sinon.stub(App.StackServiceComponent, 'find').returns(Em.Object.create({
        stackService: Em.Object.create({
          serviceName: 'S1',
          displayName: 's1'
        })
      }));
      sinon.stub(controller, 'loadClients', Em.K);
      controller.set('content.configGroups', [
        {
          ConfigGroup: {
            tag: 'S1',
            group_name: 'G1'
          }
        }
      ]);
    });
    afterEach(function () {
      controller.loadClients.restore();
      App.StackServiceComponent.find.restore();
    });
    it("Clients is null", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', null);
      controller.set('content.clients', null);

      expect(controller.loadServiceConfigGroupsByClients(selectedServices)).to.be.false;
      expect(selectedServices).to.be.empty;
    });
    it("No CLIENT component", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', []);
      controller.set('content.clients', []);

      expect(controller.loadServiceConfigGroupsByClients(selectedServices)).to.be.false;
      expect(selectedServices).to.be.empty;
    });
    it("Clients is empty", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', [
        {
          componentName: 'CLIENT',
          hosts: []
        }
      ]);
      controller.set('content.clients', []);

      expect(controller.loadServiceConfigGroupsByClients(selectedServices)).to.be.false;
      expect(selectedServices).to.be.empty;
    });
    it("Client component does not have hosts", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', [
        {
          componentName: 'CLIENT',
          hosts: []
        }
      ]);
      controller.set('content.clients', [
        {}
      ]);

      expect(controller.loadServiceConfigGroupsByClients(selectedServices)).to.be.false;
      expect(selectedServices).to.be.empty;
    });
    it("Client present, selectedServices is empty", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', [
        {
          componentName: 'CLIENT',
          hosts: [
            {hostName: 'host1'}
          ]
        }
      ]);
      controller.set('content.clients', [
        {
          component_name: 'C1'
        }
      ]);

      expect(controller.loadServiceConfigGroupsByClients(selectedServices)).to.be.true;
      expect(selectedServices).to.be.eql([
        {
          "serviceId": "S1",
          "displayName": "s1",
          "hosts": [
            "host1"
          ],
          "configGroupsNames": [
            "Default",
            "G1"
          ],
          "configGroups": [
            {
              "ConfigGroup": {
                "tag": "S1",
                "group_name": "G1"
              }
            }
          ],
          "selectedConfigGroup": "Default"
        }
      ]);
    });
    it("Client present, selectedServices has service", function () {
      var selectedServices = [
        {
          serviceId: 'S1',
          hosts: ['host1', 'host2']
        }
      ];
      controller.set('content.slaveComponentHosts', [
        {
          componentName: 'CLIENT',
          hosts: [
            {hostName: 'host1'}
          ]
        }
      ]);
      controller.set('content.clients', [
        {
          component_name: 'C1'
        }
      ]);

      expect(controller.loadServiceConfigGroupsByClients(selectedServices)).to.be.true;
      expect(selectedServices[0].hosts).to.be.eql(["host1", "host2"]);
    });
  });

  describe("#loadServiceConfigProperties()", function () {
    beforeEach(function () {
      this.mock = sinon.stub(App.db, 'get');
      this.mock.withArgs('Installer', 'serviceConfigProperties').returns([1]);
    });
    afterEach(function () {
      this.mock.restore();
    });
    it("serviceConfigProperties is null", function () {
      this.mock.withArgs('AddService', 'serviceConfigProperties').returns(null);
      controller.loadServiceConfigProperties();
      expect(controller.get('content.serviceConfigProperties')).to.eql([1]);
    });
    it("serviceConfigProperties is empty", function () {
      this.mock.withArgs('AddService', 'serviceConfigProperties').returns([]);
      controller.loadServiceConfigProperties();
      expect(controller.get('content.serviceConfigProperties')).to.eql([1]);
    });
    it("serviceConfigProperties has data", function () {
      this.mock.withArgs('AddService', 'serviceConfigProperties').returns([1]);
      controller.loadServiceConfigProperties();
      expect(controller.get('content.serviceConfigProperties')).to.eql([1]);
    });
  });

  describe("#clearAllSteps()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'clearInstallOptions', Em.K);
      sinon.stub(controller, 'getCluster').returns({});
      controller.clearAllSteps();
    });
    afterEach(function () {
      controller.clearInstallOptions.restore();
      controller.getCluster.restore();
    });
    it("getCluster called once", function () {
      expect(controller.getCluster.calledOnce).to.be.true;
    });
    it('clearInstallOptions called once', function () {
      expect(controller.clearInstallOptions.calledOnce).to.be.true;
    });
    it('content.cluster is empty object', function () {
      expect(controller.get('content.cluster')).to.eql({});
    });
  });

  describe("#clearStorageData()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'resetDbNamespace', Em.K);
    });
    afterEach(function () {
      controller.resetDbNamespace.restore();
    });
    it("launch resetDbNamespace", function () {
      controller.clearStorageData();
      expect(controller.resetDbNamespace.calledOnce).to.be.true;
    });
  });

  describe("#finish()", function () {
    var mock = {
      updateAll: Em.K,
      getAllHostNames: Em.K
    };
    beforeEach(function () {
      sinon.stub(controller, 'clearAllSteps', Em.K);
      sinon.stub(controller, 'clearStorageData', Em.K);
      sinon.stub(App.router, 'get').returns(mock);
      sinon.spy(mock, 'updateAll');
      sinon.spy(mock, 'getAllHostNames');
      controller.finish();
    });
    afterEach(function () {
      controller.clearAllSteps.restore();
      controller.clearStorageData.restore();
      App.router.get.restore();
      mock.updateAll.restore();
      mock.getAllHostNames.restore();
    });
    it("clearAllSteps called once", function () {
      expect(controller.clearAllSteps.calledOnce).to.be.true;
    });
    it('clearStorageData called once', function () {
      expect(controller.clearStorageData.calledOnce).to.be.true;
    });
    it('updateAll called once', function () {
      expect(mock.updateAll.calledOnce).to.be.true;
    });
    it('App.updater.immediateRun called with valid arguments', function () {
      expect(App.updater.immediateRun.calledWith('updateHost')).to.be.true;
    });
    it('getAllHostNames called once', function () {
      expect(mock.getAllHostNames.calledOnce).to.be.true;
    });
  });
});

});

require.register("test/controllers/main/host/bulk_operations_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('BulkOperationsController', function () {

  var hostController;

  describe('#bulkOperation', function() {

    beforeEach(function() {
      hostController = App.BulkOperationsController.create({});
      sinon.stub(hostController, 'bulkOperationForHostsRestart', Em.K);
      sinon.stub(hostController, 'bulkOperationForHosts', Em.K);
      sinon.stub(hostController, 'bulkOperationForHostsReinstall', Em.K);
      sinon.stub(hostController, 'bulkOperationForHostComponentsRestart', Em.K);
      sinon.stub(hostController, 'bulkOperationForHostComponentsDecommission', Em.K);
      sinon.stub(hostController, 'bulkOperationForHostComponents', Em.K);
      sinon.stub(hostController, 'bulkOperationForHostComponentsAdd', Em.K);
      sinon.stub(hostController, 'bulkOperationForHostsPassiveState', Em.K);
    });

    afterEach(function() {
      hostController.bulkOperationForHosts.restore();
      hostController.bulkOperationForHostsRestart.restore();
      hostController.bulkOperationForHostsReinstall.restore();
      hostController.bulkOperationForHostComponentsRestart.restore();
      hostController.bulkOperationForHostComponentsDecommission.restore();
      hostController.bulkOperationForHostComponents.restore();
      hostController.bulkOperationForHostComponentsAdd.restore();
      hostController.bulkOperationForHostsPassiveState.restore();

    });

    it('RESTART for hosts', function() {
      var operationData = {
        action: 'RESTART'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostsRestart.calledOnce).to.equal(true);
    });

    it('START for hosts', function() {
      var operationData = {
        action: 'STARTED'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHosts.calledOnce).to.equal(true);
    });

    it('STOP for hosts', function() {
      var operationData = {
        action: 'INSTALLED'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHosts.calledOnce).to.equal(true);
    });

    it('REINSTALL for hosts', function() {
      var operationData = {
        action: 'REINSTALL'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostsReinstall.calledOnce).to.equal(true);
    });

    it('PASSIVE_STATE for hosts', function() {
      var operationData = {
        action: 'PASSIVE_STATE'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostsPassiveState.calledOnce).to.equal(true);
    });

    it('RESTART for hostComponents', function() {
      var operationData = {
        action: 'RESTART',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponentsRestart.calledOnce).to.equal(true);
    });

    it('START for hostComponents', function() {
      var operationData = {
        action: 'STARTED',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponents.calledOnce).to.equal(true);
    });

    it('STOP for hostComponents', function() {
      var operationData = {
        action: 'INSTALLED',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponents.calledOnce).to.equal(true);
    });

    it('ADD for hostComponents', function() {
      var operationData = {
        action: 'ADD',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponentsAdd.calledOnce).to.equal(true);
    });

    it('DECOMMISSION for hostComponents', function() {
      var operationData = {
        action: 'DECOMMISSION',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponentsDecommission.calledOnce).to.equal(true);
    });

    it('RECOMMISSION for hostComponents', function() {
      var operationData = {
        action: 'DECOMMISSION_OFF',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponentsDecommission.calledOnce).to.equal(true);
    });

  });

  describe('#warnBeforeDecommissionSuccess()', function () {
    var mock = {
      showHbaseActiveWarning: Em.K,
      checkRegionServerState: Em.K
    };
    beforeEach(function () {
      hostController = App.BulkOperationsController.create({});
      sinon.stub(App.router, 'get', function () {
        return mock;
      });
      sinon.spy(mock, 'showHbaseActiveWarning');
      sinon.spy(mock, 'checkRegionServerState');
    });
    afterEach(function () {
      App.router.get.restore();
      mock.showHbaseActiveWarning.restore();
      mock.checkRegionServerState.restore();
    });

    it('items length more than 0', function () {
      hostController.warnBeforeDecommissionSuccess({items: [1]}, {}, {});
      expect(mock.showHbaseActiveWarning.calledOnce).to.be.true;
    });
    it('items length equal 0', function () {
      hostController.warnBeforeDecommissionSuccess({items: []}, {}, {hostNames: 'host1'});
      expect(mock.checkRegionServerState.calledWith('host1')).to.be.true;
    });
  });

});

});

require.register("test/controllers/main/host/configs_service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/host/configs_service');


describe('App.MainHostServiceConfigsController', function () {

  var controller = App.MainHostServiceConfigsController.create({
    host: Em.Object.create()
  });


  describe('#filterServiceConfigs()', function () {
    var testCases = [
      {
        title: 'configCategories is empty',
        content: {
          configCategories: [],
          hostComponents: []
        },
        result: []
      },
      {
        title: 'Category hostComponentNames is null',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: null})
          ],
          hostComponents: []
        },
        result: [
          Em.Object.create({hostComponentNames: null})
        ]
      },
      {
        title: 'Components of host are empty',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: ['comp1']})
          ],
          hostComponents: []
        },
        result: []
      },
      {
        title: 'Host components do not match component of categories',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: ['comp1']})
          ],
          hostComponents: [
            {
              componentName: 'comp2'
            }
          ]
        },
        result: []
      },
      {
        title: 'Host components match component of categories',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: ['comp1']})
          ],
          hostComponents: [
            {
              componentName: 'comp1'
            }
          ]
        },
        result: [
          Em.Object.create({hostComponentNames: ['comp1']})
        ]
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('host.hostComponents', test.content.hostComponents);
        expect(controller.filterServiceConfigs(test.content.configCategories)).to.eql(test.result);
      });
    });
  });

	describe("#loadStep()", function () {
    beforeEach(function() {
      sinon.stub(App.themesMapper, 'generateAdvancedTabs', Em.K);
      sinon.stub(controller, 'loadCurrentVersions', Em.K);
      sinon.stub(controller, 'loadConfigTheme', function() {
        return { always: Em.K };
      });
      sinon.stub(controller, 'trackRequest');
    });
    afterEach(function() {
      controller.loadCurrentVersions.restore();
      controller.loadConfigTheme.restore();
      App.themesMapper.generateAdvancedTabs.restore();
      controller.trackRequest.restore();
    });
		it("should set host", function () {
			controller.set('content', {
				host: 'host1',
        dependentServiceNames: []
			});
			controller.loadStep();
			expect(controller.get('host')).to.be.equal('host1');
		});
	});

	describe("#renderServiceConfigs()", function () {

    beforeEach(function () {
      sinon.stub(controller, 'filterServiceConfigs', function () {
        this._super = Em.K;
      });
    });

    afterEach(function () {
      controller.filterServiceConfigs.restore();
    });

		it("should call filterServiceConfigs", function () {
			var serviceConfigs = {
				configCategories: 'val'
			};
			controller.renderServiceConfigs(serviceConfigs);
			expect(controller.filterServiceConfigs.calledWith('val')).to.be.true;
		});
	});

	describe("#switchHostGroup()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'launchSwitchConfigGroupOfHostDialog', Em.K);
      });

    afterEach(function () {
      controller.launchSwitchConfigGroupOfHostDialog.restore();
    });

		it("should call launchSwitchConfigGroupOfHostDialog", function () {
			controller.set('selectedConfigGroup', {});
			controller.set('configGroups', []);
			controller.set('host', {hostName: 'host1'});
			controller.switchHostGroup();

			expect(controller.launchSwitchConfigGroupOfHostDialog.calledWith({}, [], 'host1')).to.be.true;
		});
	});

});

});

require.register("test/controllers/main/host/details_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/host/details');
require('models/service');
require('models/host_component');
require('models/host_stack_version');
var batchUtils = require('utils/batch_scheduled_requests');
var hostsManagement = require('utils/hosts');
var testHelpers = require('test/helpers');
var controller;

function getController() {
  return App.MainHostDetailsController.create(App.InstallComponent, {
    content: Em.Object.create({
      hostComponents: []
    })
  });
}
describe('App.MainHostDetailsController', function () {

  beforeEach(function () {
    controller = getController();
  });

  App.TestAliases.testAsComputedFilterBy(getController(), 'serviceNonClientActiveComponents', 'serviceActiveComponents', 'isClient', false);

  describe('#routeHome()', function () {

    beforeEach(function () {
      sinon.stub(App.router, 'transitionTo', Em.K);
    });

    afterEach(function () {
      App.router.transitionTo.restore();
    });

    it('transition to dashboard', function () {
      controller.routeHome();
      expect(App.router.transitionTo.calledWith('main.dashboard.index')).to.be.true;
    });
  });

  describe('#startComponent()', function () {

    var event = {
      context: Em.Object.create({
        displayName: 'comp'
      })
    };

    beforeEach(function () {
      sinon.stub(App, 'showConfirmationPopup', function (callback) {
        callback();
      });
      sinon.stub(controller, 'sendComponentCommand');
      controller.startComponent(event);
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.sendComponentCommand.restore();
    });

    it('configmation popup is shown', function () {
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
    });

    it('call sendComponentCommand', function () {
      expect(controller.sendComponentCommand.calledWith(Em.Object.create({
        displayName: 'comp'
      })), Em.I18n.t('requestInfo.startHostComponent') + " comp", App.HostComponentStatus.started).to.be.true;

    });
  });

  describe('#stopComponent()', function () {

    beforeEach(function () {
      sinon.stub(App, 'showConfirmationPopup', Em.clb);
      sinon.stub(controller, 'checkNnLastCheckpointTime', Em.clb);
      sinon.stub(controller, 'sendComponentCommand');
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.sendComponentCommand.restore();
      controller.checkNnLastCheckpointTime.restore();
    });

    it('call sendComponentCommand', function () {
      var event = {
        context: Em.Object.create({
          displayName: 'comp'
        })
      };
      controller.stopComponent(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      expect(controller.sendComponentCommand.calledWith(Em.Object.create({
        displayName: 'comp'
      })), Em.I18n.t('requestInfo.stopHostComponent') + " comp", App.HostComponentStatus.stopped).to.be.true;
    });
    it('stop NN, should check last NN checkpoint before stop', function () {
      var event = {
        context: Em.Object.create({
          displayName: 'NameNode',
          componentName: 'NAMENODE'
        })
      };
      controller.stopComponent(event);
      expect(controller.checkNnLastCheckpointTime.calledOnce).to.be.true;
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      expect(controller.sendComponentCommand.calledWith(event.context, Em.I18n.t('requestInfo.stopHostComponent') + " NameNode", App.HostComponentStatus.stopped)).to.be.true;
    });
  });

  describe("#pullNnCheckPointTime()", function() {
    it("valid request is sent", function() {
      controller.pullNnCheckPointTime('host1');
      var args = testHelpers.findAjaxRequest('name', 'common.host_component.getNnCheckPointTime');
      expect(args[0]).to.exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        host: 'host1'
      });
    });
  });

  describe('#sendComponentCommand()', function () {

    describe('single component', function () {
      var component;
      beforeEach(function () {
        controller.set('content.hostName', 'host1');
        component = Em.Object.create({
          service: {serviceName: 'S1'},
          componentName: 'COMP1'
        });

        controller.sendComponentCommand(component, {}, 'state');
      });

      it('1st call endpoint is valid', function () {
        var args = testHelpers.findAjaxRequest('name', 'common.host.host_component.update');
        expect(args).to.exists;
      });

      it('1st call data is valid', function () {
        var args = testHelpers.findAjaxRequest('name', 'common.host.host_component.update');
        expect(args[0]).to.exists;
        expect(args[0].data).to.be.eql({
          "hostName": "host1",
          "context": {},
          "component": component,
          "HostRoles": {
            "state": "state"
          },
          "componentName": "COMP1",
          "serviceName": "S1"
        });
      });
    });

    describe('multiple component', function () {
      var component;
      beforeEach(function () {
        controller.set('content.hostName', 'host1');
        component = [
          Em.Object.create({
            service: {serviceName: 'S1'},
            componentName: 'COMP1'
          }),
          Em.Object.create({
            service: {serviceName: 'S1'},
            componentName: 'COMP2'
          })
        ];
        controller.sendComponentCommand(component, {}, 'state');
      });

      it('1st call endpoint is valid', function () {
        var args = testHelpers.findAjaxRequest('name', 'common.host.host_components.update');
        expect(args).exists;
      });

      it('1st call data is valid', function () {
        var args = testHelpers.findAjaxRequest('name', 'common.host.host_components.update');
        expect(args[0]).exists;
        expect(args[0].data).to.be.eql({
          "hostName": "host1",
          "context": {},
          "component": component,
          "HostRoles": {
            "state": "state"
          },
          "query": "HostRoles/component_name.in(COMP1,COMP2)"
        });
      });
    });

  });

  describe('#sendComponentCommandSuccessCallback()', function () {

    var params = {
      component: Em.Object.create({}),
      HostRoles: {
        state: App.HostComponentStatus.stopped
      }
    };

    beforeEach(function () {
      sinon.stub(controller, 'mimicWorkStatusChange', Em.K);
      sinon.stub(controller, 'showBackgroundOperationsPopup', Em.K);
      controller.sendComponentCommandSuccessCallback({}, {}, params);
    });

    afterEach(function () {
      controller.showBackgroundOperationsPopup.restore();
      controller.mimicWorkStatusChange.restore();
    });

    it('mimicWorkStatusChange is not called', function () {
      expect(controller.mimicWorkStatusChange.called).to.be.false;
    });
    it('showBackgroundOperationsPopup is called once', function () {
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#ajaxErrorCallback()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'ajaxErrorCallback', Em.K);
    });
    afterEach(function () {
      controller.ajaxErrorCallback.restore();
    });
    it('call mainServiceItemController.ajaxErrorCallback', function () {
      controller.ajaxErrorCallback('request', 'ajaxOptions', 'error', 'opt', 'params');
      expect(controller.ajaxErrorCallback.calledWith('request', 'ajaxOptions', 'error', 'opt', 'params')).to.be.true;
    });
  });

  describe('#showBackgroundOperationsPopup()', function () {
    var mock = {
      done: function (callback) {
        callback(this.initValue);
      }
    };
    var bgController = {
      showPopup: Em.K
    };

    beforeEach(function () {
      var stub = sinon.stub(App.router, 'get');
      stub.withArgs('userSettingsController').returns({
        dataLoading: function () {
          return mock;
        }
      });
      stub.withArgs('backgroundOperationsController').returns(bgController);
      sinon.spy(bgController, 'showPopup');
      sinon.spy(mock, 'done');
      this.callback = sinon.stub();
    });

    afterEach(function () {
      bgController.showPopup.restore();
      mock.done.restore();
      App.router.get.restore();
    });

    it('initValue is true, callback is undefined', function () {
      mock.initValue = true;
      controller.showBackgroundOperationsPopup();
      expect(mock.done.calledOnce).to.be.true;
      expect(bgController.showPopup.calledOnce).to.be.true;
    });

    it('initValue is false, callback is defined', function () {
      mock.initValue = false;
      controller.showBackgroundOperationsPopup(this.callback);
      expect(mock.done.calledOnce).to.be.true;
      expect(bgController.showPopup.calledOnce).to.be.false;
      expect(this.callback.calledOnce).to.be.true;
    });
  });

  describe('#serviceActiveComponents', function () {

    it('No host-components', function () {
      controller.set('content', {hostComponents: []});
      expect(controller.get('serviceActiveComponents')).to.be.empty;
    });

    it('No host-components in active state', function () {
      controller.set('content', {
        hostComponents: [Em.Object.create({
          service: {
            isInPassive: true
          }
        })]
      });
      expect(controller.get('serviceActiveComponents')).to.be.empty;
    });
    it('Host-components in active state', function () {
      controller.set('content', {
        hostComponents: [Em.Object.create({
          service: {
            isInPassive: false
          }
        })]
      });
      expect(controller.get('serviceActiveComponents')).to.eql([Em.Object.create({
        service: {
          isInPassive: false
        }
      })]);
    });
  });

  describe('#serviceNonClientActiveComponents', function () {

    it('No active host-components', function () {
      controller.reopen({
        serviceActiveComponents: []
      });
      controller.set('serviceActiveComponents', []);
      expect(controller.get('serviceNonClientActiveComponents')).to.be.empty;
    });

    it('Active host-component is client', function () {
      controller.reopen({
        serviceActiveComponents: [Em.Object.create({
          isClient: true
        })]
      });
      expect(controller.get('serviceNonClientActiveComponents')).to.be.empty;
    });
    it('Active host-component is not client', function () {
      controller.reopen({
        serviceActiveComponents: [Em.Object.create({
          isClient: false
        })]
      });
      expect(controller.get('serviceNonClientActiveComponents')).to.eql([Em.Object.create({
        isClient: false
      })]);
    });
  });

  describe.skip('#deleteComponent()', function () {

    var jQueryMock,
      cases = [
        {
          isDisabled: false,
          showCallCount: 1,
          title: 'confirm popup should be displayed'
        },
        {
          isDisabled: true,
          showCallCount: 0,
          title: 'confirm popup shouldn\'t be displayed'
        }
      ];

    beforeEach(function () {
      jQueryMock = sinon.stub(window, '$');
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(controller, '_doDeleteHostComponent', Em.K);
    });

    afterEach(function () {
      jQueryMock.restore();
      App.ModalPopup.show.restore();
      controller._doDeleteHostComponent.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        jQueryMock.returns({
          closest: function () {
            return {
              hasClass: function () {
                return item.isDisabled;
              }
            }
          }
        });
        var event = {
            context: Em.Object.create({})
          },
          popup = controller.deleteComponent(event);
        expect(App.ModalPopup.show.callCount).to.equal(item.showCallCount);
        if (item.showCallCount) {
          popup.onPrimary();
          expect(controller._doDeleteHostComponent.calledWith(Em.Object.create({}))).to.be.true;
        }
      });
    });

  });

  describe('#mimicWorkStatusChange()', function () {

    var clock;
    beforeEach(function () {
      clock = sinon.useFakeTimers();
    });
    afterEach(function () {
      clock.restore();
    });

    it('change status of object', function () {
      var entity = Em.Object.create({
        workStatus: ''
      });
      controller.mimicWorkStatusChange(entity, 'STATE1', 'STATE2');
      expect(entity.get('workStatus')).to.equal('STATE1');
      clock.tick(App.testModeDelayForActions);
      expect(entity.get('workStatus')).to.equal('STATE2');
    });
    it('change status of objects in array', function () {
      var entity = [Em.Object.create({
        workStatus: ''
      })];
      controller.mimicWorkStatusChange(entity, 'STATE1', 'STATE2');
      expect(entity[0].get('workStatus')).to.equal('STATE1');
      clock.tick(App.testModeDelayForActions);
      expect(entity[0].get('workStatus')).to.equal('STATE2');
    });
  });

  describe('#upgradeComponent()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it('confirm popup should be displayed', function () {
      var popup = controller.upgradeComponent({context: Em.Object.create()});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      var args = testHelpers.findAjaxRequest('name', 'host.host_component.upgrade');
      expect(args).exists;
    });
  });

  describe('#restartComponent()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(batchUtils, "restartHostComponents", Em.K);
      sinon.stub(controller, 'checkNnLastCheckpointTime', Em.clb);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      batchUtils.restartHostComponents.restore();
      controller.checkNnLastCheckpointTime.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.restartComponent({context: Em.Object.create({'displayName': 'Comp1'})});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(batchUtils.restartHostComponents.calledOnce).to.be.true;
    });

    it('restart NN, should check last NN checkpoint before restart', function () {
      var event = {
        context: Em.Object.create({
          displayName: 'NameNode',
          componentName: 'NAMENODE'
        })
      };
      controller.restartComponent(event);
      expect(controller.checkNnLastCheckpointTime.calledOnce).to.equal(true);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
    });
  });

  describe('#addComponent()', function () {
    var cases = [
      {
        componentName: 'ZOOKEEPER_SERVER',
        showAddComponentPopupCallCount: 1,
        showConfirmationPopupCallCount: 0
      },
      {
        componentName: 'RESOURCEMANAGER',
        showAddComponentPopupCallCount: 1,
        showConfirmationPopupCallCount: 0
      },
      {
        componentName: 'JOURNALNODE',
        showAddComponentPopupCallCount: 0,
        showConfirmationPopupCallCount: 1
      },
      {
        componentName: 'HIVE_CLIENT',
        showAddComponentPopupCallCount: 1,
        showConfirmationPopupCallCount: 0
      }
    ];
    beforeEach(function () {
      sinon.stub(controller, "checkComponentDependencies", Em.K);
      sinon.stub(controller, "showAddComponentPopup", Em.K);
      sinon.stub(controller, "clearConfigsChanges", Em.K);
      sinon.stub(App, "showConfirmationPopup", Em.K);
      controller.set('content', {
        hostComponents: [Em.Object.create({
          componentName: "HDFS_CLIENT"
        })]
      });
    });

    afterEach(function () {
      controller.checkComponentDependencies.restore();
      controller.showAddComponentPopup.restore();
      controller.clearConfigsChanges.restore();
      App.showConfirmationPopup.restore();
    });

    cases.forEach(function (testCase) {

      describe('add ' + testCase.componentName, function () {

        beforeEach(function () {
          var event = {
            context: Em.Object.create({
              componentName: testCase.componentName
            })
          };
          controller.addComponent(event);
        });

        it('controller.showAddComponentPopup', function () {
          expect(controller.showAddComponentPopup.callCount).to.equal(testCase.showAddComponentPopupCallCount);
        });

        it('App.showConfirmationPopup', function () {
          expect(App.showConfirmationPopup.callCount).to.equal(testCase.showConfirmationPopupCallCount);
        });

      });

    });

  });

  describe("#loadOozieConfigs()", function() {
    it("valid request is sent", function() {
      controller.loadOozieConfigs({Clusters: {
        desired_configs: {
          'oozie-env': {
            tag: 'tag'
          }
        }
      }});
      var args = testHelpers.findAjaxRequest('name', 'admin.get.all_configurations');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        urlParams: '(type=oozie-env&tag=tag)'
      });
    });
  });

  describe("#loadStormConfigs()", function() {
    it("valid request is sent", function() {
      controller.loadStormConfigs({Clusters: {
        desired_configs: {
          'storm-site': {
            tag: 'tag'
          }
        }
      }}, null, {});
      var args = testHelpers.findAjaxRequest('name', 'admin.get.all_configurations');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        urlParams: '(type=storm-site&tag=tag)'
      });
    });
  });

  describe("#onLoadStormConfigs()", function() {

    var data = {items: [
      {
        type: 'storm-site',
        properties: {
          'nimbus.seeds': ''
        }
      }
    ]};

    beforeEach(function () {
      sinon.stub(controller, 'getStormNimbusHosts').returns("host1");
      sinon.stub(controller, 'updateZkConfigs', Em.K);
      sinon.stub(controller, 'saveConfigsBatch', Em.K);
      sinon.stub(controller, 'saveLoadedConfigs', Em.K);
      controller.set('nimbusHost', 'host2');
      controller.onLoadStormConfigs(data);
    });
    afterEach(function () {
      controller.getStormNimbusHosts.restore();
      controller.updateZkConfigs.restore();
      controller.saveConfigsBatch.restore();
      controller.saveLoadedConfigs.restore();
    });
    it("updateZkConfigs called with valid arguments", function() {
      expect(controller.updateZkConfigs.calledWith({'storm-site': {
        'nimbus.seeds': "'host1'"
      }})).to.be.true;
    });
    it('saveConfigsBatch called with valid arguments', function () {
      expect(controller.saveConfigsBatch.calledWith([
        {
          properties: {
            'storm-site': {
              'nimbus.seeds': "'host1'"
            }
          },
          properties_attributes: {
            'storm-site': {}
          }
        }
      ], 'NIMBUS', 'host2')).to.be.true;
    });
  });

  describe("#loadHiveConfigs()", function() {
    it("valid request is sent", function() {
      controller.loadHiveConfigs({Clusters: {
        desired_configs: {
          'hive-site': {
            tag: 'tag'
          },
          'webhcat-site': {
            tag: 'tag'
          },
          'hive-env': {
            tag: 'tag'
          },
          'core-site': {
            tag: 'tag'
          }
        }
      }}, null, {});
      var args = testHelpers.findAjaxRequest('name', 'admin.get.all_configurations');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        urlParams: '(type=hive-site&tag=tag)|(type=webhcat-site&tag=tag)|(type=hive-env&tag=tag)|(type=core-site&tag=tag)'
      });
    });
  });

  describe("#loadRangerConfigs()", function() {
    it("valid request is sent", function() {
      controller.loadRangerConfigs({Clusters: {
        desired_configs: {
          'hdfs-site': {
            tag: 'tag'
          },
          'kms-env': {
            tag: 'tag'
          },
          'core-site': {
            tag: 'tag'
          }
        }
      }}, null, {});
      var args = testHelpers.findAjaxRequest('name', 'admin.get.all_configurations');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        urlParams: '(type=core-site&tag=tag)|(type=hdfs-site&tag=tag)|(type=kms-env&tag=tag)'
      });
    });
  });

  describe("#getRangerKMSServerHosts()", function() {
    beforeEach(function(){
      sinon.stub(App.HostComponent, 'find').returns([{
        componentName: 'RANGER_KMS_SERVER',
        hostName: 'host1'
      }]);
      controller.set('rangerKMSServerHost', 'host2');
      controller.set('content.hostName', 'host1');
      controller.set('deleteRangerKMSServer', true);
      controller.set('fromDeleteHost', true);
      this.hosts = controller.getRangerKMSServerHosts();
    });
    afterEach(function(){
      App.HostComponent.find.restore();
    });
    it('hosts list is valid', function() {
      expect(this.hosts).to.eql(['host2']);
    });
    it('rangerKMSServerHost is empty', function () {
      expect(controller.get('rangerKMSServerHost')).to.be.empty;
    });
    it('deleteRangerKMSServer is false', function () {
      expect(controller.get('deleteRangerKMSServer')).to.be.false;
    });
    it('fromDeleteHost is false', function () {
      expect(controller.get('fromDeleteHost')).to.be.false;
    });
  });

  describe("#getStormNimbusHosts()", function() {
    beforeEach(function(){
      sinon.stub(App.HostComponent, 'find').returns([{
        componentName: 'NIMBUS',
        hostName: 'host1'
      }]);
      controller.set('nimbusHost', 'host2');
      controller.set('content.hostName', 'host1');
      controller.set('deleteNimbusHost', true);
      controller.set('fromDeleteHost', true);
      this.hosts = controller.getStormNimbusHosts();
    });
    afterEach(function(){
      App.HostComponent.find.restore();
    });
    it("hosts list is valid", function() {
      expect(this.hosts).to.eql(['host2']);
    });
    it('nimbusHost is empty', function () {
      expect(controller.get('nimbusHost')).to.be.empty;
    });
    it('deleteNimbusHost is false', function () {
      expect(controller.get('deleteNimbusHost')).to.be.false;
    });
    it('fromDeleteHost is false', function () {
      expect(controller.get('fromDeleteHost')).to.be.false;
    });
  });

  describe('#showAddComponentPopup()', function () {

    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('should display add component confirmation', function () {
      controller.showAddComponentPopup(Em.Object.create());
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe('#installNewComponentSuccessCallback()', function () {

    beforeEach(function () {
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
    });
    afterEach(function () {
      controller.showBackgroundOperationsPopup.restore();
    });

    it('data is null', function () {
      expect(controller.installNewComponentSuccessCallback(null, {}, {})).to.be.false;
      expect(controller.showBackgroundOperationsPopup.called).to.be.false;
    });
    it('data.Requests is null', function () {
      var data = {Requests: null};
      expect(controller.installNewComponentSuccessCallback(data, {}, {})).to.be.false;
      expect(controller.showBackgroundOperationsPopup.called).to.be.false;
    });
    it('data.Requests.id is null', function () {
      var data = {Requests: {id: null}};
      expect(controller.installNewComponentSuccessCallback(data, {}, {})).to.be.false;
      expect(controller.showBackgroundOperationsPopup.called).to.be.false;
    });
    it('data.Requests.id is correct', function () {
      var data = {Requests: {id: 1}};
      expect(controller.installNewComponentSuccessCallback(data, {}, {component: []})).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#refreshComponentConfigs()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "sendRefreshComponentConfigsCommand", Em.K);
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.sendRefreshComponentConfigsCommand.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.refreshComponentConfigs({context: Em.Object.create({'displayName': 'Comp1'})});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.sendRefreshComponentConfigsCommand.calledOnce).to.be.true;
    });
  });

  describe('#sendRefreshComponentConfigsCommand()', function () {
    it('Query should be sent', function () {
      var component = Em.Object.create({
        service: {},
        componentName: 'COMP1',
        host: {}
      });
      controller.sendRefreshComponentConfigsCommand(component, {});
      var args = testHelpers.findAjaxRequest('name', 'host.host_component.refresh_configs');
      expect(args[0]).exists;
    });
  });

  describe('#loadConfigs()', function () {
    it('Query should be sent', function () {
      controller.loadConfigs();
      var args = testHelpers.findAjaxRequest('name', 'config.tags');
      expect(args).exists;
    });
  });

  describe('#constructConfigUrlParams()', function () {

    function loadService(serviceName) {
      App.store.safeLoad(App.Service, {
        id: serviceName,
        service_name: serviceName
      });
    }

    var data = {
      Clusters: {
        desired_configs: {
          'core-site': {
            tag: 1
          },
          'hbase-site': {
            tag: 1
          },
          'webhcat-site': {
            tag: 1
          },
          'hive-site': {
            tag: 1
          },
          'storm-site': {
            tag: 1
          },
          'yarn-site': {
            tag: 1
          },
          'zoo.cfg': {
            tag: 1
          },
          'accumulo-site': {
            tag: 1
          },
          'application-properties': {
            tag: 1
          }
        }
      }
    };

    afterEach(function () {
      App.Service.find().clear();
    });

    it('URL params should be empty', function () {
      App.Service.find().clear();
      expect(controller.constructConfigUrlParams(data)).to.eql([]);
    });

    it('isHaEnabled = true', function () {
      loadService('HDFS');

      App.HostComponent.find().clear();
      App.propertyDidChange('isHaEnabled');
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=core-site&tag=1)']);
      App.store.safeLoad(App.HostComponent, {
        id: 'SECONDARY_NAMENODE_host1',
        component_name: 'SECONDARY_NAMENODE'
      });
    });

    it('HBASE is installed', function () {
      loadService('HBASE');
      App.propertyDidChange('isHaEnabled');
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=hbase-site&tag=1)']);
    });

    it('HIVE is installed', function () {
      loadService('HIVE');
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=hive-site&tag=1)', '(type=webhcat-site&tag=1)']);
    });

    it('STORM is installed', function () {
      loadService('STORM');
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=storm-site&tag=1)']);
    });

    it('YARN is installed', function () {
      loadService('YARN');
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=yarn-site&tag=1)', '(type=zoo.cfg&tag=1)']);
    });

    it('ACCUMULO is installed', function () {
      loadService('ACCUMULO');
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=accumulo-site&tag=1)']);
    });

    it('ATLAS is installed, AMBARI_INFRA isn\'t installed', function () {
      loadService('ATLAS');
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=application-properties&tag=1)']);
    });
  });

  describe('#loadConfigsSuccessCallback()', function () {
    var mockUrlParams = [];
    beforeEach(function () {
      sinon.stub(controller, "constructConfigUrlParams", function () {
        return mockUrlParams;
      });
    });
    afterEach(function () {
      controller.constructConfigUrlParams.restore();
    });

    it('url params is empty', function () {
      expect(controller.loadConfigsSuccessCallback(null, null, {})).to.be.false;
      var args = testHelpers.findAjaxRequest('name', 'reassign.load_configs');
      expect(args).not.exists;
    });
    it('url params are correct', function () {
      mockUrlParams = ['param1'];
      var args = testHelpers.findAjaxRequest('name', 'reassign.load_configs');
      expect(args).exists;
    });
    it('isConfigsLoadingInProgress is false', function () {
      mockUrlParams = [];
      controller.set('isConfigsLoadingInProgress', true);
      controller.loadConfigsSuccessCallback(null, null, {});
      expect(controller.get('isConfigsLoadingInProgress')).to.be.false;
    });
  });

  describe('#saveZkConfigs()', function () {

    var data = {
      items: [
        {
          type: 'yarn-site',
          properties: {
            p: 'ys'
          },
          properties_attributes: {
            p: 'pa_ys'
          }
        },
        {
          type: 'hive-site',
          properties: {
            hs: 'hs'
          },
          properties_attributes: {
            hs: 'pa_hs'
          }
        },
        {
          type: 'webhcat-site',
          properties: {
            ws: 'ws'
          },
          properties_attributes: {
            ws: 'pa_ws'
          }
        },
        {
          type: 'hbase-site',
          properties: {
            hbs: 'hbs'
          },
          properties_attributes: {
            hbs: 'pa_hbs'
          }
        },
        {
          type: 'accumulo-site',
          properties: {
            as: 'as'
          },
          properties_attributes: {
            as: 'pa_as'
          }
        }
      ]
    };

    beforeEach(function () {
      sinon.stub(controller, 'saveConfigsBatch', Em.K);
      sinon.stub(controller, 'updateZkConfigs', Em.K);
      sinon.stub(controller, 'saveLoadedConfigs', Em.K);
      sinon.stub(App.Service, 'find', function() {
        return [
          Em.Object.create({ serviceName: 'HIVE' }),
          Em.Object.create({ serviceName: 'YARN' }),
          Em.Object.create({ serviceName: 'HBASE' }),
          Em.Object.create({ serviceName: 'ACCUMULO' })
        ];
      });

      controller.saveZkConfigs(data);
      this.groups = controller.saveConfigsBatch.args[0][0];
    });
    afterEach(function () {
      App.Service.find.restore();
      controller.updateZkConfigs.restore();
      controller.saveConfigsBatch.restore();
      controller.saveLoadedConfigs.restore();
    });

    it('configs for YARN', function () {
      var expected = {
        properties: {
          'yarn-site': {
            p: 'ys'
          }
        },
        properties_attributes: {
          'yarn-site': {
            p: 'pa_ys'
          }
        }
      };
      expect(this.groups[1]).to.be.eql(expected);
    });

    it('configs for HIVE', function () {
      var expected = {
        "properties": {
          "hive-site": {
            "hs": "hs"
          },
          "webhcat-site": {
            "ws": "ws"
          }
        },
        "properties_attributes": {
          "hive-site": {
            "hs": "pa_hs"
          },
          "webhcat-site": {
            "ws": "pa_ws"
          }
        }
      };
      expect(this.groups[0]).to.be.eql(expected);
    });

    it('configs for HBASE', function () {
      var expected = {
        "properties": {
          "hbase-site": {
            "hbs": "hbs"
          }
        },
        "properties_attributes": {
          "hbase-site": {
            "hbs": "pa_hbs"
          }
        }
      };
      expect(this.groups[2]).to.be.eql(expected);
    });

    it('configs for ACCUMULO', function () {
      var expected = {
        "properties": {
          "accumulo-site": {
            "as": "as"
          }
        },
        "properties_attributes": {
          "accumulo-site": {
            "as": "pa_as"
          }
        }
      };
      expect(this.groups[3]).to.be.eql(expected);
    });

  });

  describe("#saveConfigsBatch()", function () {
    it("no groups", function () {
      controller.saveConfigsBatch([]);
      var args = testHelpers.filterAjaxRequests('name', 'common.service.configurations');
      expect(args).to.be.empty;
    });
    it("configs is empty", function () {
      controller.saveConfigsBatch([{}]);
      var args = testHelpers.filterAjaxRequests('name', 'common.service.configurations');
      expect(args).to.be.empty;
    });
    it("configs is correct", function () {
      controller.saveConfigsBatch([{'properties': {'site': {}}, 'properties_attributes': {'site': {}}}]);
      var args = testHelpers.filterAjaxRequests('name', 'common.service.configurations');
      expect(args).to.have.property('length').equal(1);
    });
  });

  describe('#updateZkConfigs()', function () {
    var makeHostComponentModel = function(componentName, hostNames) {
      return hostNames.map(function(hostName) {
        return {
          componentName: componentName,
          hostName: hostName
        };
      });
    };

    var tests = [
      {
        appGetterStubs: {
          isHaEnabled: true
        },
        hostComponentModel: makeHostComponentModel('ZOOKEEPER_SERVER', ['host1', 'host2']),
        configs: {
          "core-site": {
            "ha.zookeeper.quorum": "host2:8080"
          }
        },
        m: 'NameNode HA enabled, ha.zookeeper.quorum config should be updated',
        e: {
          configs: {
            "core-site": {
              "ha.zookeeper.quorum": "host1:2181,host2:2181"
            }
          }
        }
      },
      {
        appGetterStubs: {
          isHaEnabled: false
        },
        hostComponentModel: makeHostComponentModel('ZOOKEEPER_SERVER', ['host1', 'host2']),
        configs: {
          "core-site": {
            "ha.zookeeper.quorum": "host3:8080"
          }
        },
        m: 'NameNode HA disabled, ha.zookeeper.quorum config should be untouched',
        e: {
          configs: {
            "core-site": {
              "ha.zookeeper.quorum": "host3:8080"
            }
          }
        }
      },
      {
        hostComponentModel: makeHostComponentModel('ZOOKEEPER_SERVER', ['host1', 'host2']),
        configs: {
          "hbase-site": {
            "hbase.zookeeper.quorum": "host3"
          }
        },
        m: 'hbase.zookeeper.quorum property update test',
        e: {
          configs: {
            "hbase-site": {
              "hbase.zookeeper.quorum": "host1,host2"
            }
          }
        }
      },
      {
        hostComponentModel: makeHostComponentModel('ZOOKEEPER_SERVER', ['host1', 'host2']),
        ctrlStubs: {
          'content.hostName': 'host2',
          fromDeleteHost: true
        },
        configs: {
          "zoo.cfg": {
            "clientPort": "1919"
          },
          "accumulo-site": {
            "instance.zookeeper.host": "host3:2020"
          }
        },
        m: 'instance.zookeeper.host property update test, zookeper marked to delete from host2',
        e: {
          configs: {
            "zoo.cfg": {
              "clientPort": "1919"
            },
            "accumulo-site": {
              "instance.zookeeper.host": "host1:1919"
            }
          }
        }
      },
      {
        hostComponentModel: makeHostComponentModel('ZOOKEEPER_SERVER', ['host1', 'host2']),
        configs: {
          "webhcat-site": {
            "templeton.zookeeper.hosts": "host3:2020"
          }
        },
        m: 'templeton.zookeeper.hosts property update test',
        e: {
          configs: {
            "webhcat-site": {
              "templeton.zookeeper.hosts": "host1:2181,host2:2181"
            }
          }
        }
      },
      {
        hostComponentModel: makeHostComponentModel('ZOOKEEPER_SERVER', ['host1', 'host2']),
        configs: {
          "hive-site": {
            "hive.cluster.delegation.token.store.zookeeper.connectString": "host3:2020"
          }
        },
        m: 'hive.cluster.delegation.token.store.zookeeper.connectString property update test',
        e: {
          configs: {
            "hive-site": {
              "hive.cluster.delegation.token.store.zookeeper.connectString": "host1:2181,host2:2181"
            }
          }
        }
      },
      {
        hostComponentModel: makeHostComponentModel('ZOOKEEPER_SERVER', ['host1', 'host2']),
        configs: {
          "storm-site": {
            "storm.zookeeper.servers": "['host3','host2']"
          }
        },
        m: 'storm.zookeeper.servers property update test',
        e: {
          configs: {
            "storm-site": {
              "storm.zookeeper.servers": "['host1','host2']"
            }
          }
        }
      },
      {
        appGetterStubs: {
          isRMHaEnabled: true
        },
        hostComponentModel: makeHostComponentModel('ZOOKEEPER_SERVER', ['host1', 'host2']),
        configs: {
          "yarn-site": {
            "yarn.resourcemanager.zk-address": "host3:2181"
          }
        },
        m: 'yarn.resourcemanager.zk-address property, ResourceManager HA enabled. Property value should be changed.',
        e: {
          configs: {
            "yarn-site": {
              "yarn.resourcemanager.zk-address": "host1:2181,host2:2181"
            }
          }
        }
      },
      {
        appGetterStubs: {
          currentStackVersionNumber: '2.2'
        },
        hostComponentModel: makeHostComponentModel('ZOOKEEPER_SERVER', ['host1', 'host2']),
        configs: {
          "hive-site": {
            "hive.zookeeper.quorum": "host3:2181"
          }
        },
        m: 'hive.zookeeper.quorum property, current stack version is 2.2 property should be updated.',
        e: {
          configs: {
            "hive-site": {
              "hive.zookeeper.quorum": "host1:2181,host2:2181"
            }
          }
        }
      },
      {
        appGetterStubs: {
          currentStackVersionNumber: '2.2'
        },
        hostComponentModel: makeHostComponentModel('ZOOKEEPER_SERVER', ['host1', 'host2']),
        configs: {
          "yarn-site": {
            "hadoop.registry.zk.quorum": "host3:2181"
          }
        },
        m: 'hadoop.registry.zk.quorum property, current stack version is 2.2 property should be changed.',
        e: {
          configs: {
            "yarn-site": {
              "hadoop.registry.zk.quorum": "host1:2181,host2:2181"
            }
          }
        }
      },
      {
        m: 'ATLAS configs',
        hostComponentModel: makeHostComponentModel('ZOOKEEPER_SERVER', ['host1', 'host2']),
        configs: {
          'application-properties': {
            'atlas.audit.hbase.zookeeper.quorum': '',
            'atlas.graph.index.search.solr.zookeeper-url': '',
            'atlas.graph.storage.hostname': '',
            'atlas.kafka.zookeeper.connect': ''
          }
        },
        e: {
          configs: {
            'application-properties': {
              'atlas.audit.hbase.zookeeper.quorum': 'host1,host2',
              'atlas.graph.index.search.solr.zookeeper-url': 'host1:2181/ambari-solr,host2:2181/ambari-solr',
              'atlas.graph.storage.hostname': 'host1,host2',
              'atlas.kafka.zookeeper.connect': 'host1:2181,host2:2181'
            }
          }
        }
      },
      {
        m: 'ATLAS configs with custom solr',
        hostComponentModel: makeHostComponentModel('ZOOKEEPER_SERVER', ['host1', 'host2']),
        configs: {
          'infra-solr-env': {
            'infra_solr_znode': '/custom-solr'
          },
          'application-properties': {
            'atlas.audit.hbase.zookeeper.quorum': '',
            'atlas.graph.index.search.solr.zookeeper-url': '',
            'atlas.graph.storage.hostname': '',
            'atlas.kafka.zookeeper.connect': ''
          }
        },
        e: {
          configs: {
            'infra-solr-env': {
              'infra_solr_znode': '/custom-solr'
            },
            'application-properties': {
              'atlas.audit.hbase.zookeeper.quorum': 'host1,host2',
              'atlas.graph.index.search.solr.zookeeper-url': 'host1:2181/custom-solr,host2:2181/custom-solr',
              'atlas.graph.storage.hostname': 'host1,host2',
              'atlas.kafka.zookeeper.connect': 'host1:2181,host2:2181'
            }
          }
        }
      }
    ];

    tests.forEach(function(test) {
      describe(test.m, function() {

        beforeEach(function() {
          if (test.appGetterStubs) {
            Em.keys(test.appGetterStubs).forEach(function(key) {
              sinon.stub(App, 'get').withArgs(key).returns(test.appGetterStubs[key]);
            });
          }
          if (test.ctrlStubs) {
            var stub = sinon.stub(controller, 'get');
            Em.keys(test.ctrlStubs).forEach(function(key) {
              stub.withArgs(key).returns(test.ctrlStubs[key]);
            });
          }
          sinon.stub(App.HostComponent, 'find').returns(test.hostComponentModel);
          controller.updateZkConfigs(test.configs);
        });

        afterEach(function () {
          if (test.ctrlStubs) {
            controller.get.restore();
          }
          if (test.appGetterStubs) {
            App.get.restore();
          }
          App.HostComponent.find.restore();
        });

        it('configs are mapped correctly', function () {
          expect(test.configs).to.be.eql(test.e.configs);
        });

      });
    });
  });

  describe('#installComponent()', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, "show");
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('popup should be displayed', function () {
      var event = {context: Em.Object.create()};
      var popup = controller.installComponent(event);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      var args = testHelpers.findAjaxRequest('name', 'common.host.host_component.update');
      expect(args).exists;
    });
  });

  describe('#decommission()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "runDecommission", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.runDecommission.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.decommission(Em.Object.create({service: {}}));
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.runDecommission.calledOnce).to.be.true;
    });
  });

  describe('#recommission()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "runRecommission", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.runRecommission.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.recommission(Em.Object.create({service: {}}));
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.runRecommission.calledOnce).to.be.true;
    });
  });

  describe('#runDecommission()', function () {

    beforeEach(function () {
      sinon.stub(controller, "doDecommission", Em.K);
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
    });

    afterEach(function () {
      controller.doDecommission.restore();
      controller.showBackgroundOperationsPopup.restore();
    });

    it('HDFS service', function () {
      controller.runDecommission('host1', 'HDFS');
      expect(controller.doDecommission.calledWith('host1', 'HDFS', "NAMENODE", "DATANODE")).to.be.true;
    });
    it('YARN service', function () {
      controller.runDecommission('host1', 'YARN');
      expect(controller.doDecommission.calledWith('host1', 'YARN', "RESOURCEMANAGER", "NODEMANAGER")).to.be.true;
    });

    describe('HBASE service', function () {

      beforeEach(function () {
        sinon.stub(controller, 'warnBeforeDecommission', Em.K);
      });

      afterEach(function () {
        controller.warnBeforeDecommission.restore();
      });
      it('warnBeforeDecommission is called with valid arguments', function () {
        controller.runDecommission('host1', 'HBASE');
        expect(controller.warnBeforeDecommission.calledWith('host1')).to.be.true;
      });

    });

  });

  describe('#runRecommission()', function () {

    beforeEach(function () {
      sinon.stub(controller, "doRecommissionAndStart", Em.K);
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
    });

    afterEach(function () {
      controller.doRecommissionAndStart.restore();
      controller.showBackgroundOperationsPopup.restore();
    });

    it('HDFS service', function () {
      controller.runRecommission('host1', 'HDFS');
      expect(controller.doRecommissionAndStart.calledWith('host1', 'HDFS', "NAMENODE", "DATANODE")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('YARN service', function () {
      controller.runRecommission('host1', 'YARN');
      expect(controller.doRecommissionAndStart.calledWith('host1', 'YARN', "RESOURCEMANAGER", "NODEMANAGER")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('HBASE service', function () {
      controller.runRecommission('host1', 'HBASE');
      expect(controller.doRecommissionAndStart.calledWith('host1', 'HBASE', "HBASE_MASTER", "HBASE_REGIONSERVER")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#doDecommission()', function () {
    it('Query should be sent', function () {
      controller.doDecommission('', '', '', '');
      var args = testHelpers.findAjaxRequest('name', 'host.host_component.decommission_slave');
      expect(args).exists;
    });
  });

  describe('#doDecommissionRegionServer()', function () {
    it('Query should be sent', function () {
      controller.doDecommissionRegionServer('', '', '', '');
      var args = testHelpers.findAjaxRequest('name', 'host.host_component.recommission_and_restart');
      expect(args).exists;
    });
  });

  describe('#warnBeforeDecommission()', function () {
    beforeEach(function () {
      sinon.stub(controller, "showHbaseActiveWarning", Em.K);
      sinon.stub(controller, "checkRegionServerState", Em.K);
    });
    afterEach(function () {
      controller.checkRegionServerState.restore();
      controller.showHbaseActiveWarning.restore();
    });

    it('Component in passive state', function () {
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'HBASE_REGIONSERVER',
        passiveState: 'ON'
      })]);
      controller.warnBeforeDecommission('host1');
      expect(controller.checkRegionServerState.calledOnce).to.be.true;
    });
    it('Component is not in passive state', function () {
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'HBASE_REGIONSERVER',
        passiveState: 'OFF'
      })]);
      controller.warnBeforeDecommission('host1');
      expect(controller.showHbaseActiveWarning.calledOnce).to.be.true;
    });
  });

  describe('#checkRegionServerState()', function () {
    var result;
    beforeEach(function () {
      result = controller.checkRegionServerState('host1');
    });
    it('returns object', function () {
      expect(result).to.be.an('object');
    });
    it('request is sent with correct data', function () {
      var args = testHelpers.findAjaxRequest('name', 'host.region_servers.in_inservice');
      expect(args[0]).exists;
      expect(args[0].data.hostNames).to.be.equal('host1');
    });
  });

  describe('#checkRegionServerStateSuccessCallback()', function () {
    beforeEach(function () {
      sinon.stub(controller, "doDecommissionRegionServer", Em.K);
      sinon.stub(controller, "showRegionServerWarning", Em.K);
    });
    afterEach(function () {
      controller.doDecommissionRegionServer.restore();
      controller.showRegionServerWarning.restore();
    });

    it('Decommission all regionservers', function () {
      var data = {
        items: [
          {
            HostRoles: {
              host_name: 'host1'
            }
          },
          {
            HostRoles: {
              host_name: 'host2'
            }
          }
        ]
      };
      controller.checkRegionServerStateSuccessCallback(data, {}, {hostNames: 'host1,host2'});
      expect(controller.showRegionServerWarning.calledOnce).to.be.true;
    });
    it('Decommission one of two regionservers', function () {
      var data = {
        items: [
          {
            HostRoles: {
              host_name: 'host1'
            }
          },
          {
            HostRoles: {
              host_name: 'host2'
            }
          }
        ]
      };
      controller.checkRegionServerStateSuccessCallback(data, {}, {hostNames: 'host1'});
      expect(controller.doDecommissionRegionServer.calledWith('host1', "HBASE", "HBASE_MASTER", "HBASE_REGIONSERVER")).to.be.true;
    });
    it('Decommission one of three regionservers', function () {
      var data = {
        items: [
          {
            HostRoles: {
              host_name: 'host1'
            }
          },
          {
            HostRoles: {
              host_name: 'host2'
            }
          },
          {
            HostRoles: {
              host_name: 'host3'
            }
          }
        ]
      };
      controller.checkRegionServerStateSuccessCallback(data, {}, {hostNames: 'host1'});
      expect(controller.doDecommissionRegionServer.calledWith('host1', "HBASE", "HBASE_MASTER", "HBASE_REGIONSERVER")).to.be.true;
    });
  });

  describe('#showRegionServerWarning()', function () {
    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show', Em.K);
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
    });
    it('modal popup is shown', function () {
      controller.showRegionServerWarning();
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe('#doRecommissionAndStart()', function () {
    it('Query should be sent', function () {
      controller.doRecommissionAndStart('', '', '', '');
      var args = testHelpers.findAjaxRequest('name', 'host.host_component.recommission_and_restart');
      expect(args).exists;
    });
  });

  describe('#decommissionSuccessCallback()', function () {

    beforeEach(function () {
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
    });
    afterEach(function () {
      controller.showBackgroundOperationsPopup.restore();
    });

    it('data is null', function () {
      expect(controller.decommissionSuccessCallback(null)).to.be.false;
      expect(controller.showBackgroundOperationsPopup.called).to.be.false;
    });
    it('data has Requests', function () {
      var data = {Requests: []};
      expect(controller.decommissionSuccessCallback(data)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('data has resources', function () {
      var data = {
        resources: [
          {RequestSchedule: {}}
        ]
      };
      expect(controller.decommissionSuccessCallback(data)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#doAction()', function () {

    beforeEach(function () {
      sinon.stub(controller, "validateAndDeleteHost", Em.K);
      sinon.stub(controller, "doStartAllComponents", Em.K);
      sinon.stub(controller, "doStopAllComponents", Em.K);
      sinon.stub(controller, "doRestartAllComponents", Em.K);
      sinon.stub(controller, "onOffPassiveModeForHost", Em.K);
      sinon.stub(controller, "setRackIdForHost", Em.K);
    });

    afterEach(function () {
      controller.validateAndDeleteHost.restore();
      controller.doStartAllComponents.restore();
      controller.doStopAllComponents.restore();
      controller.doRestartAllComponents.restore();
      controller.onOffPassiveModeForHost.restore();
      controller.setRackIdForHost.restore();
    });

    it('"deleteHost" action', function () {
      var option = {context: {action: "deleteHost"}};
      controller.doAction(option);
      expect(controller.validateAndDeleteHost.calledOnce).to.be.true;
    });

    it('"startAllComponents" action, isNotHeartBeating = false', function () {
      var option = {context: {action: "startAllComponents"}};
      controller.set('content', {isNotHeartBeating: false});
      controller.doAction(option);
      expect(controller.doStartAllComponents.calledOnce).to.be.true;
    });

    it('"startAllComponents" action, isNotHeartBeating = true', function () {
      var option = {context: {action: "startAllComponents"}};
      controller.set('content', {isNotHeartBeating: true});
      controller.doAction(option);
      expect(controller.doStartAllComponents.called).to.be.false;
    });

    it('"stopAllComponents" action, isNotHeartBeating = false', function () {
      var option = {context: {action: "stopAllComponents"}};
      controller.set('content', {isNotHeartBeating: false});
      controller.doAction(option);
      expect(controller.doStopAllComponents.calledOnce).to.be.true;
    });

    it('"stopAllComponents" action, isNotHeartBeating = true', function () {
      var option = {context: {action: "stopAllComponents"}};
      controller.set('content', {isNotHeartBeating: true});
      controller.doAction(option);
      expect(controller.doStopAllComponents.called).to.be.false;
    });

    it('"restartAllComponents" action, isNotHeartBeating = false', function () {
      var option = {context: {action: "restartAllComponents"}};
      controller.set('content', {isNotHeartBeating: false});
      controller.doAction(option);
      expect(controller.doRestartAllComponents.calledOnce).to.be.true;
    });

    it('"restartAllComponents" action, isNotHeartBeating = true', function () {
      var option = {context: {action: "restartAllComponents"}};
      controller.set('content', {isNotHeartBeating: true});
      controller.doAction(option);
      expect(controller.doRestartAllComponents.called).to.be.false;
    });

    it('"onOffPassiveModeForHost" action', function () {
      var option = {context: {action: "onOffPassiveModeForHost"}};
      controller.doAction(option);
      expect(controller.onOffPassiveModeForHost.calledWith({action: "onOffPassiveModeForHost"})).to.be.true;
    });

    it('"setRackId" action', function () {
      var option = {context: {action: "setRackId"}};
      controller.doAction(option);
      expect(controller.setRackIdForHost.calledOnce).to.be.true;
    });
  });

  describe("#setRackIdForHost()", function() {
    beforeEach(function(){
      sinon.stub(hostsManagement, 'setRackInfo', Em.K);
    });
    afterEach(function() {
      hostsManagement.setRackInfo.restore();
    });
    it('setRackInfo called with valid arguments', function() {
      controller.set('content.rack', 'rack');
      controller.set('content.hostName', 'host1');
      controller.setRackIdForHost();
      expect(hostsManagement.setRackInfo.calledWith({message: Em.I18n.t('hosts.host.details.setRackId')}, [{hostName: 'host1'}], 'rack')).to.be.true;
    });
  });

  describe('#onOffPassiveModeForHost()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "hostPassiveModeRequest", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.hostPassiveModeRequest.restore();
    });

    it('popup should be displayed, active = true', function () {
      var popup = controller.onOffPassiveModeForHost({active: true});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.hostPassiveModeRequest.calledWith('ON')).to.be.true;
    });
    it('popup should be displayed, active = false', function () {
      var popup = controller.onOffPassiveModeForHost({active: false});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.hostPassiveModeRequest.calledWith('OFF')).to.be.true;
    });
  });

  describe('#hostPassiveModeRequest()', function () {
    it('Query should be sent', function () {
      controller.hostPassiveModeRequest('', '');
      var args = testHelpers.findAjaxRequest('name', 'bulk_request.hosts.passive_state');
      expect(args).exists;
    });
  });

  describe('#doStartAllComponents()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, 'sendComponentCommand', Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.sendComponentCommand.restore();
    });

    it('serviceNonClientActiveComponents is empty', function () {
      controller.reopen({
        serviceNonClientActiveComponents: Em.A([])
      });
      controller.doStartAllComponents();
      expect(App.showConfirmationPopup.called).to.be.false;
    });
    it('serviceNonClientActiveComponents is correct', function () {
      controller.reopen({
        serviceNonClientActiveComponents: Em.A([{}])
      });
      var popup = controller.doStartAllComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.sendComponentCommand.calledWith(
        controller.get('serviceNonClientActiveComponents'),
        Em.I18n.t('hosts.host.maintainance.startAllComponents.context'),
        App.HostComponentStatus.started)
      ).to.be.true;
    });
  });

  describe('#doStopAllComponents()', function () {
    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, 'sendComponentCommand', Em.K);
      sinon.stub(controller, 'checkNnLastCheckpointTime', function(callback){
        callback();
      });
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.sendComponentCommand.restore();
      controller.checkNnLastCheckpointTime.restore();
    });

    it('serviceNonClientActiveComponents is empty', function () {
      controller.reopen({
        serviceNonClientActiveComponents: []
      });
      controller.doStopAllComponents();
      expect(App.showConfirmationPopup.called).to.be.false;
    });

    it('serviceNonClientActiveComponents is correct', function () {
      controller.reopen({
        serviceNonClientActiveComponents: Em.A([{}])
      });

      var popup = controller.doStopAllComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.sendComponentCommand.calledWith(
        controller.get('serviceNonClientActiveComponents'),
        Em.I18n.t('hosts.host.maintainance.stopAllComponents.context'),
        App.HostComponentStatus.stopped)
      ).to.be.true;
    });
    it('serviceNonClientActiveComponents is correct, NAMENODE started', function () {
      controller.reopen({
        serviceNonClientActiveComponents: Em.A([Em.Object.create({
          componentName: 'NAMENODE',
          workStatus: 'STARTED'
        })])
      });
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'NAMENODE',
        workStatus: 'STARTED'
      })]);
      controller.doStopAllComponents();
      expect(controller.checkNnLastCheckpointTime.calledOnce).to.be.true;
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
    });
  });

  describe('#doRestartAllComponents()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(batchUtils, 'restartHostComponents', Em.K);
      sinon.stub(controller, 'checkNnLastCheckpointTime', function(callback){
        callback();
      });
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      batchUtils.restartHostComponents.restore();
      controller.checkNnLastCheckpointTime.restore();
    });

    it('serviceActiveComponents is empty', function () {
      controller.reopen({
        serviceActiveComponents: []
      });
      controller.doRestartAllComponents();
      expect(App.showConfirmationPopup.called).to.be.false;
    });

    it('serviceActiveComponents is correct', function () {
      var components = [{}];
      controller.reopen({
        serviceActiveComponents: components
      });

      var popup = controller.doRestartAllComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(batchUtils.restartHostComponents.calledWith(components)).to.be.true;
    });
    it('serviceActiveComponents is correct, NAMENODE started', function () {
      controller.reopen({
        serviceActiveComponents: Em.A([Em.Object.create({
          componentName: 'NAMENODE',
          workStatus: 'STARTED'
        })])
      });
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'NAMENODE',
        workStatus: 'STARTED'
      })]);
      controller.doRestartAllComponents();
      expect(controller.checkNnLastCheckpointTime.calledOnce).to.be.true;
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
    });
  });

  describe('#getHostComponentsInfo()', function () {

    var result = {
      zkServerInstalled: false,
      lastComponents: [],
      masterComponents: [],
      runningComponents: [],
      nonDeletableComponents: [],
      unknownComponents: [],
      toDecommissionComponents: []
    };

    beforeEach(function () {
      this.stub = sinon.stub(App.HostComponent, 'find').returns([{
        id: 'TASKTRACKER_host1',
        componentName: 'TASKTRACKER'
      }]);
      this.mockTotal = sinon.stub(controller, 'getTotalComponent');
      this.mockTotal.returns(2);
    });

    afterEach(function () {
      this.stub.restore();
      this.mockTotal.restore();
    });

    it('content.hostComponents is null', function () {
      controller.set('content', {hostComponents: null});
      expect(controller.getHostComponentsInfo()).to.eql(result);
    });

    it('content.hostComponents is empty', function () {
      controller.set('content', {hostComponents: []});
      expect(controller.getHostComponentsInfo()).to.eql(result);
    });

    it('content.hostComponents has ZOOKEEPER_SERVER', function () {
      App.HostComponent.find().clear();
      controller.set('content', {
        hostComponents: [Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INIT',
          isDeletable: true
        })]
      });
      expect(controller.getHostComponentsInfo().zkServerInstalled).to.be.true;
    });

    it('content.hostComponents has last component', function () {
      controller.set('content', {
        hostComponents: [Em.Object.create({
          componentName: 'TASKTRACKER',
          displayName: 'TaskTracker',
          workStatus: 'INIT',
          isDeletable: true
        })]
      });
      this.mockTotal.returns(1);
      expect(controller.getHostComponentsInfo().lastComponents).to.eql(['TaskTracker']);
    });

    it('content.hostComponents has master non-deletable component', function () {
      controller.set('content', {
        hostComponents: [Em.Object.create({
          componentName: 'TASKTRACKER',
          workStatus: 'INIT',
          isDeletable: false,
          isMaster: true,
          displayName: 'ZK1'
        })]
      });
      expect(controller.getHostComponentsInfo().masterComponents).to.eql(['ZK1']);
      expect(controller.getHostComponentsInfo().nonDeletableComponents).to.eql(['ZK1']);
    });

    it('content.hostComponents has running component', function () {
      controller.set('content', {
        hostComponents: [Em.Object.create({
          componentName: 'TASKTRACKER',
          workStatus: 'STARTED',
          isDeletable: true,
          displayName: 'ZK1'
        })]
      });
      expect(controller.getHostComponentsInfo().runningComponents).to.eql(['ZK1']);
    });

    it('content.hostComponents has non-deletable component', function () {
      controller.set('content', {
        hostComponents: [Em.Object.create({
          componentName: 'TASKTRACKER',
          workStatus: 'INIT',
          isDeletable: false,
          displayName: 'ZK1'
        })]
      });
      expect(controller.getHostComponentsInfo().nonDeletableComponents).to.eql(['ZK1']);
    });

    it('content.hostComponents has component with UNKNOWN state', function () {
      controller.set('content', {
        hostComponents: [Em.Object.create({
          componentName: 'TASKTRACKER',
          workStatus: 'UNKNOWN',
          isDeletable: false,
          displayName: 'ZK1'
        })]
      });
      expect(controller.getHostComponentsInfo().unknownComponents).to.eql(['ZK1']);
    });

  });

  describe('#validateAndDeleteHost()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "getHostComponentsInfo", function () {
        return this.get('mockHostComponentsInfo');
      });
      sinon.stub(controller, "raiseDeleteComponentsError", Em.K);
      sinon.stub(controller, "confirmDeleteHost", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.getHostComponentsInfo.restore();
      controller.raiseDeleteComponentsError.restore();
      controller.confirmDeleteHost.restore();
    });

    it('masterComponents exist', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [
          {}
        ]
      });
      controller.validateAndDeleteHost();
      expect(controller.raiseDeleteComponentsError.calledWith({masterComponents: [
        {}
      ]}, 'masterList')).to.be.true;
    });
    it('nonDeletableComponents exist', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [
          {}
        ]
      });
      controller.validateAndDeleteHost();
      expect(controller.raiseDeleteComponentsError.calledWith({
        masterComponents: [],
        nonDeletableComponents: [
          {}
        ]
      }, 'nonDeletableList')).to.be.true;
    });
    it('runningComponents exist', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [],
        runningComponents: [{}]
      });
      controller.validateAndDeleteHost();
      expect(controller.raiseDeleteComponentsError.calledWith({
        masterComponents: [],
        nonDeletableComponents: [],
        runningComponents: [{}]
      }, 'runningList')).to.be.true;
    });
    it('zkServerInstalled = true', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [],
        runningComponents: [],
        unknownComponents: [],
        lastComponents: [],
        zkServerInstalled: true
      });
      var popup = controller.validateAndDeleteHost();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.confirmDeleteHost.calledWith({
        masterComponents: [],
        nonDeletableComponents: [],
        runningComponents: [],
        unknownComponents: [],
        lastComponents: [],
        zkServerInstalled: true
      })).to.be.true;
    });
    it('zkServerInstalled = false', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [],
        runningComponents: [],
        unknownComponents: [],
        lastComponents: [],
        zkServerInstalled: false
      });
      controller.validateAndDeleteHost();
      expect(controller.confirmDeleteHost.calledWith({
        masterComponents: [],
        nonDeletableComponents: [],
        runningComponents: [],
        unknownComponents: [],
        lastComponents: [],
        zkServerInstalled: false
      })).to.be.true;
    });
  });

  describe('#raiseDeleteComponentsError()', function () {

    beforeEach(function () {
      sinon.stub(App.ModalPopup, "show", Em.K);
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('Popup should be displayed', function () {
      controller.raiseDeleteComponentsError([], '');
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe('#confirmDeleteHost()', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, "show");
      sinon.stub(controller, 'doDeleteHost');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
      controller.doDeleteHost.restore();
    });

    it('Popup should be displayed', function () {
      var popup = controller.confirmDeleteHost({toDecommissionComponents:[]});
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.doDeleteHost.calledOnce).to.be.true;
    });
  });

  describe('#setRackId', function () {
    beforeEach(function () {
      sinon.stub(hostsManagement, 'setRackInfo', Em.K);

    });
    afterEach(function () {
      hostsManagement.setRackInfo.restore();
    });
    it('should call setRackInfo with appropriate arguments', function () {
      var mockedHost = Em.Object.create({
        rack: 'rackId'
      });
      controller.setRackId({
        context: mockedHost
      });
      expect(hostsManagement.setRackInfo.calledWith({message: Em.I18n.t('hosts.host.details.setRackId')}, [mockedHost], 'rackId')).to.be.true;
    });
  });

  describe('#restartAllStaleConfigComponents()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(batchUtils, "restartHostComponents", Em.K);
      sinon.stub(controller, 'checkNnLastCheckpointTime', function(callback){
        callback();
      });
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      batchUtils.restartHostComponents.restore();
      controller.checkNnLastCheckpointTime.restore();
    });

    it('popup should be displayed', function () {
      controller.set('content', {
        componentsWithStaleConfigs: [
          {}
        ]
      });
      var popup = controller.restartAllStaleConfigComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(batchUtils.restartHostComponents.calledWith([
        {}
      ])).to.be.true;
    });

    it('popup ro check NameNode checkpoint should be displayed first', function () {
      controller.set('content.componentsWithStaleConfigs', [Em.Object.create({
        componentName: 'NAMENODE',
        workStatus: 'STARTED'
      })]);
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'NAMENODE',
        workStatus: 'STARTED'
      })]);
      controller.restartAllStaleConfigComponents();
      expect(controller.checkNnLastCheckpointTime.calledOnce).to.be.true;
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
    });
  });

  describe.skip('#moveComponent()', function () {

    var jQueryMock,
      mock = {
        saveComponentToReassign: Em.K,
        getSecurityStatus: Em.K,
        setCurrentStep: Em.K
      },
      cases = [
        {
          isDisabled: false,
          showConfirmationPopupCallCount: 1,
          title: 'popup should be displayed'
        },
        {
          isDisabled: true,
          showConfirmationPopupCallCount: 0,
          title: 'popup shouldn\'t be displayed'
        }
      ];

    beforeEach(function () {
      jQueryMock = sinon.stub(window, '$');
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(App.router, 'get').withArgs('reassignMasterController').returns(mock);
      sinon.stub(App.router, 'transitionTo', Em.K);
      sinon.spy(mock, "saveComponentToReassign");
      sinon.spy(mock, "getSecurityStatus");
      sinon.spy(mock, "setCurrentStep");
    });

    afterEach(function () {
      window.$.restore();
      App.showConfirmationPopup.restore();
      App.router.get.restore();
      App.router.transitionTo.restore();
      mock.saveComponentToReassign.restore();
      mock.getSecurityStatus.restore();
      mock.setCurrentStep.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        jQueryMock.returns({
          closest: function () {
            return {
              hasClass: function () {
                return item.isDisabled;
              }
            }
          }
        });
        var popup = controller.moveComponent({context: {}});
        expect(App.showConfirmationPopup.callCount).to.equal(item.showConfirmationPopupCallCount);
        if (item.showConfirmationPopupCallCount) {
          popup.onPrimary();
          expect(App.router.get.calledWith('reassignMasterController')).to.be.true;
          expect(mock.saveComponentToReassign.calledWith({})).to.be.true;
          expect(mock.getSecurityStatus.calledOnce).to.be.true;
          expect(mock.setCurrentStep.calledWith('1')).to.be.true;
          expect(App.router.transitionTo.calledWith('reassign')).to.be.true;
        }
      });
    });

  });

  describe('#refreshConfigs()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(batchUtils, "restartHostComponents", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      batchUtils.restartHostComponents.restore();
    });

    it('No components', function () {
      var event = {context: Em.A([])};
      controller.refreshConfigs(event);
      expect(App.showConfirmationPopup.called).to.be.false;
    });
    it('Some components present', function () {
      var event = {context: Em.A([Em.Object.create()])};
      var popup = controller.refreshConfigs(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(batchUtils.restartHostComponents.calledWith(event.context)).to.be.true;
    });
  });

  describe('#getTotalComponent()', function () {

    beforeEach(function () {
      sinon.stub(App.SlaveComponent, 'find', function () {
        return Em.Object.create({
          componentName: "SLAVE",
          totalCount: 1
        });
      });
      sinon.stub(App.ClientComponent, 'find', function () {
        return Em.Object.create({
          componentName: "CLIENT",
          totalCount: 1
        });
      });
      sinon.stub(App.HostComponent, 'find', function () {
        return [Em.Object.create({
          componentName: "MASTER",
          totalCount: 1
        })]
      });
    });
    afterEach(function () {
      App.SlaveComponent.find.restore();
      App.ClientComponent.find.restore();
      App.HostComponent.find.restore();
    });

    it('component is slave', function () {
      expect(controller.getTotalComponent(Em.Object.create({
        componentName: "SLAVE",
        isSlave: true
      }))).to.equal(1);
    });
    it('component is client', function () {
      expect(controller.getTotalComponent(Em.Object.create({
        componentName: "CLIENT",
        isClient: true
      }))).to.equal(1);
    });
    it('component is master', function () {
      expect(controller.getTotalComponent(Em.Object.create({
        componentName: "MASTER"
      }))).to.equal(1);
    });
    it('unknown component', function () {
      expect(controller.getTotalComponent(Em.Object.create({
        componentName: "UNKNOWN"
      }))).to.equal(0);
    });
  });

  describe('#downloadClientConfigsCall', function () {

    beforeEach(function () {
      sinon.stub(controller, 'downloadClientConfigsCall', Em.K);
    });
    afterEach(function () {
      controller.downloadClientConfigsCall.restore();
    });

    it('should launch controller.downloadClientConfigsCall method', function () {
      controller.downloadClientConfigs({
        context: Em.Object.create({
          componentName: 'name',
          hostName: 'host1'
        })
      });
      expect(controller.downloadClientConfigsCall.calledWith({
        componentName: 'name',
        hostName: 'host1',
        resourceType: controller.resourceTypeEnum.HOST_COMPONENT
      })).to.be.true;
    });
  });

  describe('#downloadAllClientConfigs', function () {

    beforeEach(function () {
      sinon.stub(controller, 'downloadClientConfigsCall', Em.K);
      sinon.stub(controller, 'get').withArgs('content.hostName').returns('host1');
    });
    afterEach(function () {
      controller.downloadClientConfigsCall.restore();
      controller.get.restore();
    });

    it('should launch controller.downloadClientConfigsCall method', function () {
      controller.downloadAllClientConfigs();
      expect(controller.downloadClientConfigsCall.calledWith({
        hostName: 'host1',
        resourceType: controller.resourceTypeEnum.HOST
      })).to.be.true;
    });
  });

  describe('#executeCustomCommands', function () {
    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it('confirm popup should be displayed', function () {
      var popup = controller.executeCustomCommand({context: Em.Object.create()});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      var args = testHelpers.findAjaxRequest('name', 'service.item.executeCustomCommand');
      expect(args).exists;
    });
  });

  describe('#_doDeleteHostComponent()', function () {
    it('single component', function () {
      controller.set('content.hostName', 'host1');
      var componentName = 'COMP';
      controller._doDeleteHostComponent(componentName);
      var args = testHelpers.findAjaxRequest('name', 'common.delete.host_component');
      expect(args[0]).exists;
      expect(args[0].data).to.be.eql({
        componentName: 'COMP',
        hostName: 'host1'
      });
    });
    it('all components', function () {
      controller.set('content.hostName', 'host1');
      controller._doDeleteHostComponent(null);
      var args = testHelpers.findAjaxRequest('name', 'common.delete.host');
      expect(args[0]).exists;
      expect(args[0].data).to.be.eql({
        componentName: '',
        hostName: 'host1'
      });
    });
  });

  describe('#_doDeleteHostComponentSuccessCallback()', function () {
    var data = {
      componentName: 'COMPONENT',
      hostName: 'h1'
    };

    beforeEach(function () {
      sinon.stub(controller, 'removeHostComponentModel', Em.K);
      controller.set('_deletedHostComponentResult', {});
      controller._doDeleteHostComponentSuccessCallback({}, {}, data);
    });

    afterEach(function () {
      controller.removeHostComponentModel.restore();
    });

    it('should reset `_deletedHostComponentResult`', function () {
      expect(controller.get('_deletedHostComponentResult')).to.be.null;
    });

    it('should call `removeHostComponentModel` with correct params', function () {
      expect(controller.removeHostComponentModel.calledWith('COMPONENT', 'h1')).to.be.true;
    });
  });

  describe('#upgradeComponentSuccessCallback()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'showBackgroundOperationsPopup', Em.K);
      sinon.stub(controller, 'mimicWorkStatusChange', Em.K);
    });
    afterEach(function () {
      controller.mimicWorkStatusChange.restore();
      controller.showBackgroundOperationsPopup.restore();
    });
    it('testMode is false', function () {
      controller.upgradeComponentSuccessCallback({}, {}, {component: "COMP"});
      expect(controller.mimicWorkStatusChange.called).to.be.false;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#refreshComponentConfigsSuccessCallback()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'showBackgroundOperationsPopup', Em.K);
    });

    afterEach(function () {
      controller.showBackgroundOperationsPopup.restore();
    });

    it('call showBackgroundOperationsPopup', function () {
      controller.refreshComponentConfigsSuccessCallback();
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#_doDeleteHostComponentErrorCallback()', function () {
    it('call showBackgroundOperationsPopup', function () {
      controller._doDeleteHostComponentErrorCallback({}, 'textStatus', {}, {url: 'url'});
      expect(controller.get('_deletedHostComponentResult')).to.be.eql({xhr: {}, url: 'url', method: 'DELETE'});
    });
  });

  describe('#installComponentSuccessCallback()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'showBackgroundOperationsPopup', Em.K);
      sinon.stub(controller, 'mimicWorkStatusChange', Em.K);
    });
    afterEach(function () {
      controller.mimicWorkStatusChange.restore();
      controller.showBackgroundOperationsPopup.restore();
    });

    it('testMode is false', function () {
      controller.installComponentSuccessCallback({}, {}, {component: "COMP"});
      expect(controller.mimicWorkStatusChange.called).to.be.false;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#showHbaseActiveWarning()', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, "show");
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('popup should be displayed', function () {
      controller.showHbaseActiveWarning(Em.Object.create({service: {}}));
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe('#updateHost()', function () {

    beforeEach(function () {
      sinon.stub(batchUtils, "infoPassiveState", Em.K);
    });

    afterEach(function () {
      batchUtils.infoPassiveState.restore();
    });

    it('popup should be displayed', function () {
      controller.updateHost({}, {}, {passive_state: 'state'});
      expect(controller.get('content.passiveState')).to.equal('state');
      expect(batchUtils.infoPassiveState.calledWith('state')).to.be.true;
    });
  });

  describe('#updateComponentPassiveState()', function () {
    it('popup should be displayed', function () {
      controller.set('content.hostName', 'host1');
      var component = Em.Object.create({
        componentName: 'COMP1'
      });
      controller.updateComponentPassiveState(component, 'state', 'message');
      var args = testHelpers.findAjaxRequest('name', 'common.host.host_component.passive');
      expect(args[0]).exists;
      expect(args[0].data).to.be.eql({
        "hostName": "host1",
        "componentName": "COMP1",
        "component": component,
        "passive_state": "state",
        "context": "message"
      });
    });
  });

  describe('#updateHostComponent()', function () {

    var params = {
      component: Em.Object.create(),
      passive_state: 'state'
    };

    beforeEach(function () {
      sinon.stub(batchUtils, "infoPassiveState", Em.K);
    });

    afterEach(function () {
      batchUtils.infoPassiveState.restore();
    });

    it('popup should be displayed', function () {
      controller.updateHostComponent({}, {}, params);
      expect(params.component.get('passiveState')).to.equal('state');
      expect(batchUtils.infoPassiveState.calledWith('state')).to.be.true;
    });
  });

  describe('#toggleMaintenanceMode()', function () {
    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, 'updateComponentPassiveState');
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.updateComponentPassiveState.restore();
    });
    it('passive state is ON', function () {
      var event = {
        context: Em.Object.create({
          passiveState: 'ON'
        })
      };
      var popup = controller.toggleMaintenanceMode(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.updateComponentPassiveState.calledWith(Em.Object.create({
        passiveState: 'ON'
      }), 'OFF')).to.be.true;
    });
    it('passive state is OFF', function () {
      var event = {
        context: Em.Object.create({
          passiveState: 'OFF'
        })
      };
      var popup = controller.toggleMaintenanceMode(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.updateComponentPassiveState.calledWith(Em.Object.create({
        passiveState: 'OFF'
      }), 'ON')).to.be.true;
    });
    it('isImpliedState is true', function () {
      var event = {
        context: Em.Object.create({
          isImpliedState: true
        })
      };
      var result = controller.toggleMaintenanceMode(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.false;
      expect(result).to.be.null;
    });
  });

  describe('#installClients()', function () {

    var cases = [
      {
        context: [
          Em.Object.create({
            componentName: 'c0',
            workStatus: 'INSTALLED'
          }),
          Em.Object.create({
            componentName: 'c1',
            workStatus: 'INIT'
          }),
          Em.Object.create({
            componentName: 'c2',
            workStatus: 'INSTALL_FAILED'
          })
        ],
        dependencies: {
          c0: [],
          c1: [],
          c2: []
        },
        getSecurityTypeCalled: null, //should have same value as getKDCSessionStateCalled, always
        getKDCSessionStateCalled: true,
        sendComponentCommandCalled: true,
        showAlertPopupCalled: false,
        title: 'No clients to add, some clients to install'
      },
      {
        context: [
          Em.Object.create({
            componentName: 'c3',
            displayName: 'c3'
          })
        ],
        dependencies: {
          c3: []
        },
        getSecurityTypeCalled: null, //should have same value as getKDCSessionStateCalled, always
        getKDCSessionStateCalled: true,
        sendComponentCommandCalled: false,
        showAlertPopupCalled: false,
        title: 'No clients to install, some clients to add'
      },
      {
        context: [
          Em.Object.create({
            componentName: 'c4',
            displayName: 'c4'
          })
        ],
        dependencies: {
          c4: ['c5']
        },
        getSecurityTypeCalled: null, //should have same value as getKDCSessionStateCalled, always
        getKDCSessionStateCalled: false,
        sendComponentCommandCalled: false,
        showAlertPopupCalled: true,
        title: 'Clients to add have unresolved dependencies'
      },
      {
        context: [
          Em.Object.create({
            componentName: 'c5',
            displayName: 'c5'
          }),
          Em.Object.create({
            componentName: 'c6',
            displayName: 'c6'
          })
        ],
        dependencies: {
          c5: ['c6'],
          c6: ['c5']
        },
        getSecurityTypeCalled: null, //should have same value as getKDCSessionStateCalled, always
        getKDCSessionStateCalled: true,
        sendComponentCommandCalled: false,
        showAlertPopupCalled: false,
        title: 'Clients to add have mutual dependencies'
      }
    ];

    beforeEach(function () {
      sinon.stub(controller, 'sendComponentCommand', Em.K);
      sinon.stub(controller, 'showAddComponentPopup', Em.K);
      sinon.stub(App.get('router.mainAdminKerberosController'), 'getKDCSessionState', function (arg) {
        return arg();
      });
      sinon.stub(App.get('router.mainAdminKerberosController'), 'getSecurityType', function (arg) {
        return arg();
      });
      sinon.stub(App, 'showAlertPopup', Em.K);
      sinon.stub(App.StackServiceComponent, 'find', function (componentName) {
        return Em.Object.create({
          displayName: componentName
        });
      });
      controller.set('content.hostComponents', []);
    });
    afterEach(function () {
      controller.sendComponentCommand.restore();
      controller.showAddComponentPopup.restore();
      App.get('router.mainAdminKerberosController').getKDCSessionState.restore();
      App.get('router.mainAdminKerberosController').getSecurityType.restore();
      App.showAlertPopup.restore();
      App.StackServiceComponent.find.restore();
      controller.checkComponentDependencies.restore();
    });

    cases.forEach(function (item) {
      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(controller, 'checkComponentDependencies', function (componentName) {
            return item.dependencies[componentName];
          });
          controller.installClients(item.context);
        });

        it('getSecurityType is ' + (item.getKDCSessionStateCalled ? '' : 'not') + ' called', function() {
          expect(App.get('router.mainAdminKerberosController').getSecurityType.calledOnce).to.equal(item.getKDCSessionStateCalled);
        });

        it('getKDCSessionState is ' + (item.getKDCSessionStateCalled ? '' : 'not') + ' called', function() {
          expect(App.get('router.mainAdminKerberosController').getKDCSessionState.calledOnce).to.equal(item.getKDCSessionStateCalled);
        });

        it('sendComponentCommand is ' + (item.sendComponentCommandCalled ? '' : 'not') + ' called', function() {
          expect(controller.sendComponentCommand.calledOnce).to.equal(item.sendComponentCommandCalled);
        });

        it('showAlertPopup is ' + (item.showAlertPopupCalled ? '' : 'not') + ' called', function() {
          expect(App.showAlertPopup.calledOnce).to.equal(item.showAlertPopupCalled);
        });

      });
    });
  });

  describe("#executeCustomCommandErrorCallback()", function () {
    beforeEach(function () {
      sinon.stub($, 'parseJSON');
      sinon.spy(App, 'showAlertPopup');
    });
    afterEach(function () {
      App.showAlertPopup.restore();
      $.parseJSON.restore();
    });
    it("data empty", function () {
      controller.executeCustomCommandErrorCallback(null);

      expect(App.showAlertPopup.calledWith(Em.I18n.t('services.service.actions.run.executeCustomCommand.error'), Em.I18n.t('services.service.actions.run.executeCustomCommand.error'))).to.be.true;
      expect($.parseJSON.called).to.be.false;
    });
    it("responseText empty", function () {
      var data = {
        responseText: null
      };
      controller.executeCustomCommandErrorCallback(data);

      expect(App.showAlertPopup.calledWith(Em.I18n.t('services.service.actions.run.executeCustomCommand.error'), Em.I18n.t('services.service.actions.run.executeCustomCommand.error'))).to.be.true;
      expect($.parseJSON.called).to.be.false;
    });
    it("data empty (2)", function () {
      var data = {
        responseText: "test"
      };
      controller.executeCustomCommandErrorCallback(data);
      expect(App.showAlertPopup.calledWith(Em.I18n.t('services.service.actions.run.executeCustomCommand.error'), Em.I18n.t('services.service.actions.run.executeCustomCommand.error'))).to.be.true;
      expect($.parseJSON.calledWith('test')).to.be.true;
    });
  });

  describe("#doDeleteHost()", function () {
    beforeEach(function () {
      controller.set('fromDeleteHost', false);
      controller.set('content.hostName', 'host1');
      sinon.stub(controller, '_doDeleteHostComponent', function (comp, callback) {
        callback();
      });
    });
    afterEach(function () {
      controller._doDeleteHostComponent.restore();
    });

    describe("Host has no components", function () {

      beforeEach(function () {
        controller.set('content.hostComponents', Em.A([]));
        controller.doDeleteHost(Em.K);
        this.args = testHelpers.findAjaxRequest('name', 'common.delete.host');
      });

      it('fromDeleteHost is true', function () {
        expect(controller.get('fromDeleteHost')).to.be.true;
      });
      it('1st request is to delete host', function () {
        expect(this.args[0]).exists;
      });
      it('1st request is done with valid hostName', function () {
        expect(this.args[0].data.hostName).to.be.equal('host1');
      });
    });

    describe("Host has components", function () {

      beforeEach(function () {
        controller.set('content.hostComponents', Em.A([Em.Object.create({
          componentName: 'COMP1'
        })]));
        controller.doDeleteHost(Em.K);
      });

      it('_doDeleteHostComponent is called with correct arguments', function () {
        expect(controller._doDeleteHostComponent.calledWith('COMP1')).to.be.true;
      });
      it('fromDeleteHost is true', function () {
        expect(controller.get('fromDeleteHost')).to.be.true;
      });
      it('1st request is to delete host', function () {
        var args = testHelpers.findAjaxRequest('name', 'common.delete.host');
        expect(args[0]).exists;
      });
      it('1st request is done with valid hostName', function () {
        var args = testHelpers.findAjaxRequest('name', 'common.delete.host');
        expect(args[0].data.hostName).to.be.equal('host1');
      });

    });
  });

  describe("#deleteHostSuccessCallback", function () {
    var mock;
    beforeEach(function () {
      mock = {
        updateHost: function (callback) {
          callback();
        },
        getAllHostNames: Em.K
      };
      sinon.stub(App.router, 'get').withArgs('updateController').returns(mock).withArgs('clusterController').returns(mock);
      sinon.spy(mock, 'updateHost');
      sinon.spy(mock, 'getAllHostNames');
      sinon.stub(controller, 'loadConfigs', Em.K);
      sinon.stub(App.router, 'transitionTo', Em.K);
      sinon.stub(controller, 'isServiceMetricsLoaded', Em.clb);
      controller.deleteHostSuccessCallback();
    });

    afterEach(function () {
      App.router.get.restore();
      mock.updateHost.restore();
      mock.getAllHostNames.restore();
      controller.loadConfigs.restore();
      controller.isServiceMetricsLoaded.restore();
      App.router.transitionTo.restore();
    });

    it('updateController is used', function () {
      expect(App.router.get.calledWith('updateController')).to.be.true;
    });
    it('updateHost is called once', function () {
      expect(mock.updateHost.calledOnce).to.be.true;
    });
    it('loadConfigs is not called', function () {
      expect(controller.loadConfigs.called).to.be.false;
    });
    it('user is moved to the hosts', function () {
      expect(App.router.transitionTo.calledWith('hosts.index')).to.be.true;
    });
    it('clusterController is used', function () {
      expect(App.router.get.calledWith('clusterController')).to.be.true;
    });
    it('getAllHostNames is called once', function () {
      expect(mock.getAllHostNames.calledOnce).to.be.true;
    });
  });

  describe("#deleteHostErrorCallback", function () {

    beforeEach(function () {
      sinon.stub(controller, 'loadConfigs', Em.K);
      sinon.stub(App.ajax, 'defaultErrorHandler', Em.K);
      sinon.stub(controller, 'isServiceMetricsLoaded', Em.clb);
      controller.deleteHostErrorCallback({
        status: 'status',
        statusText: "statusText"
      }, 'textStatus', 'errorThrown', {url: 'url'});
    });

    afterEach(function () {
      App.ajax.defaultErrorHandler.restore();
      controller.loadConfigs.restore();
      controller.isServiceMetricsLoaded.restore();
    });

    it('loadConfigs is called once', function () {
      expect(controller.loadConfigs.calledOnce).to.be.true;
    });
    it('defaultErrorHandler is called once', function () {
      expect(App.ajax.defaultErrorHandler.calledOnce).to.be.true;
    });
  });

  describe('#installVersionConfirmation()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, 'installVersion', Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.installVersion.restore();
    });

    it('confirm popup should be displayed', function () {
      var event = {context: Em.Object.create({displayName: 'displayName'})};
      var popup = controller.installVersionConfirmation(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.installVersion.calledWith(event)).to.be.true;
    });
  });

  describe("#installVersion()", function () {
    it("call App.ajax.send", function () {
      controller.set('content.hostName', 'host1');
      controller.installVersion({context: {}});
      var args = testHelpers.findAjaxRequest('name', 'host.stack_versions.install');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        hostName: 'host1',
        version: {}
      });
    });
  });

  describe("#installVersionSuccessCallback()", function () {
    var version = Em.Object.create({
      id: 1,
      status: 'INIT'
    });
    beforeEach(function () {
      this.mock = sinon.stub(App.HostStackVersion, 'find');
      this.mock.returns(version);
      sinon.stub(App.db, 'set', Em.K);
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
      controller.installVersionSuccessCallback({Requests: {id: 1}}, {}, {version: version});
    });
    afterEach(function () {
      this.mock.restore();
      App.db.set.restore();
      App.clusterStatus.setClusterStatus.restore();
    });
    it("status is INSTALLING", function () {
      expect(version.get('status')).to.equal('INSTALLING');
    });
    it('valid data is saved to the localDB', function () {
      expect(App.db.set.calledWith('repoVersionInstall', 'id', [1])).to.be.true;
    });
    it('clusterStatus is updated', function () {
      expect(App.clusterStatus.setClusterStatus.calledOnce).to.be.true;
    });
  });

  describe('#getHiveHosts()', function () {

    var cases = [
      {
        'input': {
          'hiveMetastoreHost': '',
          'fromDeleteHost': false,
          'deleteHiveMetaStore': false,
          'deleteWebHCatServer': false
        },
        'hiveHosts': ['h1', 'h2', 'h4'],
        'title': 'adding HiveServer2'
      },
      {
        'input': {
          'hiveMetastoreHost': 'h0',
          'fromDeleteHost': false,
          'deleteHiveMetaStore': false,
          'deleteWebHCatServer': false
        },
        'hiveHosts': ['h0', 'h1', 'h2', 'h4'],
        'title': 'adding Hive Metastore'
      },
      {
        'input': {
          'webhcatServerHost': 'h0',
          'fromDeleteHost': false,
          'deleteHiveMetaStore': false,
          'deleteWebHCatServer': false
        },
        'hiveHosts': ['h0', 'h1', 'h2', 'h4'],
        'title': 'adding WebHCat Server'
      },
      {
        'input': {
          'hiveMetastoreHost': '',
          'content.hostName': 'h1',
          'fromDeleteHost': false,
          'deleteHiveMetaStore': true,
          'deleteWebHCatServer': false
        },
        'hiveHosts': ['h2', 'h4'],
        'title': 'deleting Hive component'
      },
      {
        'input': {
          'hiveMetastoreHost': '',
          'content.hostName': 'h4',
          'fromDeleteHost': false,
          'deleteHiveMetaStore': false,
          'deleteWebHCatServer': true
        },
        'hiveHosts': ['h1', 'h2'],
        'title': 'deleting WebHCat Server'
      },
      {
        'input': {
          'hiveMetastoreHost': '',
          'content.hostName': 'h2',
          'fromDeleteHost': true,
          'deleteHiveMetaStore': false,
          'deleteWebHCatServer': false
        },
        'hiveHosts': ['h1', 'h4'],
        'title': 'deleting host with Hive component'
      },
      {
        'input': {
          'webhcatServerHost': '',
          'content.hostName': 'h2',
          'fromDeleteHost': true,
          'deleteHiveMetaStore': false,
          'deleteWebHCatServer': false
        },
        'hiveHosts': ['h1', 'h4'],
        'title': 'deleting host with WebHCat Server'
      }
    ];

    before(function () {
      sinon.stub(App.HostComponent, 'find').returns([
        {
          componentName: 'HIVE_METASTORE',
          hostName: 'h2'
        },
        {
          componentName: 'HIVE_METASTORE',
          hostName: 'h1'
        },
        {
          componentName: 'HIVE_SERVER',
          hostName: 'h3'
        },
        {
          componentName: 'WEBHCAT_SERVER',
          hostName: 'h4'
        }
      ]);
    });

    after(function () {
      App.HostComponent.find.restore();
    });

    cases.forEach(function (item) {
      describe(item.title, function () {

        beforeEach(function () {
          Em.keys(item.input).forEach(function (key) {
            controller.set(key, item.input[key]);
          });
          this.hostsMap = controller.getHiveHosts().toArray();
          this.expectedHosts = this.hostsMap.filter(function(hostInfo) {
            return ['WEBHCAT_SERVER', 'HIVE_METASTORE'].contains(hostInfo.component) && hostInfo.isInstalled === true;
          }).mapProperty('hostName').uniq();
        });

        it(JSON.stringify(item.hiveHosts) + ' are in the list', function () {
          expect(this.expectedHosts).to.include.same.members(item.hiveHosts);
        });
        it('hiveMetastoreHost is empty', function () {
          expect(controller.get('hiveMetastoreHost')).to.be.empty;
        });
        it('webhcatServerHost is empty', function () {
          expect(controller.get('webhcatServerHost')).to.be.empty;
        });
        it('fromDeleteHost is false', function () {
          expect(controller.get('fromDeleteHost')).to.be.false;
        });
        it('deleteHiveMetaStore is false', function () {
          expect(controller.get('deleteHiveMetaStore')).to.be.false;
        });
      });
    });

  });

  describe('#onLoadRangerConfigs()', function () {

    var cases = [
      {
        'kmsHosts': ['host1'],
        'kmsPort': 'port',
        'title': 'single host',
        'hostToInstall': undefined,
        'result': [
          {
            properties: {
              'core-site': {'hadoop.security.key.provider.path': 'kms://http@host1:port/kms'},
              'hdfs-site': {'dfs.encryption.key.provider.uri': 'kms://http@host1:port/kms'}
            },
            properties_attributes: {
              'core-site': undefined,
              'hdfs-site': undefined
            }
          }
        ]
      },
      {
        'kmsHosts': ['host1', 'host2'],
        'kmsPort': 'port',
        'title': 'two hosts',
        'hostToInstall': 'host2',
        'result': [
          {
            properties: {
              'core-site': {'hadoop.security.key.provider.path': 'kms://http@host2;host1:port/kms'},
              'hdfs-site': {'dfs.encryption.key.provider.uri': 'kms://http@host1;host2:port/kms'}
            },
            properties_attributes: {
              'core-site': undefined,
              'hdfs-site': undefined
            }
          }
        ]
      }
    ];

    beforeEach(function () {
      sinon.spy(controller, 'saveConfigsBatch');
      sinon.stub(controller, 'saveLoadedConfigs', Em.K);
    });

    afterEach(function () {
      controller.saveConfigsBatch.restore();
      controller.saveLoadedConfigs.restore();
    });

    cases.forEach(function (item) {
      describe(item.title, function () {

        var data = {
          items: [
            {
              type: 'kms-env',
              properties: {'kms_port': item.kmsPort}
            },
            {
              type: 'core-site',
              properties: {
                'hadoop.security.key.provider.path': 'kms://http@host2;host1:port/kms'
              }
            },
            {
              type: 'hdfs-site',
              properties: {
                'dfs.encryption.key.provider.uri': 'kms://http@host2:port/kms'
              }
            }
          ]
        };

        beforeEach(function () {
          controller.set('rangerKMSServerHost', item.hostToInstall);
          sinon.stub(controller, 'getRangerKMSServerHosts').returns(item.kmsHosts);
          controller.onLoadRangerConfigs(data);
        });

        it('saveConfigsBatch is called with valid arguments', function () {
          expect(controller.saveConfigsBatch.calledWith(item.result, 'RANGER_KMS_SERVER', item.hostToInstall)).to.be.true;
        });
      });
    });

  });

  describe("#removeHostComponentModel()", function () {

    beforeEach(function () {
      App.cache.services = [
        {
          ServiceInfo: {
            service_name: 'S1'
          },
          host_components: ['C1_host1']
        }
      ];
      sinon.stub(App.HostComponent, 'find').returns([
        Em.Object.create({
          id: 'C1_host1',
          componentName: 'C1',
          hostName: 'host1',
          service: Em.Object.create({
            serviceName: 'S1'
          })
        })
      ]);
      sinon.stub(App.serviceMapper, 'deleteRecord', Em.K);
      controller.removeHostComponentModel('C1', 'host1');
    });
    afterEach(function () {
      App.HostComponent.find.restore();
      App.serviceMapper.deleteRecord.restore();
    });
    it("App.cache is updated", function () {
      expect(App.cache.services[0].host_components).to.be.empty;
    });
    it('Record is deleted', function () {
      expect(App.serviceMapper.deleteRecord.calledOnce).to.be.true;
    });
  });

  describe("#parseNnCheckPointTime", function () {
    var tests = [
      {
        m: "NameNode on this host has JMX data, the last checkpoint time is less than 12 hours ago",
        data:
        {
          "href" : "",
          "HostRoles" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "host_name" : "c6401.ambari.apache.org"
          },
          "metrics" : {
            "dfs" : {
              "FSNamesystem" : {
                "HAState" : "active",
                "LastCheckpointTime" : 1435775648000
              }
            }
          }
        },
        result: false
      },
      {
        m: "NameNode on this host has JMX data, the last checkpoint time is > 12 hours ago",
        data:
        {
          "href" : "",
          "HostRoles" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "host_name" : "c6401.ambari.apache.org"
          },
          "metrics" : {
            "dfs" : {
              "FSNamesystem" : {
                "HAState" : "active",
                "LastCheckpointTime" : 1435617248000
              }
            }
          }
        },
        result: "c6401.ambari.apache.org"
      },
      {
        m: "NameNode(standby) on this host has JMX data",
        data:
        {
          "href" : "",
          "HostRoles" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "host_name" : "c6401.ambari.apache.org"
          },
          "metrics" : {
            "dfs" : {
              "FSNamesystem" : {
                "HAState" : "standby",
                "LastCheckpointTime" : 1435617248000
              }
            }
          }
        },
        result: false
      },
      {
        m: "NameNode on this host has no JMX data",
        data:
        {
          "href" : "",
          "HostRoles" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "host_name" : "c6401.ambari.apache.org"
          },
          "metrics" : {
            "dfs" : {
              "FSNamesystem" : {
                "HAState" : "active"
              }
            }
          }
        },
        result: null
      },
      {
        m: "NameNode on this host has no JMX data",
        data:
        {
          "href" : "",
          "HostRoles" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "host_name" : "c6401.ambari.apache.org"
          },
          "metrics" : {
          }
        },
        result: null
      }
    ];

    beforeEach(function () {
      sinon.stub(App, 'dateTime').returns(1435790048000);
    });

    afterEach(function () {
      App.dateTime.restore();
    });

    tests.forEach(function (test) {
      it(test.m, function () {
        var mainHostDetailsController = App.MainHostDetailsController.create({isNNCheckpointTooOld: null});
        mainHostDetailsController.parseNnCheckPointTime(test.data);
        expect(mainHostDetailsController.get('isNNCheckpointTooOld')).to.equal(test.result);
      });
    });
  });

  describe("#checkComponentDependencies()", function() {

    beforeEach(function () {
      this.mock = sinon.stub(App.StackServiceComponent, 'find');
      sinon.stub(App.HostComponent, 'find').returns([{
        hostName: 'host1',
        componentName: 'C1'
      }]);
    });
    afterEach(function () {
      this.mock.restore();
      App.HostComponent.find.restore();
    });

    it("no dependencies", function () {
      var opt = {scope: '*'};
      this.mock.returns(Em.Object.create({
        dependencies: []
      }));
      expect(controller.checkComponentDependencies('C1', opt)).to.be.empty;
    });
    it("dependecies already installed", function () {
      var opt = {scope: '*', installedComponents: ['C2']};
      this.mock.returns(Em.Object.create({
        dependencies: [{componentName: 'C2'}]
      }));
      expect(controller.checkComponentDependencies('C1', opt)).to.be.empty;
    });
    it("dependecies should be added", function () {
      var opt = {scope: '*', installedComponents: ['C2']};
      this.mock.returns(Em.Object.create({
        dependencies: [{componentName: 'C3'}]
      }));
      expect(controller.checkComponentDependencies('C1', opt)).to.eql(['C3']);
    });
    it("scope is host", function () {
      var opt = {scope: 'host', hostName: 'host1'};
      this.mock.returns(Em.Object.create({
        dependencies: [{componentName: 'C3', scope: 'host'}]
      }));
      expect(controller.checkComponentDependencies('C1', opt)).to.eql(['C3']);
    });
  });

  describe('#onLoadHiveConfigs', function() {

    beforeEach(function() {
      sinon.stub(controller, 'saveConfigsBatch', Em.K);
      sinon.stub(controller, 'saveLoadedConfigs', Em.K);
      controller.set('configs', {});
    });

    afterEach(function() {
      controller.saveConfigsBatch.restore();
      controller.saveLoadedConfigs.restore();
    });

    var makeHostComponentModel = function(componentName, hostNames) {
      if (Em.isArray(componentName)) {
        return componentName.map(function(cName, index) {
          return makeHostComponentModel(cName, hostNames[index]);
        }).reduce(function(p,c) { return p.concat(c); }, []);
      }
      return hostNames.map(function(hostName) {
        return {
          componentName: componentName,
          hostName: hostName
        };
      });
    };

    var makeFileNameProps = function(fileName, configs) {
      var ret = {
        type: fileName,
        properties: {}
      };
      var propRet = {};
      configs.forEach(function(property) {
        propRet[property[0]] = property[1];
      });
      ret.properties = propRet;
      return ret;
    };

    var makeEmptyPropAttrs = function() {
      var fileNames = Array.prototype.slice.call(arguments);
      var ret = {};
      fileNames.forEach(function(fileName) {
        ret[fileName] = {};
      });
      return ret;
    };

    var inlineComponentHostInfo = function(hostComponentModel) {
      return hostComponentModel.mapProperty('componentName').uniq()
        .map(function(componentName) {
          return componentName + ":" + hostComponentModel.filterProperty('componentName', componentName).mapProperty('hostName').join();
        }).join(',');
    };

    var tests = [
      {
        hostComponentModel: makeHostComponentModel(['HIVE_SERVER', 'HIVE_METASTORE'], [['host1', 'host2'], ['host1']]),
        configs: {
          items: [
            makeFileNameProps('hive-site', [
              ['hive.metastore.uris', 'thrift://host1:9090']
            ]),
            makeFileNameProps('hive-env', [
              ['hive_user', 'hive_user_val']
            ]),
            makeFileNameProps('webhcat-site', [
              ['templeton.hive.properties', 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9083,hive.metastore.sasl.enabled=false']
            ]),
            makeFileNameProps('core-site', [
              ['hadoop.proxyuser.hive_user_val.hosts', 'host1']
            ])
          ]
        },
        m: 'Components: {0}, appropriate configs should be changed, thrift port 9090, Controller stubs: {1}',
        e: {
          configs: [
            {
              "properties": {
                "hive-site": makeFileNameProps('hive-site', [
                  ['hive.metastore.uris', 'thrift://host1:9090']
                ]).properties,
                "webhcat-site": makeFileNameProps('webhcat-site', [
                  ['templeton.hive.properties', 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9090,hive.metastore.sasl.enabled=false']
                ]).properties,
                "hive-env": makeFileNameProps('hive-env', [
                  ['hive_user', 'hive_user_val']
                ]).properties
              },
              "properties_attributes": makeEmptyPropAttrs("hive-site", "webhcat-site", "hive-env")
            },
            {
              "properties": {
                "core-site": makeFileNameProps('core-site', [
                  ['hadoop.proxyuser.hive_user_val.hosts', 'host1,host2']
                ]).properties
              },
              "properties_attributes": makeEmptyPropAttrs("core-site")
            },
          ]
        }
      },
      {
        hostComponentModel: makeHostComponentModel(['HIVE_SERVER', 'HIVE_METASTORE', 'WEBHCAT_SERVER'], [['host1', 'host2'], ['host1'], ['host2']]),
        ctrlStubs: {
          webhcatServerHost: 'host3'
        },
        configs: {
          items: [
            makeFileNameProps('hive-site', [
              ['hive.metastore.uris', 'thrift://host1']
            ]),
            makeFileNameProps('hive-env', [
              ['hive_user', 'hive_user_val']
            ]),
            makeFileNameProps('webhcat-site', [
              ['templeton.hive.properties', 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9083,hive.metastore.sasl.enabled=false']
            ]),
            makeFileNameProps('core-site', [
              ['hadoop.proxyuser.hive_user_val.hosts', 'host1']
            ])
          ]
        },
        m: 'Components: {0}, appropriate configs should be changed, thrift port should be default 9083, Controller Stubs: {1}',
        e: {
          configs: [
            {
              "properties": {
                "hive-site": makeFileNameProps('hive-site', [
                  ['hive.metastore.uris', 'thrift://host1:9083']
                ]).properties,
                "webhcat-site": makeFileNameProps('webhcat-site', [
                  ['templeton.hive.properties', 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9083,hive.metastore.sasl.enabled=false']
                ]).properties,
                "hive-env": makeFileNameProps('hive-env', [
                  ['hive_user', 'hive_user_val']
                ]).properties
              },
              "properties_attributes": makeEmptyPropAttrs("hive-site", "webhcat-site", "hive-env")
            },
            {
              "properties": {
                "core-site": makeFileNameProps('core-site', [
                  ['hadoop.proxyuser.hive_user_val.hosts', 'host1,host2,host3']
                ]).properties
              },
              "properties_attributes": makeEmptyPropAttrs("core-site")
            },
          ]
        }
      },
      {
        hostComponentModel: makeHostComponentModel(['HIVE_SERVER', 'HIVE_METASTORE', 'WEBHCAT_SERVER'], [['host1'], ['host1'], ['host1']]),
        ctrlStubs: {
          webhcatServerHost: 'host3',
          hiveMetastoreHost: 'host2'
        },
        configs: {
          items: [
            makeFileNameProps('hive-site', [
              ['hive.metastore.uris', 'thrift://host1:1111']
            ]),
            makeFileNameProps('hive-env', [
              ['hive_user', 'hive_user_val']
            ]),
            makeFileNameProps('webhcat-site', [
              ['templeton.hive.properties', 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9083,hive.metastore.sasl.enabled=false']
            ]),
            makeFileNameProps('core-site', [
              ['hadoop.proxyuser.hive_user_val.hosts', 'host1']
            ])
          ]
        },
        m: 'Components: {0}, appropriate configs should be changed, thrift port should be 1111, Controller Stubs: {1}',
        e: {
          configs: [
            {
              "properties": {
                "hive-site": makeFileNameProps('hive-site', [
                  ['hive.metastore.uris', 'thrift://host1:1111,thrift://host2:1111']
                ]).properties,
                "webhcat-site": makeFileNameProps('webhcat-site', [
                  ['templeton.hive.properties', 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:1111\\,thrift://host2:1111,hive.metastore.sasl.enabled=false']
                ]).properties,
                "hive-env": makeFileNameProps('hive-env', [
                  ['hive_user', 'hive_user_val']
                ]).properties
              },
              "properties_attributes": makeEmptyPropAttrs("hive-site", "webhcat-site", "hive-env")
            },
            {
              "properties": {
                "core-site": makeFileNameProps('core-site', [
                  ['hadoop.proxyuser.hive_user_val.hosts', 'host1,host2,host3']
                ]).properties
              },
              "properties_attributes": makeEmptyPropAttrs("core-site")
            },
          ]
        }
      },
      {
        hostComponentModel: makeHostComponentModel(['HIVE_SERVER', 'HIVE_METASTORE', 'WEBHCAT_SERVER'], [['host1', 'host2'], ['host1','host2'], ['host1', 'host3']]),
        ctrlStubs: {
          fromDeleteHost: true,
          'content.hostName': 'host2',
          webhcatServerHost: '',
          hiveMetastoreHost: ''
        },
        webHCat: true,
        configs: {
          items: [
            makeFileNameProps('hive-site', [
              ['hive.metastore.uris', 'thrift://host1:1111']
            ]),
            makeFileNameProps('hive-env', [
              ['webhcat_user', 'webhcat_user_val']
            ]),
            makeFileNameProps('webhcat-site', [
              ['templeton.hive.properties', 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9083,hive.metastore.sasl.enabled=false']
            ]),
            makeFileNameProps('core-site', [
              ['hadoop.proxyuser.webhcat_user_val.hosts', 'host1']
            ])
          ]
        },
        m: 'Change WebHCat proxyuser',
        e: {
          configs: [
            {
              "properties": {
                "hive-site": makeFileNameProps('hive-site', [
                  ['hive.metastore.uris', 'thrift://host1:1111']
                ]).properties,
                "webhcat-site": makeFileNameProps('webhcat-site', [
                  ['templeton.hive.properties', 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9083,hive.metastore.sasl.enabled=false']
                ]).properties,
                "hive-env": makeFileNameProps('hive-env', [
                  ['webhcat_user', 'webhcat_user_val']
                ]).properties
              },
              "properties_attributes": makeEmptyPropAttrs("hive-site", "webhcat-site", "hive-env")
            },
            {
              "properties": {
                "core-site": makeFileNameProps('core-site', [
                  ['hadoop.proxyuser.webhcat_user_val.hosts', 'host1,host3']
                ]).properties
              },
              "properties_attributes": makeEmptyPropAttrs("core-site")
            },
          ]
        }
      },
      {
        hostComponentModel: makeHostComponentModel(['HIVE_SERVER', 'HIVE_METASTORE', 'WEBHCAT_SERVER'], [['host1', 'host2'], ['host1','host2'], ['host1', 'host3']]),
        ctrlStubs: {
          fromDeleteHost: true,
          'content.hostName': 'host2',
          webhcatServerHost: '',
          hiveMetastoreHost: ''
        },
        configs: {
          items: [
            makeFileNameProps('hive-site', [
              ['hive.metastore.uris', 'thrift://host1:1111']
            ]),
            makeFileNameProps('hive-env', [
              ['hive_user', 'hive_user_val']
            ]),
            makeFileNameProps('webhcat-site', [
              ['templeton.hive.properties', 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9083,hive.metastore.sasl.enabled=false']
            ]),
            makeFileNameProps('core-site', [
              ['hadoop.proxyuser.hive_user_val.hosts', 'host1']
            ])
          ]
        },
        m: 'Components: {0}, appropriate configs should be changed, thrift port should be default 9083, Controller Stubs: {1}',
        e: {
          configs: [
            {
              "properties": {
                "hive-site": makeFileNameProps('hive-site', [
                  ['hive.metastore.uris', 'thrift://host1:1111']
                ]).properties,
                "webhcat-site": makeFileNameProps('webhcat-site', [
                  ['templeton.hive.properties', 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:1111,hive.metastore.sasl.enabled=false']
                ]).properties,
                "hive-env": makeFileNameProps('hive-env', [
                  ['hive_user', 'hive_user_val']
                ]).properties
              },
              "properties_attributes": makeEmptyPropAttrs("hive-site", "webhcat-site", "hive-env")
            },
            {
              "properties": {
                "core-site": makeFileNameProps('core-site', [
                  ['hadoop.proxyuser.hive_user_val.hosts', 'host1,host3']
                ]).properties
              },
              "properties_attributes": makeEmptyPropAttrs("core-site")
            }
          ]
        }
      }
    ];

    tests.forEach(function(test) {
      describe(test.m.format(inlineComponentHostInfo(test.hostComponentModel), test.ctrlStubs ? JSON.stringify(test.ctrlStubs) : 'None'), function() {

        beforeEach(function () {
          if (test.appGetterStubs) {
            Em.keys(test.appGetterStubs).forEach(function(key) {
              sinon.stub(App, 'get').withArgs(key).returns(test.appGetterStubs[key]);
            });
          }
          if (test.ctrlStubs) {
            var stub = sinon.stub(controller, 'get');
            Em.keys(test.ctrlStubs).forEach(function(key) {
              stub.withArgs(key).returns(test.ctrlStubs[key]);
            });
          }
          sinon.stub(App.HostComponent, 'find').returns(test.hostComponentModel);
        });

        afterEach(function () {
          if (test.ctrlStubs) {
            controller.get.restore();
          }
          if (test.appGetterStubs) {
            App.get.restore();
          }
          App.HostComponent.find.restore();
        });

        it('saveConfigsBatch is called with correct configs', function () {
          controller.onLoadHiveConfigs(test.configs, null, {webHCat: test.webHCat});
          var configs = controller.saveConfigsBatch.args[0];
          var properties = configs[0];
          expect(properties).to.be.eql(test.e.configs);
        });

      });
    });
  });

  describe('#setConfigsChangesForDisplay', function () {

    var propertiesToChange = [
        {
          propertyName: 'n0',
          propertyFileName: 'f0'
        },
        {
          propertyName: 'n1',
          propertyFileName: 'f1'
        },
        {
          propertyName: 'n2',
          propertyFileName: 'f2'
        },
        {
          propertyName: 'n3',
          propertyFileName: 'f3'
        }
      ],
      result = {
        recommendedPropertiesToChange: [
          {
            propertyName: 'n0',
            propertyFileName: 'f0',
            saveRecommended: true
          },
          {
            propertyName: 'n3',
            propertyFileName: 'f3',
            saveRecommended: true
          }
        ],
        requiredPropertiesToChange: [
          {
            propertyName: 'n1',
            propertyFileName: 'f1'
          },
          {
            propertyName: 'n2',
            propertyFileName: 'f2'
          }
        ]
      };

    beforeEach(function () {
      controller.setProperties({
        allPropertiesToChange: propertiesToChange,
        recommendedPropertiesToChange: [],
        requiredPropertiesToChange: []
      });
      sinon.stub(App.configsCollection, 'getConfigByName', function (propertyName) {
        var map = {
          n0: {
            isEditable: true,
            isReconfigurable: true
          },
          n1: {
            isEditable: true,
            isReconfigurable: false
          },
          n2: {
            isEditable: false,
            isReconfigurable: false
          }
        };
        return map[propertyName];
      });
      sinon.stub(App, 'get').withArgs('router.clusterController.isConfigsPropertiesLoaded').returns(true);
      controller.set('isConfigsLoadingInProgress', true);
      controller.setConfigsChangesForDisplay();
    });

    afterEach(function () {
      App.configsCollection.getConfigByName.restore();
      App.get.restore();
    });

    it('editable changes', function () {
      expect(controller.get('recommendedPropertiesToChange').toArray()).to.eql(result.recommendedPropertiesToChange);
    });

    it('non-editable changes', function () {
      expect(controller.get('requiredPropertiesToChange').toArray()).to.eql(result.requiredPropertiesToChange);
    });

    it('isConfigsLoadingInProgress', function () {
      expect(controller.get('isConfigsLoadingInProgress')).to.be.false;
    });

  });

  describe('#clearConfigsChanges', function () {

    beforeEach(function () {
      sinon.stub(controller, 'abortRequests', Em.K);
      controller.setProperties({
        allPropertiesToChange: [{}],
        recommendedPropertiesToChange: [{}],
        requiredPropertiesToChange: [{}],
        groupedPropertiesToChange: [{}],
        isReconfigureRequired: true,
        configs: {}
      });
    });

    afterEach(function () {
      controller.abortRequests.restore();
    });

    describe('default case', function () {

      beforeEach(function () {
        controller.clearConfigsChanges();
      });

      it('allPropertiesToChange', function () {
        expect(controller.get('allPropertiesToChange')).to.have.length(0);
      });

      it('recommendedPropertiesToChange', function () {
        expect(controller.get('recommendedPropertiesToChange')).to.have.length(0);
      });

      it('groupedPropertiesToChange', function () {
        expect(controller.get('groupedPropertiesToChange')).to.have.length(0);
      });

      it('isReconfigureRequired', function () {
        expect(controller.get('isReconfigureRequired')).to.be.false;
      });

      it('configs', function () {
        expect(controller.get('configs')).to.be.null;
      });

    });

    describe('no loaded configs cleanup', function () {

      beforeEach(function () {
        controller.clearConfigsChanges(true);
      });

      it('configs shouldn\'t be cleared', function () {
        expect(controller.get('configs')).to.not.be.null;
      });

    });

  });

  describe('#saveLoadedConfigs', function () {

    var data = {
      items: [
        {
          type: 't0',
          properties: {
            p0: 'v0',
            p1: 'v1'
          },
          properties_attributes: {}
        },
        {
          type: 't1',
          properties: {
            p2: 'v2',
            p3: 'v3'
          },
          properties_attributes: {}
        }
      ]
    };

    it('should store data in configs object', function () {
      controller.set('configs', null);
      controller.saveLoadedConfigs(data);
      expect(controller.get('configs')).to.eql(data);
    });

  });

  describe('#loadComponentRelatedConfigs', function () {

    var testCases = [
      {
        isReconfigureRequired: true,
        loadConfigsCallCount: 1,
        isConfigsLoadingInProgress: true,
        message: 'reconfigure required'
      },
      {
        isReconfigureRequired: false,
        loadConfigsCallCount: 0,
        isConfigsLoadingInProgress: false,
        message: 'no reconfigure required'
      }
    ];

    testCases.forEach(function (test) {

      describe(test.message, function () {

        beforeEach(function () {
          sinon.stub(controller, 'isServiceMetricsLoaded', Em.clb);
          sinon.stub(controller, 'loadConfigs', Em.K);
          controller.setProperties({
            isReconfigureRequired: test.isReconfigureRequired,
            isConfigsLoadingInProgress: false
          });
          controller.loadComponentRelatedConfigs();
        });

        afterEach(function () {
          controller.isServiceMetricsLoaded.restore();
          controller.loadConfigs.restore();
        });

        it('loadConfigs', function () {
          expect(controller.loadConfigs.callCount).to.equal(test.loadConfigsCallCount);
        });

        it('isConfigsLoadingInProgress', function () {
          expect(controller.get('isConfigsLoadingInProgress')).to.equal(test.isConfigsLoadingInProgress);
        });

      });

    });

  });
});

});

require.register("test/controllers/main/host/host_alerts_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/host/host_alerts_controller');

var controller;

function getController() {
  return App.MainHostAlertsController.create();
}

describe('App.MainHostAlertsController', function () {

  beforeEach(function() {
    controller = getController();
  });

  App.TestAliases.testAsComputedAlias(getController(), 'selectedHost', 'App.router.mainHostDetailsController.content', 'object');

  describe("#routeToAlertDefinition()", function () {

    beforeEach(function () {
      sinon.stub(App.AlertDefinition, 'find').returns('alertDefinition');
      sinon.stub(App.router, 'transitionTo', Em.K);
    });
    afterEach(function () {
      App.AlertDefinition.find.restore();
      App.router.transitionTo.restore();
    });

    it("transitionTo is called with valid route and data", function () {
      controller.routeToAlertDefinition({context: 'id'});
      expect(App.router.transitionTo.calledWith('main.alerts.alertDetails', 'alertDefinition')).to.be.true;
    });
  });

});

});

require.register("test/controllers/main/host_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var testHelpers = require('test/helpers');
require('utils/batch_scheduled_requests');
require('controllers/main/host');
require('mappers/server_data_mapper');

describe('MainHostController', function () {

  var hostController, db;

  beforeEach(function () {
    hostController = App.MainHostController.create({});
  });

  afterEach(function () {
    hostController.destroy();
  });

  describe("#totalCount()", function () {

    it("TOTAL is undefined", function () {
      hostController.set('hostsCountMap', {});
      hostController.propertyDidChange('totalCount');
      expect(hostController.get('totalCount')).to.be.equal(0);
    });

    it("TOTAL is 1", function () {
      hostController.set('hostsCountMap', {TOTAL: 1});
      hostController.propertyDidChange('totalCount');
      expect(hostController.get('totalCount')).to.be.equal(1);
    });
  });

  describe('#getRegExp()', function () {
    var message = '`{0}` should convert to `{1}`',
      tests = [
        {value: '.*', expected: '.*'},
        {value: '.', expected: '.*'},
        {value: '.*.*', expected: '.*'},
        {value: '*', expected: '^$'},
        {value: '........', expected: '.*'},
        {value: '........*', expected: '.*'},
        {value: 'a1', expected: '.*a1.*'},
        {value: 'a1.', expected: '.*a1.*'},
        {value: 'a1...', expected: '.*a1.*'},
        {value: 'a1.*', expected: '.*a1.*'},
        {value: 'a1.*.a2.a3', expected: '.*a1.*.a2.a3.*'},
        {value: 'a1.*.a2...a3', expected: '.*a1.*.a2...a3.*'}
      ];

    tests.forEach(function (test) {
      it(message.format(test.value, test.expected), function () {
        expect(hostController.getRegExp(test.value)).to.be.equal(test.expected);
      });
    });
  });

  describe('#getQueryParameters', function () {
    beforeEach(function () {
      sinon.spy(hostController, 'getRegExp');
      sinon.stub(App.db, 'getFilterConditions', function () {
        return [{
          iColumn: 1,
          skipFilter: false,
          type: "string",
          value: "someval"
        }];
      });
    });

    afterEach(function () {
      App.db.getFilterConditions.restore();
      hostController.getRegExp.restore();
    });

    it('should call #getRegExp with value `someval` on host name filter', function () {
      hostController.getQueryParameters();
      expect(hostController.getRegExp.calledWith('someval')).to.ok;
    });

    it('result should include host name filter converted value', function () {
      expect(hostController.getQueryParameters().findProperty('key', 'Hosts/host_name').value).to.equal('.*someval.*');
    });
  });

  describe('#getSortProps', function () {

    beforeEach(function () {
      db = {
        mainHostController: [
          {name: 'hostName', status: 'sorting'}
        ]
      };
      sinon.stub(App.db, 'getSortingStatuses', function (k) {
        return db[k];
      });
      sinon.stub(App.db, 'setSortingStatuses', function (k, v) {
        db[k] = Em.makeArray(v);
      });
    });

    afterEach(function () {
      App.db.getSortingStatuses.restore();
      App.db.setSortingStatuses.restore();
    });

    it('should set default sorting condition', function () {
      hostController.getSortProps();
      expect(db.mainHostController).to.eql([{name: 'hostName', status: 'sorting_asc'}]);
    });

  });

  describe("#updateStatusCounters()", function() {

    it("isCountersUpdating is false", function() {
      hostController.set('isCountersUpdating', false);
      hostController.updateStatusCounters();
      expect(testHelpers.findAjaxRequest('name', 'host.status.counters')).to.be.undefined;
    });

    it("isCountersUpdating is true", function() {
      hostController.set('isCountersUpdating', true);
      hostController.updateStatusCounters();
      expect(testHelpers.findAjaxRequest('name', 'host.status.counters')).to.be.exist;
    });
  });

  describe("#updateStatusCountersSuccessCallback()", function() {
    var data = {
      Clusters: {
        health_report: {
          'Host/host_status/HEALTHY': 1,
          'Host/host_status/UNHEALTHY': 2,
          'Host/host_status/ALERT': 3,
          'Host/host_status/UNKNOWN': 4,
          'Host/stale_config': 5,
          'Host/maintenance_state': 6
        },
        total_hosts: 21
      }
    };

    it("hostsCountMap should be set", function() {
      hostController.updateStatusCountersSuccessCallback(data);
      expect(hostController.get('hostsCountMap')).to.be.eql({
        "HEALTHY": 1,
        "UNHEALTHY": 2,
        "ALERT": 3,
        "UNKNOWN": 4,
        "health-status-RESTART": 5,
        "health-status-PASSIVE_STATE": 6,
        "TOTAL": 21
      });
    });
  });

  describe("#getProperValue()", function() {

    var testCases = [
      {
        input: '>1',
        expected: '1'
      },
      {
        input: '<1',
        expected: '1'
      },
      {
        input: '=1',
        expected: '1'
      },
      {
        input: '1',
        expected: '1'
      }
    ];

    testCases.forEach(function(test) {
      it("value =" + test.input, function() {
        expect(hostController.getProperValue(test.input)).to.be.equal(test.expected);
      });
    });

  });

  describe("#convertMemory()", function() {

    beforeEach(function() {
      sinon.stub(hostController, 'getProperValue', function(input) {
        return input;
      })
    });
    afterEach(function() {
      hostController.getProperValue.restore();
    });

    var testCases = [
      {
        input: 'm',
        expected: 'm'
      },
      {
        input: '1',
        expected: 1048576
      },
      {
        input: '1g',
        expected: 1048576
      },
      {
        input: '1m',
        expected: 1024
      },
      {
        input: '1k',
        expected: 1
      }
    ];

    testCases.forEach(function(test) {
      it("value =" + test.input, function() {
        expect(hostController.convertMemory(test.input)).to.be.equal(test.expected);
      });
    });
  });

  describe("#convertMemoryToRange()", function() {

    beforeEach(function() {
      sinon.stub(hostController, 'rangeConvertNumber', function(arg1) {
        return [arg1, arg1];
      })
    });
    afterEach(function() {
      hostController.rangeConvertNumber.restore();
    });

    var testCases = [
      {
        input: 'm',
        expected: [0, 0]
      },
      {
        input: '1',
        expected: [1048576, 1048576]
      },
      {
        input: '1g',
        expected: [1048576, 1048576]
      },
      {
        input: '1m',
        expected: [1024, 1024]
      },
      {
        input: '1k',
        expected: [1, 1]
      }
    ];

    testCases.forEach(function(test) {
      it("value =" + test.input, function() {
        expect(hostController.convertMemoryToRange(test.input)).to.be.eql(test.expected);
      });
    });
  });

  describe("#rangeConvertNumber()", function() {

    var testCases = [
      {
        value: 'm',
        scale: '',
        expected: [0, 0]
      },
      {
        value: 1,
        scale: '',
        expected: [0.995, 1.004999999]
      },
      {
        value: 1,
        scale: 'g',
        expected: [0.995, 1.004999999]
      },
      {
        value: 1,
        scale: 'm',
        expected: [0.95, 1.04999]
      },
      {
        value: 1,
        scale: 'k',
        expected: [0.95, 1.04999]
      }
    ];

    testCases.forEach(function(test) {
      it("value = " + test.value + 'scale = ' + test.scale, function() {
        expect(hostController.rangeConvertNumber(test.value, test.scale)).to.be.eql(test.expected);
      });
    });
  });

  describe("#getComparisonType()", function() {

    var testCases = [
      {
        value: '1',
        expected: 'EQUAL'
      },
      {
        value: '>',
        expected: 'MORE'
      },
      {
        value: '<',
        expected: 'LESS'
      },
      {
        value: '=',
        expected: 'EQUAL'
      }
    ];

    testCases.forEach(function(test) {
      it("value = " + test.value, function() {
        expect(hostController.getComparisonType(test.value)).to.be.equal(test.expected);
      });
    });
  });

  describe("#filterByComponent()", function() {

    beforeEach(function() {
      sinon.stub(App.db, 'setFilterConditions');
    });
    afterEach(function() {
      App.db.setFilterConditions.restore();
    });

    it("component is null", function() {
      hostController.filterByComponent();
      expect(App.db.setFilterConditions.called).to.be.false;
    });

    it("component exist", function() {
      hostController.set('name', 'ctrl1');
      hostController.filterByComponent(Em.Object.create({
        componentName: 'C1'
      }));
      expect(App.db.setFilterConditions.calledWith('ctrl1', [{
        iColumn: 15,
        value: 'C1:ALL',
        type: 'string'
      }])).to.be.true;
    });
  });

  describe("#filterByStack()", function() {

    beforeEach(function() {
      sinon.stub(App.db, 'setFilterConditions');
    });
    afterEach(function() {
      App.db.setFilterConditions.restore();
    });

    it("displayName is null", function() {
      hostController.filterByStack(null, ['INSTALLED']);
      expect(App.db.setFilterConditions.called).to.be.false;
    });

    it("state is null", function() {
      hostController.filterByStack('stack1', null);
      expect(App.db.setFilterConditions.called).to.be.false;
    });

    it("stack and displayName exist", function() {
      hostController.set('name', 'ctrl1');
      hostController.filterByStack('stack1', ['INSTALLED']);
      expect(App.db.setFilterConditions.calledWith('ctrl1', [
      {
        iColumn: 16,
        value: 'stack1',
        type: 'string'
      },
      {
        iColumn: 17,
        value: ['INSTALLED'],
        type: 'string'
      }])).to.be.true;
    });
  });

  describe("#goToHostAlerts()", function() {

    beforeEach(function() {
      sinon.stub(App.router, 'transitionTo');
    });
    afterEach(function() {
      App.router.transitionTo.restore();
    });

    it("event is null", function() {
      hostController.goToHostAlerts(null);
      expect(App.router.transitionTo.called).to.be.false;
    });

    it("event.context is null", function() {
      hostController.goToHostAlerts({context: null});
      expect(App.router.transitionTo.called).to.be.false;
    });

    it("event.context is exist", function() {
      hostController.goToHostAlerts({context: {}});
      expect(App.router.transitionTo.calledWith('main.hosts.hostDetails.alerts', {})).to.be.true;
    });
  });

  describe("#removeHosts()", function() {

    it("host should be removed", function() {
      var host1 = Em.Object.create({id: 'host1', isChecked: true});
      hostController.set('content', [host1]);
      hostController.set('fullContent', [host1]);
      hostController.removeHosts();
      expect(hostController.get('fullContent')).to.be.empty;
    });
  });

  describe("#checkRemoved()", function() {

    it("host should be removed", function() {
      var host1 = Em.Object.create({id: 'host1', isChecked: true});
      hostController.set('content', [host1]);
      hostController.set('fullContent', [host1]);
      hostController.checkRemoved('host1');
      expect(hostController.get('fullContent')).to.be.empty;
    });
  });

});

});

require.register("test/controllers/main/service/add_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/wizard');
require('controllers/main/service/add_controller');
var addServiceController = null;
var testHelpers = require('test/helpers');

describe('App.AddServiceController', function() {

  beforeEach(function () {
    addServiceController = App.AddServiceController.create({});
  });

  describe('#generateDataForInstallServices', function() {
    var tests = [{
      selected: ["YARN","HBASE"],
      res: {
        "context": Em.I18n.t('requestInfo.installServices'),
        "ServiceInfo": {"state": "INSTALLED"},
        "urlParams": "ServiceInfo/service_name.in(YARN,HBASE)"
      }
    },
    {
      selected: ['OOZIE'],
      res: {
        "context": Em.I18n.t('requestInfo.installServices'),
        "ServiceInfo": {"state": "INSTALLED"},
        "urlParams": "ServiceInfo/service_name.in(OOZIE,HDFS,YARN,MAPREDUCE2)"
      }
    }];
    tests.forEach(function(t){
      it('should generate data with ' + t.selected.join(","), function () {
        expect(addServiceController.generateDataForInstallServices(t.selected)).to.be.eql(t.res);
      });
    });
  });

  describe('#saveServices', function() {
    beforeEach(function() {
      sinon.stub(addServiceController, 'setDBProperty', Em.K);
    });

    afterEach(function() {
      addServiceController.setDBProperty.restore();
    });

    var tests = [
      {
        appService: [
          Em.Object.create({ serviceName: 'HDFS' }),
          Em.Object.create({ serviceName: 'KERBEROS' })
        ],
        stepCtrlContent: Em.Object.create({
          content: Em.A([
            Em.Object.create({ serviceName: 'HDFS', isInstalled: true, isSelected: true }),
            Em.Object.create({ serviceName: 'YARN', isInstalled: false, isSelected: true })
          ])
        }),
        e: {
          selected: ['YARN'],
          installed: ['HDFS', 'KERBEROS']
        }
      },
      {
        appService: [
          Em.Object.create({ serviceName: 'HDFS' }),
          Em.Object.create({ serviceName: 'STORM' })
        ],
        stepCtrlContent: Em.Object.create({
          content: Em.A([
            Em.Object.create({ serviceName: 'HDFS', isInstalled: true, isSelected: true }),
            Em.Object.create({ serviceName: 'YARN', isInstalled: false, isSelected: true }),
            Em.Object.create({ serviceName: 'MAPREDUCE2', isInstalled: false, isSelected: true })
          ])
        }),
        e: {
          selected: ['YARN', 'MAPREDUCE2'],
          installed: ['HDFS', 'STORM']
        }
      }
    ];

    var message = '{0} installed, {1} selected. Installed list should be {2} and selected - {3}';
    tests.forEach(function(test) {

      var installed = test.appService.mapProperty('serviceName');
      var selected = test.stepCtrlContent.get('content').filterProperty('isSelected', true)
        .filterProperty('isInstalled', false).mapProperty('serviceName');

      describe(message.format(installed, selected, test.e.installed, test.e.selected), function() {

        beforeEach(function () {
          sinon.stub(App.Service, 'find').returns(test.appService);
          addServiceController.saveServices(test.stepCtrlContent);
          this.savedServices = addServiceController.setDBProperty.withArgs('services').args[0][1];
        });

        afterEach(function () {
          App.Service.find.restore();
        });

        it(JSON.stringify(test.e.selected) + ' are in the selectedServices', function () {
          expect(this.savedServices.selectedServices).to.have.members(test.e.selected);
        });

        it(JSON.stringify(test.e.installed) + ' are in the installedServices', function () {
          expect(this.savedServices.installedServices).to.have.members(test.e.installed);
        });

      });
    });
  });

  describe('#loadHosts', function () {

    var cases = [
      {
        hosts: {},
        isAjaxRequestSent: false,
        title: 'hosts are already loaded'
      },
      {
        areHostsLoaded: false,
        isAjaxRequestSent: true,
        title: 'hosts aren\'t yet loaded'
      }
    ];

    afterEach(function () {
      addServiceController.getDBProperty.restore();
    });

    cases.forEach(function (item) {
      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(addServiceController, 'getDBProperty').withArgs('hosts').returns(item.hosts);
          addServiceController.loadHosts();
          this.args = testHelpers.findAjaxRequest('name', 'hosts.confirmed');
        });

        it('request is ' + (item.isAjaxRequestSent ? '' : 'not') + ' sent', function () {
          expect(Em.isNone(this.args)).to.be.equal(!item.isAjaxRequestSent);
        });
      });
    });

  });

  describe('#loadHostsSuccessCallback', function () {

    it('should load hosts to local db and model', function () {
      var diskInfo = [
          {
            available: '600000',
            used: '400000',
            percent: '40%',
            size: '10000000',
            type: 'ext4',
            mountpoint: '/'
          },
          {
            available: '500000',
            used: '300000',
            percent: '50%',
            size: '6000000',
            type: 'ext4',
            mountpoint: '/'
          }
        ],
        hostComponents = [
          [
            {
              HostRoles: {
                component_name: 'c0',
                state: 'STARTED'
              }
            },
            {
              HostRoles: {
                component_name: 'c1',
                state: 'INSTALLED'
              }
            }
          ],
          [
            {
              HostRoles: {
                component_name: 'c2',
                state: 'STARTED'
              }
            },
            {
              HostRoles: {
                component_name: 'c3',
                state: 'INSTALLED'
              }
            }
          ]
        ],
        response = {
          items: [
            {
              Hosts: {
                cpu_count: 1,
                disk_info: [
                  diskInfo[0]
                ],
                host_name: 'h0',
                ip: '10.1.1.0',
                os_arch: 'x86_64',
                os_type: 'centos6',
                total_mem: 4194304,
                maintenance_state: 'ON'
              },
              host_components: hostComponents[0]
            },
            {
              Hosts: {
                cpu_count: 2,
                disk_info: [
                  diskInfo[1]
                ],
                host_name: 'h1',
                ip: '10.1.1.1',
                os_arch: 'x86',
                os_type: 'centos5',
                total_mem: 3145728,
                maintenance_state: 'OFF'
              },
              host_components: hostComponents[1]
            }
          ]
        },
        expected = {
          h0: {
            name: 'h0',
            cpu: 1,
            memory: 4194304,
            disk_info: [diskInfo[0]],
            osType: 'centos6',
            osArch: 'x86_64',
            ip: '10.1.1.0',
            bootStatus: 'REGISTERED',
            isInstalled: true,
            maintenance_state: 'ON',
            hostComponents: hostComponents[0],
            id: 0
          },
          h1: {
            name: 'h1',
            cpu: 2,
            memory: 3145728,
            disk_info: [diskInfo[1]],
            osType: 'centos5',
            osArch: 'x86',
            ip: '10.1.1.1',
            bootStatus: 'REGISTERED',
            isInstalled: true,
            maintenance_state: 'OFF',
            hostComponents: hostComponents[1],
            id: 1
          }
        };
      addServiceController.loadHostsSuccessCallback(response);
      var hostsInDb = addServiceController.getDBProperty('hosts');
      var hostsInModel = addServiceController.get('content.hosts');
      expect(hostsInDb).to.eql(expected);
      expect(hostsInModel).to.eql(expected);
    });

  });

  describe('#loadHostsErrorCallback', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, 'defaultErrorHandler', Em.K);
    });

    afterEach(function () {
      App.ajax.defaultErrorHandler.restore();
    });

    it('should execute default error handler', function () {
      addServiceController.loadHostsErrorCallback({status: '500'}, 'textStatus', 'errorThrown', {url: 'url', type: 'GET'});
      expect(App.ajax.defaultErrorHandler.calledOnce).to.be.true;
      expect(App.ajax.defaultErrorHandler.calledWith({status: '500'}, 'url', 'GET', '500')).to.be.true;
    });

  });

  describe('#loadServices', function() {
    var mock = {
      db: {}
    };
    beforeEach(function() {
      this.controller = App.AddServiceController.create({});
      this.mockGetDBProperty = sinon.stub(this.controller, 'getDBProperty');
      sinon.stub(this.controller, 'setDBProperty', function(key, value) {
        mock.db = value;
      });
      sinon.stub(this.controller, 'hasDependentSlaveComponent');
      sinon.stub(App.store, 'fastCommit', Em.K);
      this.mockStackService = sinon.stub(App.StackService, 'find');
      this.mockService = sinon.stub(App.Service, 'find');
    });

    afterEach(function() {
      this.mockGetDBProperty.restore();
      this.controller.setDBProperty.restore();
      this.controller.hasDependentSlaveComponent.restore();
      this.mockStackService.restore();
      this.mockService.restore();
      App.store.fastCommit.restore();
    });

    var tests = [
      {
        appStackService: [
          Em.Object.create({ id: 'HDFS', serviceName: 'HDFS', coSelectedServices: []}),
          Em.Object.create({ id: 'YARN', serviceName: 'YARN', coSelectedServices: ['MAPREDUCE2']}),
          Em.Object.create({ id: 'MAPREDUCE2', serviceName: 'MAPREDUCE2', coSelectedServices: []}),
          Em.Object.create({ id: 'FALCON', serviceName: 'FALCON', coSelectedServices: []}),
          Em.Object.create({ id: 'STORM', serviceName: 'STORM', coSelectedServices: []})
        ],
        appService: [
          Em.Object.create({ id: 'HDFS', serviceName: 'HDFS'}),
          Em.Object.create({ id: 'STORM', serviceName: 'STORM'})
        ],
        servicesFromDB: false,
        serviceToInstall: 'MAPREDUCE2',
        e: {
          selectedServices: ['HDFS', 'YARN', 'MAPREDUCE2', 'STORM'],
          installedServices: ['HDFS', 'STORM']
        },
        m: 'MapReduce selected on Admin -> Stack Versions Page, Yarn service should be selected because it coselected'
      },
      {
        appStackService: [
          Em.Object.create({ id: 'HDFS', serviceName: 'HDFS', coSelectedServices: []}),
          Em.Object.create({ id: 'YARN', serviceName: 'YARN', coSelectedServices: ['MAPREDUCE2']}),
          Em.Object.create({ id: 'HBASE', serviceName: 'HBASE', coSelectedServices: []}),
          Em.Object.create({ id: 'STORM', serviceName: 'STORM', coSelectedServices: []})
        ],
        appService: [
          Em.Object.create({ id: 'HDFS', serviceName: 'HDFS'}),
          Em.Object.create({ id: 'STORM', serviceName: 'STORM'})
        ],
        servicesFromDB: {
          selectedServices: ['HBASE'],
          installedServices: ['HDFS', 'STORM']
        },
        serviceToInstall: null,
        e: {
          selectedServices: ['HDFS', 'HBASE', 'STORM'],
          installedServices: ['HDFS', 'STORM']
        },
        m: 'HDFS and STORM are installed. Select HBASE'
      }
    ];

    tests.forEach(function(test) {
      describe(test.m, function() {

        beforeEach(function () {
          this.mockStackService.returns(test.appStackService);
          this.mockService.returns(test.appService);
          this.mockGetDBProperty.withArgs('services').returns(test.servicesFromDB);
          this.controller.set('serviceToInstall', test.serviceToInstall);
          this.controller.loadServices();
        });

        if (test.servicesFromDB) {
          // verify values for App.StackService
          it(JSON.stringify(test.e.selectedServices) + ' are selected', function () {
            expect(test.appStackService.filterProperty('isSelected', true).mapProperty('serviceName')).to.be.eql(test.e.selectedServices);
          });
          it(JSON.stringify(test.e.installedServices) + ' are installed', function () {
            expect(test.appStackService.filterProperty('isInstalled', true).mapProperty('serviceName')).to.be.eql(test.e.installedServices);
          });
        }
        else {
          // verify saving to local db on first enter to the wizard
          it('selectedServices are saced', function () {
            expect(mock.db.selectedServices).to.be.eql(test.e.selectedServices);
          });
          it('installedServices are saved', function () {
            expect(mock.db.installedServices).to.be.eql(test.e.installedServices);
          });

        }

        it('serviceToInstall is null', function () {
          expect(this.controller.get('serviceToInstall')).to.be.null;
        });

      });
    }, this);
  });

  describe('#checkSecurityStatus', function () {

    var cases = [
      {
        securityEnabled: true,
        skipConfigureIdentitiesStep: false,
        isStep5Disabled: false,
        title: 'security enabled'
      },
      {
        securityEnabled: false,
        skipConfigureIdentitiesStep: true,
        isStep5Disabled: true,
        title: 'security disabled'
      }
    ];

    beforeEach(function () {
      addServiceController.setProperties({
        skipConfigureIdentitiesStep: false,
        isStepDisabled: [
          Em.Object.create({
            step: 5,
            value: false
          })
        ]
      });
    });

    afterEach(function () {
      App.get.restore();
    });

    cases.forEach(function (item) {
      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(App, 'get').withArgs('isKerberosEnabled').returns(item.securityEnabled);
          addServiceController.checkSecurityStatus();
        });

        it('skipConfigureIdentitiesStep is ' + item.skipConfigureIdentitiesStep, function () {
          expect(addServiceController.get('skipConfigureIdentitiesStep')).to.equal(item.skipConfigureIdentitiesStep);
        });

        it('step 5 is ' + (item.isStep5Disabled ? 'disabved' : 'enabled'), function () {
          expect(addServiceController.get('isStepDisabled').findProperty('step', 5).get('value')).to.equal(item.isStep5Disabled);
        });

      });
    });

  });

  describe('#loadServiceConfigGroups', function () {

    var dbMock,
      dbMock2,
      cases = [
        {
          serviceConfigGroups: null,
          areInstalledConfigGroupsLoaded: false,
          title: 'config groups not yet loaded'
        },
        {
          serviceConfigGroups: [],
          areInstalledConfigGroupsLoaded: true,
          title: 'config groups already loaded'
        }
      ];

    beforeEach(function () {
      dbMock = sinon.stub(addServiceController, 'getDBProperties');
      dbMock2 = sinon.stub(addServiceController, 'getDBProperty');
    });

    afterEach(function () {
      dbMock.restore();
      dbMock2.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        dbMock.withArgs(['serviceConfigGroups', 'hosts']).returns({
          hosts: {},
          serviceConfigGroups: item.serviceConfigGroups
        });
        dbMock2.withArgs('hosts').returns({}).
          withArgs('serviceConfigGroups').returns(item.serviceConfigGroups);
        addServiceController.loadServiceConfigGroups();
        expect(addServiceController.get('areInstalledConfigGroupsLoaded')).to.equal(item.areInstalledConfigGroupsLoaded);
      });
    });

  });

  describe('#clearStorageData', function () {
    it('areInstalledConfigGroupsLoaded should be false', function () {
      addServiceController.set('areInstalledConfigGroupsLoaded', true);
      addServiceController.clearStorageData();
      expect(addServiceController.get('areInstalledConfigGroupsLoaded')).to.be.false;
    });
  });

  describe('#loadClients', function () {

    var cases = [
      {
        clients: null,
        contentClients: [],
        saveClientsCallCount: 1,
        title: 'no clients info in local db'
      },
      {
        clients: [{}],
        contentClients: [{}],
        saveClientsCallCount: 0,
        title: 'clients info saved in local db'
      }
    ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(addServiceController, 'getDBProperty').withArgs('clientInfo').returns(item.clients);
          sinon.stub(addServiceController, 'saveClients', Em.K);
          addServiceController.set('content.clients', []);
          addServiceController.loadClients();
        });

        afterEach(function () {
          addServiceController.getDBProperty.restore();
          addServiceController.saveClients.restore();
        });

        it('content.clients', function () {
          expect(addServiceController.get('content.clients', [])).to.eql(item.contentClients);
        });

        it('saveClients call', function () {
          expect(addServiceController.saveClients.callCount).to.equal(item.saveClientsCallCount);
        });

      });

    });

  });

  describe('#getServicesBySelectedSlaves', function () {

    beforeEach(function () {
      sinon.stub(App.StackServiceComponent, 'find').returns([
        Em.Object.create({
          componentName: 'c1',
          serviceName: 's1'
        }),
        Em.Object.create({
          componentName: 'c2',
          serviceName: 's2'
        }),
        Em.Object.create({
          componentName: 'c3',
          serviceName: 's3'
        }),
        Em.Object.create({
          componentName: 'c4',
          serviceName: 's1'
        })
      ]);
    });

    [
      {
        title: 'should return empty array',
        sch: [],
        expect: []
      },
      {
        title: 'should return empty array if component is absent in StackServiceComponent model',
        sch: [
          {
            componentName: 'c5',
            hosts: [
              {
                isInstalled: false
              },
              {
                isInstalled: true
              }
            ]
          },
        ],
        expect: []
      },
      {
        title: 'should return services for not installed slaves',
        sch: [
          {
            componentName: 'c1',
            hosts: [
              {
                isInstalled: false
              },
              {
                isInstalled: true
              }
            ]
          },
          {
            componentName: 'c2',
            hosts: [
              {
                isInstalled: false
              },
              {
                isInstalled: true
              }
            ]
          },
          {
            componentName: 'c4',
            hosts: [
              {
                isInstalled: false
              },
              {
                isInstalled: true
              }
            ]
          }
        ],
        expect: ['s1', 's2']
      }
    ].forEach(function (test) {
          describe(test.title, function () {
            it(function () {
              addServiceController.set('content.slaveComponentHosts', test.sch);
              expect(addServiceController.getServicesBySelectedSlaves()).to.eql(test.expect);
            });
          })
        });

  });

});

});

require.register("test/controllers/main/service/info/config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/service/info/configs');
var batchUtils = require('utils/batch_scheduled_requests');
var mainServiceInfoConfigsController = null;
var testHelpers = require('test/helpers');

function getController() {
  return App.MainServiceInfoConfigsController.create({
    dependentServiceNames: [],
    loadDependentConfigs: function () {
      return {done: Em.K}
    },
    loadConfigTheme: function () {
      return $.Deferred().resolve().promise();
    }
  });
}

describe("App.MainServiceInfoConfigsController", function () {

  beforeEach(function () {
    sinon.stub(App.themesMapper, 'generateAdvancedTabs').returns(Em.K);
    sinon.stub(App.router.get('mainController'), 'startPolling');
    sinon.stub(App.router.get('mainController'), 'stopPolling');
    mainServiceInfoConfigsController = getController();
  });

  App.TestAliases.testAsComputedAlias(getController(), 'serviceConfigs', 'App.config.preDefinedServiceConfigs', 'array');

  afterEach(function() {
    App.themesMapper.generateAdvancedTabs.restore();
    App.router.get('mainController').startPolling.restore();
    App.router.get('mainController').stopPolling.restore();
  });

  describe("#getHash", function () {

    var tests = [
      {
        msg: "properties only used for ui purpose should be excluded from hash",
        configs: [
          Em.Object.create({
            id: "hive.llap.daemon.task.scheduler.enable.preemption",
            isRequiredByAgent: true,
            isFinal: false,
            value: ''
          }),
          Em.Object.create({
            id: "ambari.copy.hive.llap.daemon.num.executors",
            isRequiredByAgent: false,
            isFinal: false,
            value: ''
          })
        ],
        result: JSON.stringify({
          'hive.llap.daemon.task.scheduler.enable.preemption': {
            value: '',
            overrides: [],
            isFinal: false
          }
        })
      },
      {
        msg: "properties should be sorted in alphabetical order",
        configs: [
          Em.Object.create({
            id: "b.b",
            isRequiredByAgent: true,
            isFinal: false,
            value: ''
          }),
          Em.Object.create({
            id: "b.a",
            isRequiredByAgent: true,
            isFinal: false,
            value: ''
          }),
          Em.Object.create({
            id: "b.c",
            isRequiredByAgent: true,
            isFinal: false,
            value: ''
          }),
          Em.Object.create({
            id: "a.b",
            isRequiredByAgent: true,
            isFinal: false,
            value: ''
          })
        ],
        result: JSON.stringify({
          'a.b': {
            value: '',
            overrides: [],
            isFinal: false
          },
          'b.a': {
            value: '',
            overrides: [],
            isFinal: false
          },
          'b.b': {
            value: '',
            overrides: [],
            isFinal: false
          },
          'b.c': {
            value: '',
            overrides: [],
            isFinal: false
          }
        })
      },{
        msg: "properties without id should be sorted with",
        configs: [
          Em.Object.create({
            isRequiredByAgent: true,
            isFinal: false,
            value: '',
            name: 'name',
            filename: 'filename'
          }),
          Em.Object.create({
            id: "a",
            isRequiredByAgent: true,
            isFinal: false,
            value: ''
          })
        ],
        result: JSON.stringify({
          'a': {
            value: '',
            overrides: [],
            isFinal: false
          },
          'name__filename': {
            value: '',
            overrides: [],
            isFinal: false
          }
        })
      }
    ];

    afterEach(function () {
      mainServiceInfoConfigsController.set('selectedService', '');
    });

    tests.forEach(function (t) {
      it(t.msg, function () {
        mainServiceInfoConfigsController.set('selectedService', {configs: t.configs});
        expect(mainServiceInfoConfigsController.getHash()).to.equal(t.result);
      });
    });
  });


  describe("#showSavePopup", function () {
    var tests = [
      {
        transitionCallback: false,
        callback: false,
        action: "onSave",
        m: "save configs without transitionCallback/callback",
        results: [
          {
            method: "restartServicePopup",
            called: true
          }
        ]
      },
      {
        transitionCallback: true,
        callback: true,
        action: "onSave",
        m: "save configs with transitionCallback/callback",
        results: [
          {
            method: "restartServicePopup",
            called: true
          }
        ]
      },
      {
        transitionCallback: false,
        callback: false,
        action: "onDiscard",
        m: "discard changes without transitionCallback/callback",
        results: [
          {
            method: "restartServicePopup",
            called: false
          }
        ]
      },
      {
        transitionCallback: false,
        callback: true,
        action: "onDiscard",
        m: "discard changes with callback",
        results: [
          {
            method: "restartServicePopup",
            called: false
          },
          {
            method: "callback",
            called: true
          },
          {
            field: "hash",
            value: "hash"
          }
        ]
      },
      {
        transitionCallback: true,
        callback: false,
        action: "onDiscard",
        m: "discard changes with transitionCallback",
        results: [
          {
            method: "restartServicePopup",
            called: false
          },
          {
            method: "transitionCallback",
            called: true
          }
        ]
      }
    ];

    beforeEach(function () {
      mainServiceInfoConfigsController.reopen({
        passwordConfigsAreChanged: false
      });
      sinon.stub(mainServiceInfoConfigsController, "get", function(key) {
        return key === 'isSubmitDisabled' ? false : Em.get(mainServiceInfoConfigsController, key);
      });
      sinon.stub(mainServiceInfoConfigsController, "restartServicePopup", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "getHash", function () {
        return "hash"
      });
      sinon.stub(mainServiceInfoConfigsController, 'trackRequest');
    });

    afterEach(function () {
      mainServiceInfoConfigsController.get.restore();
      mainServiceInfoConfigsController.restartServicePopup.restore();
      mainServiceInfoConfigsController.getHash.restore();
      mainServiceInfoConfigsController.trackRequest.restore();
    });

    tests.forEach(function (t) {
      t.results.forEach(function (r) {
        describe(t.m + " " + r.method + " " + r.field, function () {

          beforeEach(function () {
            if (t.callback) {
              t.callback = sinon.stub();
            }
            if (t.transitionCallback) {
              t.transitionCallback = sinon.stub();
            }
            mainServiceInfoConfigsController.showSavePopup(t.transitionCallback, t.callback)[t.action]();
          });


          if (r.method) {
            if (r.method === 'callback') {
              it('callback is ' + (r.called ? '' : 'not') + ' called once', function () {
                expect(t.callback.calledOnce).to.equal(r.called);
              });
            }
            else {
              if (r.method === 'transitionCallback') {
                it('transitionCallback is ' + (r.called ? '' : 'not') + ' called once', function () {
                  expect(t.transitionCallback.calledOnce).to.equal(r.called);
                });
              }
              else {
                it(r.method + ' is ' + (r.called ? '' : 'not') + ' called once', function () {
                  expect(mainServiceInfoConfigsController[r.method].calledOnce).to.equal(r.called);
                });
              }
            }
          }
          else {
            if (r.field) {
              it(r.field + ' is equal to ' + r.value, function () {
                expect(mainServiceInfoConfigsController.get(r.field)).to.equal(r.value);
              });

            }
          }
        }, this);
      });
    }, this);
  });

  describe("#hasUnsavedChanges", function () {
    var cases = [
      {
        hash: null,
        hasUnsavedChanges: false,
        title: 'configs not rendered'
      },
      {
        hash: 'hash1',
        hasUnsavedChanges: true,
        title: 'with unsaved'
      },
      {
        hash: 'hash',
        hasUnsavedChanges: false,
        title: 'without unsaved'
      }
    ];

    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "getHash", function () {
        return "hash"
      });
    });
    afterEach(function () {
      mainServiceInfoConfigsController.getHash.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        mainServiceInfoConfigsController.set('hash', item.hash);
        expect(mainServiceInfoConfigsController.hasUnsavedChanges()).to.equal(item.hasUnsavedChanges);
      });
    });
  });

  describe("#showComponentsShouldBeRestarted", function () {

    var tests = [
      {
        input: {
          context: {
            restartRequiredHostsAndComponents: {
              'publicHostName1': ['TaskTracker'],
              'publicHostName2': ['JobTracker', 'TaskTracker']
            }
          }
        },
        components: "2 TaskTrackers, 1 JobTracker",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.components'))
      },
      {
        input: {
          context: {
            restartRequiredHostsAndComponents: {
              'publicHostName1': ['TaskTracker']
            }
          }
        },
        components: "1 TaskTracker",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.component'))
      }
    ];

    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "showItemsShouldBeRestarted", Em.K);
    });
    afterEach(function () {
      mainServiceInfoConfigsController.showItemsShouldBeRestarted.restore();
    });

    tests.forEach(function (t) {
      it("trigger showItemsShouldBeRestarted popup with components", function () {
        mainServiceInfoConfigsController.showComponentsShouldBeRestarted(t.input);
        expect(mainServiceInfoConfigsController.showItemsShouldBeRestarted.calledWith(t.components, t.text)).to.equal(true);
      });
    });
  });

  describe("#showHostsShouldBeRestarted", function () {

    var tests = [
      {
        input: {
          context: {
            restartRequiredHostsAndComponents: {
              'publicHostName1': ['TaskTracker'],
              'publicHostName2': ['JobTracker', 'TaskTracker']
            }
          }
        },
        hosts: "publicHostName1, publicHostName2",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.hosts'))
      },
      {
        input: {
          context: {
            restartRequiredHostsAndComponents: {
              'publicHostName1': ['TaskTracker']
            }
          }
        },
        hosts: "publicHostName1",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.host'))
      }
    ];

    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "showItemsShouldBeRestarted", Em.K);
    });
    afterEach(function () {
      mainServiceInfoConfigsController.showItemsShouldBeRestarted.restore();
    });

    tests.forEach(function (t) {
      it("trigger showItemsShouldBeRestarted popup with hosts", function () {
        mainServiceInfoConfigsController.showHostsShouldBeRestarted(t.input);
        expect(mainServiceInfoConfigsController.showItemsShouldBeRestarted.calledWith(t.hosts, t.text)).to.equal(true);
      });
    });
  });

  describe("#rollingRestartStaleConfigSlaveComponents", function () {
    var tests = [
      {
        componentName: {
          context: "ComponentName"
        },
        displayName: "displayName",
        passiveState: "ON"
      },
      {
        componentName: {
          context: "ComponentName1"
        },
        displayName: "displayName1",
        passiveState: "OFF"
      }
    ];

    beforeEach(function () {
      mainServiceInfoConfigsController.set("content", {displayName: "", passiveState: ""});
      sinon.stub(batchUtils, "launchHostComponentRollingRestart", Em.K);
    });
    afterEach(function () {
      batchUtils.launchHostComponentRollingRestart.restore();
    });
    tests.forEach(function (t) {
      it("trigger rollingRestartStaleConfigSlaveComponents", function () {
        mainServiceInfoConfigsController.set("content.displayName", t.displayName);
        mainServiceInfoConfigsController.set("content.passiveState", t.passiveState);
        mainServiceInfoConfigsController.rollingRestartStaleConfigSlaveComponents(t.componentName);
        expect(batchUtils.launchHostComponentRollingRestart.calledWith(t.componentName.context, t.displayName, t.passiveState === "ON", true)).to.equal(true);
      });
    });
  });

  describe("#restartAllStaleConfigComponents", function () {

    beforeEach(function () {
      sinon.stub(batchUtils, "restartAllServiceHostComponents", Em.K);
    });

    afterEach(function () {
      batchUtils.restartAllServiceHostComponents.restore();
    });

    it("trigger restartAllServiceHostComponents", function () {
      mainServiceInfoConfigsController.restartAllStaleConfigComponents().onPrimary();
      expect(batchUtils.restartAllServiceHostComponents.calledOnce).to.equal(true);
    });

    describe("trigger check last check point warning before triggering restartAllServiceHostComponents", function () {
      var mainConfigsControllerHdfsStarted = App.MainServiceInfoConfigsController.create({
        content: {
          serviceName: "HDFS",
          hostComponents: [{
            componentName: 'NAMENODE',
            workStatus: 'STARTED'
          }],
          restartRequiredHostsAndComponents: {
            "host1": ['NameNode'],
            "host2": ['DataNode', 'ZooKeeper']
          }
        }
      });
      var mainServiceItemController = App.MainServiceItemController.create({});

      beforeEach(function () {
        sinon.stub(mainServiceItemController, 'checkNnLastCheckpointTime', function() {
          return true;
        });
        sinon.stub(App.router, 'get', function(k) {
          if ('mainServiceItemController' === k) {
            return mainServiceItemController;
          }
          return Em.get(App.router, k);
        });
        mainConfigsControllerHdfsStarted.restartAllStaleConfigComponents();
      });

      afterEach(function () {
        mainServiceItemController.checkNnLastCheckpointTime.restore();
        App.router.get.restore();
      });

      it('checkNnLastCheckpointTime is called once', function () {
        expect(mainServiceItemController.checkNnLastCheckpointTime.calledOnce).to.equal(true);
      });


    });
  });

  describe("#doCancel", function () {
    beforeEach(function () {
      sinon.stub(Em.run, 'once', Em.K);
      sinon.stub(mainServiceInfoConfigsController, 'loadSelectedVersion');
      sinon.spy(mainServiceInfoConfigsController, 'clearRecommendations');
      mainServiceInfoConfigsController.set('groupsToSave', { HDFS: 'my cool group'});
      mainServiceInfoConfigsController.set('recommendations', Em.A([{name: 'prop_1'}]));
      mainServiceInfoConfigsController.doCancel();
    });
    afterEach(function () {
      Em.run.once.restore();
      mainServiceInfoConfigsController.loadSelectedVersion.restore();
      mainServiceInfoConfigsController.clearRecommendations.restore();
    });

    it("should launch recommendations cleanup", function() {
      expect(mainServiceInfoConfigsController.clearRecommendations.calledOnce).to.be.true;
    });

    it("should clear dependent configs", function() {
      expect(App.isEmptyObject(mainServiceInfoConfigsController.get('recommendations'))).to.be.true;
    });
  });

  describe("#putChangedConfigurations", function () {
      var sc = [
      Em.Object.create({
        configs: [
          Em.Object.create({
            name: '_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: '_newsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: '_maxnewsize',
            value: '1024m'
          })
        ]
      })
    ],
    scExc = [
      Em.Object.create({
        configs: [
          Em.Object.create({
            name: 'hadoop_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: 'yarn_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: 'nodemanager_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: 'resourcemanager_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: 'apptimelineserver_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: 'jobhistory_heapsize',
            value: '1024m'
          })
        ]
      })
    ];
    beforeEach(function () {
      sinon.stub(App.router, 'getClusterName', function() {
        return 'clName';
      });
    });
    afterEach(function () {
      App.router.getClusterName.restore();
    });
    it("ajax request to put cluster cfg", function () {
      mainServiceInfoConfigsController.set('stepConfigs', sc);
      mainServiceInfoConfigsController.putChangedConfigurations([]);
      var args = testHelpers.findAjaxRequest('name', 'common.across.services.configurations');
      expect(args[0]).exists;
    });
    it('values should be parsed', function () {
      mainServiceInfoConfigsController.set('stepConfigs', sc);
      mainServiceInfoConfigsController.putChangedConfigurations([]);
      expect(mainServiceInfoConfigsController.get('stepConfigs')[0].get('configs').mapProperty('value').uniq()).to.eql(['1024m']);
    });
    it('values should not be parsed', function () {
      mainServiceInfoConfigsController.set('stepConfigs', scExc);
      mainServiceInfoConfigsController.putChangedConfigurations([]);
      expect(mainServiceInfoConfigsController.get('stepConfigs')[0].get('configs').mapProperty('value').uniq()).to.eql(['1024m']);
    });
  });

  describe("#isDirChanged", function() {

    describe("when service name is HDFS", function() {
      beforeEach(function() {
        mainServiceInfoConfigsController.set('content', Ember.Object.create ({ serviceName: 'HDFS' }));
      });

      describe("for hadoop 2", function() {

        var tests = [
          {
            it: "should set dirChanged to false if none of the properties exist",
            expect: false,
            config: Ember.Object.create ({})
          },
          {
            it: "should set dirChanged to true if dfs.namenode.name.dir is not default",
            expect: true,
            config: Ember.Object.create ({
              name: 'dfs.namenode.name.dir',
              isNotDefaultValue: true
            })
          },
          {
            it: "should set dirChanged to false if dfs.namenode.name.dir is default",
            expect: false,
            config: Ember.Object.create ({
              name: 'dfs.namenode.name.dir',
              isNotDefaultValue: false
            })
          },
          {
            it: "should set dirChanged to true if dfs.namenode.checkpoint.dir is not default",
            expect: true,
            config: Ember.Object.create ({
              name: 'dfs.namenode.checkpoint.dir',
              isNotDefaultValue: true
            })
          },
          {
            it: "should set dirChanged to false if dfs.namenode.checkpoint.dir is default",
            expect: false,
            config: Ember.Object.create ({
              name: 'dfs.namenode.checkpoint.dir',
              isNotDefaultValue: false
            })
          },
          {
            it: "should set dirChanged to true if dfs.datanode.data.dir is not default",
            expect: true,
            config: Ember.Object.create ({
              name: 'dfs.datanode.data.dir',
              isNotDefaultValue: true
            })
          },
          {
            it: "should set dirChanged to false if dfs.datanode.data.dir is default",
            expect: false,
            config: Ember.Object.create ({
              name: 'dfs.datanode.data.dir',
              isNotDefaultValue: false
            })
          }
        ];

        beforeEach(function() {
          sinon.stub(App, 'get').returns(true);
        });

        afterEach(function() {
          App.get.restore();
        });

        tests.forEach(function(test) {
          it(test.it, function() {
            mainServiceInfoConfigsController.set('stepConfigs', [Ember.Object.create ({ configs: [test.config], serviceName: 'HDFS' })]);
            expect(mainServiceInfoConfigsController.isDirChanged()).to.equal(test.expect);
          })
        });
      });
    });

  });

  describe("#formatConfigValues", function () {
    var t = {
      configs: [
        Em.Object.create({ name: "p1", value: " v1 v1 ", displayType: "" }),
        Em.Object.create({ name: "p2", value: true, displayType: "" }),
        Em.Object.create({ name: "p3", value: " d1 ", displayType: "directory" }),
        Em.Object.create({ name: "p4", value: " d1 d2 d3 ", displayType: "directories" }),
        Em.Object.create({ name: "p5", value: " v1 ", displayType: "password" }),
        Em.Object.create({ name: "p6", value: " v ", displayType: "host" }),
        Em.Object.create({ name: "javax.jdo.option.ConnectionURL", value: " v1 ", displayType: "string" }),
        Em.Object.create({ name: "oozie.service.JPAService.jdbc.url", value: " v1 ", displayType: "string" })
      ],
      result: [
        Em.Object.create({ name: "p1", value: " v1 v1", displayType: "" }),
        Em.Object.create({ name: "p2", value: "true", displayType: "" }),
        Em.Object.create({ name: "p3", value: "d1", displayType: "directory" }),
        Em.Object.create({ name: "p4", value: "d1,d2,d3", displayType: "directories" }),
        Em.Object.create({ name: "p5", value: " v1 ", displayType: "password" }),
        Em.Object.create({ name: "p6", value: "v", displayType: "host" }),
        Em.Object.create({ name: "javax.jdo.option.ConnectionURL", value: " v1", displayType: "string" }),
        Em.Object.create({ name: "oozie.service.JPAService.jdbc.url", value: " v1", displayType: "string" })
      ]
    };

    it("format config values", function () {
      mainServiceInfoConfigsController.formatConfigValues(t.configs);
      expect(t.configs).to.deep.equal(t.result);
    });

  });

  describe("#checkOverrideProperty", function () {
    var tests = [{
      overrideToAdd: {
        name: "name1",
        filename: "filename1"
      },
      componentConfig: {
        configs: [
          {
            name: "name1",
            filename: "filename2"
          },
          {
            name: "name1",
            filename: "filename1"
          }
        ]
      },
      add: true,
      m: "add property"
    },
      {
        overrideToAdd: {
          name: "name1"
        },
        componentConfig: {
          configs: [
            {
              name: "name2"
            }
          ]
        },
        add: false,
        m: "don't add property, different names"
      },
      {
        overrideToAdd: {
          name: "name1",
          filename: "filename1"
        },
        componentConfig: {
          configs: [
            {
              name: "name1",
              filename: "filename2"
            }
          ]
        },
        add: false,
        m: "don't add property, different filenames"
      },
      {
        overrideToAdd: null,
        componentConfig: {},
        add: false,
        m: "don't add property, overrideToAdd is null"
      }];

    beforeEach(function() {
      sinon.stub(App.config,"createOverride", Em.K)
    });
    afterEach(function() {
      App.config.createOverride.restore();
    });
    tests.forEach(function(t) {
      it(t.m, function() {
        mainServiceInfoConfigsController.set("overrideToAdd", t.overrideToAdd);
        mainServiceInfoConfigsController.checkOverrideProperty(t.componentConfig);
        if(t.add) {
          expect(App.config.createOverride.calledWith(t.overrideToAdd)).to.equal(true);
          expect(mainServiceInfoConfigsController.get("overrideToAdd")).to.equal(null);
        } else {
          expect(App.config.createOverride.calledOnce).to.equal(false);
        }
      });
    });
  });

  describe("#trackRequest()", function () {
    after(function(){
      mainServiceInfoConfigsController.get('requestsInProgress').clear();
    });
    it("should set requestsInProgress", function () {
      var dfd = $.Deferred();
      mainServiceInfoConfigsController.get('requestsInProgress').clear();
      mainServiceInfoConfigsController.trackRequest(dfd);
      expect(mainServiceInfoConfigsController.get('requestsInProgress')[0]).to.eql(
        {
          request: dfd,
          id: 0,
          status: 'pending',
          completed: false
        }
      );
    });
    it('should update request status when it become resolved', function() {
      var request = $.Deferred();
      mainServiceInfoConfigsController.get('requestsInProgress').clear();
      mainServiceInfoConfigsController.trackRequest(request);
      expect(mainServiceInfoConfigsController.get('requestsInProgress')[0]).to.eql({
        request: request,
        id: 0,
        status: 'pending',
        completed: false
      });
      request.resolve();
      expect(mainServiceInfoConfigsController.get('requestsInProgress')[0]).to.eql({
        request: request,
        id: 0,
        status: 'resolved',
        completed: true
      });
    });
  });

  describe('#trackRequestChain', function() {
    beforeEach(function() {
      mainServiceInfoConfigsController.get('requestsInProgress').clear();
    });
    it('should set 2 requests in to requestsInProgress list', function() {
      mainServiceInfoConfigsController.trackRequestChain($.Deferred());
      expect(mainServiceInfoConfigsController.get('requestsInProgress')).to.have.length(2);
    });
    it('should update status for both requests when tracked requests become resolved', function() {
      var request = $.Deferred(),
          requests;
      mainServiceInfoConfigsController.trackRequestChain(request);
      requests = mainServiceInfoConfigsController.get('requestsInProgress');
      assert.deepEqual(requests.mapProperty('status'), ['pending', 'pending'], 'initial statuses');
      assert.deepEqual(requests.mapProperty('completed'), [false, false], 'initial completed');
      request.reject();
      assert.deepEqual(requests.mapProperty('status'), ['rejected', 'resolved'], 'update status when rejected');
      assert.deepEqual(requests.mapProperty('completed'), [true, true], 'initial complete are false');
    });
  });

  describe('#abortRequests', function() {
    beforeEach(function() {
      mainServiceInfoConfigsController.get('requestsInProgress').clear();
    });
    it('should clear requests when abort called', function() {
      mainServiceInfoConfigsController.trackRequest($.Deferred());
      mainServiceInfoConfigsController.abortRequests();
      expect(mainServiceInfoConfigsController.get('requestsInProgress')).to.have.length(0);
    });
    it('should abort requests which are not finished', function() {
      var pendingRequest = {
        abort: sinon.spy(),
        readyState: 0,
        state: sinon.spy(),
        always: sinon.spy()
      };
      var finishedRequest = {
        abort: sinon.spy(),
        readyState: 4,
        state: sinon.spy(),
        always: sinon.spy()
      };
      mainServiceInfoConfigsController.trackRequest(pendingRequest);
      mainServiceInfoConfigsController.trackRequest(finishedRequest);
      mainServiceInfoConfigsController.abortRequests();
      expect(pendingRequest.abort.calledOnce).to.be.true;
      expect(finishedRequest.abort.calledOnce).to.be.false;
    });
  });

  describe("#setCompareDefaultGroupConfig", function() {
    beforeEach(function() {
      sinon.stub(mainServiceInfoConfigsController, "getComparisonConfig").returns("compConfig");
      sinon.stub(mainServiceInfoConfigsController, "getMockComparisonConfig").returns("mockConfig");
      sinon.stub(mainServiceInfoConfigsController, "hasCompareDiffs").returns(true);
    });
    afterEach(function() {
      mainServiceInfoConfigsController.getComparisonConfig.restore();
      mainServiceInfoConfigsController.getMockComparisonConfig.restore();
      mainServiceInfoConfigsController.hasCompareDiffs.restore();
    });
    it("empty service config passed, expect that setCompareDefaultGroupConfig will not run anything", function() {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({}).compareConfigs.length).to.equal(0);
    });
    it("empty service config and comparison passed, expect that setCompareDefaultGroupConfig will not run anything", function() {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({},{}).compareConfigs).to.eql(["compConfig"]);
    });
    it("expect that serviceConfig.compareConfigs will be getMockComparisonConfig", function() {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({isUserProperty: true}, null)).to.eql({compareConfigs: ["mockConfig"], isUserProperty: true, isComparison: true, hasCompareDiffs: true});
    });
    it("expect that serviceConfig.compareConfigs will be getComparisonConfig", function() {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({isUserProperty: true}, {})).to.eql({compareConfigs: ["compConfig"], isUserProperty: true, isComparison: true, hasCompareDiffs: true});
    });
    it("expect that serviceConfig.compareConfigs will be getComparisonConfig (2)", function() {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({isReconfigurable: true}, {})).to.eql({compareConfigs: ["compConfig"], isReconfigurable: true, isComparison: true, hasCompareDiffs: true});
    });
    it("expect that serviceConfig.compareConfigs will be getComparisonConfig (3)", function() {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({isReconfigurable: true, isMock: true}, {})).to.eql({compareConfigs: ["compConfig"], isReconfigurable: true, isMock: true, isComparison: true, hasCompareDiffs: true});
    });
    it("property was created during upgrade and have no comparison, compare with 'Undefined' value should be created", function() {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({name: 'prop1', isUserProperty: false}, null)).to.eql({
        name: 'prop1', isUserProperty: false, compareConfigs: ["mockConfig"],
        isComparison: true, hasCompareDiffs: true
      });
    });
  });

  describe('#showSaveConfigsPopup', function () {

    var bodyView;

    describe('#bodyClass', function () {
      beforeEach(function() {
        sinon.stub(App.StackService, 'find').returns([{dependentServiceNames: []}]);
        // default implementation
        bodyView = mainServiceInfoConfigsController.showSaveConfigsPopup().get('bodyClass').create({
          parentView: Em.View.create()
        });
      });

      afterEach(function() {
        App.StackService.find.restore();
      });

      describe('#componentsFilterSuccessCallback', function () {
        it('check components with unknown state', function () {
          bodyView = mainServiceInfoConfigsController.showSaveConfigsPopup('', true, '', {}, '', 'unknown', '').get('bodyClass').create({
            didInsertElement: Em.K,
            parentView: Em.View.create()
          });
          bodyView.componentsFilterSuccessCallback({
            items: [
              {
                ServiceComponentInfo: {
                  total_count: 4,
                  started_count: 2,
                  installed_count: 1,
                  component_name: 'c1'
                },
                host_components: [
                  {HostRoles: {host_name: 'h1'}}
                ]
              }
            ]
          });
          var unknownHosts = bodyView.get('unknownHosts');
          expect(unknownHosts.length).to.equal(1);
          expect(unknownHosts[0]).to.eql({name: 'h1', components: 'C1'});
        });
      });
    });
  });

  describe('#errorsCount', function () {

    it('should ignore configs with widgets (enhanced configs)', function () {

      mainServiceInfoConfigsController.reopen({selectedService: Em.Object.create({
        configsWithErrors: Em.A([
          Em.Object.create({widget: {}}),
          Em.Object.create({widget: null})
        ])
      })});

      expect(mainServiceInfoConfigsController.get('errorsCount')).to.equal(1);

    });

  });

  describe('#_onLoadComplete', function () {

    beforeEach(function () {
      sinon.stub(Em.run, 'next', Em.K);
      mainServiceInfoConfigsController.setProperties({
        dataIsLoaded: false,
        versionLoaded: false,
        isInit: true
      });
    });

    afterEach(function () {
      Em.run.next.restore();
    });

    it('should update flags', function () {

      mainServiceInfoConfigsController._onLoadComplete();
      expect(mainServiceInfoConfigsController.get('dataIsLoaded')).to.be.true;
      expect(mainServiceInfoConfigsController.get('versionLoaded')).to.be.true;
      expect(mainServiceInfoConfigsController.get('isInit')).to.be.false;

    });

  });

  describe('#hasCompareDiffs', function () {

    it('should return false for `password`-configs', function () {

      var hasCompareDiffs = mainServiceInfoConfigsController.hasCompareDiffs({displayType: 'password'}, {});
      expect(hasCompareDiffs).to.be.false;

    });

  });

  describe('#getServicesDependencies', function() {
    var createService = function(serviceName, dependencies) {
      return Em.Object.create({
        serviceName: serviceName,
        dependentServiceNames: dependencies || []
      });
    };
    var stackServices = [
      createService('STORM', ['RANGER', 'ATLAS', 'ZOOKEEPER']),
      createService('RANGER', ['HIVE', 'HDFS']),
      createService('HIVE', ['YARN']),
      createService('ZOOKEEPER', ['HDFS']),
      createService('ATLAS'),
      createService('HDFS', ['ZOOKEEPER']),
      createService('YARN', ['HIVE'])
    ];
    beforeEach(function() {
      sinon.stub(App.StackService, 'find', function(serviceName) {
        return stackServices.findProperty('serviceName', serviceName);
      });
    });
    afterEach(function() {
      App.StackService.find.restore();
    });

    it('should returns all service dependencies STORM service', function() {
      var result = mainServiceInfoConfigsController.getServicesDependencies('STORM');
      expect(result).to.be.eql(['RANGER', 'ATLAS', 'ZOOKEEPER', 'HIVE', 'HDFS', 'YARN']);
    });

    it('should returns all service dependencies for ATLAS', function() {
      var result = mainServiceInfoConfigsController.getServicesDependencies('ATLAS');
      expect(result).to.be.eql([]);
    });

    it('should returns all service dependencies for RANGER', function() {
      var result = mainServiceInfoConfigsController.getServicesDependencies('RANGER');
      expect(result).to.be.eql(['HIVE', 'HDFS', 'YARN', 'ZOOKEEPER']);
    });

    it('should returns all service dependencies for YARN', function() {
      var result = mainServiceInfoConfigsController.getServicesDependencies('YARN');
      expect(result).to.be.eql(['HIVE']);
    });
  });
});

});

require.register("test/controllers/main/service/info/summary_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/service/info/summary');
var testHelpers = require('test/helpers');
function getController() {
  return App.MainServiceInfoSummaryController.create();
}

describe('App.MainServiceInfoSummaryController', function () {

  var controller;

  beforeEach(function () {
    controller = App.MainServiceInfoSummaryController.create();
  });

App.TestAliases.testAsComputedOr(getController(), 'showTimeRangeControl', ['!isServiceWithEnhancedWidgets', 'someWidgetGraphExists']);

  describe('#setRangerPlugins', function () {

    var cases = [
      {
        isLoaded: true,
        isRangerPluginsArraySet: false,
        expectedIsRangerPluginsArraySet: true,
        title: 'cluster loaded, ranger plugins array not set'
      },
      {
        isLoaded: false,
        isRangerPluginsArraySet: false,
        expectedIsRangerPluginsArraySet: false,
        title: 'cluster not loaded, ranger plugins array not set'
      },
      {
        isLoaded: false,
        isRangerPluginsArraySet: true,
        expectedIsRangerPluginsArraySet: true,
        title: 'cluster not loaded, ranger plugins array set'
      },
      {
        isLoaded: true,
        isRangerPluginsArraySet: true,
        expectedIsRangerPluginsArraySet: true,
        title: 'cluster loaded, ranger plugins array set'
      }
    ];

    beforeEach(function () {
      sinon.stub(App.Service, 'find').returns([
        Em.Object.create({
          serviceName: 'HDFS'
        }),
        Em.Object.create({
          serviceName: 'YARN'
        }),
        Em.Object.create({
          serviceName: 'HIVE'
        })
      ]);
      sinon.stub(App.StackService, 'find').returns([
        Em.Object.create({
          serviceName: 'HDFS',
          displayName: 'HDFS',
          configTypes: {
            'ranger-hdfs-plugin-properties': {}
          }
        }),
        Em.Object.create({
          serviceName: 'HIVE',
          displayName: 'Hive',
          configTypes: {
            'hive-env': {}
          }
        }),
        Em.Object.create({
          serviceName: 'HBASE',
          displayName: 'HBase',
          configTypes: {
            'ranger-hbase-plugin-properties': {}
          }
        }),
        Em.Object.create({
          serviceName: 'KNOX',
          displayName: 'Knox',
          configTypes: {
            'ranger-knox-plugin-properties': {}
          }
        }),
        Em.Object.create({
          serviceName: 'STORM',
          displayName: 'Storm',
          configTypes: {
            'ranger-storm-plugin-properties': {}
          }
        }),
        Em.Object.create({
          serviceName: 'YARN',
          displayName: 'YARN',
          configTypes: {}
        })
      ]);
    });

    afterEach(function () {
      App.Service.find.restore();
      App.StackService.find.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('isRangerPluginsArraySet', item.isRangerPluginsArraySet);
        App.set('router.clusterController.isLoaded', item.isLoaded);
        expect(controller.get('isRangerPluginsArraySet')).to.equal(item.expectedIsRangerPluginsArraySet);
        expect(controller.get('rangerPlugins').filterProperty('isDisplayed').mapProperty('serviceName').sort()).to.eql(['HDFS', 'HIVE']);
      });
    });

  });

  describe('#getRangerPluginsStatusSuccess', function () {

    beforeEach(function () {
      controller.getRangerPluginsStatusSuccess({
        'items': [
          {
            'type': 'ranger-hdfs-plugin-properties',
            'properties': {
              'ranger-hdfs-plugin-enabled': 'Yes'
            }
          },
          {
            'type': 'hive-env',
            'properties': {
              'hive_security_authorization': 'Ranger'
            }
          },
          {
            'type': 'ranger-hbase-plugin-properties',
            'properties': {
              'ranger-hbase-plugin-enabled': ''
            }
          }
        ]
      });
    });

    it('isPreviousRangerConfigsCallFailed is false', function () {
      expect(controller.get('isPreviousRangerConfigsCallFailed')).to.be.false;
    });
    it('rangerPlugins.HDFS status is valid', function () {
      expect(controller.get('rangerPlugins').findProperty('serviceName', 'HDFS').status).to.equal(Em.I18n.t('alerts.table.state.enabled'));
    });
    it('rangerPlugins.HIVE status is valid', function () {
      expect(controller.get('rangerPlugins').findProperty('serviceName', 'HIVE').status).to.equal(Em.I18n.t('alerts.table.state.enabled'));
    });
    it('rangerPlugins.HBASE status is valid', function () {
      expect(controller.get('rangerPlugins').findProperty('serviceName', 'HBASE').status).to.equal(Em.I18n.t('common.unknown'));
    });
  });

  describe('#getRangerPluginsStatusError', function () {

    it('should set isPreviousRangerConfigsCallFailed to true', function () {
      controller.getRangerPluginsStatusError();
      expect(controller.get('isPreviousRangerConfigsCallFailed')).to.be.true;
    });

  });

  describe("#getActiveWidgetLayout() for Enhanced Dashboard", function () {

    it("make GET call", function () {
      var _controller = App.MainServiceInfoSummaryController.create({
        isServiceWithEnhancedWidgets: true,
        content: Em.Object.create({serviceName: 'HDFS'})
      });
      _controller.getActiveWidgetLayout();
      expect(testHelpers.findAjaxRequest('name', 'widgets.layouts.active.get')).to.exists;
    });
  });

  describe("#getActiveWidgetLayoutSuccessCallback()", function () {
    beforeEach(function () {
      sinon.stub( App.widgetLayoutMapper, 'map');
      sinon.stub( App.widgetMapper, 'map');
    });
    afterEach(function () {
      App.widgetLayoutMapper.map.restore();
      App.widgetMapper.map.restore();
    });
    it("isWidgetLayoutsLoaded should be set to true", function () {
      var _controller = App.MainServiceInfoSummaryController.create({
        isServiceWithEnhancedWidgets: true,
        content: Em.Object.create({serviceName: 'HDFS'})
      });
      _controller.getActiveWidgetLayoutSuccessCallback({items:[{
        WidgetLayoutInfo: {}
      }]});
      expect(_controller.get('isWidgetsLoaded')).to.be.true;
    });

  });

  describe("#hideWidgetSuccessCallback()", function () {
    beforeEach(function () {
      sinon.stub(App.widgetLayoutMapper, 'map');
      sinon.stub(controller, 'propertyDidChange');
      var params = {
        data: {
          WidgetLayoutInfo: {
            widgets: [
              {id: 1}
            ]
          }
        }
      };
      controller.hideWidgetSuccessCallback({}, {}, params);
    });
    afterEach(function () {
      App.widgetLayoutMapper.map.restore();
      controller.propertyDidChange.restore();
    });
    it("mapper is called with valid data", function () {
      expect(App.widgetLayoutMapper.map.calledWith({
        items: [{
          WidgetLayoutInfo: {
            widgets: [
              {
                WidgetInfo: {
                  id: 1
                }
              }
            ]
          }
        }]
      })).to.be.true;
    });
    it('`widgets` is forced to be recalculated', function () {
      expect(controller.propertyDidChange.calledWith('widgets')).to.be.true;
    });
  });

});
});

require.register("test/controllers/main/service/item_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');
require('ember');
require('models/host_component');
require('views/common/modal_popup');
require('mixins/common/userPref');
require('controllers/application');
require('controllers/global/background_operations_controller');
require('controllers/global/cluster_controller');
require('controllers/main/service/reassign_controller');
require('controllers/main/service/item');
var batchUtils = require('utils/batch_scheduled_requests');
var testHelpers = require('test/helpers');
var stackSerivceModel = {
  'HDFS': Em.Object.create({
    serviceName: 'HDFS',
    requiredServices: ['ZOOKEEPER']
  }),
  'YARN': Em.Object.create({
    serviceName: 'YARN',
    requiredServices: ['MAPREDUCE2', 'HDFS']
  }),
  'MAPREDUCE2': Em.Object.create({
    serviceName: 'MAPREDUCE2',
    requiredServices: ['YARN']
  }),
  'TEZ': Em.Object.create({
    serviceName: 'TEZ',
    requiredServices: ['YARN']
  }),
  'HIVE': Em.Object.create({
    serviceName: 'HIVE',
    requiredServices: ['YARN', 'TEZ']
  })
};

describe('App.MainServiceItemController', function () {

  describe('#setStartStopState', function () {
    var tests = [
      {
        serviceController: {
          serviceName: "YARN"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: true,
              dependentService: "ALL_SERVICES"
            }
          ]
        },
        isPending: true,
        m: 'operaion is active because all services are running'
      },
      {
        serviceController: {
          serviceName: "HBASE"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: true,
              dependentService: "HBASE"
            }
          ]
        },
        isPending: true,
        m: 'operaion is active button because current service is running'
      },
      {
        serviceController: {
          serviceName: "HDFS"
        },
        backgroundOperationsController: {
          services: [

          ]
        },
        isPending: true,
        m: 'pending is true - backgroundOperationsController.services is empty'
      },
      {
        serviceController: {
          serviceName: "HBASE"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: false,
              dependentService: "ALL_SERVICES"
            }
          ]
        },
        isPending: false,
        m: 'pending is false - operation is not running'
      },
      {
        serviceController: {
          serviceName: "HBASE"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: true,
              dependentService: "HDFS"
            }
          ]
        },
        isPending: false,
        m: 'pending is false - current service is not running'
      }
    ];

    tests.forEach(function (test) {
      describe(test.m, function () {

        var mainServiceItemController;

        beforeEach(function () {
          sinon.stub(App.router, 'get', function(k) {
            if ('backgroundOperationsController.services' === k) return test.backgroundOperationsController.services;
            return Em.get(App.router, k);
          });
          mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: test.serviceController.serviceName}});
          mainServiceItemController.setStartStopState();
        });

        afterEach(function () {
          App.router.get.restore();
        });

        it('isPending is ' + test.isPending, function () {
          expect(mainServiceItemController.get('isPending')).to.equal(test.isPending);
        });

      });
    })
  });

  describe('#reassignMaster()', function () {
    var tests = [
      {
        host_components: [
          {componentName: "RESOURCEMANGER"}
        ],
        componentName: "RESOURCEMANGER",
        result: true,
        m: 'run reassignMaster'
      },
      {
        host_components: [
          {componentName: "RESOURCEMANGER"}
        ],
        componentName: "DATANODE",
        result: false,
        m: 'don\t run reassignMaster'
      }
    ];

    tests.forEach(function (test) {
      describe(test.m, function () {

        var reassignMasterController = App.ReassignMasterController.create({currentStep: ''});

        beforeEach(function () {
          sinon.stub(reassignMasterController, 'saveComponentToReassign', Em.K);
          sinon.stub(reassignMasterController, 'setCurrentStep', Em.K);
          sinon.stub(App.router, 'transitionTo', Em.K);
          var mainServiceItemController = App.MainServiceItemController.create({});
          sinon.stub(App.HostComponent, 'find', function() {
            return test.host_components
          });
          sinon.stub(App.router, 'get', function(k) {
            if ('reassignMasterController' === k) return reassignMasterController;
            return Em.get(App.router, k);
          });
          mainServiceItemController.reassignMaster(test.componentName);
        });

        afterEach(function () {
          reassignMasterController.saveComponentToReassign.restore();
          reassignMasterController.setCurrentStep.restore();
          App.HostComponent.find.restore();
          App.router.transitionTo.restore();
          App.router.get.restore();
        });

        it('saveComponentToReassign is ' + (test.result ? '' : 'not') + ' called once', function () {
          expect(reassignMasterController.saveComponentToReassign.calledOnce).to.equal(test.result);
        });

        it('setCurrentStep is ' + (test.result ? '' : 'not') + ' called once', function () {
          expect(reassignMasterController.setCurrentStep.calledOnce).to.equal(test.result);
        });

      });
    }, this);
  });

  describe("#doAction", function () {

    var el = document.createElement("BUTTON");
    el.disabled = false;
    var tests = [
      {
        event: {
          target: el,
          context: {
            action: 'runSmokeTest'
          }
        },
        m: "run runSmokeTest"
      },
      {
        event: {
          target: el,
          context: {
            action: 'refreshConfigs'
          }
        },
        m: "run refreshConfigs"
      },
      {
        event: {
          target: el,
          context: {
            action: 'restartAllHostComponents'
          }
        },
        m: "run restartAllHostComponents"
      },
      {
        event: {
          target: el,
          context: {
            action: 'rollingRestart'
          }
        },
        m: "run rollingRestart"
      }
    ];

    tests.forEach(function (test) {
      var mainServiceItemController = App.MainServiceItemController.create({});
      mainServiceItemController.set(test.event.context.action, Em.K);
      beforeEach(function () {
        sinon.spy(mainServiceItemController, test.event.context.action);
      });
      afterEach(function () {
        mainServiceItemController[test.event.context.action].restore();
      });
      it(test.m, function () {
        mainServiceItemController.doAction(test.event);
        expect(mainServiceItemController[test.event.context.action].calledOnce).to.equal(!test.event.target.disabled);
      });
    });
  });

  describe("#startService , #stopService", function () {
    var mainServiceItemController = App.MainServiceItemController.create({startStopPopup: Em.K});
    beforeEach(function () {
      sinon.spy(mainServiceItemController, "startStopPopup");
    });
    afterEach(function () {
      mainServiceItemController.startStopPopup.restore();
    });
    it("start service", function () {
      mainServiceItemController.startService({});
      expect(mainServiceItemController.startStopPopup.calledWith({},App.HostComponentStatus.started)).to.equal(true);
    });
    it("stop service", function () {
      mainServiceItemController.stopService({});
      expect(mainServiceItemController.startStopPopup.calledWith({},App.HostComponentStatus.stopped)).to.equal(true);
    });
  });

  describe("#turnOnOffPassive", function () {
    var mainServiceItemController = App.MainServiceItemController.create({turnOnOffPassiveRequest: Em.K});
    beforeEach(function () {
      sinon.spy(batchUtils, "turnOnOffPassiveRequest");
      mainServiceItemController.set('content', {serviceName: ''});
    });
    afterEach(function () {
      batchUtils.turnOnOffPassiveRequest.restore();
    });
    it("turns on/off passive mode for service", function () {
      mainServiceItemController.turnOnOffPassive({}).onPrimary();
      expect(batchUtils.turnOnOffPassiveRequest.calledOnce).to.equal(true);
    });
  });

  describe("#runSmokeTest", function () {
    var tests = [
      {
        content: {
          id: "YARN",
          service_name: "YARN",
          work_status: "STARTED"
        },
        startSmoke: true,
        serviceName: "MAPREDUCE2",
        m: "don't run smoke test primary for MAPREDUCE2"
      },
      {
        content: {
          id: "YARN",
          service_name: "YARN",
          work_status: "STOPPED"
        },
        startSmoke: false,
        serviceName: "MAPREDUCE2",
        m: "run smoke test primary for MAPREDUCE2"
      },
      {
        m: "run smoke test primary for all services (not MAPREDUCE2)",
        startSmoke: true,
        default: true
      }
    ];

    tests.forEach(function (test) {
      var mainServiceItemController = test.default ? App.MainServiceItemController.create({runSmokeTestPrimary: Em.K}) :
        App.MainServiceItemController.create({content: {serviceName: test.serviceName}, runSmokeTestPrimary: Em.K});
      beforeEach(function () {
        sinon.spy(mainServiceItemController, "runSmokeTestPrimary");
      });
      afterEach(function () {
        mainServiceItemController.runSmokeTestPrimary.restore();
      });
      it(test.m, function () {
        if (!test.default) {
          App.store.safeLoad(App.Service, test.content);
        }
        mainServiceItemController.runSmokeTest({}).onPrimary();
        expect(mainServiceItemController.runSmokeTestPrimary.calledOnce).to.equal(test.startSmoke);
      });
    });
  });

  describe("#startStopPopup", function () {
    var el = document.createElement("BUTTON");
    el.disabled = false;
    var event = {
      target: el
    };
    var mainServiceItemController = App.MainServiceItemController.create({
      content: {
        serviceName: "HDFS",
        hostComponents: [ {
          componentName: 'NAMENODE',
          workStatus: 'INSTALLED'
        }]
      }
    });
    var mainServiceItemControllerHdfsStarted = App.MainServiceItemController.create({
      content: {
        serviceName: "HDFS",
        hostComponents: [ {
          componentName: 'NAMENODE',
          workStatus: 'STARTED'
        }]
      }
    });
    beforeEach(function () {
      sinon.spy(mainServiceItemController, "startStopPopupPrimary");
      sinon.spy(mainServiceItemControllerHdfsStarted, "startStopPopupPrimary");
      sinon.spy(Em.I18n, "t");
      sinon.stub(mainServiceItemControllerHdfsStarted, 'checkNnLastCheckpointTime', function(callback) {
        return callback;
      });
    });
    afterEach(function () {
      mainServiceItemController.startStopPopupPrimary.restore();
      mainServiceItemControllerHdfsStarted.startStopPopupPrimary.restore();
      mainServiceItemControllerHdfsStarted.checkNnLastCheckpointTime.restore();
      Em.I18n.t.restore();
    });
    it("start start/stop service popup", function () {
      mainServiceItemController.startStopPopup(event, "").onPrimary();
      expect(mainServiceItemController.startStopPopupPrimary.calledOnce).to.equal(true);
    });

    it ("should popup warning to check last checkpoint time if work status is STARTED", function() {
      mainServiceItemControllerHdfsStarted.startStopPopup(event, "INSTALLED");
      expect(mainServiceItemControllerHdfsStarted.checkNnLastCheckpointTime.calledOnce).to.equal(true);
    });

    describe("modal messages", function() {

      beforeEach(function () {
        sinon.stub(App.StackService, 'find').returns([
          Em.Object.create({
            serviceName: 'HDFS',
            displayName: 'HDFS',
            isInstalled: true,
            isSelected: true,
            requiredServices:["ZOOKEEPER"]
          }),
          Em.Object.create({
            serviceName: 'HIVE',
            displayName: 'Hive',
            isInstalled: true,
            isSelected: true
          }),
          Em.Object.create({
            serviceName: 'HBASE',
            displayName: 'HBase',
            isInstalled: true,
            isSelected: true,
            requiredServices:["HDFS", "ZOOKEEPER"]
          }),
          Em.Object.create({
            serviceName: 'YARN',
            displayName: 'YARN',
            isInstalled: true,
            isSelected: true,
            requiredServices:["HDFS"]
          }),
          Em.Object.create({
            serviceName: 'SPARK',
            displayName: 'Spark',
            isInstalled: true,
            isSelected: true,
            requiredServices:["HIVE"]
          })
        ]);
      });

      it ("should confirm stop if serviceHealth is INSTALLED", function() {
        mainServiceItemController.startStopPopup(event, "INSTALLED");
        expect(Em.I18n.t.calledWith('services.service.stop.confirmMsg')).to.be.ok;
        expect(Em.I18n.t.calledWith('services.service.stop.confirmButton')).to.be.ok;
      });

      it ("should confirm start if serviceHealth is not INSTALLED", function() {
        mainServiceItemController.startStopPopup(event, "");
        expect(Em.I18n.t.calledWith('services.service.start.confirmMsg')).to.be.ok;
        expect(Em.I18n.t.calledWith('services.service.start.confirmButton')).to.be.ok;
      });

      it ("should not display a dependent list if it is to start a service", function() {
        var _mainServiceItemController = App.MainServiceItemController.create(
            {content: {serviceName: "HDFS", passiveState:'OFF'}});
        _mainServiceItemController.startStopPopup(event, "");
        expect(Em.I18n.t.calledWith('services.service.stop.warningMsg.dependent.services')).to.not.be.ok;
      });

      describe ("should display dependent list if other services depend on the one to be stopped", function() {
        beforeEach(function () {
          var _mainServiceItemController = App.MainServiceItemController.create(
            {content: {
              serviceName: "HDFS",
              passiveState:'OFF',
              hostComponents: [{
                componentName: 'NAMENODE',
                workStatus: 'INSTALLED'
              }]
            }}
          );
          _mainServiceItemController.startStopPopup(event, "INSTALLED");
          this.dependencies = Em.I18n.t('services.service.stop.warningMsg.dependent.services').format("HDFS", "HBase,YARN");
          this.msg = Em.I18n.t('services.service.stop.warningMsg.turnOnMM').format("HDFS");
          this.fullMsg = _mainServiceItemController.addAdditionalWarningMessage("INSTALLED", this.msg, "HDFS");
        });

        it('turnOnMM message is shown', function () {
          expect(Em.I18n.t.calledWith('services.service.stop.warningMsg.turnOnMM')).to.be.ok;
        });
        it('message about dependent services is shown', function () {
          expect(Em.I18n.t.calledWith('services.service.stop.warningMsg.dependent.services')).to.be.ok;
        });
        it('full message is valid', function () {
          expect(this.fullMsg).to.be.equal(this.msg + " " + this.dependencies);
        });
      });

      describe("should display the dependent service if another service depends on the one to be stopped", function() {

        beforeEach(function () {
          var _mainServiceItemController = App.MainServiceItemController.create(
            {content: {serviceName: "HIVE", passiveState:'OFF'}});
          _mainServiceItemController.startStopPopup(event, "INSTALLED");
          this.dependencies = Em.I18n.t('services.service.stop.warningMsg.dependent.services').format("HIVE", "Spark");
          this.msg = Em.I18n.t('services.service.stop.warningMsg.turnOnMM').format("HIVE");
          this.fullMsg = _mainServiceItemController.addAdditionalWarningMessage("INSTALLED", this.msg, "HIVE");
        });

        it('message about dependent services is shown', function () {
          expect(Em.I18n.t.calledWith('services.service.stop.warningMsg.dependent.services')).to.be.ok;
        });
        it('full message is valid', function () {
          expect(this.fullMsg).to.be.equal(this.msg + " " + this.dependencies);
        });
      });

      afterEach(function () {
        App.StackService.find.restore();
      });
    });
  });

  describe("#restartAllHostComponents", function () {
    var temp = batchUtils.restartAllServiceHostComponents;
    var mainServiceItemController = App.MainServiceItemController.create({
      content: {
        serviceName: "HDFS",
        hostComponents: [{
          componentName: 'NAMENODE',
          workStatus: 'STARTED'
        }]
      }
    });
    beforeEach(function () {
      batchUtils.restartAllServiceHostComponents = Em.K;
      sinon.spy(batchUtils, "restartAllServiceHostComponents");
      sinon.stub(App.Service, 'find', function() {
        return Em.Object.create({serviceTypes: []});
      });
      sinon.stub(mainServiceItemController, 'checkNnLastCheckpointTime', function() {
        return true;
      });
    });
    afterEach(function () {
      batchUtils.restartAllServiceHostComponents.restore();
      batchUtils.restartAllServiceHostComponents = temp;
      App.Service.find.restore();
      mainServiceItemController.checkNnLastCheckpointTime.restore();
    });

    it("start restartAllHostComponents for service", function () {
      var controller = App.MainServiceItemController.create({
        content: {
          serviceName: "HDFS",
          hostComponents: [{
            componentName: 'NAMENODE',
            workStatus: 'INSTALLED'
          }]
        }
      });
      controller.restartAllHostComponents({}).onPrimary();
      expect(batchUtils.restartAllServiceHostComponents.calledOnce).to.equal(true);
    });

    it("check last checkpoint time for NameNode before start restartAllHostComponents for service", function () {
      mainServiceItemController.restartAllHostComponents({});
      expect(mainServiceItemController.checkNnLastCheckpointTime.calledOnce).to.equal(true);
    });
  });

  describe("#rollingRestart", function () {
    var temp = batchUtils.launchHostComponentRollingRestart;
    beforeEach(function () {
      batchUtils.launchHostComponentRollingRestart = Em.K;
      sinon.spy(batchUtils, "launchHostComponentRollingRestart");
    });
    afterEach(function () {
      batchUtils.launchHostComponentRollingRestart.restore();
      batchUtils.launchHostComponentRollingRestart = temp;
    });

    var mainServiceItemController = App.MainServiceItemController.create();

    it("start restartAllHostComponents for service", function () {
      mainServiceItemController.rollingRestart();
      expect(batchUtils.launchHostComponentRollingRestart.calledOnce).to.equal(true);
    });
  });

  describe("#parseNnCheckPointTime", function () {
    var tests = [
      {
        m: "NameNode has JMX data, the last checkpoint time is less than 12 hours ago",
        data:
        {"href" : "",
          "ServiceComponentInfo" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "service_name" : "HDFS"
          },
          "host_components" : [
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6401.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "active",
                    "LastCheckpointTime" : 1435775648000
                  }
                }
              }
            }
          ]
        },
        result: false
      },
      {
        m: "NameNode has JMX data, the last checkpoint time is > 12 hours ago",
        data:
          {"href" : "",
            "ServiceComponentInfo" : {
              "cluster_name" : "c123",
              "component_name" : "NAMENODE",
              "service_name" : "HDFS"
            },
            "host_components" : [
              {
                "href" : "",
                "HostRoles" : {
                  "cluster_name" : "c123",
                  "component_name" : "NAMENODE",
                  "host_name" : "c6401.ambari.apache.org"
                },
                "metrics" : {
                  "dfs" : {
                    "FSNamesystem" : {
                      "HAState" : "active",
                      "LastCheckpointTime" : 1435617248000
                    }
                  }
                }
              }
            ]
          },
        result: "c6401.ambari.apache.org"
      },
      {
        m: "NameNode has no JMX data available",
        data:
        {"href" : "",
          "ServiceComponentInfo" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "service_name" : "HDFS"
          },
          "host_components" : [
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6401.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "active"
                  }
                }
              }
            }
          ]
        },
        result: null
      },
      {
        m: "HA enabled, both active and standby NN has JMX data normally.",
        data:
        {"href" : "",
          "ServiceComponentInfo" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "service_name" : "HDFS"
          },
          "host_components" : [
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6401.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "active",
                    "LastCheckpointTime" : 1435775648000
                  }
                }
              }
            },
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6402.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "standby",
                    "LastCheckpointTime" : 1435775648000
                  }
                }
              }
            }
          ]
        },
        result: false
      },
      {
        m: "HA enabled, both NamoNodes are standby NN",
        data:
        {"href" : "",
          "ServiceComponentInfo" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "service_name" : "HDFS"
          },
          "host_components" : [
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6401.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "standby",
                    "LastCheckpointTime" : 1435775648000
                  }
                }
              }
            },
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6402.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "standby",
                    "LastCheckpointTime" : 1435775648000
                  }
                }
              }
            }
          ]
        },
        result: false
      },
      {
        m: "HA enabled, active NN has no JMX data, use the standby's data",
        data:
        {"href" : "",
          "ServiceComponentInfo" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "service_name" : "HDFS"
          },
          "host_components" : [
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6401.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "active"
                  }
                }
              }
            },
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6402.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "standby",
                    "LastCheckpointTime" : 1435775648000
                  }
                }
              }
            }
          ]
        },
        result: false
      },
      {
        m: "HA enabled, both NamoNodes no JMX data",
        data:
        {"href" : "",
          "ServiceComponentInfo" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "service_name" : "HDFS"
          },
          "host_components" : [
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6401.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "active"
                  }
                }
              }
            },
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6402.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "standby"
                  }
                }
              }
            }
          ]
        },
        result: null
      }
    ];

    beforeEach(function () {
      sinon.stub(App, 'dateTime').returns(1435790048000);
    });

    afterEach(function () {
      App.dateTime.restore();
    });

    tests.forEach(function (test) {
      it(test.m, function () {
        var mainServiceItemController = App.MainServiceItemController.create({isNNCheckpointTooOld: null});
        mainServiceItemController.parseNnCheckPointTime(test.data);
        expect(mainServiceItemController.get('isNNCheckpointTooOld')).to.equal(test.result);
      });
    });
  });

  describe("#isStartDisabled", function () {
    var tests = [
      {
        content: {
          healthStatus: 'red'
        },
        isPending: true,
        disabled: true,
        m: "disabled because of pending"
      },
      {
        content: {
          healthStatus: 'green'
        },
        isPending: false,
        disabled: true,
        m: "disabled because healthStatus is not red"
      },
      {
        content: {
          healthStatus: 'red'
        },
        isPending: false,
        disabled: false,
        m: "enabled because healthStatus is red and pending is false"
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        var mainServiceItemController = App.MainServiceItemController.create({content: {healthStatus: test.content.healthStatus}, isPending: test.isPending});
        expect(mainServiceItemController.get('isStartDisabled')).to.equal(test.disabled);
      });
    });
  });

  describe("#isStopDisabled", function () {
    var tests = [
      {
        content: {
          healthStatus: 'red'
        },
        isPending: true,
        disabled: true,
        m: "disabled because of pending"
      },
      {
        content: {
          healthStatus: 'green'
        },
        isPending: false,
        disabled: false,
        m: "enabled because healthStatus is green and pending is false"
      },
      {
        content: {
          healthStatus: 'red'
        },
        isPending: false,
        disabled: true,
        m: "disabled because healthStatus is not green"
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        var mainServiceItemController = App.MainServiceItemController.create({content: test.content, isPending: test.isPending});
        expect(mainServiceItemController.get('isStopDisabled')).to.equal(test.disabled);
      });
    });
  });

  describe("#isHAWQStopDisabled", function () {
    var tests = [
      {
        content: {
          serviceName: 'HAWQ',
          healthStatus: 'green',
          hostComponents: [
            {
              componentName: 'HAWQMASTER',
              workStatus: 'STARTED'
            }, {
              componentName: 'HAWQSTANDBY',
              workStatus: 'STARTED'
            }]
        },
        isPending: true,
        disabled: true,
        m: "disabled because of pending"
      },
      {
        content: {
          serviceName: 'HAWQ',
          healthStatus: 'red',
          hostComponents: [
            {
              componentName: 'HAWQMASTER',
              workStatus: 'INSTALLED'
            }, {
              componentName: 'HAWQSTANDBY',
              workStatus: 'STARTED'
            }]
        },
        isPending: false,
        disabled: true,
        m: "disabled because HAWQMASTER is stopped and health is red"
      },
      {
        content: {
          serviceName: 'HAWQ',
          healthStatus: 'green',
          hostComponents: [
            {
              componentName: 'HAWQMASTER',
              workStatus: 'STARTED'
            }, {
              componentName: 'HAWQSTANDBY',
              workStatus: 'INSTALLED'
            }]
        },
        isPending: false,
        disabled: false,
        m: "enabled because HAWQMASTER is started"
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        var mainServiceItemController = App.MainServiceItemController.create({content: test.content, isPending: test.isPending});
        expect(mainServiceItemController.get('isStopDisabled')).to.equal(test.disabled);
      });
    });
  });

  describe("#isPXFStopDisabled", function () {

    var hostComponentStub;

    before(function () {
      hostComponentStub = sinon.stub(App.HostComponent.find(), 'filterProperty');
    });
    after(function () {
      hostComponentStub.restore();
    });

    var tests = [
      {
        content: {
          serviceName: 'PXF',
        },
        isPending: false,
        pxfWorkstatus: [{"workStatus": "STARTED"}, {"workStatus": "STARTED"}],
        disabled: false,
        m: "Enabled because all agents are started."
      },
      {
        content: {
          serviceName: 'PXF',
        },
        isPending: false,
        pxfWorkstatus: [{"workStatus": "INSTALLED"}, {"workStatus": "STARTED"}],
        disabled: false,
        m: "Enabled because atleast one agent is started."
      },
      {
        content: {
          serviceName: 'PXF',
        },
        isPending: false,
        pxfWorkstatus: [{"workStatus": "INSTALLED"}, {"workStatus": "INSTALLED"}],
        disabled: true,
        m: "Disabled because all PXF agents are down."
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        hostComponentStub.withArgs('componentName', 'PXF').returns(test.pxfWorkstatus);
        var mainServiceItemController = App.MainServiceItemController.create({content: test.content, isPending: test.isPending});
        expect(mainServiceItemController.get('isStopDisabled')).to.equal(test.disabled);
      });
    });
  });

  describe("#runRebalancer", function () {

    beforeEach(function () {
      sinon.stub(App.router, 'get', function(k) {
        if ('applicationController' === k) {
          return Em.Object.create({
            dataLoading: function() {
              return {done: Em.K}
            }
          });
        }
        return Em.get(App.router, k);
      });
    });

    afterEach(function () {
      App.router.get.restore();
    });

    it("run rebalancer", function () {
      var mainServiceItemController = App.MainServiceItemController.create({content: {runRebalancer: false}});
      mainServiceItemController.runRebalancer().onPrimary();
      expect(mainServiceItemController.get("content.runRebalancer")).to.equal(true);
    });
  });

  describe("#runCompaction", function () {

    beforeEach(function () {
      sinon.stub(App.router, 'get', function(k) {
        if ('applicationController' === k) {
          return Em.Object.create({
            dataLoading: function() {
              return {done: Em.K}
            }
          });
        }
        return Em.get(App.router, k);
      });
    });

    afterEach(function () {
      App.router.get.restore();
    });

    it("run compaction", function () {
      var mainServiceItemController = App.MainServiceItemController.create({content: {runCompaction: false}});
      mainServiceItemController.runCompaction().onPrimary();
      expect(mainServiceItemController.get("content.runCompaction")).to.equal(true);
    });
  });

  describe("#runSmokeTestPrimary", function () {
    beforeEach(function () {
      sinon.stub(App, 'get').withArgs('clusterName').returns('myCluster');
    });

    afterEach(function () {
      App.get.restore();
    });

    var tests = [
      {
        data: {
          'serviceName': "HDFS",
          'displayName': "HDFS",
          'query': "test"
        },
        "RequestInfo": {
          "context": "HDFS Service Check",
          "command" : "HDFS_SERVICE_CHECK"
        },
        "Requests/resource_filters": [{"service_name" : "HDFS"}]
      },
      {
        data: {
          'serviceName': "KERBEROS",
          'displayName': "Kerberos",
          'query': "test"
        },
        "RequestInfo": {
          "context": "Kerberos Service Check",
          "command" : "KERBEROS_SERVICE_CHECK",
          "operation_level": {
            "level": "CLUSTER",
            "cluster_name": "myCluster"
          }
        },
        "Requests/resource_filters": [{"service_name" : "KERBEROS"}]
      }
    ];

    tests.forEach(function (test) {

      var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: test.data.serviceName,
        displayName: test.data.displayName}});
      describe('send request to run smoke test for ' + test.data.serviceName, function () {

        beforeEach(function () {
          mainServiceItemController.set("runSmokeTestErrorCallBack", Em.K);
          mainServiceItemController.set("runSmokeTestSuccessCallBack", Em.K);
          mainServiceItemController.runSmokeTestPrimary(test.data.query);
          this.args = testHelpers.findAjaxRequest('name', 'service.item.smoke')[0];
          this.data = this.args.data;
          this.data = JSON.parse(App.ajax.fakeGetUrl('service.item.smoke').format(this.data).data);
        });

        it('ajax request is sent', function () {
          expect(this.args).exists;
        });

        it('RequestInfo.context is valid', function () {
          expect(this.data.RequestInfo.context).to.equal(test.RequestInfo.context);
        });

        it('RequestInfo.command is valid', function () {
          expect(this.data.RequestInfo.command).to.equal(test.RequestInfo.command);
        });

        it('Requests/resource_filter.0.serviceName is valid', function () {
          expect(this.data["Requests/resource_filters"][0].serviceName).to.equal(test["Requests/resource_filters"][0].serviceName);
        });

        it('RequestInfo.operation_level is valid', function () {
          expect(this.data.RequestInfo.operation_level).to.be.deep.equal(test.RequestInfo.operation_level);
        });

      });
    });
  });

  describe('#downloadClientConfigs()', function () {

    var mainServiceItemController = App.MainServiceItemController.create({
      content: {
        clientComponents: [
          Em.Object.create({
            totalCount: 1,
            componentName: 'C1',
            displayName: 'd1'
          })
        ],
        serviceName: 'S1'
      }
    });

    beforeEach(function () {
      sinon.stub(mainServiceItemController, 'downloadClientConfigsCall', Em.K);
    });
    afterEach(function () {
      mainServiceItemController.downloadClientConfigsCall.restore();
    });

    it('should launch $.fileDownload method', function () {
      mainServiceItemController.downloadClientConfigs();
      expect(mainServiceItemController.downloadClientConfigsCall.calledWith({
        serviceName: 'S1',
        componentName: 'C1',
        resourceType: mainServiceItemController.resourceTypeEnum.SERVICE_COMPONENT
      })).to.be.true;
    });
    it('should launch $.fileDownload method, event passed', function () {
      var event = {
        label: 'label1',
        name: 'name1'
      };
      mainServiceItemController.downloadClientConfigs(event);
      expect(mainServiceItemController.downloadClientConfigsCall.calledWith({
        serviceName: 'S1',
        componentName: 'name1',
        resourceType: mainServiceItemController.resourceTypeEnum.SERVICE_COMPONENT
      })).to.be.true;
    });
  });

  describe('#downloadAllClientConfigs()', function () {

    var mainServiceItemController = App.MainServiceItemController.create({
      content: {
        clientComponents: [
          Em.Object.create({
            totalCount: 1,
            componentName: 'C1',
            displayName: 'd1'
          }),
          Em.Object.create({
            totalCount: 1,
            componentName: 'C2',
            displayName: 'd2'
          })
        ],
        serviceName: 'S1'
      }
    });

    beforeEach(function () {
      sinon.stub(mainServiceItemController, 'downloadClientConfigsCall', Em.K);
    });
    afterEach(function () {
      mainServiceItemController.downloadClientConfigsCall.restore();
    });

    it('should call downloadClientConfigsCall method for all clients', function () {
      mainServiceItemController.downloadAllClientConfigs();
      expect(mainServiceItemController.downloadClientConfigsCall.calledWith({
        serviceName: 'S1',
        resourceType: mainServiceItemController.resourceTypeEnum.SERVICE
      })).to.be.true;
    });
  });

  describe('#startLdapKnox() and #stopLdapKnox() should call startStopLdapKnox once: ', function () {


    var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: 'KNOX',
      displayName: 'Knox'}});

    beforeEach(function () {
      sinon.stub(mainServiceItemController, 'startStopLdapKnox', function(){
        return true;
      });
    });
    afterEach(function () {
      mainServiceItemController.startStopLdapKnox.restore();
    });

    var tests = [
      {
        methodName: 'startLdapKnox',
        callback: mainServiceItemController.startLdapKnox
      },
      {
        methodName: 'stopLdapKnox',
        callback: mainServiceItemController.stopLdapKnox
      }
    ];

    tests.forEach(function(test){
      it(test.methodName + ' should call startStopLdapKnox method', function () {
        test.callback.call(mainServiceItemController);
        expect(mainServiceItemController.startStopLdapKnox.calledOnce).to.be.true;
      });
    },this);

  });

  describe("#executeCustomCommand", function () {
    var data = {
      data: {
        'serviceName': "SAMPLESRV",
        'displayName': "SAMPLESRV",
        'query': "test"
      },
      "RequestInfo": {
        "context": "Execute Custom Commands",
        "command" : "SAMPLESRVCUSTOMCOMMANDS"
      },
      "Requests/resource_filters": [{"service_name" : "SAMPLESRV"}]
    };

    var context = {
      label: 'Execute Custom Commands',
      service: data.data.serviceName,
      component: data.data.serviceName,
      command: data.RequestInfo.command
    };

    var mainServiceItemController = App.MainServiceItemController.create({
      content: {
        serviceName: data.data.serviceName,
        displayName: data.data.displayName
      }
    });

    before(function () {
      mainServiceItemController.set("executeCustomCommandErrorCallback", Em.K);
      mainServiceItemController.set("executeCustomCommandSuccessCallback", Em.K);
      sinon.spy(App, 'showConfirmationPopup');
    });

    after(function () {
      App.showConfirmationPopup.restore();
    });

    it('shows a confirmation popup', function () {
      mainServiceItemController.executeCustomCommand(context);
      expect(App.showConfirmationPopup.calledOnce).to.equal(true);
    });
  });

  describe("#findDependentServices()", function() {
    var mainServiceItemController;

    beforeEach(function() {
      mainServiceItemController = App.MainServiceItemController.create({});
      sinon.stub(App.StackService, 'find', function (serviceName) {
        return stackSerivceModel[serviceName];
      });
      this.mockService = sinon.stub(App.Service, 'find');
    });
    afterEach(function() {
      App.StackService.find.restore();
      this.mockService.restore();
    });

    it("no services", function() {
      this.mockService.returns([]);
      expect(mainServiceItemController.findDependentServices(['S1'])).to.be.empty;
    });

    it("service has dependencies", function() {
      this.mockService.returns([
        Em.Object.create({ serviceName: 'HDFS' }),
        Em.Object.create({ serviceName: 'YARN' }),
        Em.Object.create({ serviceName: 'MAPREDUCE2' }),
        Em.Object.create({ serviceName: 'TEZ' }),
        Em.Object.create({ serviceName: 'HIVE' })
      ]);
      expect(mainServiceItemController.findDependentServices(['YARN', 'MAPREDUCE2'])).to.eql(['TEZ', 'HIVE']);
    });

    it("service has no dependencies", function() {
       this.mockService.returns([
         Em.Object.create({ serviceName: 'HDFS' }),
         Em.Object.create({ serviceName: 'YARN' }),
         Em.Object.create({ serviceName: 'MAPREDUCE2' }),
         Em.Object.create({ serviceName: 'TEZ' }),
         Em.Object.create({ serviceName: 'HIVE' })
      ]);
      expect(mainServiceItemController.findDependentServices(['HIVE'])).to.be.empty;
    });

    it("service has no dependencies (except interdependent)", function() {
      this.mockService.returns([
        Em.Object.create({ serviceName: 'HDFS' }),
        Em.Object.create({ serviceName: 'YARN' }),
        Em.Object.create({ serviceName: 'MAPREDUCE2' })
      ]);
      expect(mainServiceItemController.findDependentServices(['YARN', 'MAPREDUCE2'])).to.be.empty;
    });

  });

  describe("#deleteService()", function() {
    var mainServiceItemController;

    beforeEach(function() {
      mainServiceItemController = App.MainServiceItemController.create({});
      this.mockDependentServices = sinon.stub(mainServiceItemController, 'findDependentServices');
      sinon.stub(mainServiceItemController, 'dependentServicesWarning');
      sinon.stub(mainServiceItemController, 'servicesDisplayNames', function(servicesDisplayNames) {
        return servicesDisplayNames;
      });
      this.allowUninstallServices = sinon.stub(mainServiceItemController, 'allowUninstallServices');
      this.mockService = sinon.stub(App.Service, 'find');
      this.mockRangerPluginEnabled = sinon.stub(mainServiceItemController, 'isRangerPluginEnabled');
      sinon.stub(App, 'showConfirmationPopup');
      sinon.stub(App.ModalPopup, 'show');
      sinon.stub(App.format, 'role', function(name) {return name});
      sinon.stub(mainServiceItemController, 'kerberosDeleteWarning');
      sinon.stub(mainServiceItemController, 'showLastWarning');

      mainServiceItemController.reopen({
        interDependentServices: []
      })
    });
    afterEach(function() {
      mainServiceItemController.allowUninstallServices.restore();
      mainServiceItemController.servicesDisplayNames.restore();
      this.mockDependentServices.restore();
      this.mockService.restore();
      mainServiceItemController.dependentServicesWarning.restore();
      App.showConfirmationPopup.restore();
      App.ModalPopup.show.restore();
      App.format.role.restore();
      mainServiceItemController.kerberosDeleteWarning.restore();
      this.mockRangerPluginEnabled.restore();
    });

    it("Kerberos delete should show specific warning", function() {
      mainServiceItemController.deleteService('KERBEROS');
      expect(mainServiceItemController.kerberosDeleteWarning.
        calledWith(Em.I18n.t('services.service.delete.popup.header'))).to.be.true;
    });

    it("RANGER delete should show specific warning", function() {
      this.mockRangerPluginEnabled.returns(true);
      mainServiceItemController.deleteService('RANGER');
      expect(App.ModalPopup.show.calledWith({
        secondary: null,
        header: Em.I18n.t('services.service.delete.popup.header'),
        encodeBody: false,
        body: Em.I18n.t('services.service.delete.popup.ranger')
      })).to.be.true;
    });

    it("only one service installed", function() {
      this.mockDependentServices.returns(['S2']);
      this.mockService.returns(Em.Object.create({length: 1}));
      mainServiceItemController.deleteService('S1');
      expect(App.ModalPopup.show.calledWith({
        secondary: null,
        header: Em.I18n.t('services.service.delete.popup.header'),
        encodeBody: false,
        body: Em.I18n.t('services.service.delete.lastService.popup.body').format('S1')
      })).to.be.true;
    });

    it("service has installed dependent services", function() {
      this.mockDependentServices.returns(['S2']);
      this.mockService.returns([Em.Object.create({workStatus: App.Service.statesMap.stopped}), Em.Object.create({workStatus: App.Service.statesMap.stopped})]);
      mainServiceItemController.deleteService('S1');
      expect(mainServiceItemController.dependentServicesWarning.calledWith('S1', ['S2'])).to.be.true;
    });

    it("service has not dependent services, and stopped", function() {
      this.mockDependentServices.returns([]);
      this.allowUninstallServices.returns(true);
      this.mockService.returns([Em.Object.create({workStatus: App.Service.statesMap.stopped}), Em.Object.create({workStatus: App.Service.statesMap.stopped})]);
      mainServiceItemController.deleteService('S1');
      expect(mainServiceItemController.showLastWarning.calledOnce).to.be.true;
    });

    it("service has not dependent services, and install failed", function() {
      this.mockDependentServices.returns([]);
      this.allowUninstallServices.returns(true);
      this.mockService.returns([Em.Object.create({workStatus: App.Service.statesMap.install_failed}), Em.Object.create({workStatus: App.Service.statesMap.install_failed})]);
      mainServiceItemController.deleteService('S1');
      expect(mainServiceItemController.showLastWarning.calledOnce).to.be.true;
    });

    it("service has not dependent services, and not stopped", function() {
      this.mockDependentServices.returns([]);
      this.mockService.returns(Em.Object.create({workStatus: App.Service.statesMap.started}));
      mainServiceItemController.deleteService('S1');
      expect(App.ModalPopup.show.calledWith({
        secondary: null,
        header: Em.I18n.t('services.service.delete.popup.header'),
        encodeBody: false,
        body: Em.I18n.t('services.service.delete.popup.mustBeStopped').format('S1')
      })).to.be.true;
    });
  });

  describe("#kerberosDeleteWarning()", function () {
    var mainServiceItemController;

    beforeEach(function() {
      mainServiceItemController = App.MainServiceItemController.create({});
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(App.router, 'transitionTo');
    });

    afterEach(function() {
      App.ModalPopup.show.restore();
      App.router.transitionTo.restore();
    });

    it("App.ModalPopup.show should be called", function() {
      var popup = mainServiceItemController.kerberosDeleteWarning('header');
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onSecondary();
      expect(App.router.transitionTo.calledWith('main.admin.adminKerberos.index')).to.be.true;
    });
  });

  describe("#dependentServicesWarning()", function() {
    var mainServiceItemController;

    beforeEach(function() {
      mainServiceItemController = App.MainServiceItemController.create({});
      sinon.stub(App.ModalPopup, 'show');
      sinon.stub(App.format, 'role', function(name) {return name});
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      App.format.role.restore();
    });

    it("App.ModalPopup.show should be called", function() {
      mainServiceItemController.dependentServicesWarning('S1', ['S2']);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe("#confirmDeleteService()", function() {
    var mainServiceItemController;

    beforeEach(function () {
      mainServiceItemController = App.MainServiceItemController.create();
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    describe('confirmation popup', function () {

      beforeEach(function () {
        sinon.stub(App.ModalPopup, 'show', Em.K);
        mainServiceItemController.confirmDeleteService('S1', [], '');
      });

      it("App.ModalPopup.show should be called", function() {
        expect(App.ModalPopup.show.calledOnce).to.be.true;
      });

    });

    describe('progress popup', function () {

      var cases = [
        {
          serviceName: 'S0',
          dependentServiceNames: [],
          serviceNames: ['S0'],
          message: 's0',
          title: 'no dependent services'
        },
        {
          serviceName: 'S1',
          dependentServiceNames: ['S2', 'S3', 'S4'],
          serviceNames: ['S1', 'S2', 'S3', 'S4'],
          message: 's1, s2, s3 and s4',
          title: 'dependent services present'
        }
      ];

      cases.forEach(function (item) {

        describe(item.title, function () {

          beforeEach(function () {
            sinon.stub(App.ModalPopup, 'show', function (options) {
              options._super = Em.K;
              if (options.onPrimary) {
                options.onPrimary();
              }
              return options;
            });
            sinon.stub(App.Service, 'find', function (serviceName) {
              return Em.Object.create({
                displayName: serviceName.toLowerCase()
              });
            });
            sinon.stub(mainServiceItemController, 'deleteServiceCall', Em.K);
            mainServiceItemController.confirmDeleteService(item.serviceName, item.dependentServiceNames, '');
          });

          afterEach(function () {
            App.Service.find.restore();
            mainServiceItemController.deleteServiceCall.restore();
          });

          it('modal popups display', function () {
            expect(App.ModalPopup.show.calledTwice).to.be.true;
          });

          it('progress popup message', function () {
            expect(mainServiceItemController.get('deleteServiceProgressPopup.message')).to.equal(Em.I18n.t('services.service.delete.progressPopup.message').format(item.message));
          });

          it('delete service call', function () {
            expect(mainServiceItemController.deleteServiceCall.calledOnce).to.be.true;
          });

          it('delete service call arguments', function () {
            expect(mainServiceItemController.deleteServiceCall.calledWith(item.serviceNames)).to.be.true;
          });

          it('progress popup close', function () {
            mainServiceItemController.get('deleteServiceProgressPopup').onClose();
            expect(mainServiceItemController.get('deleteServiceProgressPopup')).to.be.null;
          });

        });

      });

    });

  });

  describe('#interDependentServices', function() {
    var mainServiceItemController;

    beforeEach(function() {
      sinon.stub(App.StackService, 'find', function (serviceName) {
        return stackSerivceModel[serviceName];
      });
      mainServiceItemController = App.MainServiceItemController.create({
        content: {}
      });
    });

    afterEach(function() {
      App.StackService.find.restore();
    });

    it('get interdependent services for YARN', function() {
      mainServiceItemController.set('content', Em.Object.create({
        serviceName: 'YARN'
      }));
      expect(mainServiceItemController.get('interDependentServices')).to.eql(['MAPREDUCE2']);
    });

    it('get interdependent services for MAPREDUCE2', function() {
      mainServiceItemController.set('content', Em.Object.create({
        serviceName: 'MAPREDUCE2'
      }));
      expect(mainServiceItemController.get('interDependentServices')).to.eql(['YARN']);
    });
  });

  describe("#deleteServiceCall()", function() {
    var mainServiceItemController;
    var service;

    beforeEach(function() {
      mainServiceItemController = App.MainServiceItemController.create({});
      service = Em.Object.create({serviceName: 'S1', deleteInProgress: false});
      sinon.stub( App.Service, 'find', function () {
        return [service];
      });
      mainServiceItemController.deleteServiceCall(['S1', 'S2']);
    });

    afterEach(function () {
      App.Service.find.restore();
    });

    it("App.ajax.send should be called", function() {
      var args = testHelpers.findAjaxRequest('name', 'common.delete.service');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(mainServiceItemController);
      expect(args[0].data).to.be.eql({
        serviceName : 'S1',
        servicesToDeleteNext: ['S2']
      });
    });

    it('service is marked as deleted', function () {
      expect(service.get('deleteInProgress')).to.be.true;
    });

  });

  describe("#deleteServiceCallSuccessCallback()", function() {
    var mainServiceItemController;

    beforeEach(function() {
      mainServiceItemController = App.MainServiceItemController.create({});
      sinon.stub(mainServiceItemController, 'saveConfigs', Em.K);
      sinon.stub(mainServiceItemController, 'deleteServiceCall', Em.K);
      mainServiceItemController.reopen({
        interDependentServices: []
      })
    });
    afterEach(function() {
      mainServiceItemController.saveConfigs.restore();
      mainServiceItemController.deleteServiceCall.restore();
    });

    it("saveConfigs should be called", function() {
      mainServiceItemController.deleteServiceCallSuccessCallback([], null, {});
      expect(mainServiceItemController.deleteServiceCall.called).to.be.false;
      expect(mainServiceItemController.saveConfigs.calledOnce).to.be.true;
    });

    it("deleteServiceCall should be called", function() {
      mainServiceItemController.deleteServiceCallSuccessCallback([], null, {servicesToDeleteNext: true});
      expect(mainServiceItemController.deleteServiceCall.calledOnce).to.be.true;
      expect(mainServiceItemController.saveConfigs.called).to.be.false;
    });
  });

  describe("#restartLLAP()", function () {
    var mainServiceItemController;

    beforeEach(function () {
      mainServiceItemController = App.MainServiceItemController.create();
      sinon.stub(mainServiceItemController, 'restartLLAPAndRefreshQueueRequest', Em.K);
      sinon.stub(mainServiceItemController, 'restartLLAPRequest', Em.K);
      this.mockService = sinon.stub(App.Service, 'find');
    });
    afterEach(function () {
      mainServiceItemController.restartLLAPAndRefreshQueueRequest.restore();
      mainServiceItemController.restartLLAPRequest.restore();
      this.mockService.restore();
    });

    [
      {
        m: 'should call only restartLLAPRequest',
        isRestartRequired: false,
        toCall: 'restartLLAPRequest'
      },
      {
        m: 'should call only restartLLAPAndRefreshQueueRequest',
        isRestartRequired: true,
        toCall: 'restartLLAPAndRefreshQueueRequest'
      }
    ].forEach(function (test) {
        it(test.m, function () {
          this.mockService.returns([Em.Object.create({
            serviceName: 'YARN',
            isRestartRequired: test.isRestartRequired
          })]);
          var confirmationPopup = mainServiceItemController.restartLLAP();
          confirmationPopup.onPrimary();
          expect(mainServiceItemController[test.toCall].calledOnce).to.be.true;
        });
      });
  });

  describe("#saveConfigs()", function () {
    var mainServiceItemController;

    beforeEach(function () {
      mainServiceItemController = App.MainServiceItemController.create();
      sinon.stub(mainServiceItemController, 'getServiceConfigToSave').returns({});
      sinon.stub(mainServiceItemController, 'putChangedConfigurations');
      sinon.stub(mainServiceItemController, 'confirmServiceDeletion');
    });

    afterEach(function () {
      mainServiceItemController.getServiceConfigToSave.restore();
      mainServiceItemController.putChangedConfigurations.restore();
      mainServiceItemController.confirmServiceDeletion.restore();
    });

    it("empty stepConfigs", function() {
      mainServiceItemController.set('stepConfigs', []);
      mainServiceItemController.saveConfigs();
      expect(mainServiceItemController.confirmServiceDeletion.calledOnce).to.be.true;
      expect(mainServiceItemController.putChangedConfigurations.called).to.be.false;
    });

    it("stepConfigs has configs", function() {
      mainServiceItemController.set('stepConfigs', [Em.Object.create({serviceName: 'S1'})]);
      mainServiceItemController.saveConfigs();
      expect(mainServiceItemController.putChangedConfigurations.calledWith([{}], 'confirmServiceDeletion')).to.be.true;
      expect(mainServiceItemController.confirmServiceDeletion.called).to.be.false;
    });
  });

  describe("#isRangerPluginEnabled()", function () {
    var mainServiceItemController;

    beforeEach(function() {
      mainServiceItemController = App.MainServiceItemController.create();
      this.mock = sinon.stub(App.router, 'get');
    });

    afterEach(function() {
      this.mock.restore();
    });

    it("should return false", function() {
      this.mock.returns([Em.Object.create({
        isDisplayed: true,
        status: 'Disabled'
      })]);
      expect(mainServiceItemController.isRangerPluginEnabled()).to.be.false;
    });

    it("should return true", function() {
      this.mock.returns([Em.Object.create({
        isDisplayed: true,
        status: 'Enabled'
      })]);
      expect(mainServiceItemController.isRangerPluginEnabled()).to.be.true;
    });
  });

  describe('#dependentServiceNames', function () {

    var controller,
      serviceName = 's0',
      dependentServiceNames = ['s1', 's2'],
      testCases = [
        {
          isConfigsPropertiesLoaded: true,
          dependentServiceNames: dependentServiceNames,
          message: 'model is ready'
        },
        {
          isConfigsPropertiesLoaded: false,
          dependentServiceNames: [],
          message: 'model is not ready'
        }
      ];

    beforeEach(function () {
      controller = App.MainServiceItemController.create({
        content: {
          serviceName: serviceName
        }
      });
      sinon.stub(App.StackService, 'find').returns(Em.Object.create({
        dependentServiceNames: dependentServiceNames
      }));
    });

    afterEach(function () {
      App.StackService.find.restore();
    });

    testCases.forEach(function (test) {

      it(test.message, function () {
        App.set('router.clusterController.isConfigsPropertiesLoaded', test.isConfigsPropertiesLoaded);
        expect(controller.get('dependentServiceNames')).to.eql(test.dependentServiceNames);
      });

    });

  });

  describe('#applyRecommendedValues', function () {

    var controller;

    beforeEach(function () {
      controller = App.MainServiceItemController.create({
        stepConfigs: [
          Em.Object.create({
            serviceName: 's1',
            configs: [
              Em.Object.create({
                name: 'p1',
                value: 'v1'
              }),
              Em.Object.create({
                name: 'p2',
                value: 'v2'
              })
            ]
          }),
          Em.Object.create({
            serviceName: 's2',
            configs: [
              Em.Object.create({
                name: 'p3',
                value: 'v3'
              }),
              Em.Object.create({
                name: 'p4',
                value: 'v4'
              })
            ]
          })
        ],
        changedProperties: [
          {
            serviceName: 's1',
            propertyName: 'p1',
            recommendedValue: 'r1',
            initialValue: 'i1',
            saveRecommended: false
          },
          {
            serviceName: 's1',
            propertyName: 'p2',
            recommendedValue: 'r2',
            initialValue: 'i2',
            saveRecommended: true
          },
          {
            serviceName: 's2',
            propertyName: 'p3',
            recommendedValue: 'r3',
            initialValue: 'i3',
            saveRecommended: true
          }
        ]
      });
    });

    it('should update properties with saveRecommended flag set to true', function () {
      controller.applyRecommendedValues(controller.get('stepConfigs'));
      expect(controller.get('stepConfigs').findProperty('serviceName', 's1').get('configs').findProperty('name', 'p1').get('value')).to.equal('i1');
      expect(controller.get('stepConfigs').findProperty('serviceName', 's1').get('configs').findProperty('name', 'p2').get('value')).to.equal('r2');
      expect(controller.get('stepConfigs').findProperty('serviceName', 's2').get('configs').findProperty('name', 'p3').get('value')).to.equal('r3');
      expect(controller.get('stepConfigs').findProperty('serviceName', 's2').get('configs').findProperty('name', 'p4').get('value')).to.equal('v4');
    });

  });

});

});

require.register("test/controllers/main/service/manage_config_groups_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var c;

describe('App.ManageConfigGroupsController', function() {
  var controller = App.ManageConfigGroupsController.create({});

  beforeEach(function() {
    c = App.ManageConfigGroupsController.create({});
  });

  var manageConfigGroupsController = App.ManageConfigGroupsController.create({});

  describe('#addConfigGroup', function() {
    beforeEach(function() {
      manageConfigGroupsController.addConfigGroup();
    });

    describe("#validate", function() {
      it("should display no warning if user inputs valid characters into group name", function() {

        manageConfigGroupsController.addGroupPopup.set('configGroupName', 'hello');

        expect(manageConfigGroupsController.addGroupPopup.warningMessage).to.be.empty;
      });

      it("should display warning if user inputs invalid characters into group name", function() {
        manageConfigGroupsController.addGroupPopup.set('configGroupName', '/{"!@#$%');

        expect(manageConfigGroupsController.addGroupPopup.warningMessage).to.equal('Invalid Group Name. Only alphanumerics, hyphens, spaces and underscores are allowed.');
      });
    });
  });

  describe('#renameConfigGroup', function() {
    beforeEach(function() {
      var configGroup = Ember.Object.create ({
        name: 'name',
        description: 'description'
      });

      manageConfigGroupsController.set('selectedConfigGroup', configGroup);
      manageConfigGroupsController.renameConfigGroup();
    });

    describe("#validate", function() {
      it("should display no warning if user inputs valid characters into group name", function() {
        manageConfigGroupsController.renameGroupPopup.set('configGroupName', 'hello');

        expect(manageConfigGroupsController.renameGroupPopup.warningMessage).to.be.empty;
      });

      it("should display warning if user inputs invalid characters into group name", function() {
        manageConfigGroupsController.renameGroupPopup.set('configGroupName', '/{"!@#$%');

        expect(manageConfigGroupsController.renameGroupPopup.warningMessage).to.equal('Invalid Group Name. Only alphanumerics, hyphens, spaces and underscores are allowed.');
      });
    });
  });

  describe('#addHostsCallback', function() {

    beforeEach(function() {

      c.reopen({
        selectedConfigGroup: Em.Object.create({
          hosts: ['h1'],
          parentConfigGroup: Em.Object.create({
            hosts: ['h2', 'h3']
          })
        })
      });
    });

    it('should set hosts to selectedConfigGroup and remove them form default group', function () {

      c.addHostsCallback(['h2', 'h3']);

      expect(c.get('selectedConfigGroup.hosts')).to.include.members(['h1','h2','h3']);
      expect(c.get('selectedConfigGroup.parentConfigGroup.hosts').toArray()).to.be.empty;
    });

  });

  describe('#isHostsModified', function () {

    Em.A([
      {
        o: {
          toClearHosts: [],
          toDelete: [],
          toSetHosts: [],
          toCreate: []
        },
        e: false
      },
      {
        o: {
          toClearHosts: [{}],
          toDelete: [],
          toSetHosts: [],
          toCreate: []
        },
        e: true
      },
      {
        o: {
          toClearHosts: [],
          toDelete: [{}],
          toSetHosts: [],
          toCreate: []
        },
        e: true
      },
      {
        o: {
          toClearHosts: [],
          toDelete: [],
          toSetHosts: [{}],
          toCreate: []
        },
        e: true
      },
      {
        o: {
          toClearHosts: [],
          toDelete: [],
          toSetHosts: [],
          toCreate: [{}]
        },
        e: true
      }
    ]).forEach(function (test, index) {
      it('test #' + index, function () {
        c.reopen({
          isLoaded: true,
          hostsModifiedConfigGroups: test.o
        });
        expect(c.get('isHostsModified')).to.equal(test.e);
      });
    });

  });

  describe('#deleteConfigGroup', function () {

    beforeEach(function() {

      var defaultGroup = Em.Object.create({
        hosts: ['h2', 'h3'],
        isDefault: true
      });

      var selectedGroup = Em.Object.create({
        hosts: ['h1'],
        parentConfigGroup: defaultGroup
      });

      c.reopen({
        configGroups: [defaultGroup, selectedGroup],
        selectedConfigGroup: selectedGroup
      });

      sinon.stub(App.configGroupsMapper, 'deleteRecord', Em.K);
    });

    afterEach(function(){
      App.configGroupsMapper.deleteRecord.restore();
    });

    it('after deleting some config group, Default should be selected', function () {

      c.deleteConfigGroup();

      expect(c.get('configGroups.length')).to.equal(1);
      expect(c.get('selectedConfigGroup.hosts')).to.include.members(['h1','h2','h3']);
      expect(c.get('selectedConfigGroup.isDefault')).to.be.true;
    });

  });

  describe("#manageConfigurationGroups", function () {
    var service = Em.Object.create({});
    manageConfigGroupsController.set('hostsModifiedConfigGroups', {});
    describe("#controller passed", function () {
      controller = Em.Object.create({
        content: Em.Object.create()
      });
      var popup = manageConfigGroupsController.manageConfigurationGroups(controller, service);

      describe("#onPrimary()", function () {
        beforeEach(function () {
          sinon.stub(popup, 'onPrimaryWizard', Em.K);
        });
        afterEach(function () {
          popup.onPrimaryWizard.restore();
        });
        it("onPrimaryWizard is called", function () {
          popup.onPrimary();
          expect(popup.onPrimaryWizard.calledOnce).to.be.true;
        });
      });

      describe("#onPrimaryWizard()", function () {

        var ctrl = Em.Object.create({
          selectedService: Em.Object.create({
            selected: false
          }),
          selectedServiceObserver: Em.K,
          setGroupsToDelete: Em.K
        });

        beforeEach(function () {
          sinon.spy(ctrl, 'selectedServiceObserver');
          sinon.spy(ctrl, 'setGroupsToDelete');
          sinon.stub(manageConfigGroupsController, 'persistConfigGroups', Em.K);
          sinon.stub(popup, 'updateConfigGroupOnServicePage', Em.K);
          sinon.stub(popup, 'hide', Em.K);
        });

        afterEach(function () {
          ctrl.setGroupsToDelete.restore();
          ctrl.selectedServiceObserver.restore();
          manageConfigGroupsController.persistConfigGroups.restore();
          popup.updateConfigGroupOnServicePage.restore();
          popup.hide.restore();
        });

        describe("groups deleted on 7th step", function () {

          beforeEach(function () {
            ctrl.set('name', 'wizardStep7Controller');
            popup.onPrimaryWizard(ctrl, {toDelete: [1]});
          });

          it('selectedServiceObserver is called once', function () {
            expect(ctrl.selectedServiceObserver.calledOnce).to.be.true;
          });
          it('setGroupsToDelete is called with [1]', function () {
            expect(ctrl.setGroupsToDelete.calledWith([1])).to.be.true;
          });
          it('persistConfigGroups is called once', function () {
            expect(manageConfigGroupsController.persistConfigGroups.calledOnce).to.be.true;
          });
          it('updateConfigGroupOnServicePage is called once', function () {
            expect(popup.updateConfigGroupOnServicePage.calledOnce).to.be.true;
          });
          it('hide is called once', function () {
            expect(popup.hide.calledOnce).to.be.true;
          });
        });

        describe("wizard not on 7th step", function () {

          beforeEach(function () {
            ctrl.set('name', '');
            popup.onPrimaryWizard(ctrl, {});
          });

          it('selectedServiceObserver is called once', function () {
            expect(ctrl.selectedServiceObserver.calledOnce).to.be.true;
          });

          it('setGroupsToDelete is not called', function () {
            expect(ctrl.setGroupsToDelete.called).to.be.false;
          });

          it('persistConfigGroups is not called', function () {
            expect(manageConfigGroupsController.persistConfigGroups.called).to.be.false;
          });

          it('updateConfigGroupOnServicePage is not called', function () {
            expect(popup.updateConfigGroupOnServicePage.called).to.be.false;
          });

          it('hide is called once', function () {
            expect(popup.hide.calledOnce).to.be.true;
          });
        });

        describe("wizard on 7th step, service selected", function () {

          beforeEach(function () {
            ctrl.set('name', 'wizardStep7Controller');
            ctrl.set('selectedService.selected', true);
            popup.onPrimaryWizard(ctrl, {toDelete: [1]});
          });

          it('selectedServiceObserver is called once', function () {
            expect(ctrl.selectedServiceObserver.calledOnce).to.be.true;
          });
          it('setGroupsToDelete is not called', function () {
            expect(ctrl.setGroupsToDelete.called).to.be.false;
          });
          it('persistConfigGroups is called once', function () {
            expect(manageConfigGroupsController.persistConfigGroups.calledOnce).to.be.true;
          });
          it('updateConfigGroupOnServicePage is called once', function () {
            expect(popup.updateConfigGroupOnServicePage.calledOnce).to.be.true;
          });
          it('hide is called once', function () {
            expect(popup.hide.calledOnce).to.be.true;
          });
        });

        describe("wizard on 7th step, no groups to delete", function () {

          beforeEach(function () {
            ctrl.set('name', 'wizardStep7Controller');
            ctrl.set('selectedService.selected', false);
            popup.onPrimaryWizard(ctrl, {toDelete: []});
          });

          it('selectedServiceObserver is called once', function () {
            expect(ctrl.selectedServiceObserver.calledOnce).to.be.true;
          });
          it('setGroupsToDelete is not called', function () {
            expect(ctrl.setGroupsToDelete.called).to.be.false;
          });
          it('persistConfigGroups is called once', function () {
            expect(manageConfigGroupsController.persistConfigGroups.calledOnce).to.be.true;
          });
          it('updateConfigGroupOnServicePage is called once', function () {
            expect(popup.updateConfigGroupOnServicePage.calledOnce).to.be.true;
          });
          it('hide is called once', function () {
            expect(popup.hide.calledOnce).to.be.true;
          });

        });

      });
    });

    describe("#controller not passed", function () {
      var popup = manageConfigGroupsController.manageConfigurationGroups(null, service);

      describe("#onPrimary()", function () {
        beforeEach(function () {
          sinon.stub(popup, 'runClearCGQueue').returns({
            done: function (callback) {
              callback();
            }
          });
          sinon.stub(popup, 'runModifyCGQueue').returns({
            done: function (callback) {
              callback();
            }
          });
          sinon.stub(popup, 'runCreateCGQueue').returns({
            done: function (callback) {
              callback();
            }
          });
          sinon.stub(popup, 'updateConfigGroupOnServicePage', Em.K);
          sinon.stub(popup, 'hide', Em.K);
          manageConfigGroupsController.set('hostsModifiedConfigGroups', {toCreate: []});
          popup.onPrimary();
        });
        afterEach(function () {
          popup.runCreateCGQueue.restore();
          popup.runModifyCGQueue.restore();
          popup.runClearCGQueue.restore();
          popup.updateConfigGroupOnServicePage.restore();
          popup.hide.restore();
        });
        it("runClearCGQueue is called", function () {
          expect(popup.runClearCGQueue.calledOnce).to.be.true;
        });
        it("runModifyCGQueue is called", function () {
          expect(popup.runModifyCGQueue.calledOnce).to.be.true;
        });
        it("runCreateCGQueue is called", function () {
          expect(popup.runCreateCGQueue.calledOnce).to.be.true;
        });
        it("updateConfigGroupOnServicePage is called", function () {
          expect(popup.updateConfigGroupOnServicePage.calledOnce).to.be.true;
        });
        it("hide is called", function () {
          expect(popup.hide.calledOnce).to.be.true;
        });
      });
      describe("#runClearCGQueue()", function () {
        beforeEach(function () {
          sinon.stub(manageConfigGroupsController, 'updateConfigurationGroup', Em.K);
          sinon.stub(manageConfigGroupsController, 'deleteConfigurationGroup', Em.K);
          popup.runClearCGQueue(Em.K, {
            initialGroups: [],
            toClearHosts: [Em.Object.create()],
            toDelete: [1]
          });
        });
        afterEach(function () {
          manageConfigGroupsController.updateConfigurationGroup.restore();
          manageConfigGroupsController.deleteConfigurationGroup.restore();
        });
        it("updateConfigurationGroup is called once", function () {
          expect(manageConfigGroupsController.updateConfigurationGroup.calledOnce).to.be.true;
        });
        it("deleteConfigurationGroup is called once", function () {
          expect(manageConfigGroupsController.deleteConfigurationGroup.calledOnce).to.be.true;
        });
      });
      describe("#runModifyCGQueue()", function () {
        beforeEach(function () {
          sinon.stub(manageConfigGroupsController, 'updateConfigurationGroup', Em.K);
        });
        afterEach(function () {
          manageConfigGroupsController.updateConfigurationGroup.restore();
        });
        it("updateConfigurationGroup is called once", function () {
          popup.runModifyCGQueue(Em.K, {toSetHosts: [1]});
          expect(manageConfigGroupsController.updateConfigurationGroup.calledOnce).to.be.true;
        });
      });
      describe("#runCreateCGQueue()", function () {
        beforeEach(function () {
          sinon.stub(manageConfigGroupsController, 'postNewConfigurationGroup', Em.K);
        });
        afterEach(function () {
          manageConfigGroupsController.postNewConfigurationGroup.restore();
        });
        it("postNewConfigurationGroup is called once", function () {
          popup.runCreateCGQueue(Em.K, {toCreate: [1]});
          expect(manageConfigGroupsController.postNewConfigurationGroup.calledOnce).to.be.true;
        });
      });
    });
  });

  describe('#_onLoadPropertiesSuccess', function () {

    var data = {
      items: [
        {
          type: 'type1',
          tag: 'tag1',
          properties: {
            prop1: 'val1',
            prop2: 'val2'
          }
        },
        {
          type: 'type1',
          tag: 'tag2',
          properties: {
            prop3: 'val3'
          }
        },
        {
          type: 'type2',
          tag: 'tag1',
          properties: {
            prop4: 'val4'
          }
        }
      ]
    };
    var params = {
      typeTagToGroupMap: {
        'type1///tag1': 'group1',
        'type1///tag2': 'group2',
        'type2///tag1': 'group3'
      }
    };
    var configGroups = [
      Em.Object.create({
        name: 'group1',
        properties: []
      }),
      Em.Object.create({
        name: 'group2',
        properties: []
      }),
      Em.Object.create({
        name: 'group3',
        properties: []
      }),
      Em.Object.create({
        name: 'group4',
        properties: []
      })
    ];

    beforeEach(function () {
      sinon.stub(c, 'resortConfigGroup', Em.K);
    });

    afterEach(function () {
      c.resortConfigGroup.restore();
    });

    it('should set properties to config groups', function () {
      c.set('configGroups', configGroups);
      c._onLoadPropertiesSuccess(data, null, params);
      expect(JSON.stringify(c.get('configGroups'))).to.equal(JSON.stringify([
        Em.Object.create({
          properties: [
            {
              name: 'prop1',
              value: 'val1',
              type: 'type1'
            },
            {
              name: 'prop2',
              value: 'val2',
              type: 'type1'
            }
          ],
          name: 'group1'
        }),
        Em.Object.create({
          properties: [
            {
              name: 'prop3',
              value: 'val3',
              type: 'type1'
            }
          ],
          name: 'group2'
        }),
        Em.Object.create({
          properties: [
            {
              name: 'prop4',
              value: 'val4',
              type: 'type2'
            }
          ],
          name: 'group3'
        }),
        Em.Object.create({
          properties: [],
          name: 'group4'
        })
      ]));
    });

  });

  describe('#componentsForFilter', function () {

    beforeEach(function () {
      sinon.stub(App.StackServiceComponent, 'find', function () {
        return [
          Em.Object.create({
            serviceName: 'HDFS'
          }),
          Em.Object.create({
            serviceName: 'noHDFS'
          }),
          Em.Object.create({
            serviceName: 'HDFS'
          })
        ];
      });
      c.set('serviceName', 'HDFS');
    });

    afterEach(function () {
      App.StackServiceComponent.find.restore();
    });

    it('should map components for current service', function () {
      expect(c.get('componentsForFilter')).to.have.property('length').equal(2);
    });

    it('no one is selected', function () {
      expect(c.get('componentsForFilter').mapProperty('selected')).to.be.eql([false, false]);
    });

  });

});

});

require.register("test/controllers/main/service/reassign/step1_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('controllers/main/service/reassign/step1_controller');
require('models/host_component');
var testHelpers = require('test/helpers');

describe('App.ReassignMasterWizardStep1Controller', function () {


  var controller = App.ReassignMasterWizardStep1Controller.create({
    content: Em.Object.create({
      reassign: Em.Object.create({}),
      services: []
    })
  });
  controller.set('_super', Em.K);

  describe('#loadConfigsTags', function() {
    beforeEach(function() {
      this.stub = sinon.stub(App.router, 'get');
    });

    afterEach(function() {
      this.stub.restore();
    });

    it('tests loadConfigsTags', function() {
      controller.loadConfigsTags();
      var args = testHelpers.findAjaxRequest('name', 'config.tags');
      expect(args).exists;
    });

    it('tests saveDatabaseType with type', function() {
      this.stub.returns({ saveDatabaseType: Em.K});

      controller.saveDatabaseType(true);
      expect(App.router.get.calledOnce).to.be.true;
    });

    it('tests saveDatabaseType without type', function() {
      this.stub.returns({ saveDatabaseType: Em.K});

      controller.saveDatabaseType(false);
      expect(App.router.get.called).to.be.false;
    });

    it('tests saveServiceProperties with properties', function() {
      this.stub.returns({ saveServiceProperties: Em.K});

      controller.saveServiceProperties(true);
      expect(App.router.get.calledOnce).to.be.true;
    });

    it('tests saveServiceProperties without properties', function() {
      this.stub.returns({ saveServiceProperties: Em.K});

      controller.saveServiceProperties(false);
      expect(App.router.get.called).to.be.false;
    });

    it('tests getDatabaseHost', function() {
      controller.set('content.configs', {
        'hive-site': {
          'javax.jdo.option.ConnectionURL': 'jdbc:mysql://c6401/hive?createDatabaseIfNotExist=true'

        }
      });

      controller.set('content.reassign.service_id', 'HIVE');
      controller.set('databaseType', 'mysql');

      expect(controller.getDatabaseHost()).to.equal('c6401')
    });

  });

  describe('#onLoadConfigs', function() {

    var reassignCtrl;

    beforeEach(function() {
      controller = App.ReassignMasterWizardStep1Controller.create({
        content: Em.Object.create({
          reassign: Em.Object.create({
            'component_name': 'OOZIE_SERVER',
            'service_id': 'OOZIE'
          }),
          services: []
        })
      });
      controller.set('_super', Em.K);

      sinon.stub(controller, 'getDatabaseHost', Em.K);
      sinon.stub(controller, 'saveDatabaseType', Em.K);
      sinon.stub(controller, 'saveServiceProperties', Em.K);
      sinon.stub(controller, 'saveConfigs', Em.K);

      reassignCtrl = App.router.reassignMasterController;
      reassignCtrl.set('content.hasManualSteps', true);
    });

    afterEach(function() {
      controller.getDatabaseHost.restore();
      controller.saveDatabaseType.restore();
      controller.saveServiceProperties.restore();
      controller.saveConfigs.restore();
    });
  
    it('should not set hasManualSteps to false for oozie with derby db', function() {
      var data = {
        items: [
          {
            type: 'oozie-site',
            properties: {
              'oozie.service.JPAService.jdbc.driver': 'jdbc:derby:${oozie.data.dir}/${oozie.db.schema.name}-db;create=true'
            }
          }
        ]
      };
    
      expect(reassignCtrl.get('content.hasManualSteps')).to.be.true;

      controller.onLoadConfigs(data);

      expect(reassignCtrl.get('content.hasManualSteps')).to.be.true;
    });
  
    it('should set hasManualSteps to false for oozie without derby db', function() {
      var data = {
        items: [
          {
            type: 'oozie-site',
            properties: {
              'oozie.service.JPAService.jdbc.driver': 'mysql'
            }
          }
        ]
      };

    
      expect(reassignCtrl.get('content.hasManualSteps')).to.be.true;

      controller.onLoadConfigs(data);

      expect(reassignCtrl.get('content.hasManualSteps')).to.be.false;
    });
  });

  describe("#getConfigUrlParams()", function() {
    it("unknown component", function() {
      expect(controller.getConfigUrlParams("", {})).to.be.empty;
    });
    it("OOZIE_SERVER component", function() {
      var data = {
        Clusters: {
          desired_configs: {
            'oozie-site': {
              tag: 'tag'
            },
            'oozie-env': {
              tag: 'tag'
            }
          }
        }
      };
      expect(controller.getConfigUrlParams("OOZIE_SERVER", data)).to.eql([
        "(type=oozie-site&tag=tag)",
        "(type=oozie-env&tag=tag)"
      ]);
    });
    it("HIVE_SERVER component", function() {
      var data = {
        Clusters: {
          desired_configs: {
            'hive-site': {
              tag: 'tag'
            },
            'hive-env': {
              tag: 'tag'
            }
          }
        }
      };
      expect(controller.getConfigUrlParams("HIVE_SERVER", data)).to.eql([
        "(type=hive-site&tag=tag)",
        "(type=hive-env&tag=tag)"
      ]);
    });
  });

  describe("#onLoadConfigsTags()", function () {
    beforeEach(function () {
      this.mock = sinon.stub(controller, 'getConfigUrlParams');
    });
    afterEach(function () {
      this.mock.restore();
    });
    it("empty params", function () {
      this.mock.returns([]);
      controller.onLoadConfigsTags();
      var args = testHelpers.findAjaxRequest('name', 'reassign.load_configs');
      expect(args).not.exists;
    });
    it("correct params", function () {
      this.mock.returns(['p1', 'p2']);
      controller.onLoadConfigsTags();
      var args = testHelpers.findAjaxRequest('name', 'reassign.load_configs');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        urlParams: 'p1|p2'
      });
    });
  });
});

});

require.register("test/controllers/main/service/reassign/step2_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('controllers/main/service/reassign/step2_controller');
require('models/host_component');

describe('App.ReassignMasterWizardStep2Controller', function () {


  var controller = App.ReassignMasterWizardStep2Controller.create({
    content: Em.Object.create({
      reassign: Em.Object.create({}),
      services: []
    }),
    renderComponents: Em.K,
    multipleComponents: []
  });

  describe('#customClientSideValidation', function () {
    var hostComponents = [];

    beforeEach(function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return hostComponents;
      });
    });
    afterEach(function () {
      App.HostComponent.find.restore();
    });
    it('No host-components, reassigned equal 0', function () {
      expect(controller.customClientSideValidation()).to.be.false;
    });
    it('Reassign component match existed components, reassigned equal 0', function () {
      controller.set('content.reassign.component_name', 'COMP1');
      hostComponents = [Em.Object.create({
        componentName: 'COMP1',
        hostName: 'host1'
      })];
      controller.set('servicesMasters', [{
        component_name: 'COMP1',
        selectedHost: 'host1'
      }]);

      expect(controller.customClientSideValidation()).to.be.false;
    });
    it('Reassign component do not match existed components, reassigned equal 1', function () {
      controller.set('content.reassign.component_name', 'COMP1');
      hostComponents = [Em.Object.create({
        componentName: 'COMP1',
        hostName: 'host1'
      })];
      controller.set('servicesMasters', []);

      expect(controller.customClientSideValidation()).to.be.true;
    });
    it('Reassign component do not match existed components, reassigned equal 2', function () {
      controller.set('content.reassign.component_name', 'COMP1');
      hostComponents = [
        Em.Object.create({
          componentName: 'COMP1',
          hostName: 'host1'
        }),
        Em.Object.create({
          componentName: 'COMP1',
          hostName: 'host2'
        })
      ];
      controller.set('servicesMasters', []);

      expect(controller.customClientSideValidation()).to.be.false;
    });

    it('submitDisabled is already true', function () {
      expect(controller.customClientSideValidation()).to.be.false;
    });
  });

  describe("#mastersToShow", function() {
    it("should be like array with `content.reassign.component_name`", function() {
      controller.set('content.reassign.component_name', 'C1');
      controller.propertyDidChange('mastersToShow');
      expect(controller.get('mastersToShow')).to.eql(['C1']);
    });
  });

  describe("#mastersToMove", function() {
    it("should be like array with `content.reassign.component_name`", function() {
      controller.set('content.reassign.component_name', 'C1');
      controller.propertyDidChange('mastersToMove');
      expect(controller.get('mastersToMove')).to.eql(['C1']);
    });
  });

  describe("#additionalHostsList", function () {
    beforeEach(function () {
      sinon.stub(App.HostComponent, 'find').returns([Em.Object.create({
        componentName: 'C1',
        hostName: 'host1'
      })]);
    });
    afterEach(function () {
      App.HostComponent.find.restore();
    });
    it("servicesMastersToShow empty", function () {
      controller.reopen({
        servicesMastersToShow: []
      });
      controller.set('content.reassign.component_name', 'C1');
      controller.propertyDidChange('additionalHostsList');
      expect(controller.get('additionalHostsList')).to.be.empty;
    });
    it("servicesMastersToShow has one master", function () {
      controller.reopen({
        servicesMastersToShow: [{}]
      });
      controller.set('content.reassign.component_name', 'C1');
      controller.propertyDidChange('additionalHostsList');
      expect(controller.get('additionalHostsList')).to.eql([{
        label: Em.I18n.t('services.reassign.step2.currentHost'),
        host: 'host1'
      }]);
    });
  });
});

});

require.register("test/controllers/main/service/reassign/step3_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/service/reassign/step3_controller');
require('controllers/main/service/reassign_controller');
var testHelpers = require('test/helpers');
var controller;

describe('App.ReassignMasterWizardStep3Controller', function () {

  beforeEach(function(){
    controller = App.ReassignMasterWizardStep3Controller.create();
  });

  describe("#submit()", function() {
    var mock = {
      getKDCSessionState: function (callback) {
        callback();
      }
    };
    beforeEach(function () {
      sinon.stub(App, 'get').returns(mock);
      sinon.spy(mock, 'getKDCSessionState');
      sinon.stub(App.router, 'send', Em.K);
      controller.submit();
    });
    afterEach(function () {
      App.get.restore();
      mock.getKDCSessionState.restore();
      App.router.send.restore();
    });
    it('getKDCSessionState is called once', function () {
      expect(mock.getKDCSessionState.calledOnce).to.be.true;
    });
    it('User is moved to the next step', function () {
      expect(App.router.send.calledWith("next")).to.be.true;
    });
  });

  describe('#setAdditionalConfigs()', function () {

    beforeEach(function () {
      sinon.stub(App, 'get').withArgs('isHaEnabled').returns(true);
    });

    afterEach(function () {
      App.get.restore();
    });

    it('Component is absent', function () {
      controller.set('additionalConfigsMap', []);
      var configs = {};

      expect(controller.setAdditionalConfigs(configs, 'COMP1', '')).to.be.false;
      expect(configs).to.eql({});
    });

    it('configs for Hadoop 2 is present', function () {
      controller.set('additionalConfigsMap', [
        {
          componentName: 'COMP1',
          configs: {
            'test-site': {
              'property1': '<replace-value>:1111'
            }
          },
          configs_Hadoop2: {
            'test-site': {
              'property2': '<replace-value>:2222'
            }
          }
        }
      ]);
      var configs = {
        'test-site': {}
      };

      expect(controller.setAdditionalConfigs(configs, 'COMP1', 'host1')).to.be.true;
      expect(configs).to.eql({
        'test-site': {
          'property2': 'host1:2222'
        }
      });
    });

    it('ignore some configs for NameNode after HA', function () {
      controller.set('additionalConfigsMap', [
        {
          componentName: 'NAMENODE',
          configs: {
            'test-site': {
              'fs.defaultFS': '<replace-value>:1111',
              'dfs.namenode.rpc-address': '<replace-value>:1111'
            }
          }
        }
      ]);
      var configs = {'test-site': {}};

      expect(controller.setAdditionalConfigs(configs, 'NAMENODE', 'host1')).to.be.true;
      expect(configs).to.eql({'test-site': {}});
    });
  });

  describe('#getConfigUrlParams()', function () {
    var testCases = [
      {
        componentName: 'NAMENODE',
        result: [
          "(type=hdfs-site&tag=1)",
          "(type=core-site&tag=2)"
        ]
      },
      {
        componentName: 'SECONDARY_NAMENODE',
        result: [
          "(type=hdfs-site&tag=1)",
          "(type=core-site&tag=2)"
        ]
      },
      {
        componentName: 'JOBTRACKER',
        result: [
          "(type=mapred-site&tag=4)"
        ]
      },
      {
        componentName: 'RESOURCEMANAGER',
        result: [
          "(type=yarn-site&tag=5)"
        ]
      },
      {
        componentName: 'APP_TIMELINE_SERVER',
        result: [
          "(type=yarn-site&tag=5)",
          "(type=yarn-env&tag=8)"
        ]
      },
      {
        componentName: 'OOZIE_SERVER',
        result: [
          "(type=oozie-site&tag=6)",
          "(type=core-site&tag=2)",
          "(type=oozie-env&tag=2)"
        ]
      },
      {
        componentName: 'WEBHCAT_SERVER',
        result: [
          "(type=hive-env&tag=11)",
          "(type=webhcat-site&tag=7)",
          "(type=core-site&tag=2)"
        ]
      },
      {
        componentName: 'HIVE_SERVER',
        result: [
          '(type=hive-site&tag=10)',
          '(type=webhcat-site&tag=7)',
          '(type=hive-env&tag=11)',
          '(type=core-site&tag=2)'
        ]
      },
      {
        componentName: 'HIVE_METASTORE',
        result: [
          '(type=hive-site&tag=10)',
          '(type=webhcat-site&tag=7)',
          '(type=hive-env&tag=11)',
          '(type=core-site&tag=2)'
        ]
      },
      {
        componentName: 'MYSQL_SERVER',
        result: [
          '(type=hive-site&tag=10)'
        ]
      },
      {
        componentName: 'HISTORYSERVER',
        result: [
          '(type=mapred-site&tag=4)'
        ]
      }
    ];

    var data = {
      Clusters: {
        desired_configs: {
          'hdfs-site': {tag: 1},
          'core-site': {tag: 2},
          'hbase-site': {tag: 3},
          'mapred-site': {tag: 4},
          'yarn-site': {tag: 5},
          'oozie-site': {tag: 6},
          'oozie-env': {tag: 2},
          'webhcat-site': {tag: 7},
          'yarn-env': {tag: 8},
          'accumulo-site': {tag: 9},
          'hive-site': {tag: 10},
          'hive-env': {tag: 11}
        }
      }
    };

    var services = [];

    beforeEach(function () {
      controller.set('wizardController', App.get('router.reassignMasterController'));
      sinon.stub(App.Service, 'find', function () {
        return services;
      });
    });
    afterEach(function () {
      App.Service.find.restore();
    });

    testCases.forEach(function (test) {
      it('get config of ' + test.componentName, function () {
        expect(controller.getConfigUrlParams(test.componentName, data)).to.eql(test.result);
      });
    });
    it('get config of NAMENODE when HBASE installed', function () {
      services = [
        {
          serviceName: 'HBASE'
        }
      ];
      expect(controller.getConfigUrlParams('NAMENODE', data)).to.eql([
        "(type=hdfs-site&tag=1)",
        "(type=core-site&tag=2)",
        "(type=hbase-site&tag=3)"
      ]);
    });

    it('get config of NAMENODE when ACCUMULO installed', function () {
      services = [
        {
          serviceName: 'ACCUMULO'
        }
      ];
      expect(controller.getConfigUrlParams('NAMENODE', data)).to.eql([
        "(type=hdfs-site&tag=1)",
        "(type=core-site&tag=2)",
        "(type=accumulo-site&tag=9)"
      ]);
    });

  });

  describe('#onLoadConfigsTags()', function () {
    var dummyData = {
      Clusters: {
        desired_configs : {}
      }
    };

    beforeEach(function () {
      sinon.stub(controller, 'getConfigUrlParams', function () {
        return [];
      });
      controller.set('content', {
        reassign: {
          component_name: 'COMP1'
        }
      });
      controller.onLoadConfigsTags(dummyData);
      this.args = testHelpers.findAjaxRequest('name', 'reassign.load_configs');
    });

    afterEach(function () {
      controller.getConfigUrlParams.restore();
    });

    it('request is sent', function () {
      expect(this.args).exists;
    });

    it('getConfigUrlParams is called with correct data', function () {
      expect(controller.getConfigUrlParams.calledWith('COMP1', dummyData)).to.be.true;
    });
  });

  describe('#setSecureConfigs()', function () {

    beforeEach(function () {
      this.stub = sinon.stub(App, 'get');
    });

    afterEach(function () {
      Em.tryInvoke(App.get, 'restore');
    });

    it('undefined component and security disabled', function () {
      var secureConfigs = [];
      this.stub.withArgs('isKerberosEnabled').returns(false);
      controller.set('secureConfigsMap', []);
      expect(controller.setSecureConfigs(secureConfigs, {}, 'COMP1')).to.be.false;
      expect(secureConfigs).to.eql([]);
    });

    it('component exist and security disabled', function () {
      var secureConfigs = [];
      this.stub.withArgs('isKerberosEnabled').returns(false);
      controller.set('secureConfigsMap', [{
        componentName: 'COMP1'
      }]);
      expect(controller.setSecureConfigs(secureConfigs, {}, 'COMP1')).to.be.false;
      expect(secureConfigs).to.eql([]);
    });

    it('undefined component and security enabled', function () {
      var secureConfigs = [];
      this.stub.withArgs('isKerberosEnabled').returns(true);
      controller.set('secureConfigsMap', []);
      expect(controller.setSecureConfigs(secureConfigs, {}, 'COMP1')).to.be.false;
      expect(secureConfigs).to.eql([]);
    });
    it('component exist and security enabled', function () {
      var secureConfigs = [];
      this.stub.withArgs('isKerberosEnabled').returns(true);
      var configs = {'s1': {
        'k1': 'kValue',
        'p1': 'pValue'
      }};
      controller.set('secureConfigsMap', [{
        componentName: 'COMP1',
        configs: [{
          site: 's1',
          keytab: 'k1',
          principal: 'p1'
        }]
      }]);
      expect(controller.setSecureConfigs(secureConfigs, configs, 'COMP1')).to.be.true;
      expect(secureConfigs).to.eql([
        {
          "keytab": "kValue",
          "principal": "pValue"
        }
      ]);
    });
  });

  describe('#setDynamicCinfigs()', function () {

    describe('HIVE', function() {
      beforeEach(function () {
        controller.set('content', Em.Object.create({
          masterComponentHosts: [
            {
              component: 'HIVE_METASTORE',
              hostName: 'host1'
            },
            {
              component: 'HIVE_METASTORE',
              hostName: 'host3'
            },
            {
              component: 'HIVE_SERVER',
              hostName: 'host4'
            }
          ],
          reassignHosts: {
            source: 'host1',
            target: 'host2'
          }
        }));
      });
      it("reassign component is HIVE_METASTORE", function() {
        var configs = {
          'hive-env': {
            'hive_user': 'hive_user'
          },
          'hive-site': {
            'hive.metastore.uris': ''
          },
          'webhcat-site': {
            'templeton.hive.properties': 'thrift'
          },
          'core-site': {
            'hadoop.proxyuser.hive_user.hosts': ''
          }
        };
        App.MoveHmConfigInitializer.setup(controller._getHiveInitializerSettings(configs));
        configs = controller.setDynamicConfigs(configs, App.MoveHmConfigInitializer);
        expect(configs['hive-site']['hive.metastore.uris']).to.equal('thrift://host3:9083,thrift://host2:9083');
        expect(configs['webhcat-site']['templeton.hive.properties']).to.equal('thrift');
        expect(configs['core-site']['hadoop.proxyuser.hive_user.hosts']).to.equal('host2,host3,host4');
      });

      it("reassign component is HIVE_SERVER", function() {
        controller.get('content.masterComponentHosts').pushObject({component: 'HIVE_SERVER', hostName: 'host1'});
        var configs = {
          'hive-env': {
            'hive_user': 'hive_user'
          },
          'hive-site': {
            'hive.metastore.uris': ''
          },
          'webhcat-site': {
            'templeton.hive.properties': 'thrift'
          },
          'core-site': {
            'hadoop.proxyuser.hive_user.hosts': ''
          }
        };
        App.MoveHsConfigInitializer.setup(controller._getHiveInitializerSettings(configs));
        configs = controller.setDynamicConfigs(configs, App.MoveHsConfigInitializer);
        expect(configs['core-site']['hadoop.proxyuser.hive_user.hosts']).to.equal('host1,host2,host3,host4');
      });

      it("reassign component is WEBHCAT_SERVER", function() {
        controller.get('content.masterComponentHosts').pushObject({component: 'WEBHCAT_SERVER', hostName: 'host1'});
        var configs = {
          'hive-env': {
            'webhcat_user': 'webhcat_user'
          },
          'hive-site': {
            'hive.metastore.uris': ''
          },
          'webhcat-site': {
            'templeton.hive.properties': 'thrift'
          },
          'core-site': {
            'hadoop.proxyuser.webhcat_user.hosts': ''
          }
        };
        App.MoveWsConfigInitializer.setup(controller._getWsInitializerSettings(configs));
        configs = controller.setDynamicConfigs(configs, App.MoveWsConfigInitializer);
        expect(configs['core-site']['hadoop.proxyuser.webhcat_user.hosts']).to.equal('host2');
      });
    });

    describe('RESOURCEMANAGER', function () {
      beforeEach(function () {
        sinon.stub(App, 'get').withArgs('isRMHaEnabled').returns(true);
      });
      afterEach(function () {
        App.get.restore();
        App.MoveRmConfigInitializer.cleanup();
      });

      it('HA enabled and resource manager 1', function () {
        controller.set('content', Em.Object.create({
          reassignHosts: {
            source: 'host1',
            target: 'host3'
          }
        }));
        var configs = {
          'yarn-site': {
            'yarn.resourcemanager.hostname.rm1': 'host1',
            'yarn.resourcemanager.webapp.address.rm1': 'host1:8088',
            'yarn.resourcemanager.webapp.https.address.rm1': 'host1:8443',
            'yarn.resourcemanager.hostname.rm2': 'host2',
            'yarn.resourcemanager.webapp.address.rm2': 'host2:8088',
            'yarn.resourcemanager.webapp.https.address.rm2': 'host2:8443'
          }
        };
        var additionalDependencies = controller._getRmAdditionalDependencies(configs);
        App.MoveRmConfigInitializer.setup(controller._getRmInitializerSettings(configs));
        configs = controller.setDynamicConfigs(configs, App.MoveRmConfigInitializer, additionalDependencies);
        expect(configs['yarn-site']).to.eql({
          'yarn.resourcemanager.hostname.rm1': 'host3',
          'yarn.resourcemanager.webapp.address.rm1': 'host3:8088',
          'yarn.resourcemanager.webapp.https.address.rm1': 'host3:8443',
          'yarn.resourcemanager.hostname.rm2': 'host2',
          'yarn.resourcemanager.webapp.address.rm2': 'host2:8088',
          'yarn.resourcemanager.webapp.https.address.rm2': 'host2:8443'
        });
      });

      it('HA enabled and resource manager 2', function () {
        controller.set('content', Em.Object.create({
          reassignHosts: {
            source: 'host2',
            target: 'host3'
          }
        }));
        var configs = {
          'yarn-site': {
            'yarn.resourcemanager.hostname.rm1': 'host1',
            'yarn.resourcemanager.webapp.address.rm1': 'host1:8088',
            'yarn.resourcemanager.webapp.https.address.rm1': 'host1:8443',
            'yarn.resourcemanager.hostname.rm2': 'host2',
            'yarn.resourcemanager.webapp.address.rm2': 'host2:8088',
            'yarn.resourcemanager.webapp.https.address.rm2': 'host2:8443'
          }
        };
        var additionalDependencies = controller._getRmAdditionalDependencies(configs);
        App.MoveRmConfigInitializer.setup(controller._getRmInitializerSettings(configs));
        configs = controller.setDynamicConfigs(configs, App.MoveRmConfigInitializer, additionalDependencies);

        expect(configs['yarn-site']).to.eql({
          'yarn.resourcemanager.hostname.rm1': 'host1',
          'yarn.resourcemanager.webapp.address.rm1': 'host1:8088',
          'yarn.resourcemanager.webapp.https.address.rm1': 'host1:8443',
          'yarn.resourcemanager.hostname.rm2': 'host3',
          'yarn.resourcemanager.webapp.address.rm2': 'host3:8088',
          'yarn.resourcemanager.webapp.https.address.rm2': 'host3:8443'
        });
      });
    });

    describe('NAMENODE', function () {
      var isHaEnabled = false;

      beforeEach(function () {
        sinon.stub(App, 'get', function () {
          return isHaEnabled;
        });
        sinon.stub(App.Service, 'find', function () {
          return [
            {serviceName: 'HDFS'},
            {serviceName: 'ACCUMULO'},
            {serviceName: 'HBASE'},
            {serviceName: 'HAWQ'}
          ];
        });
        controller.set('content', Em.Object.create({
          reassignHosts: {
            source: 'host1'
          }
        }));
      });

      afterEach(function () {
        App.get.restore();
        App.Service.find.restore();
        App.MoveNameNodeConfigInitializer.cleanup();
      });

      it('HA isn\'t enabled and HBASE, HAWQ and ACCUMULO service', function () {
        isHaEnabled = false;
        var configs = {
          'hbase-site': {
            'hbase.rootdir': 'hdfs://localhost:8020/apps/hbase/data'
          },
          'accumulo-site': {
            'instance.volumes': 'hdfs://localhost:8020/apps/accumulo/data',
            'instance.volumes.replacements': ''
          },
          'hawq-site': {
            'hawq_dfs_url': 'localhost:8020/hawq/data'
          }
        };

        controller.set('content.reassignHosts.target', 'host2');

        App.MoveNameNodeConfigInitializer.setup(controller._getNnInitializerSettings(configs));
        configs = controller.setDynamicConfigs(configs, App.MoveNameNodeConfigInitializer);

        expect(configs['hbase-site']['hbase.rootdir']).to.equal('hdfs://host2:8020/apps/hbase/data');
        expect(configs['accumulo-site']['instance.volumes']).to.equal('hdfs://host2:8020/apps/accumulo/data');
        expect(configs['accumulo-site']['instance.volumes.replacements']).to.equal('hdfs://host1:8020/apps/accumulo/data hdfs://host2:8020/apps/accumulo/data');
        expect(configs['hawq-site'].hawq_dfs_url).to.equal('host2:8020/hawq/data');
      });

      it('HA enabled and namenode 1', function () {
        isHaEnabled = true;
        var configs = {
          'hdfs-site': {
            'dfs.nameservices': 's',
            'dfs.namenode.http-address.s.nn1': 'host1:50070',
            'dfs.namenode.https-address.s.nn1': 'host1:50470',
            'dfs.namenode.rpc-address.s.nn1': 'host1:8020'
          },
          'hdfs-client': {
            'dfs.namenode.rpc-address.s.nn1': '',
            'dfs.namenode.http-address.s.nn1': 'host1:50070'
          }
        };

        controller.set('content.reassignHosts.target', 'host2');
        App.MoveNameNodeConfigInitializer.setup(controller._getNnInitializerSettings(configs));
        configs = controller.setDynamicConfigs(configs, App.MoveNameNodeConfigInitializer);
        expect(configs['hdfs-site']).to.eql({
          "dfs.nameservices": "s",
          "dfs.namenode.http-address.s.nn1": "host2:50070",
          "dfs.namenode.https-address.s.nn1": "host2:50470",
          "dfs.namenode.rpc-address.s.nn1": "host2:8020"
        });
        expect(configs['hdfs-client']).to.eql({
          "dfs.namenode.http-address.s.nn1": "host2:50070",
          "dfs.namenode.rpc-address.s.nn1": "host2:8020"
        });
      });

      it('HA enabled and namenode 2', function () {
        isHaEnabled = true;
        var configs = {
          'hdfs-site': {
            'dfs.nameservices': 's',
            "dfs.namenode.http-address.s.nn1": "host1:50070",
            'dfs.namenode.http-address.s.nn2': 'host2:50070',
            'dfs.namenode.https-address.s.nn2': 'host2:50470',
            'dfs.namenode.rpc-address.s.nn2': 'host2:8020'
          },
          'hdfs-client': {
            'dfs.namenode.rpc-address.s.nn2': '',
            'dfs.namenode.http-address.s.nn2': 'host2:50070'
          }
        };
        controller.set('content.reassignHosts.source', 'host2');
        controller.set('content.reassignHosts.target', 'host3');

        App.MoveNameNodeConfigInitializer.setup(controller._getNnInitializerSettings(configs));
        configs = controller.setDynamicConfigs(configs, App.MoveNameNodeConfigInitializer);

        expect(configs['hdfs-site']).to.eql({
          "dfs.nameservices": "s",
          "dfs.namenode.http-address.s.nn1": "host1:50070",
          "dfs.namenode.http-address.s.nn2": "host3:50070",
          "dfs.namenode.https-address.s.nn2": "host3:50470",
          "dfs.namenode.rpc-address.s.nn2": "host3:8020"
        });
        expect(configs['hdfs-client']).to.eql({
          "dfs.namenode.http-address.s.nn2": "host3:50070",
          "dfs.namenode.rpc-address.s.nn2": "host3:8020"
        });
      });

    });

    describe('OOZIE_SERVER', function () {

      it('should upodate hadoop.proxyuser.${oozie_user}.hosts', function () {

        var configs = {
          'oozie-env': {
            'oozie_user': 'cool_dude'
          },
          'core-site': {
            'hadoop.proxyuser.cool_dude.hosts': ''
          }
        };

        controller.set('content', Em.Object.create({
          masterComponentHosts: [
            {
              component: 'OOZIE_SERVER',
              hostName: 'host2'
            },
            {
              component: 'OOZIE_SERVER',
              hostName: 'host3'
            },
            {
              component: 'OOZIE_SERVER',
              hostName: 'host1'
            }
          ],
          reassignHosts: {
            source: 'host1',
            target: 'host4'
          }
        }));

        App.MoveOSConfigInitializer.setup(controller._getOsInitializerSettings(configs));
        configs = controller.setDynamicConfigs(configs, App.MoveOSConfigInitializer);
        App.MoveOSConfigInitializer.cleanup();

        expect(configs['core-site']['hadoop.proxyuser.cool_dude.hosts']).to.equal('host2,host3,host4');

      });

    });

  });
});

});

require.register("test/controllers/main/service/reassign/step4_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('controllers/main/service/reassign/step4_controller');
require('controllers/main/service/reassign_controller');
var testHelpers = require('test/helpers');

describe('App.ReassignMasterWizardStep4Controller', function () {

  var controller = App.ReassignMasterWizardStep4Controller.create({
    content: Em.Object.create({
      reassign: Em.Object.create(),
      reassignHosts: Em.Object.create()
    })
  });

  describe('#getHostComponentsNames()', function () {
    it('No host-components', function () {
      controller.set('hostComponents', []);
      expect(controller.getHostComponentsNames()).to.be.empty;
    });
    it('one host-components', function () {
      controller.set('hostComponents', ['COMP1']);
      expect(controller.getHostComponentsNames()).to.equal('Comp1');
    });
    it('ZKFC host-components', function () {
      controller.set('hostComponents', ['COMP1', 'ZKFC']);
      expect(controller.getHostComponentsNames()).to.equal('Comp1+ZKFC');
    });
  });

  describe('#testDBConnection', function() {
    beforeEach(function() {
      controller.set('requiredProperties', Em.A([]));
      controller.set('content.configs', Em.Object.create({
        'hive-site': {
          'javax.jdo.option.ConnectionDriverName': 'mysql'
        }
      }));
      controller.set('content.reassign.component_name', 'HIVE_SERVER');
      sinon.stub(controller, 'getConnectionProperty', Em.K);
      sinon.stub(App.router, 'get', Em.K);
    });

    afterEach(function() {
      controller.getConnectionProperty.restore();
      App.router.get.restore();
    });

    describe('tests database connection', function() {

      beforeEach(function () {
        sinon.stub(controller, 'prepareDBCheckAction', Em.K);
      });

      afterEach(function () {
        controller.prepareDBCheckAction.restore();
      });

      it('prepareDBCheckAction is called once', function() {
        controller.testDBConnection();
        expect(controller.prepareDBCheckAction.calledOnce).to.be.true;
      });

    });

    it('tests prepareDBCheckAction', function() {
      controller.prepareDBCheckAction();
      var args = testHelpers.findAjaxRequest('name', 'cluster.custom_action.create');
      expect(args).exists;
    });

  });

  describe('#removeUnneededTasks()', function () {
    var isHaEnabled = false;
    var commands;
    var commandsForDB;

    beforeEach(function () {
      sinon.stub(App, 'get', function () {
        return isHaEnabled;
      });

      commands = [
        { id: 1, command: 'stopRequiredServices' },
        { id: 2, command: 'cleanMySqlServer' },
        { id: 3, command: 'createHostComponents' },
        { id: 4, command: 'putHostComponentsInMaintenanceMode' },
        { id: 5, command: 'reconfigure' },
        { id: 6, command: 'installHostComponents' },
        { id: 7, command: 'startZooKeeperServers' },
        { id: 8, command: 'startNameNode' },
        { id: 9, command: 'deleteHostComponents' },
        { id: 10, command: 'configureMySqlServer' },
        { id: 11, command: 'startMySqlServer' },
        { id: 12, command: 'startNewMySqlServer' },
        { id: 13, command: 'startRequiredServices' }
      ];

      commandsForDB = [
        { id: 1, command: 'createHostComponents' },
        { id: 2, command: 'installHostComponents' },
        { id: 3, command: 'configureMySqlServer' },
        { id: 4, command: 'restartMySqlServer' },
        { id: 5, command: 'testDBConnection' },
        { id: 6, command: 'stopRequiredServices' },
        { id: 7, command: 'cleanMySqlServer' },
        { id: 8, command: 'putHostComponentsInMaintenanceMode' },
        { id: 9, command: 'reconfigure' },
        { id: 10, command: 'deleteHostComponents' },
        { id: 11, command: 'configureMySqlServer' },
        { id: 12, command: 'startRequiredServices' }
      ];
    });

    afterEach(function () {
      App.get.restore();
    });

    it('hasManualSteps is false', function () {
      controller.set('tasks', commands);
      controller.set('content.hasManualSteps', false);

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 3, 4, 6, 9, 12, 13]);
    });

    it('reassign component is not NameNode and HA disabled', function () {
      controller.set('tasks', commands);
      controller.set('content.hasManualSteps', true);
      controller.set('content.reassign.component_name', 'COMP1');
      isHaEnabled = false;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 3, 4, 6]);
    });

    it('reassign component is not NameNode and HA enabled', function () {
      controller.set('tasks', commands);
      controller.set('content.hasManualSteps', true);
      controller.set('content.reassign.component_name', 'COMP1');
      isHaEnabled = true;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 3, 4, 6]);
    });

    it('reassign component is NameNode and HA disabled', function () {
      controller.set('tasks', commands);
      controller.set('content.hasManualSteps', true);
      controller.set('content.reassign.component_name', 'NAMENODE');
      isHaEnabled = false;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 3, 4, 6]);
    });

    it('reassign component is NameNode and HA enabled', function () {
      controller.set('tasks', commands);
      controller.set('content.hasManualSteps', true);
      controller.set('content.reassign.component_name', 'NAMENODE');
      isHaEnabled = true;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 3, 4, 6, 7, 8]);
    });

    it('component with reconfiguration', function () {
      controller.set('tasks', commands);
      controller.set('content.hasManualSteps', false);
      controller.set('content.reassign.component_name', 'COMP1');
      controller.set('wizardController', {
        isComponentWithReconfiguration: true
      });

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 3, 4, 5, 6, 9, 13]);
    });

    it('reassign component is HiveServer and db type is mysql', function () {
      controller.set('tasks', commandsForDB);
      controller.set('content.hasManualSteps', false);
      controller.set('content.databaseType', 'mysql');
      controller.set('content.reassign.component_name', 'HIVE_SERVER');
      isHaEnabled = false;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);
    });

    it('reassign component is HiveServer and db type is not mysql', function () {
      controller.set('tasks', commandsForDB);
      controller.set('content.hasManualSteps', false);
      controller.set('content.databaseType', 'derby');
      controller.set('content.reassign.component_name', 'HIVE_SERVER');
      isHaEnabled = false;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 2, 6, 8, 9, 10, 12]);
    });

    it('reassign component is Oozie Server and db type is derby', function () {
      controller.set('tasks', commandsForDB);
      controller.set('content.hasManualSteps', true);
      controller.set('content.databaseType', 'derby');
      controller.set('content.reassign.component_name', 'OOZIE_SERVER');
      isHaEnabled = false;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1,2,6,8,9]);
    });

    it('reassign component is Oozie Server and db type is mysql', function () {
      controller.set('content.hasManualSteps', false);
      controller.set('content.databaseType', 'mysql');
      controller.set('content.reassign.component_name', 'OOZIE_SERVER');
      isHaEnabled = false;

      controller.set('tasks', commandsForDB);
      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1,2,3,4,5,6,7,8,9,10,11,12]);
    });

    it('reassign component is Mysql Server', function () {
      controller.set('content.hasManualSteps', false);
      controller.set('content.databaseType', 'mysql');
      controller.set('content.reassign.component_name', 'MYSQL_SERVER');
      isHaEnabled = false;

      controller.set('tasks', commandsForDB);
      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1,2,3,4,5,6,8,9,10,11,12]);
    });
  });

  describe("#stopRequiredServices()", function() {
    before(function () {
      controller.set('wizardController', App.get('router.reassignMasterController'));
      sinon.stub(controller, 'stopServices', Em.K);
    });
    after(function () {
      controller.stopServices.restore();
    });
    it('stopServices is called with valid list of services', function() {
      controller.set('content.reassign.component_name', 'JOBTRACKER');
      controller.stopRequiredServices();
      expect(controller.stopServices.calledWith(['PIG', 'OOZIE'], true)).to.be.true;
    });
  });

  describe('#initializeTasks()', function () {
    beforeEach(function () {
      controller.set('tasks', []);
      sinon.stub(controller, 'getHostComponentsNames', Em.K);
      sinon.stub(controller, 'removeUnneededTasks', Em.K);
      this.mock = sinon.stub(controller, 'isComponentWithDB');
    });
    afterEach(function () {
      controller.removeUnneededTasks.restore();
      controller.getHostComponentsNames.restore();
      this.mock.restore();
    });
    it('No commands (isComponentWithDB = false)', function () {
      controller.set('commands', []);
      controller.set('commandsForDB', []);
      this.mock.returns(false);
      controller.initializeTasks();

      expect(controller.get('tasks')).to.be.empty;
    });

    it('No commands (isComponentWithDB = true)', function () {
      controller.set('commands', []);
      controller.set('commandsForDB', []);
      this.mock.returns(true);
      controller.initializeTasks();

      expect(controller.get('tasks')).to.be.empty;
    });

    it('One command', function () {
      controller.set('commands', ['COMMAND1']);
      controller.set('commandsForDB', ['COMMAND1']);
      controller.initializeTasks();

      expect(controller.get('tasks')[0].get('id')).to.equal(0);
      expect(controller.get('tasks')[0].get('command')).to.equal('COMMAND1');
    });
  });

  describe('#hideRollbackButton()', function () {

    it('No showRollback command', function () {
      controller.set('tasks', [Em.Object.create({
        showRollback: false
      })]);
      controller.hideRollbackButton();
      expect(controller.get('tasks')[0].get('showRollback')).to.be.false;
    });
    it('showRollback command is present', function () {
      controller.set('tasks', [Em.Object.create({
        showRollback: true
      })]);
      controller.hideRollbackButton();
      expect(controller.get('tasks')[0].get('showRollback')).to.be.false;
    });
  });

  describe('#onComponentsTasksSuccess()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'onTaskCompleted', Em.K);
    });
    afterEach(function () {
      controller.onTaskCompleted.restore();
    });

    it('One host-component', function () {
      controller.set('multiTaskCounter', 1);
      controller.set('hostComponents', [
        {}
      ]);
      controller.onComponentsTasksSuccess();
      expect(controller.get('multiTaskCounter')).to.equal(0);
      expect(controller.onTaskCompleted.calledOnce).to.be.true;
    });
    it('two host-components', function () {
      controller.set('multiTaskCounter', 2);
      controller.set('hostComponents', [
        {},
        {}
      ]);
      controller.onComponentsTasksSuccess();
      expect(controller.get('multiTaskCounter')).to.equal(1);
      expect(controller.onTaskCompleted.called).to.be.false;
    });
  });

  describe('#stopServices()', function () {
    it('request is sent', function () {
      controller.stopServices();
      var args = testHelpers.findAjaxRequest('name', 'common.services.update');
      expect(args).exists;
    });
  });

  describe('#createHostComponents()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'createComponent', Em.K);
    });
    afterEach(function () {
      controller.createComponent.restore();
      controller.set('dependentHostComponents', []);
    });

    it('createComponent should be called for each host-component', function () {
      controller.set('hostComponents', ['COMP1']);
      controller.set('dependentHostComponents', ['COMP2']);
      controller.set('content.reassignHosts.target', 'host1');
      controller.set('content.reassign.service_id', 'SERVICE1');

      controller.createHostComponents();

      expect(controller.get('multiTaskCounter')).to.equal(2);
      expect(controller.createComponent.getCall(0).args).to.be.eql([
        'COMP1', 'host1', 'SERVICE1'
      ]);
      expect(controller.createComponent.getCall(1).args).to.be.eql([
        'COMP2', 'host1', 'SERVICE1'
      ]);
    });
  });

  describe('#onCreateComponent()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'onComponentsTasksSuccess', Em.K);
    });

    afterEach(function () {
      controller.onComponentsTasksSuccess.restore();
    });

    it('onComponentsTasksSuccess is called once', function () {
      controller.onCreateComponent();
      expect(controller.onComponentsTasksSuccess.calledOnce).to.be.true;
    });
  });

  describe('#putHostComponentsInMaintenanceMode()', function () {
    beforeEach(function(){
      sinon.stub(controller, 'onComponentsTasksSuccess', Em.K);
      controller.set('content.reassignHosts.source', 'source');
    });
    afterEach(function(){
      controller.onComponentsTasksSuccess.restore();
    });
    it('No host-components', function () {
      controller.set('hostComponents', []);
      controller.putHostComponentsInMaintenanceMode();
      var args = testHelpers.findAjaxRequest('name', 'common.host.host_component.passive');
      expect(args).not.exists;
      expect(controller.get('multiTaskCounter')).to.equal(0);
    });
    it('One host-components', function () {
      controller.set('hostComponents', [{}]);
      controller.putHostComponentsInMaintenanceMode();
      var args = testHelpers.findAjaxRequest('name', 'common.host.host_component.passive');
      expect(args).exists;
      expect(controller.get('multiTaskCounter')).to.equal(1);
    });
  });

  describe('#installHostComponents()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'updateComponent', Em.K);
    });
    afterEach(function () {
      controller.updateComponent.restore();
      controller.set('dependentHostComponents', []);
    });

    it('No host-components', function () {
      controller.set('hostComponents', []);

      controller.installHostComponents();

      expect(controller.get('multiTaskCounter')).to.equal(0);
      expect(controller.updateComponent.called).to.be.false;
    });
    it('createComponent should be called for each host-component', function () {
      controller.set('hostComponents', ['COMP1']);
      controller.set('dependentHostComponents', ['COMP2']);
      controller.set('content.reassignHosts.target', 'host1');
      controller.set('content.reassign.service_id', 'SERVICE1');

      controller.installHostComponents();

      expect(controller.get('multiTaskCounter')).to.equal(2);
      expect(controller.updateComponent.getCall(0).args).to.be.eql([
        'COMP1', 'host1', 'SERVICE1', 'Install', 2
      ]);
      expect(controller.updateComponent.getCall(1).args).to.be.eql([
        'COMP2', 'host1', 'SERVICE1', 'Install', 2
      ]);
    });
  });

  describe('#reconfigure()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'saveClusterStatus', Em.K);
      sinon.stub(controller, 'saveConfigsToServer', Em.K);
    });

    afterEach(function () {
      controller.saveClusterStatus.restore();
      controller.saveConfigsToServer.restore();
    });

    it('saveClusterStatus is called once', function () {
      controller.reconfigure();
      expect(controller.saveClusterStatus.calledOnce).to.be.true;
    });

    it('saveConfigsToServer is called once', function () {
      controller.reconfigure();
      expect(controller.saveConfigsToServer.calledOnce).to.be.true;
    });
  });

  describe('#loadStep()', function () {
    beforeEach(function () {
      controller.set('content.reassign.service_id', 'service1');
      sinon.stub(controller, 'onTaskStatusChange', Em.K);
      sinon.stub(controller, 'initializeTasks', Em.K);
      sinon.stub(controller, 'setDependentHostComponents');
      this.mockGet = sinon.stub(App, 'get').returns(true);
    });
    afterEach(function () {
      controller.setDependentHostComponents.restore();
      controller.onTaskStatusChange.restore();
      controller.initializeTasks.restore();
      this.mockGet.restore();
    });

    it('reassign component is NameNode and HA enabled', function () {
      controller.set('content.reassign.component_name', 'NAMENODE');

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['NAMENODE', 'ZKFC']);
      expect(controller.get('serviceName')).to.eql(['service1']);
    });
    it('reassign component is NameNode and HA disabled', function () {
      this.mockGet.returns(false);
      controller.set('content.reassign.component_name', 'NAMENODE');

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['NAMENODE']);
      expect(controller.get('serviceName')).to.eql(['service1']);
    });
    it('reassign component is JOBTRACKER and HA enabled', function () {
      controller.set('content.reassign.component_name', 'JOBTRACKER');

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['JOBTRACKER']);
      expect(controller.get('serviceName')).to.eql(['service1']);
    });
    it('reassign component is RESOURCEMANAGER and HA enabled', function () {
      controller.set('content.reassign.component_name', 'RESOURCEMANAGER');

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['RESOURCEMANAGER']);
      expect(controller.get('serviceName')).to.eql(['service1']);
    });
    it('setDependentHostComponents should be called', function () {
      controller.set('content.reassign.component_name', 'RESOURCEMANAGER');

      controller.loadStep();
      expect(controller.setDependentHostComponents.calledOnce).to.be.true;
    });
  });

  describe('#saveConfigsToServer()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'getServiceConfigData', Em.K);
      controller.saveConfigsToServer([1]);
      this.args = testHelpers.findAjaxRequest('name', 'common.across.services.configurations');
    });
    afterEach(function () {
      controller.getServiceConfigData.restore();
    });
    it('getServiceConfigData is called with valid data', function () {
      expect(controller.getServiceConfigData.calledWith([1])).to.be.true;
    });
    it('request is sent', function () {
      expect(this.args).exists;
    });
  });

  describe('#getComponentDir()', function () {
    var configs = {
      'hdfs-site': {
        'dfs.name.dir': 'case1',
        'dfs.namenode.name.dir': 'case2',
        'dfs.namenode.checkpoint.dir': 'case3'
      },
      'core-site': {
        'fs.checkpoint.dir': 'case4'
      }
    };

    it('unknown component name', function () {
      expect(controller.getComponentDir(configs, 'COMP1')).to.be.empty;
    });
    it('NAMENODE component', function () {
      expect(controller.getComponentDir(configs, 'NAMENODE')).to.equal('case2');
    });
    it('SECONDARY_NAMENODE component', function () {
      expect(controller.getComponentDir(configs, 'SECONDARY_NAMENODE')).to.equal('case3');
    });
  });

  describe('#saveClusterStatus()', function () {
    var mock = {
      saveComponentDir: Em.K,
      saveSecureConfigs: Em.K
    };
    beforeEach(function () {
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
      sinon.stub(App.router, 'get', function() {
        return mock;
      });
      sinon.spy(mock, 'saveComponentDir');
      sinon.spy(mock, 'saveSecureConfigs');
    });
    afterEach(function () {
      App.clusterStatus.setClusterStatus.restore();
      App.router.get.restore();
      mock.saveSecureConfigs.restore();
      mock.saveComponentDir.restore();
    });

    it('componentDir undefined and secureConfigs is empty', function () {
      expect(controller.saveClusterStatus([], null)).to.be.false;
    });
    it('componentDir defined and secureConfigs is empty', function () {
      expect(controller.saveClusterStatus([], 'dir1')).to.be.true;
      expect(mock.saveComponentDir.calledWith('dir1')).to.be.true;
      expect(mock.saveSecureConfigs.calledWith([])).to.be.true;
    });
    it('componentDir undefined and secureConfigs has data', function () {
      expect(controller.saveClusterStatus([1], null)).to.be.true;
      expect(mock.saveComponentDir.calledWith(null)).to.be.true;
      expect(mock.saveSecureConfigs.calledWith([1])).to.be.true;
    });
    it('componentDir defined and secureConfigs has data', function () {
      expect(controller.saveClusterStatus([1], 'dir1')).to.be.true;
      expect(mock.saveComponentDir.calledWith('dir1')).to.be.true;
      expect(mock.saveSecureConfigs.calledWith([1])).to.be.true;
    });
  });

  describe('#onSaveConfigs()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'onTaskCompleted', Em.K);
    });
    afterEach(function () {
      controller.onTaskCompleted.restore();
    });

    it('onTaskCompleted called once', function () {
      controller.onSaveConfigs();
      expect(controller.onTaskCompleted.calledOnce).to.be.true;
    });
  });

  describe('#startZooKeeperServers()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'updateComponent', Em.K);
    });
    afterEach(function () {
      controller.updateComponent.restore();
    });

    it('updateComponent called with valid arguments', function () {
      controller.set('content.masterComponentHosts', [{
        component: 'ZOOKEEPER_SERVER',
        hostName: 'host1'
      }]);
      controller.startZooKeeperServers();
      expect(controller.updateComponent.calledWith('ZOOKEEPER_SERVER', ['host1'], 'ZOOKEEPER', 'Start')).to.be.true;
    });
  });

  describe('#startNameNode()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'updateComponent', Em.K);
      controller.set('content.masterComponentHosts', [
        {
          component: 'NAMENODE',
          hostName: 'host1'
        },
        {
          component: 'NAMENODE',
          hostName: 'host2'
        }
      ]);
    });
    afterEach(function () {
      controller.updateComponent.restore();
    });

    it('reassign host does not match current', function () {
      controller.set('content.reassignHosts.source', 'host3');
      controller.set('content.reassignHosts.target', 'host2');
      controller.startNameNode();
      expect(controller.updateComponent.getCall(0).args[0]).to.be.equal('NAMENODE');
      expect(controller.updateComponent.getCall(0).args[1][0]).to.be.equal('host1');
      expect(controller.updateComponent.getCall(0).args[2]).to.be.equal('HDFS');
      expect(controller.updateComponent.getCall(0).args[3]).to.be.equal('Start');
    });

    it('reassign host matches current', function () {
      controller.set('content.reassignHosts.target', 'host2');
      controller.startNameNode();
      expect(controller.updateComponent.calledWith('NAMENODE', ['host1'], 'HDFS', 'Start')).to.be.true;
    });
  });

  describe('#startServices()', function () {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns({"skip.service.checks": "false"});
      controller.startServices();
      this.args = testHelpers.findAjaxRequest('name', 'common.services.update');
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it('request is sent', function () {
      expect(this.args).exists;
    });
  });

  describe('#deleteHostComponents()', function () {

    it('No host components', function () {
      controller.set('hostComponents', []);
      controller.set('content.reassignHosts.source', 'host1');
      controller.deleteHostComponents();
      var args = testHelpers.findAjaxRequest('name', 'common.delete.host_component');
      expect(args).not.exists;
    });
    it('delete two components', function () {
      controller.set('hostComponents', [1, 2]);
      controller.set('content.reassignHosts.source', 'host1');
      controller.deleteHostComponents();
      var args = testHelpers.filterAjaxRequests('name', 'common.delete.host_component');
      expect(args).to.have.property('length').equal(2);
      expect(args[0][0].data).to.eql({
        "hostName": "host1",
        "componentName": 1
      });
      expect(args[1][0].data).to.eql({
        "hostName": "host1",
        "componentName": 2
      });
    });
  });

  describe('#onDeleteHostComponentsError()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'onComponentsTasksSuccess', Em.K);
      sinon.stub(controller, 'onTaskError', Em.K);
    });
    afterEach(function () {
      controller.onComponentsTasksSuccess.restore();
      controller.onTaskError.restore();
    });

    it('task success', function () {
      var error = {
        responseText: 'org.apache.ambari.server.controller.spi.NoSuchResourceException'
      };
      controller.onDeleteHostComponentsError(error);
      expect(controller.onComponentsTasksSuccess.calledOnce).to.be.true;
    });
    it('unknown error', function () {
      var error = {
        responseText: ''
      };
      controller.onDeleteHostComponentsError(error);
      expect(controller.onTaskError.calledOnce).to.be.true;
    });
  });

  describe('#done()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'removeObserver', Em.K);
      sinon.stub(App.router, 'send', Em.K);
    });
    afterEach(function () {
      controller.removeObserver.restore();
      App.router.send.restore();
    });

    it('submit disabled', function () {
      controller.set('isSubmitDisabled', true);
      controller.done();
      expect(App.router.send.called).to.be.false;
    });
    it('submit enabled and does not have manual steps', function () {
      controller.set('isSubmitDisabled', false);
      controller.set('content.hasManualSteps', false);
      controller.done();
      expect(controller.removeObserver.calledWith('tasks.@each.status', controller, 'onTaskStatusChange')).to.be.true;
      expect(App.router.send.calledWith('complete')).to.be.true;
    });
    it('submit enabled and has manual steps', function () {
      controller.set('isSubmitDisabled', false);
      controller.set('content.hasManualSteps', true);
      controller.done();
      expect(controller.removeObserver.calledWith('tasks.@each.status', controller, 'onTaskStatusChange')).to.be.true;
      expect(App.router.send.calledWith('next')).to.be.true;
    });
  });

  describe('#getServiceConfigData()', function () {
    var services = [];
    var stackServices = [];
    beforeEach(function () {
      sinon.stub(App.Service, 'find', function () {
        return services;
      });
      sinon.stub(App.StackService, 'find', function () {
        return stackServices;
      });
    });
    afterEach(function () {
      App.Service.find.restore();
      App.StackService.find.restore();
    });

    it('No services', function () {
      services = [];
      controller.set('content.reassign.component_name', 'COMP1');
      expect(controller.getServiceConfigData({})).to.eql([]);
    });
    it('No services in stackServices', function () {
      services = [Em.Object.create({serviceName: 'S1'})];
      stackServices = [];
      controller.set('content.reassign.component_name', 'COMP1');
      expect(controller.getServiceConfigData({}, {})).to.eql([]);
    });
    it('Services in stackServices, but configTypesRendered is empty', function () {
      services = [Em.Object.create({serviceName: 'S1'})];
      stackServices = [Em.Object.create({
        serviceName: 'S1',
        configTypesRendered: {}
      })];
      controller.set('content.reassign.component_name', 'COMP1');
      expect(controller.getServiceConfigData({}, {})[0]).to.equal("{\"Clusters\":{\"desired_config\":[]}}");
    });
    it('Services in stackServices, and configTypesRendered has data, but configs is empty', function () {
      services = [Em.Object.create({serviceName: 'S1'})];
      stackServices = [
        Em.Object.create({
          serviceName: 'S1',
          configTypesRendered: {'type1': {}}
        })
      ];
      controller.set('content.reassign.component_name', 'COMP1');
      expect(controller.getServiceConfigData({}, {})[0]).to.equal("{\"Clusters\":{\"desired_config\":[]}}");
    });
    it('Services in stackServices, and configTypesRendered has data, and configs present', function () {
      services = [Em.Object.create({serviceName: 'S1'})];
      stackServices = [
        Em.Object.create({
          serviceName: 'S1',
          configTypesRendered: {'type1': {}}
        })
      ];
      var configs = {
        'type1': {
          'prop1': 'value1'
        }
      };
      controller.set('content.reassign.component_name', 'COMP1');
      expect(JSON.parse(controller.getServiceConfigData(configs, {})[0]).Clusters.desired_config.length).to.equal(1);
    });
  });

  describe('#cleanMySqlServer()', function () {
    beforeEach(function() {
      sinon.stub(App.HostComponent, 'find', function() {
        return Em.A([
          Em.Object.create({
            'componentName': 'MYSQL_SERVER',
            'hostName': 'host1'
          })
        ]);
      });
    });
    afterEach(function() {
      App.HostComponent.find.restore();
    });

    it('component_name is C1', function () {
      controller.set('content.reassign.component_name', 'C1');
      controller.cleanMySqlServer();
      var args = testHelpers.findAjaxRequest('name', 'service.mysql.clean');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        host: 'host1'
      });
    });

    it('component_name is MYSQL_SERVER', function () {
      controller.set('content.reassign.component_name', 'MYSQL_SERVER');
      controller.set('content.reassignHosts.target', 'host2');
      controller.cleanMySqlServer();
      var args = testHelpers.findAjaxRequest('name', 'service.mysql.clean');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        host: 'host2'
      });
    });
  });

  describe('#configureMySqlServer()', function () {
    beforeEach(function() {
      sinon.stub(App.HostComponent, 'find', function() {
        return Em.A([
          Em.Object.create({
            'componentName': 'MYSQL_SERVER',
            'hostName': 'host1'
          })
        ]);
      });
    });
    afterEach(function() {
      App.HostComponent.find.restore();
    });

    it('component_name is C1', function () {
      controller.set('content.reassign.component_name', 'C1');
      controller.configureMySqlServer();
      var args = testHelpers.findAjaxRequest('name', 'service.mysql.configure');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        host: 'host1'
      });
    });

    it('component_name is MYSQL_SERVER', function () {
      controller.set('content.reassign.component_name', 'MYSQL_SERVER');
      controller.set('content.reassignHosts.target', 'host2');
      controller.configureMySqlServer();
      var args = testHelpers.findAjaxRequest('name', 'service.mysql.configure');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        host: 'host2'
      });
    });
  });

  describe("#startRequiredServices()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'startServices', Em.K);
    });
    afterEach(function () {
      controller.startServices.restore();
    });
    it("component has related services", function() {
      controller.set('content.reassign.component_name', 'JOBTRACKER');
      controller.startRequiredServices();
      expect(controller.startServices.calledWith(false, ['PIG', 'OOZIE'], true)).to.be.true;
    });
    it("component does not have related services", function() {
      controller.set('content.reassign.component_name', 'C1');
      controller.startRequiredServices();
      expect(controller.startServices.calledWith(true)).to.be.true;
    });
  });

  describe("#startMySqlServer()", function() {
    beforeEach(function () {
      sinon.stub(App.HostComponent, 'find').returns([
        Em.Object.create({
          componentName: 'MYSQL_SERVER',
          hostName: 'host1'
        })
      ]);
    });
    afterEach(function () {
      App.HostComponent.find.restore();
    });
    it("valid request is sent", function() {
      controller.startMySqlServer();
      var args = testHelpers.findAjaxRequest('name', 'common.host.host_component.update');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        context: "Start MySQL Server",
        hostName: 'host1',
        serviceName: "HIVE",
        componentName: "MYSQL_SERVER",
        HostRoles: {
          state: "STARTED"
        }
      });
    });
  });

  describe("#restartMySqlServer()", function() {
    beforeEach(function () {
      sinon.stub(App.HostComponent, 'find').returns([
        Em.Object.create({
          componentName: 'MYSQL_SERVER',
          hostName: 'host1'
        })
      ]);
    });
    afterEach(function () {
      App.HostComponent.find.restore();
    });
    it("valid request is sent", function() {
      controller.set('content', Em.Object.create({
        cluster: Em.Object.create({
          name: 'cl1'
        })
      }));
      controller.restartMySqlServer();
      var args = testHelpers.findAjaxRequest('name', 'restart.hostComponents');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        context: 'Restart MySql Server',
        resource_filters: [{
          component_name: "MYSQL_SERVER",
          hosts: 'host1',
          service_name: "HIVE"
        }],
        operation_level: {
          level: "HOST_COMPONENT",
          cluster_name: 'cl1',
          service_name: "HIVE",
          hostcomponent_name: "MYSQL_SERVER"
        }
      });
    });
  });

  describe("#startNewMySqlServer()", function() {

    beforeEach(function () {
      controller.set('content', Em.Object.create({
        reassignHosts: Em.Object.create({
          target: 'host1'
        })
      }));
      controller.startNewMySqlServer();
      this.args = testHelpers.findAjaxRequest('name', 'common.host.host_component.update');
    });

    it('valid request is sent', function() {
      expect(this.args[0]).exists;
      expect(this.args[0].sender).to.be.eql(controller);
      expect(this.args[0].data).to.be.eql({
        context: "Start MySQL Server",
        hostName: 'host1',
        serviceName: "HIVE",
        componentName: "MYSQL_SERVER",
        HostRoles: {
          state: "STARTED"
        }
      });
    });
  });

  describe.skip("#prepareDBCheckAction()", function() {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns({
        'jdk_location': 'jdk_location',
        'jdk.name': 'jdk.name',
        'java.home': 'java.home'
      });
      sinon.stub(controller, 'getConnectionProperty').returns('prop1');
      controller.set('content.reassignHosts', Em.Object.create({target: 'host1'}));
      controller.reopen({
        dbType: 'type1',
        requiredProperties: [],
        preparedDBProperties: {}
      });
      controller.prepareDBCheckAction();
      this.args = testHelpers.findAjaxRequest('name', 'cluster.custom_action.create');
    });
    afterEach(function () {
      App.router.get.restore();
      controller.getConnectionProperty.restore();
    });
    it('valid request is sent', function () {
      expect(this.args[0]).exists;
      expect(this.args[0].data).to.eql({
        requestInfo: {
          "context": "Check host",
          "action": "check_host",
          "parameters": {
            "db_name": "type1",
            "jdk_location": "jdk_location",
            "jdk_name": "jdk.name",
            "java_home": "java.home",
            "threshold": 60,
            "ambari_server_host": "",
            "check_execute_list": "db_connection_check"
          }
        },
        filteredHosts: ['host1']
      });
    });
  });

  describe('#setDependentHostComponents', function() {
    beforeEach(function() {
      sinon.stub(App.Host, 'find').returns(Em.Object.create({
        hostComponents: [
          Em.Object.create({
            componentName: 'C1'
          })
        ]
      }));
      sinon.stub(App.Service, 'find').returns([
        Em.Object.create({
          serviceName: 'S1'
        }),
        Em.Object.create({
          serviceName: 'S2'
        })
      ]);
      sinon.stub(App.StackServiceComponent, 'find').returns(Em.Object.create({
        dependencies: [
          Em.Object.create({
            componentName: 'C1',
            serviceName: 'S1'
          }),
          Em.Object.create({
            componentName: 'C2',
            serviceName: 'S2'
          }),
          Em.Object.create({
            componentName: 'C3',
            serviceName: 'S3'
          })
        ]
      }));
    });
    afterEach(function() {
      App.Host.find.restore();
      App.Service.find.restore();
      App.StackServiceComponent.find.restore();
    });

    it('should set dependentHostComponents', function() {
      controller.setDependentHostComponents();
      expect(controller.get('dependentHostComponents')).to.be.eql(['C2']);
    });
  });
});

});

require.register("test/controllers/main/service/reassign/step6_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');

require('controllers/main/service/reassign/step6_controller');
var controller;
var testHelpers = require('test/helpers');

describe('App.ReassignMasterWizardStep6Controller', function () {

  beforeEach(function () {
    controller = App.ReassignMasterWizardStep6Controller.create({
      content: Em.Object.create({
        reassign: Em.Object.create(),
        reassignHosts: Em.Object.create()
      }),
      startServices: Em.K
    });
  });

  describe('#initializeTasks()', function () {
    it('No commands', function () {
      controller.set('commands', []);
      controller.set('hostComponents', []);
      controller.initializeTasks();

      expect(controller.get('tasks')).to.be.empty;
    });
    it('One command', function () {
      controller.set('commands', ['COMMAND1']);
      controller.initializeTasks();

      expect(controller.get('tasks')[0].get('id')).to.equal(0);
      expect(controller.get('tasks')[0].get('command')).to.equal('COMMAND1');
    });
  });

  describe('#hideRollbackButton()', function () {

    it('No showRollback command', function () {
      controller.set('tasks', [Em.Object.create({
        showRollback: false
      })]);
      controller.hideRollbackButton();
      expect(controller.get('tasks')[0].get('showRollback')).to.be.false;
    });
    it('showRollback command is present', function () {
      controller.set('tasks', [Em.Object.create({
        showRollback: true
      })]);
      controller.hideRollbackButton();
      expect(controller.get('tasks')[0].get('showRollback')).to.be.false;
    });
  });

  describe('#onComponentsTasksSuccess()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'onTaskCompleted', Em.K);
    });
    afterEach(function () {
      controller.onTaskCompleted.restore();
    });

    it('One host-component', function () {
      controller.set('multiTaskCounter', 1);
      controller.set('hostComponents', [
        {}
      ]);
      controller.onComponentsTasksSuccess();
      expect(controller.get('multiTaskCounter')).to.equal(0);
      expect(controller.onTaskCompleted.calledOnce).to.be.true;
    });
    it('two host-components', function () {
      controller.set('multiTaskCounter', 2);
      controller.set('hostComponents', [
        {},
        {}
      ]);
      controller.onComponentsTasksSuccess();
      expect(controller.get('multiTaskCounter')).to.equal(1);
      expect(controller.onTaskCompleted.called).to.be.false;
    });
  });


  describe('#loadStep()', function () {
    var isHaEnabled = true;

    beforeEach(function () {
      controller.set('content.reassign.service_id', 'service1');
      sinon.stub(controller, 'onTaskStatusChange', Em.K);
      sinon.stub(controller, 'initializeTasks', Em.K);
      sinon.stub(App, 'get', function () {
        return isHaEnabled;
      });
    });
    afterEach(function () {
      controller.onTaskStatusChange.restore();
      controller.initializeTasks.restore();
      App.get.restore();
    });

    it('reassign component is NameNode and HA enabled', function () {
      isHaEnabled = true;
      controller.set('content.reassign.component_name', 'NAMENODE');

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['NAMENODE', 'ZKFC']);
    });
    it('reassign component is NameNode and HA disabled', function () {
      isHaEnabled = false;
      controller.set('content.reassign.component_name', 'NAMENODE');

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['NAMENODE']);
    });
    it('reassign component is RESOURCEMANAGER', function () {
      controller.set('content.reassign.component_name', 'RESOURCEMANAGER');

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['RESOURCEMANAGER']);
    });
  });

  describe('#loadStep() for reassign NameNode with PXF service installed', function () {

    var serviceStub, hostComponentStub, pxfHosts, dataNodeHosts;

    var commands = [
      'stopMysqlService',
      'putHostComponentsInMaintenanceMode',
      'stopHostComponentsInMaintenanceMode',
      'deleteHostComponents',
      'startAllServices'
    ];

    var reassignHosts = {
      "source": "c6401.ambari.apache.org",
      "target": "c6403.ambari.apache.org"
    };

    beforeEach(function () {
      controller.set('content.reassign.service_id', 'HDFS');
      controller.set('content.reassign.component_name', 'NAMENODE');
      controller.set('commands', commands.copy());
      controller.set('content.reassignHosts', reassignHosts);
      sinon.stub(controller, 'onTaskStatusChange', Em.K);
      sinon.stub(controller, 'initializeTasks', Em.K);
      serviceStub = sinon.stub(App.Service.find(), 'someProperty');
      hostComponentStub = sinon.stub(App.HostComponent.find(), 'filterProperty');
      serviceStub.withArgs('serviceName', 'PXF').returns(true);
    });

    afterEach(function () {
      controller.onTaskStatusChange.restore();
      controller.initializeTasks.restore();
      serviceStub.restore();
      hostComponentStub.restore();
    });

    var setUpHosts = function (_pxfHosts, _dataNodeHosts) {
      hostComponentStub.withArgs('componentName', 'PXF').returns(_pxfHosts);
      hostComponentStub.withArgs('componentName', 'DATANODE').returns(_dataNodeHosts);
    };

    it('does not delete PXF from source host if PXF and DATANODE are not installed on the source host', function () {
      pxfHosts = [{"hostName": "c6402.ambari.apache.org"}];
      dataNodeHosts = [{"hostName": "c6402.ambari.apache.org"}];
      setUpHosts(pxfHosts, dataNodeHosts);

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['NAMENODE']);
    });

    it('does not delete PXF from source host if PXF is not installed on the source host and DATANODE is installed on the source host', function () {
      pxfHosts = [{"hostName": "c6402.ambari.apache.org"}];
      dataNodeHosts = [{"hostName": "c6401.ambari.apache.org"}, {"hostName": "c6402.ambari.apache.org"}];
      setUpHosts(pxfHosts, dataNodeHosts);

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['NAMENODE']);
    });

    it('deletes PXF from source host if PXF is installed on the source host and DATANODE is not installed on the source host', function () {
      pxfHosts = [{"hostName": "c6401.ambari.apache.org"}, {"hostName": "c6402.ambari.apache.org"}];
      dataNodeHosts = [{"hostName": "c6402.ambari.apache.org"}];
      setUpHosts(pxfHosts, dataNodeHosts);

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['NAMENODE', 'PXF']);
    });

    it('does not delete PXF from source host if PXF and DATANODE are installed on the source host', function () {
      pxfHosts = [{"hostName": "c6401.ambari.apache.org"}, {"hostName": "c6402.ambari.apache.org"}];
      dataNodeHosts = [{"hostName": "c6401.ambari.apache.org"}, {"hostName": "c6402.ambari.apache.org"}];
      setUpHosts(pxfHosts, dataNodeHosts);

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['NAMENODE']);
    });

    it('does not install PXF on the target host if PXF is already installed on the target host', function () {
      pxfHosts = [{"hostName": "c6403.ambari.apache.org"}];
      setUpHosts(pxfHosts, []);

      controller.loadStep();
      expect(controller.get('commands').indexOf('installPxf')).to.eql(-1);
    });

    it('installs PXF on the target host if PXF is not installed on the target host', function () {
      pxfHosts = [{"hostName": "c6401.ambari.apache.org"}, {"hostName": "c6402.ambari.apache.org"}];
      setUpHosts(pxfHosts, []);

      controller.loadStep();
      expect(controller.get('commands').indexOf('installPxf')).to.be.equal(4);
    });

  });

  describe('#deleteHostComponents()', function () {

    it('No host components', function () {
      controller.set('hostComponents', []);
      controller.set('content.reassignHosts.source', 'host1');
      controller.deleteHostComponents();
      var args = testHelpers.findAjaxRequest('name', 'common.delete.host_component');
      expect(args).not.exists;
    });
    it('delete two components', function () {
      controller.set('hostComponents', [1, 2]);
      controller.set('content.reassignHosts.source', 'host1');
      controller.deleteHostComponents();
      var args = testHelpers.filterAjaxRequests('name', 'common.delete.host_component');
      expect(args).to.have.property('length').equal(2);
      expect(args[0][0].data).to.eql({
        "hostName": "host1",
        "componentName": 1
      });
      expect(args[1][0].data).to.eql({
        "hostName": "host1",
        "componentName": 2
      });
    });
  });

  describe('#onDeleteHostComponentsError()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'onComponentsTasksSuccess', Em.K);
      sinon.stub(controller, 'onTaskError', Em.K);
    });
    afterEach(function () {
      controller.onComponentsTasksSuccess.restore();
      controller.onTaskError.restore();
    });

    it('task success', function () {
      var error = {
        responseText: 'org.apache.ambari.server.controller.spi.NoSuchResourceException'
      };
      controller.onDeleteHostComponentsError(error);
      expect(controller.onComponentsTasksSuccess.calledOnce).to.be.true;
    });
    it('unknown error', function () {
      var error = {
        responseText: ''
      };
      controller.onDeleteHostComponentsError(error);
      expect(controller.onTaskError.calledOnce).to.be.true;
    });
  });

  describe('#stopMysqlService()', function () {
    it('stopMysqlService', function () {
      controller.stopMysqlService();
      var args = testHelpers.findAjaxRequest('name', 'common.host.host_component.update');
      expect(args[0]).exists;
    });
  });

  describe('#putHostComponentsInMaintenanceMode()', function () {
    beforeEach(function(){
      sinon.stub(controller, 'onComponentsTasksSuccess', Em.K);
      controller.set('content.reassignHosts.source', 'source');
    });
    afterEach(function(){
      controller.onComponentsTasksSuccess.restore();
    });
    it('No host-components', function () {
      controller.set('hostComponents', []);
      controller.putHostComponentsInMaintenanceMode();
      var args = testHelpers.findAjaxRequest('name', 'common.host.host_component.passive');
      expect(args).not.exists;
      expect(controller.get('multiTaskCounter')).to.equal(0);
    });
    it('One host-components', function () {
      controller.set('hostComponents', [{}]);
      controller.putHostComponentsInMaintenanceMode();
      var args = testHelpers.findAjaxRequest('name', 'common.host.host_component.passive');
      expect(args).exists;
      expect(controller.get('multiTaskCounter')).to.equal(1);
    });
  });

  describe("#removeTasks()", function() {
    it("no tasks to delete", function() {
      controller.set('tasks', [Em.Object.create()]);
      controller.removeTasks([]);
      expect(controller.get('tasks').length).to.equal(1);
    });
    it("one task to delete", function() {
      controller.set('tasks', [Em.Object.create({command: 'task1'})]);
      controller.removeTasks(['task1']);
      expect(controller.get('tasks')).to.be.empty;
    });
  });

  describe("#startAllServices()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'startServices', Em.K);
    });
    afterEach(function () {
      controller.startServices.restore();
    });
    it("startServices is called with valid arguments", function () {
      controller.startAllServices();
      expect(controller.startServices.calledWith(true)).to.be.true;
    });
  });
});
});

require.register("test/controllers/main/service/reassign/step7_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');

require('controllers/main/service/reassign/step7_controller');
var controller;
var testHelpers = require('test/helpers');

describe('App.ReassignMasterWizardStep7Controller', function () {

  beforeEach(function () {
    controller = App.ReassignMasterWizardStep7Controller.create({
      content: Em.Object.create({
        reassign: Em.Object.create(),
        reassignHosts: Em.Object.create()
      })
    });
  });

  describe('#initializeTasks()', function () {
    it('should set isLoaded to true', function () {
      controller.set('isLoaded', false);

      controller.initializeTasks();
      expect(controller.get('isLoaded')).to.be.true;
    });
  });

  describe("#putHostComponentsInMaintenanceMode()", function() {
    it("no host-components", function() {
      controller.set('hostComponents', []);
      controller.putHostComponentsInMaintenanceMode();
      var args = testHelpers.findAjaxRequest('name', 'common.host.host_component.passive');
      expect(args).not.exists;
      expect(controller.get('multiTaskCounter')).to.equal(0);
    });
    it("one host-component", function() {
      controller.set('hostComponents', ['C1']);
      controller.set('content.reassignHosts.target', 'host1');
      controller.putHostComponentsInMaintenanceMode();
      var args = testHelpers.findAjaxRequest('name', 'common.host.host_component.passive');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        hostName: 'host1',
        passive_state: "ON",
        componentName: 'C1'
      });
      expect(controller.get('multiTaskCounter')).to.equal(0);
    });
    it("two host-components", function() {
      controller.set('hostComponents', ['C1', 'C2']);
      controller.putHostComponentsInMaintenanceMode();
      var args = testHelpers.filterAjaxRequests('name', 'common.host.host_component.passive');
      expect(args).to.have.property('length').equal(2);
      expect(controller.get('multiTaskCounter')).to.equal(0);
    });
  });

  describe("#deleteHostComponents()", function() {
    it("no host-components", function() {
      controller.set('hostComponents', []);
      controller.deleteHostComponents();
      var args = testHelpers.findAjaxRequest('name', 'common.delete.host_component');
      expect(args).not.exists;
      expect(controller.get('multiTaskCounter')).to.equal(0);
    });
    it("one host-component", function() {
      controller.set('hostComponents', ['C1']);
      controller.set('content.reassignHosts.target', 'host1');
      controller.deleteHostComponents();
      var args = testHelpers.findAjaxRequest('name', 'common.delete.host_component');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(controller);
      expect(args[0].data).to.be.eql({
        hostName: 'host1',
        componentName: 'C1'
      });
      expect(controller.get('multiTaskCounter')).to.equal(0);
    });
    it("two host-components", function() {
      controller.set('hostComponents', ['C1', 'C2']);
      controller.deleteHostComponents();
      var args = testHelpers.filterAjaxRequests('name', 'common.delete.host_component');
      expect(args).to.have.property('length').equal(2);
      expect(controller.get('multiTaskCounter')).to.equal(0);
    });
  });
});

});

require.register("test/controllers/main/service/reassign_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/cluster');
require('controllers/wizard');
require('controllers/main/service/reassign_controller');

describe('App.ReassignMasterController', function () {

  var reassignMasterController;

  beforeEach(function () {
    reassignMasterController = App.ReassignMasterController.create({});
  });

  describe('#totalSteps', function () {

    var cases = [
      {
        componentName: 'ZOOKEEPER_SERVER',
        result: 4
      },
      {
        componentName: 'RESOURCE_MANAGER',
        result: 4
      },
      {
        componentName: 'OOZIE_SERVER',
        result: 6
      },
      {
        componentName: 'APP_TIMELINE_SERVER',
        result: 6
      },
      {
        componentName: 'NAMENODE',
        result: 6
      }
    ];

    cases.forEach(function (c) {
      it('check ' + c.componentName, function () {
        reassignMasterController.set('content.reassign', {'component_name': c.componentName});
        expect(reassignMasterController.get('totalSteps')).to.equal(c.result);
        reassignMasterController.set('content.reassign', {service_id:null});
      });
    });
  });

  describe('#saveMasterComponentHosts', function () {

    var stepController = Em.Object.create({
        selectedServicesMasters: [
          Em.Object.create({
            display_name: 'd0',
            component_name: 'c0',
            selectedHost: 'h0',
            serviceId: 's0'
          }),
          Em.Object.create({
            display_name: 'd1',
            component_name: 'c1',
            selectedHost: 'h1',
            serviceId: 's1'
          })
        ]
      }),
      masterComponentHosts = [
        {
          display_name: 'd0',
          component: 'c0',
          hostName: 'h0',
          serviceId: 's0',
          isInstalled: true
        },
        {
          display_name: 'd1',
          component: 'c1',
          hostName: 'h1',
          serviceId: 's1',
          isInstalled: true
        }
      ];

    beforeEach(function () {
      sinon.stub(App.db, 'setMasterComponentHosts', Em.K);
      sinon.stub(reassignMasterController, 'setDBProperty', Em.K);
      reassignMasterController.saveMasterComponentHosts(stepController);
    });

    afterEach(function () {
      App.db.setMasterComponentHosts.restore();
      reassignMasterController.setDBProperty.restore();
    });

    it('setMasterComponentHosts is called once', function () {
      expect(App.db.setMasterComponentHosts.calledOnce).to.be.true;
    });

    it('setDBProperty is called once', function () {
      expect(reassignMasterController.setDBProperty.calledOnce).to.be.true;
    });

    it('setMasterComponentHosts is called with valid arguments', function () {
      expect(App.db.setMasterComponentHosts.calledWith(masterComponentHosts)).to.be.true;
    });

    it('setDBProperty is called with valid arguments', function () {
      expect(reassignMasterController.setDBProperty.calledWith('masterComponentHosts', masterComponentHosts)).to.be.true;
    });

    it('masterComponentHosts are equal to ' + JSON.stringify(masterComponentHosts), function () {
      expect(reassignMasterController.get('content.masterComponentHosts')).to.eql(masterComponentHosts);
    });

  });

});

});

require.register("test/controllers/main/service/widgets/create/step1_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');

require('controllers/main/service/widgets/create/step1_controller');


describe('App.WidgetWizardStep1Controller', function () {
  var controller = App.WidgetWizardStep1Controller.create();

  describe("#isSubmitDisabled", function() {
    it("disabled", function() {
      controller.set('widgetType', '');
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
    it("enabled", function() {
      controller.set('widgetType', 'w1');
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });
  });

  describe("#chooseOption()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'next');
      controller.chooseOption({context: 'type1'});
    });
    afterEach(function () {
      controller.next.restore();
    });
    it('widgetType is valid', function () {
      expect(controller.get('widgetType')).to.equal('type1');
    });
    it('User is moved to the next step', function () {
      expect(controller.next.calledOnce).to.be.true;
    });
  });

  describe("#loadStep()", function () {
    before(function () {
      sinon.stub(controller, 'clearStep');
    });
    after(function () {
      controller.clearStep.restore();
    });
    it("clearStep", function () {
      controller.loadStep();
      expect(controller.clearStep.calledOnce).to.be.true;
    });
  });

  describe("#clearStep()", function () {
    it("widgetType is empty", function () {
      controller.clearStep();
      expect(controller.get('widgetType')).to.be.empty;
    });
  });

  describe("#next()", function () {
    before(function () {
      sinon.stub(App.router, 'send');
    });
    after(function () {
      App.router.send.restore();
    });
    it("user is moved to the next step", function () {
      controller.next();
      expect(App.router.send.calledWith('next')).to.be.true;
    });
  });



});

});

require.register("test/controllers/main/service/widgets/create/step2_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');

require('controllers/main/service/widgets/create/step2_controller');


describe('App.WidgetWizardStep2Controller', function () {
  var controller = App.WidgetWizardStep2Controller.create({
    content: Em.Object.create()
  });

  App.TestAliases.testAsComputedEqual(controller, 'isEditWidget', 'content.controllerName', 'widgetEditController');

  describe("#filteredMetrics", function () {
    var testCases = [
      {
        metric: {
          point_in_time: false
        },
        type: null,
        result: []
      },
      {
        metric: {
          point_in_time: true
        },
        type: null,
        result: [
          {
            point_in_time: true
          }
        ]
      },
      {
        metric: {
          temporal: false
        },
        type: 'GRAPH',
        result: []
      },
      {
        metric: {
          temporal: true
        },
        type: 'GRAPH',
        result: [
          {
            temporal: true
          }
        ]
      }
    ];

    testCases.forEach(function (test) {
      it("type=" + test.type + "; temporal=" + test.metric.temporal + "; point_in_time=" + test.metric.point_in_time, function () {
        controller.get('content').setProperties({
          widgetType: test.type,
          allMetrics: [test.metric]
        });
        controller.propertyDidChange('filteredMetrics');
        expect(controller.get('filteredMetrics')).to.eql(test.result);
      });
    });
  });

  describe("#isSubmitDisabled", function () {
    beforeEach(function () {
      this.expressionFunc = sinon.stub(controller, 'isExpressionComplete');
      this.metricsFunc = sinon.stub(controller, 'isExpressionWithMetrics');
      this.graphFunc = sinon.stub(controller, 'isGraphDataComplete');
      this.templateFunc = sinon.stub(controller, 'isTemplateDataComplete');
      controller.set('expressions', ['']);
    });
    afterEach(function () {
      this.expressionFunc.restore();
      this.metricsFunc.restore();
      this.graphFunc.restore();
      this.templateFunc.restore();
      controller.get('expressions').clear();
    });
    it("invalid property", function () {
      controller.set('widgetPropertiesViews', [Em.Object.create({isValid: false})]);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
    it("valid number widget", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', 'NUMBER');
      this.expressionFunc.returns(true);
      this.metricsFunc.returns(true);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });
    it("invalid number widget with metrics", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', 'NUMBER');
      this.expressionFunc.returns(false);
      this.metricsFunc.returns(true);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
    it("number widget w/o metrics", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', 'NUMBER');
      this.expressionFunc.returns(true);
      this.metricsFunc.returns(false);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
    it("invalid number widget w/o metrics", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', 'NUMBER');
      this.expressionFunc.returns(false);
      this.metricsFunc.returns(false);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
    it("valid graph widget", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', 'GRAPH');
      this.graphFunc.returns(true);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });
    it("invalid graph widget", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', 'GRAPH');
      this.graphFunc.returns(false);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
    it("valid template widget", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', 'TEMPLATE');
      this.templateFunc.returns(true);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });
    it("invalid template widget", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', 'TEMPLATE');
      this.templateFunc.returns(false);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
    it("unknown widget type", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', '');
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });
  });

  describe("#isExpressionComplete()", function () {
    var testCases = [
      {
        expression: null,
        result: false,
        title: 'no expression'
      },
      {
        expression: Em.Object.create({isInvalid: true}),
        result: false,
        title: 'invalid expression'
      },
      {
        expression: Em.Object.create({isInvalid: false, isEmpty: true}),
        result: false,
        title: 'empty expression'
      },
      {
        expression: Em.Object.create({isInvalid: false, isEmpty: false}),
        result: true,
        title: 'complete expression'
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.isExpressionComplete(test.expression)).to.equal(test.result);
      });
    });
  });

  describe("#isExpressionWithMetrics()", function () {
    var testCases = [
      {
        expression: null,
        result: false,
        title: 'no expression'
      },
      {
        expression: Em.Object.create(),
        result: false,
        title: 'no data array'
      },
      {
        expression: Em.Object.create({data: []}),
        result: false,
        title: 'empty data array'
      },
      {
        expression: Em.Object.create({data: [{isMetric: false}]}),
        result: false,
        title: 'no metrics'
      },
      {
        expression: Em.Object.create({data: [{isMetric: false}, {isMetric: true}]}),
        result: true,
        title: 'metrics included'
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.isExpressionWithMetrics(test.expression)).to.equal(test.result);
      });
    });
  });

  describe("#isGraphDataComplete()", function () {
    var mock,
      cases = [
        {
          dataSets: [],
          isGraphDataComplete: false,
          title: 'dataSets is empty'
        },
        {
          dataSets: [Em.Object.create({label: ''})],
          isGraphDataComplete: false,
          title: 'label is empty'
        },
        {
          dataSets: [Em.Object.create({label: 'abc'})],
          isExpressionComplete: false,
          isGraphDataComplete: false,
          title: 'expression is not complete'
        },
        {
          dataSets: [Em.Object.create({label: 'abc'})],
          isExpressionComplete: true,
          isExpressionWithMetrics: false,
          isGraphDataComplete: false,
          title: 'no metrics in expression'
        },
        {
          dataSets: [Em.Object.create({label: 'abc', expression: {data: [{isMetric: true}]}})],
          isExpressionComplete: true,
          isExpressionWithMetrics: true,
          isGraphDataComplete: true,
          title: 'expression is complete and contains metrics'
        }
      ];

    beforeEach(function () {
      mock = {
        isExpressionComplete: sinon.stub(controller, 'isExpressionComplete'),
        isExpressionWithMetrics: sinon.stub(controller, 'isExpressionWithMetrics')
      };
    });
    afterEach(function () {
      mock.isExpressionComplete.restore();
      mock.isExpressionWithMetrics.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        mock.isExpressionComplete.returns(item.isExpressionComplete);
        mock.isExpressionWithMetrics.returns(item.isExpressionWithMetrics);
        expect(controller.isGraphDataComplete(item.dataSets)).to.equal(item.isGraphDataComplete);
      });
    });
  });

  describe("#isTemplateDataComplete()", function () {
    var mock,
      cases = [
        {
          expressions: [],
          isTemplateDataComplete: false,
          title: 'expressions is empty'
        },
        {
          expressions: [{}],
          templateValue: '',
          isTemplateDataComplete: false,
          title: 'templateValue is empty'
        },
        {
          expressions: [{}],
          templateValue: 'abc',
          isExpressionComplete: false,
          isTemplateDataComplete: false,
          title: 'expression is not complete'
        },
        {
          expressions: [{}],
          templateValue: 'abc',
          isExpressionComplete: true,
          isExpressionWithMetrics: false,
          isTemplateDataComplete: false,
          title: 'no metrics in expression'
        },
        {
          expressions: [{data: [{isMetric: true}]}],
          templateValue: 'abc',
          isExpressionComplete: true,
          isExpressionWithMetrics: true,
          isTemplateDataComplete: true,
          title: 'expression is complete and contains metrics'
        }
      ];

    beforeEach(function () {
      mock = {
        isExpressionComplete: sinon.stub(controller, 'isExpressionComplete'),
        isExpressionWithMetrics: sinon.stub(controller, 'isExpressionWithMetrics')
      };
    });
    afterEach(function () {
      mock.isExpressionComplete.restore();
      mock.isExpressionWithMetrics.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        mock.isExpressionComplete.returns(item.isExpressionComplete);
        mock.isExpressionWithMetrics.returns(item.isExpressionWithMetrics);
        expect(controller.isTemplateDataComplete(item.expressions, item.templateValue)).to.equal(item.isTemplateDataComplete);
      });
    });
  });

  describe("#addDataSet()", function () {

    beforeEach(function () {
      controller.get('dataSets').clear();
      controller.addDataSet(null, true);
      controller.addDataSet(null);
    });

    afterEach(function() {
      controller.get('dataSets').clear();
    });

    it('check id', function () {
      expect(controller.get('dataSets').mapProperty('id')).to.eql([1, 2]);
    });

    it('check isRemovable', function () {
      expect(controller.get('dataSets').mapProperty('isRemovable')).to.eql([false, true]);
    });
  });

  describe("#removeDataSet()", function () {
    it('should remove selected dataSet', function () {
      var dataSet = Em.Object.create();
      controller.get('dataSets').pushObject(dataSet);
      controller.removeDataSet({context: dataSet});
      expect(controller.get('dataSets')).to.be.empty;
    });
  });

  describe("#addExpression()", function () {

    beforeEach(function () {
      controller.get('expressions').clear();
      controller.addExpression(null, true);
      controller.addExpression(null);
    });

    afterEach(function () {
      controller.get('expressions').clear();
    });

    it('check id', function () {
      expect(controller.get('expressions').mapProperty('id')).to.eql([1, 2]);
    });

    it('check isRemovable', function () {
      expect(controller.get('expressions').mapProperty('isRemovable')).to.eql([false, true]);
    });

  });

  describe("#removeExpression()", function () {
    it("should remove selected expression", function () {
      var expression = Em.Object.create();
      controller.get('expressions').pushObject(expression);
      controller.removeExpression({context: expression});
      expect(controller.get('expressions')).to.be.empty;
    });
  });

  describe("#initWidgetData()", function () {

    describe("new data", function () {

      beforeEach(function () {
        controller.set('expressions', []);
        controller.set('dataSets', []);
        controller.get('content').setProperties({
          widgetProperties: {a: 1},
          widgetValues: [1],
          widgetMetrics: [2]
        });

        controller.initWidgetData();
      });

      it('widgetProperties is {a: 1}', function () {
        expect(controller.get('widgetProperties')).to.eql({a: 1});
      });

      it('widgetValues is []', function () {
        expect(controller.get('widgetValues')).to.eql([]);
      });

      it('widgetMetrics is []', function () {
        expect(controller.get('widgetMetrics')).to.eql([]);
      });

      it('expressions is not empty', function () {
        expect(controller.get('expressions')).to.not.be.empty;
      });

      it('dataSets is not empty', function () {
        expect(controller.get('dataSets')).to.not.be.empty;
      });

    });

    describe("previously edited", function () {

      beforeEach(function () {
        controller.set('expressions', [{}]);
        controller.set('dataSets', [{}]);
        controller.get('content').setProperties({
          widgetProperties: {a: 1},
          widgetValues: [1],
          widgetMetrics: [2]
        });

        controller.initWidgetData();
      });

      it('widgetProperties is {a: 1}', function () {
        expect(controller.get('widgetProperties')).to.eql({a: 1});
      });
      it('widgetValues is [1]', function () {
        expect(controller.get('widgetValues')).to.eql([1]);
      });
      it('widgetMetrics is  [2]', function () {
        expect(controller.get('widgetMetrics')).to.eql([2]);
      });
      it('expressions is not empty', function () {
        expect(controller.get('expressions')).to.not.be.empty;
      });
      it('dataSets is not empty', function () {
        expect(controller.get('dataSets')).to.not.be.empty;
      });

    });
  });

  describe("#updateExpressions()", function () {

    beforeEach(function () {
      sinon.stub(controller, 'parseExpression').returns({values: [1], metrics: [1]});
      sinon.stub(controller, 'parseTemplateExpression').returns({values: [1], metrics: [1]});
      sinon.stub(controller, 'parseGraphDataset').returns({values: [1], metrics: [1]});
    });

    afterEach(function () {
      controller.parseExpression.restore();
      controller.parseTemplateExpression.restore();
      controller.parseGraphDataset.restore();
    });

    describe("empty expressions", function () {

      beforeEach(function () {
        controller.set('expressions', []);
        controller.updateExpressions();
      });

      it('parseExpression is not called', function () {
        expect(controller.parseExpression.called).to.be.false;
      });
      it('parseTemplateExpression is not called', function () {
        expect(controller.parseTemplateExpression.called).to.be.false;
      });
      it('parseGraphDataset is not called', function () {
        expect(controller.parseGraphDataset.called).to.be.false;
      });
      it('widgetValues is empty', function () {
        expect(controller.get('widgetValues')).to.be.empty;
      });
      it('widgetMetrics is empty', function () {
        expect(controller.get('widgetMetrics')).to.be.empty;
      });
    });

    describe("empty dataSets", function () {

      beforeEach(function () {
        controller.set('dataSets', []);
        controller.updateExpressions();
      });

      it('parseExpression is not called', function () {
        expect(controller.parseExpression.called).to.be.false;
      });
      it('parseTemplateExpression is not called', function () {
        expect(controller.parseTemplateExpression.called).to.be.false;
      });
      it('parseGraphDataset is not called', function () {
        expect(controller.parseGraphDataset.called).to.be.false;
      });
      it('widgetValues is empty', function () {
        expect(controller.get('widgetValues')).to.be.empty;
      });
      it('widgetMetrics is empty', function () {
        expect(controller.get('widgetMetrics')).to.be.empty;
      });
    });

    describe("GAUGE widget", function () {

      beforeEach(function () {
        controller.set('expressions', [{}]);
        controller.set('content.widgetType', 'GAUGE');
        controller.set('dataSets', [{}]);
        //controller.updateExpressions();
      });


      it('parseExpression is called once', function () {
        expect(controller.parseExpression.calledOnce).to.be.true;
      });
      it('parseTemplateExpression is not called', function () {
        expect(controller.parseTemplateExpression.called).to.be.false;
      });
      it('parseGraphDataset is not called', function () {
        expect(controller.parseGraphDataset.called).to.be.false;
      });
      it('widgetValues is not empty', function () {
        expect(controller.get('widgetValues')).to.not.be.empty;
      });
      it('widgetMetrics is not empty', function () {
        expect(controller.get('widgetMetrics')).to.not.be.empty;
      });
    });

    describe("NUMBER widget", function () {

      beforeEach(function () {
        controller.set('expressions', [{}]);
        controller.set('content.widgetType', 'NUMBER');
        controller.set('dataSets', [{}]);
        //controller.updateExpressions();
      });


      it('parseExpression is called once', function () {
        expect(controller.parseExpression.calledOnce).to.be.true;
      });
      it('parseTemplateExpression is not called', function () {
        expect(controller.parseTemplateExpression.called).to.be.false;
      });
      it('parseGraphDataset is not called', function () {
        expect(controller.parseGraphDataset.called).to.be.false;
      });
      it('widgetValues is not empty', function () {
        expect(controller.get('widgetValues')).to.not.be.empty;
      });
      it('widgetMetrics is not empty', function () {
        expect(controller.get('widgetMetrics')).to.not.be.empty;
      });
    });

    describe("TEMPLATE widget", function () {

      beforeEach(function () {
        controller.set('expressions', [{}]);
        controller.set('content.widgetType', 'TEMPLATE');
        controller.set('dataSets', [{}]);
        //controller.updateExpressions();
      });


      it('parseExpression is not called', function () {
        expect(controller.parseExpression.called).to.be.false;
      });
      it('parseTemplateExpression is called once', function () {
        expect(controller.parseTemplateExpression.calledOnce).to.be.true;
      });
      it('parseGraphDataset is not called', function () {
        expect(controller.parseGraphDataset.called).to.be.false;
      });
      it('widgetValues is not empty', function () {
        expect(controller.get('widgetValues')).to.not.be.empty;
      });
      it('widgetMetrics is not empty', function () {
        expect(controller.get('widgetMetrics')).to.not.be.empty;
      });
    });

    describe("GRAPH widget", function () {

      beforeEach(function () {
        controller.set('expressions', [{}]);
        controller.set('content.widgetType', 'GRAPH');
        controller.set('dataSets', [{}]);
        //controller.updateExpressions();
      });

      it('parseExpression is not called', function () {
        expect(controller.parseExpression.called).to.be.false;
      });
      it('parseTemplateExpression is not called', function () {
        expect(controller.parseTemplateExpression.called).to.be.false;
      });
      it('parseGraphDataset is called once', function () {
        expect(controller.parseGraphDataset.calledOnce).to.be.true;
      });
      it('widgetValues is not empty', function () {
        expect(controller.get('widgetValues')).to.not.be.empty;
      });
      it('widgetMetrics is not empty', function () {
        expect(controller.get('widgetMetrics')).to.not.be.empty;
      });
    });

  });

  describe("#parseGraphDataset()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'parseExpression').returns({value: 'value'});
    });
    afterEach(function () {
      controller.parseExpression.restore();
    });
    it("empty dataSets", function () {
      expect(controller.parseGraphDataset([])).to.be.eql({
        metrics: [],
        values: []
      });
    });
    it("correct dataSets", function () {
      var result = controller.parseGraphDataset([Em.Object.create({label: 'label'})]);
      expect(result.values).to.be.eql([
        {
          "name": "label",
          "value": "value"
        }
      ]);
      expect(result.metrics).to.be.empty;
    });
  });

  describe("#parseTemplateExpression()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'parseExpression').returns({value: 'value'});
    });
    afterEach(function () {
      controller.parseExpression.restore();
    });
    it("empty expressions", function () {
      expect(controller.parseTemplateExpression("{{Expression1}}", [])).to.be.eql({
        metrics: [],
        values: [
          {
            value: "{{Expression1}}"
          }
        ]
      });
    });
    it("correct expressions", function () {
      var result = controller.parseTemplateExpression("{{Expression1}}", [Em.Object.create({alias: '{{Expression1}}'})]);
      expect(result.values).to.be.eql([
        {
          value: "value"
        }
      ]);
      expect(result.metrics).to.be.empty;
    });
  });

  describe("#parseExpression()", function () {
    it("expression is empty", function () {
      expect(controller.parseExpression({data: []})).to.eql({
        metrics: [],
        value: ''
      });
    });
    it("expression is correct", function () {
      var data = [
        {
          name: 'm1',
          serviceName: 'S1',
          componentName: 'C1',
          metricPath: 'mp',
          hostComponentCriteria: 'hcc',
          isMetric: true
        },
        {
          name: '+'
        },
        {
          name: '10'
        }
      ];
      expect(controller.parseExpression({data: data})).to.eql({
        metrics: [
          {
            "name": "m1",
            "service_name": "S1",
            "component_name": "C1",
            "metric_path": "mp",
            "host_component_criteria": "hcc"
          }
        ],
        value: '${m1+10}'
      });
    });
  });

  describe("#updateProperties()", function () {
    it("widgetPropertiesViews is empty", function () {
      controller.set('widgetPropertiesViews', []);
      expect(controller.get('widgetProperties')).to.be.empty;
    });
    it("widgetPropertiesViews is correct", function () {
      controller.set('widgetPropertiesViews', [
        Em.Object.create({
          valueMap: {
            "key1": 'alias1'
          },
          key1: 1
        })
      ]);
      expect(controller.get('widgetProperties')).to.eql({
        "alias1": 1
      });
    });
  });

  describe("#renderProperties()", function () {
    beforeEach(function () {
      this.mock = sinon.stub(App.WidgetType, 'find');
      sinon.stub(App.WidgetPropertyTypes, 'findProperty').returns({valueMap: {}});
      sinon.stub(App.WidgetProperty, 'create').returns({});
    });
    afterEach(function () {
      this.mock.restore();
      App.WidgetPropertyTypes.findProperty.restore();
      App.WidgetProperty.create.restore();
    });
    it("no properties", function () {
      this.mock.returns(Em.Object.create({properties: []}));
      controller.renderProperties();
      expect(controller.get('widgetPropertiesViews')).to.be.empty;
    });
    it("correct properties", function () {
      this.mock.returns(Em.Object.create({properties: [{}]}));
      controller.renderProperties();
      expect(App.WidgetProperty.create.calledWith({valueMap: {}})).to.be.true;
      expect(controller.get('widgetPropertiesViews')).to.not.be.empty;
    });
  });

  describe("#parseValue()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'getExpressionData').returns({});
    });
    afterEach(function () {
      controller.getExpressionData.restore();
    });
    it("empty value", function () {
      expect(controller.parseValue("", [])).to.be.empty;
    });
    it("correct value", function () {
      expect(controller.parseValue("${m1}", [])).to.not.be.empty;
      expect(controller.getExpressionData.calledWith("m1", [])).to.be.true;
    });
  });

  describe("#getExpressionData()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'getExpressionVariable').returns({});
    });
    afterEach(function () {
      controller.getExpressionVariable.restore();
    });
    it("empty expression", function () {
      expect(controller.getExpressionData("", [])).to.be.empty;
    });
    it("correct expression", function () {
      expect(controller.getExpressionData("m1+10", [])).to.not.be.empty;
      expect(controller.getExpressionVariable.getCall(0).args).to.eql(["m1", 1, []]);
      expect(controller.getExpressionVariable.getCall(1).args).to.eql(["10", 3, []]);
    });
  });

  describe("#getExpressionVariable()", function () {
    it("get metric definition", function () {
      var metrics = [
        {
          name: 'm1',
          component_name: 'C1',
          service_name: 'S1',
          metric_path: 'mp',
          host_component_criteria: 'hcc'
        }
      ];
      expect(controller.getExpressionVariable("m1", 1, metrics)).to.be.eql(Em.Object.create({
        id: 1,
        name: 'm1',
        isMetric: true,
        componentName: 'C1',
        serviceName: 'S1',
        metricPath: 'mp',
        hostComponentCriteria: 'hcc'
      }));
    });
    it("get number definition", function () {
      expect(controller.getExpressionVariable("10", 2, [])).to.be.eql(Em.Object.create({
        id: 2,
        name: "10",
        isNumber: true
      }));
    });
  });

  describe("#next()", function () {
    beforeEach(function () {
      sinon.stub(App.router, 'send');
    });
    afterEach(function () {
      App.router.send.restore();
    });
    it("user is moved to the next step", function () {
      controller.next();
      expect(App.router.send.calledWith('next')).to.be.true;
    });
  });
});

});

require.register("test/controllers/main/service/widgets/create/step3_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');

require('controllers/main/service/widgets/create/step3_controller');


describe('App.WidgetWizardStep3Controller', function () {
  var controller = App.WidgetWizardStep3Controller.create({
    content: Em.Object.create()
  });

  App.TestAliases.testAsComputedEqual(controller, 'isEditController', 'content.controllerName', 'widgetEditController');

  App.TestAliases.testAsComputedIfThenElse(controller, 'widgetScope', 'isSharedChecked', 'Cluster', 'User');

  App.TestAliases.testAsComputedOr(controller, 'isSubmitDisabled', ['widgetNameEmpty', 'isNameInvalid', 'isDescriptionInvalid']);

  describe("#validateName", function(){
    var testCases = [
      {
        widgetName: 'abc 123 _ - %',
        result: {
          errorMessage: '',
          isNameInvalid: false
        }
      },
      {
        widgetName: '$#@!',
        result: {
          errorMessage: Em.I18n.t('widget.create.wizard.step3.name.invalidCharacter.msg'),
          isNameInvalid: true
        }
      },
      {
        widgetName: '123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789',
        result: {
          errorMessage: Em.I18n.t('widget.create.wizard.step3.name.invalid.msg'),
          isNameInvalid: true
        },
      },
      {
        widgetName: '',
        result: {
          errorMessage: '',
          isNameInvalid: false
        }
      }
    ];

    testCases.forEach(function(test) {
      it(JSON.stringify(test.widgetName), function () {
        controller.set('widgetName', test.widgetName);
        expect(controller.get('widgetNameErrorMessage')).to.equal(test.result.errorMessage);
        expect(controller.get('isNameInvalid')).to.equal(test.result.isNameInvalid);
      });
    });
  });

  describe("#validateDescription", function(){
    var testCases = [
      {
        widgetDescription: 'abc 123 _ - %',
        result: {
          errorMessage: '',
          isDescriptionInvalid: false
        }
      },
      {
        widgetDescription: '$#@!',
        result: {
          errorMessage: Em.I18n.t('widget.create.wizard.step3.description.invalidCharacter.msg'),
          isDescriptionInvalid: true
        }
      },
      {
        widgetDescription: '123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789',
        result: {
          errorMessage: Em.I18n.t('widget.create.wizard.step3.description.invalid.msg'),
          isDescriptionInvalid: true
        }
      },
      {
        widgetDescription: '',
        result: {
          errorMessage: '',
          isDescriptionInvalid: false
        }
      }
    ];

    testCases.forEach(function(test){
      it(JSON.stringify(test.widgetDescription), function () {
        controller.set('widgetDescription', test.widgetDescription);
        expect(controller.get('descriptionErrorMessage')).to.equal(test.result.errorMessage);
        expect(controller.get('isDescriptionInvalid')).to.equal(test.result.isDescriptionInvalid);
      });
    });
  });

  describe("#initPreviewData()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'addObserver');
      controller.set('content', Em.Object.create({
        widgetProperties: 'widgetProperties',
        widgetValues: 'widgetValues',
        widgetMetrics: 'widgetMetrics',
        widgetAuthor: 'widgetAuthor',
        widgetName: 'widgetName',
        widgetDescription: 'widgetDescription',
        widgetScope: 'CLUSTER',
        controllerName: 'widgetEditController'
      }));
      controller.initPreviewData();
    });
    afterEach(function () {
      controller.addObserver.restore();
    });
    it('checking observes calls', function () {
      controller.get('isSharedCheckboxDisabled') ? expect(controller.addObserver.calledWith('isSharedChecked')).to.be.false:
        expect(controller.addObserver.calledWith('isSharedChecked')).to.be.true;
    });
    it('check widgetProperties`', function () {
      expect(controller.get('widgetProperties')).to.equal('widgetProperties');
    });
    it('check widgetValues', function () {
      expect(controller.get('widgetValues')).to.equal('widgetValues');
    });
    it('check widgetMetrics', function () {
      expect(controller.get('widgetMetrics')).to.equal('widgetMetrics');
    });
    it('check widgetAuthor', function () {
      expect(controller.get('widgetAuthor')).to.equal('widgetAuthor');
    });
    it('check widgetName', function () {
      expect(controller.get('widgetName')).to.equal('widgetName');
    });
    it('check widgetDescription', function () {
      expect(controller.get('widgetDescription')).to.equal('widgetDescription');
    });
    it('check isSharedChecked', function () {
      expect(controller.get('isSharedChecked')).to.be.true;
    });
    it('check isSharedCheckboxDisabled', function () {
      expect(controller.get('isSharedCheckboxDisabled')).to.be.true;
    });
  });

  describe("#showConfirmationOnSharing()", function () {
    beforeEach(function () {
      sinon.spy(App, 'showConfirmationFeedBackPopup');
    });
    afterEach(function () {
      App.showConfirmationFeedBackPopup.restore();
    });
    it("isSharedChecked - false", function () {
      controller.set('isSharedChecked', false);
      controller.showConfirmationOnSharing();
      expect(App.showConfirmationFeedBackPopup.called).to.be.false;
    });
    it("isSharedChecked - true", function () {
      controller.set('isSharedChecked', true);
      var popup = controller.showConfirmationOnSharing();
      expect(App.showConfirmationFeedBackPopup.calledOnce).to.be.true;
      popup.onSecondary();
      expect(controller.get('isSharedChecked')).to.be.false;
      popup.onPrimary();
      expect(controller.get('isSharedChecked')).to.be.true;
    });
  });

  describe("#collectWidgetData()", function () {

    beforeEach(function () {
      controller.setProperties({
        widgetName: 'widgetName',
        content: Em.Object.create({widgetType: 'T1'}),
        widgetDescription: 'widgetDescription',
        widgetScope: 'Cluster',
        widgetAuthor: 'widgetAuthor',
        widgetMetrics: [{data: 'data', name: 'm1'}],
        widgetValues: [{computedValue: 'cv', value: 'v'}],
        widgetProperties: 'widgetProperties'
      });
    });

    it('collected widget data is valid', function () {
      var widgetData = controller.collectWidgetData();
      expect(widgetData).to.eql({
        "WidgetInfo": {
          "widget_name": "widgetName",
          "widget_type": "T1",
          "description": "widgetDescription",
          "scope": "CLUSTER",
          "author": "widgetAuthor",
          "metrics": [
            {"name": "m1" }
          ],
          "values": [
            { "value": "v" }
          ],
          "properties": "widgetProperties"
        }
      });
    });
  });

  describe("#cancel()", function () {
    var mock = {
      cancel: Em.K
    };
    beforeEach(function () {
      sinon.spy(mock, 'cancel');
      sinon.stub(App.router, 'get').returns(mock);
    });
    afterEach(function () {
      App.router.get.restore();
      mock.cancel.restore();
    });
    it('cancel is called', function () {
      controller.cancel();
      expect(mock.cancel.calledOnce).to.be.true;
    });
  });

  describe("#complete()", function () {
    var mock = {
      finishWizard: Em.K
    };
    beforeEach(function () {
      sinon.spy(mock, 'finishWizard');
      sinon.stub(controller, 'collectWidgetData');
      sinon.stub(App.router, 'get').returns(mock);
      sinon.stub(App.router, 'send');
      controller.complete();
    });
    afterEach(function () {
      App.router.get.restore();
      App.router.send.restore();
      controller.collectWidgetData.restore();
      mock.finishWizard.restore();
    });
    it('widget data is collected', function () {
      expect(controller.collectWidgetData.calledOnce).to.be.true;
    });
    it('user is moved to finish the wizard', function () {
      expect(App.router.send.calledWith('complete')).to.be.true;
    });
    it('finishWizard is called', function () {
      expect(mock.finishWizard.calledOnce).to.be.true;
    });
  });
});

});

require.register("test/controllers/main/service/widgets/create/wizard_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');

require('controllers/main/service/widgets/create/wizard_controller');


describe('App.WidgetWizardController', function () {
  var controller;

  /**
   * tests the function with following hierarchical queue scenario
   *                   root 
   *                    |
   *                  queue1
   *                 /     \
   *             queue2   queue3
   *                  
   */
  describe("#substitueQueueMetrics", function () {
    beforeEach(function () {
      controller = App.WidgetWizardController.create();
      sinon.stub(App.YARNService, 'find', function () {
        return Em.Object.create({
          'allQueueNames': ["root", "root/queue1", "root/queue1/queue2", "root/queue1/queue3"]
        });
      });
    });
    afterEach(function () {
      App.YARNService.find.restore();
    });


    var testCases = [
      {
        msg: 'AMS Queue metric with regex as name and regex as path should be replaced with actual metric name and path of all existing queues',
        inputMetrics: [
          {
            component_name: 'RESOURCEMANAGER',
            level: 'COMPONENT',
            name: 'yarn.QueueMetrics.Queue=(.+).AppsFailed',
            point_in_time: false,
            service_name: 'YARN',
            temporal: true,
            type: 'GANGLIA',
            widget_id: 'metrics/yarn/Queue/$1.replaceAll("([.])","/")/AppsFailed'
          }
        ],
        expectedResult: [
          {
            "component_name": "RESOURCEMANAGER",
            "level": "COMPONENT",
            "name": "yarn.QueueMetrics.Queue=root.AppsFailed",
            "point_in_time": false,
            "service_name": "YARN",
            "temporal": true,
            "type": "GANGLIA",
            "widget_id": "metrics/yarn/Queue/root/AppsFailed"
          },
          {
            "component_name": "RESOURCEMANAGER",
            "level": "COMPONENT",
            "name": "yarn.QueueMetrics.Queue=root.queue1.AppsFailed",
            "point_in_time": false,
            "service_name": "YARN",
            "temporal": true,
            "type": "GANGLIA",
            "widget_id": "metrics/yarn/Queue/root/queue1/AppsFailed"
          },
          {
            "component_name": "RESOURCEMANAGER",
            "level": "COMPONENT",
            "name": "yarn.QueueMetrics.Queue=root.queue1.queue2.AppsFailed",
            "point_in_time": false,
            "service_name": "YARN",
            "temporal": true,
            "type": "GANGLIA",
            "widget_id": "metrics/yarn/Queue/root/queue1/queue2/AppsFailed"
          },
          {
            "component_name": "RESOURCEMANAGER",
            "level": "COMPONENT",
            "name": "yarn.QueueMetrics.Queue=root.queue1.queue3.AppsFailed",
            "point_in_time": false,
            "service_name": "YARN",
            "temporal": true,
            "type": "GANGLIA",
            "widget_id": "metrics/yarn/Queue/root/queue1/queue3/AppsFailed"
          }
        ]
      },
      {
        msg: 'JMX Queue metric with regex as name and regex as path should be replaced with actual metric name and path of all existing queues',
        inputMetrics: [
          {
            component_name: 'RESOURCEMANAGER',
            host_component_criteria: 'host_components/HostRoles/ha_state=ACTIVE',
            level: 'HOSTCOMPONENT',
            name: 'Hadoop:service=ResourceManager,name=QueueMetrics(.+).AppsFailed',
            point_in_time: true,
            service_name: 'YARN',
            temporal: false,
            type: 'JMX',
            widget_id: 'metrics/yarn/Queue/$1.replaceAll(",q(\d+)=","/").substring(1)/AppsFailed'
          }
        ],
        expectedResult: [
          {
            component_name: 'RESOURCEMANAGER',
            host_component_criteria: 'host_components/HostRoles/ha_state=ACTIVE',
            level: 'HOSTCOMPONENT',
            name: 'Hadoop:service=ResourceManager,name=QueueMetrics,q0=root.AppsFailed',
            point_in_time: true,
            service_name: 'YARN',
            temporal: false,
            type: 'JMX',
            widget_id: 'metrics/yarn/Queue/root/AppsFailed'
          },
          {
            component_name: 'RESOURCEMANAGER',
            host_component_criteria: 'host_components/HostRoles/ha_state=ACTIVE',
            level: 'HOSTCOMPONENT',
            name: 'Hadoop:service=ResourceManager,name=QueueMetrics,q0=root,q1=queue1.AppsFailed',
            point_in_time: true,
            service_name: 'YARN',
            temporal: false,
            type: 'JMX',
            widget_id: 'metrics/yarn/Queue/root/queue1/AppsFailed'
          },
          {
            component_name: 'RESOURCEMANAGER',
            host_component_criteria: 'host_components/HostRoles/ha_state=ACTIVE',
            level: 'HOSTCOMPONENT',
            name: 'Hadoop:service=ResourceManager,name=QueueMetrics,q0=root,q1=queue1,q2=queue2.AppsFailed',
            point_in_time: true,
            service_name: 'YARN',
            temporal: false,
            type: 'JMX',
            widget_id: 'metrics/yarn/Queue/root/queue1/queue2/AppsFailed'
          },
          {
            component_name: 'RESOURCEMANAGER',
            host_component_criteria: 'host_components/HostRoles/ha_state=ACTIVE',
            level: 'HOSTCOMPONENT',
            name: 'Hadoop:service=ResourceManager,name=QueueMetrics,q0=root,q1=queue1,q2=queue3.AppsFailed',
            point_in_time: true,
            service_name: 'YARN',
            temporal: false,
            type: 'JMX',
            widget_id: 'metrics/yarn/Queue/root/queue1/queue3/AppsFailed'
          }
        ]
      },
      {
        msg: 'AMS Queue metric without regex in name and path should retain same name and path',
        inputMetrics: [
          {
            component_name: 'RESOURCEMANAGER',
            level: 'COMPONENT',
            name: 'yarn.QueueMetrics.Queue.Clustermetrics.AppsFailed',
            point_in_time: false,
            service_name: 'YARN',
            temporal: true,
            type: 'GANGLIA',
            widget_id: 'metrics/yarn/Queue/Clustermetrics/AppsFailed'
          }
        ],
        expectedResult: [
          {
            component_name: 'RESOURCEMANAGER',
            level: 'COMPONENT',
            name: 'yarn.QueueMetrics.Queue.Clustermetrics.AppsFailed',
            point_in_time: false,
            service_name: 'YARN',
            temporal: true,
            type: 'GANGLIA',
            widget_id: 'metrics/yarn/Queue/Clustermetrics/AppsFailed'
          }
        ]
      },
      {
        msg: 'JMX Queue metric without regex in name and path should retain same name and path',
        inputMetrics: [
          {
            component_name: 'RESOURCEMANAGER',
            host_component_criteria: 'host_components/HostRoles/ha_state=ACTIVE',
            level: 'HOSTCOMPONENT',
            name: 'Hadoop:service=ResourceManager,name=QueueMetrics.clusterMetric.AppsFailed',
            point_in_time: true,
            service_name: 'YARN',
            temporal: false,
            type: 'JMX',
            widget_id: 'metrics/yarn/Queue/clusterMetric/AppsFailed'
          }
        ],
        expectedResult: [
          {
            component_name: 'RESOURCEMANAGER',
            host_component_criteria: 'host_components/HostRoles/ha_state=ACTIVE',
            level: 'HOSTCOMPONENT',
            name: 'Hadoop:service=ResourceManager,name=QueueMetrics.clusterMetric.AppsFailed',
            point_in_time: true,
            service_name: 'YARN',
            temporal: false,
            type: 'JMX',
            widget_id: 'metrics/yarn/Queue/clusterMetric/AppsFailed'
          }
        ]
      }
    ];
    testCases.forEach(function (_testCase) {
      it(_testCase.msg, function () {
        var result = controller.substitueQueueMetrics(_testCase.inputMetrics);
        expect(JSON.stringify(result)).to.equal(JSON.stringify(_testCase.expectedResult));
      });
    });
  });
});

});

require.register("test/controllers/main/service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/service');

var testHelpers = require('test/helpers');
var mainServiceController;

function getController() {
  return App.MainServiceController.create({});
}

describe('App.MainServiceController', function () {

  var tests = Em.A([
    {
      isStartStopAllClicked: true,
      content: Em.A([
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'HIVE',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'HDFS',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'TEZ',
          isClientsOnly: true
        })
      ]),
      eStart: true,
      eStop: true,
      mStart: 'mainServiceController StartAll is Disabled 2',
      mStop: 'mainServiceController StopAll is Disabled 2'
    },
    {
      isStartStopAllClicked: false,
      content: Em.A([
        Em.Object.create({
          healthStatus: 'green',
          serviceName: 'HIVE',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'HDFS',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'TEZ',
          isClientsOnly: true
        })
      ]),
      eStart: false,
      eStop: false,
      mStart: 'mainServiceController StartAll is Enabled 3',
      mStop: 'mainServiceController StopAll is Enabled 3'
    }

  ]);
  beforeEach(function() {
    mainServiceController = getController();
  });

  afterEach(function () {
    mainServiceController.destroy();
  });

  App.TestAliases.testAsComputedNotEqual(getController(), 'isStartStopAllClicked', 'App.router.backgroundOperationsController.allOperationsCount', 0);

  describe('#isStartAllDisabled', function () {
    tests.forEach(function (test) {
      it(test.mStart, function () {
        mainServiceController = App.MainServiceController.create({
          content: test.content,
          isStartStopAllClicked: test.isStartStopAllClicked
        });
        expect(mainServiceController.get('isStartAllDisabled')).to.equals(test.eStart);
      });
    });
  });

  describe('#isStopAllDisabled', function () {
    tests.forEach(function (test) {
      it(test.mStop, function () {
        mainServiceController = App.MainServiceController.create({
          content: test.content,
          isStartStopAllClicked: test.isStartStopAllClicked
        });
        expect(mainServiceController.get('isStopAllDisabled')).to.equals(test.eStop);
      });
    });
  });

  describe("#isAllServicesInstalled", function() {

    beforeEach(function() {
      this.mock = sinon.stub(App.ServiceSimple, 'find');
    });
    afterEach(function() {
      App.ServiceSimple.find.restore();
    });

    it("content is null", function() {
      mainServiceController.reopen({
        'content': null
      });
      this.mock.returns([]);
      mainServiceController.propertyDidChange('isAllServicesInstalled');
      expect(mainServiceController.get('isAllServicesInstalled')).to.be.false;
    });

    it("content is empty", function() {
      mainServiceController.reopen({
        'content': []
      });
      this.mock.returns([
        {serviceName: 'S1', doNotShowAndInstall: false}
      ]);
      mainServiceController.propertyDidChange('isAllServicesInstalled');
      expect(mainServiceController.get('isAllServicesInstalled')).to.be.false;
    });

    it("content match stack services", function() {
      mainServiceController.reopen({
        'content': [Em.Object.create({serviceName: 'S1'})]
      });
      this.mock.returns([
        {serviceName: 'S1', doNotShowAndInstall: false}
      ]);
      mainServiceController.propertyDidChange('isAllServicesInstalled');
      expect(mainServiceController.get('isAllServicesInstalled')).to.be.true;
    });
    it("content doesn't match stack services", function() {
      mainServiceController.reopen({
        'content': [Em.Object.create({serviceName: 'S1'})]
      });
      this.mock.returns([
        {serviceName: 'S1', doNotShowAndInstall: false},
        {serviceName: 'S1', doNotShowAndInstall: false}
      ]);
      mainServiceController.propertyDidChange('isAllServicesInstalled');
      expect(mainServiceController.get('isAllServicesInstalled')).to.be.false;
    });
  });

  describe('#cluster', function() {

    Em.A([
      {
        isLoaded: true,
        cluster: [],
        m: 'cluster is loaded',
        e: {name: 'c1'}
      },
      {
        isLoaded: false,
        cluster: [],
        m: 'cluster is not loaded',
        e: null
      }
    ]).forEach(function(test) {
        describe(test.m, function() {

          beforeEach(function () {
            sinon.stub(App.router, 'get', function(k) {
              if ('clusterController.isClusterDataLoaded' === k) return test.isLoaded;
              return Em.get(App.router, k);
            });
            sinon.stub(App.Cluster, 'find', function() {
              return [test.e];
            });
          });

          afterEach(function () {
            App.router.get.restore();
            App.Cluster.find.restore();
          });

          it('cluster is valid', function () {
            var c = mainServiceController.get('cluster');
            expect(c).to.eql(test.e);
          });

        });
      });

  });

  describe('#startAllService', function() {

    beforeEach(function() {
      sinon.stub(mainServiceController, 'allServicesCall', Em.K);
    });

    afterEach(function() {
      mainServiceController.allServicesCall.restore();
    });

    it('target is disabled', function() {
      var event = {target: {className: 'disabled', nodeType: 1}};
      var r = mainServiceController.startAllService(event);
      expect(r).to.be.null;
    });

    it('parent is disabled', function() {
      var event = {target: {parentElement: {className: 'disabled', nodeType: 1}}};
      var r = mainServiceController.startAllService(event);
      expect(r).to.be.null;
    });

  });

  describe('#stopAllService', function() {

    beforeEach(function() {
      sinon.stub(mainServiceController, 'allServicesCall', Em.K);
    });

    afterEach(function() {
      mainServiceController.allServicesCall.restore();
    });

    it('target is disabled', function() {
      var event = {target: {className: 'disabled', nodeType: 1}};
      var r = mainServiceController.stopAllService(event);
      expect(r).to.be.null;
    });

    it('parent is disabled', function() {
      var event = {target: {parentElement: {className: 'disabled', nodeType: 1}}};
      var r = mainServiceController.stopAllService(event);
      expect(r).to.be.null;
    });

  });

  describe('#startStopAllService', function() {
    var event = { target: document.createElement("BUTTON") };

    beforeEach(function() {
      sinon.stub(mainServiceController, 'allServicesCall', Em.K);
      sinon.spy(Em.I18n, "t");
    });

    afterEach(function() {
      mainServiceController.allServicesCall.restore();
      Em.I18n.t.restore();
    });

    it ("should confirm stop if state is INSTALLED", function() {
      mainServiceController.startStopAllService(event, "INSTALLED");
      expect(Em.I18n.t.calledWith('services.service.stopAll.confirmMsg')).to.be.ok;
      expect(Em.I18n.t.calledWith('services.service.stop.confirmButton')).to.be.ok;
    });

    describe("should check last checkpoint for NN before confirming stop", function() {
      var mainServiceItemController;
      beforeEach(function() {
        mainServiceItemController = App.MainServiceItemController.create({});
        sinon.stub(mainServiceItemController, 'checkNnLastCheckpointTime', function() {
          return true;
        });
        sinon.stub(App.router, 'get', function(k) {
          if ('mainServiceItemController' === k) {
            return mainServiceItemController;
          }
          return Em.get(App.router, k);
        });
        sinon.stub(App.Service, 'find', function() {
          return [{
            serviceName: "HDFS",
            workStatus: "STARTED"
          }];
        });
      });

      afterEach(function () {
        mainServiceItemController.checkNnLastCheckpointTime.restore();
        App.router.get.restore();
        App.Service.find.restore();
      });

      it('checkNnLastCheckpointTime is called once', function () {
        mainServiceController.startStopAllService(event, "INSTALLED");
        expect(mainServiceItemController.checkNnLastCheckpointTime.calledOnce).to.equal(true);
      });

    });

    it ("should confirm start if state is not INSTALLED", function() {
      mainServiceController.startStopAllService(event, "STARTED");
      expect(Em.I18n.t.calledWith('services.service.startAll.confirmMsg')).to.be.ok;
      expect(Em.I18n.t.calledWith('services.service.start.confirmButton')).to.be.ok;
    });
  });

  describe('#allServicesCall', function() {

    var state = 'STARTED',
      query = 'some query';

    beforeEach(function() {
      sinon.stub(App, 'get', function(k) {
        if ('clusterName' === k) return 'tdk';
        return Em.get(App, k);
      });
      mainServiceController.allServicesCall(state, query);
      var args = testHelpers.findAjaxRequest('name', 'common.services.update');
      this.params = App.ajax.fakeGetUrl('common.services.update').format(args[0].data);
      this.data = JSON.parse(this.params.data);
    });

    afterEach(function() {
      App.get.restore();
    });

    it('PUT request is sent', function() {
      expect(this.params.type).to.equal('PUT');
    });
    it('Body.ServiceInfo.state is ' + state, function() {
      expect(this.data.Body.ServiceInfo.state).to.equal(state);
    });
    it('RequestInfo.context is ' + query, function() {
      expect(this.data.RequestInfo.context).to.equal(App.BackgroundOperationsController.CommandContexts.START_ALL_SERVICES);
    });

  });

  describe('#allServicesCallErrorCallback', function() {

    it('should set status to FAIL', function() {
      var params = {query: Em.Object.create({status: ''})};
      mainServiceController.allServicesCallErrorCallback({}, {}, '', {}, params);
      expect(params.query.get('status')).to.equal('FAIL');
    });

  });

  describe('#gotoAddService', function() {

    beforeEach(function() {
      sinon.stub(App.router, 'transitionTo', Em.K);
    });

    afterEach(function() {
      App.router.transitionTo.restore();
    });

    it('should not go to wizard', function() {
      mainServiceController.reopen({isAllServicesInstalled: true});
      mainServiceController.gotoAddService();
      expect(App.router.transitionTo.called).to.be.false;
    });

    it('should go to wizard', function() {
      mainServiceController.reopen({isAllServicesInstalled: false});
      mainServiceController.gotoAddService();
      expect(App.router.transitionTo.calledWith('main.serviceAdd')).to.be.true;
    });

  });

  App.TestAliases.testAsComputedEveryBy(getController(), 'isRestartAllRequiredDisabled', 'content', 'isRestartRequired', false);

  describe('#restartAllRequired', function () {

    beforeEach(function () {
      sinon.spy(App, 'showConfirmationPopup');
      sinon.spy(mainServiceController, 'restartHostComponents');
      sinon.stub(App.Service, 'find', function() {
        return [
          Em.Object.create({
            displayName: 'displayName1',
            isRestartRequired: true
          }),
          Em.Object.create({
            displayName: 'displayName2',
            isRestartRequired: true
          }),
          Em.Object.create({
            displayName: 'displayName3',
            isRestartRequired: false
          })
        ];
      });
    });

    afterEach(function () {
      App.Service.find.restore();
      App.showConfirmationPopup.restore();
      mainServiceController.restartHostComponents.restore();
    });

    it('should show confirmation popup with list of services and call restartHostComponents after confirmation', function () {
      var popup;
      mainServiceController.reopen({
        isRestartAllRequiredDisabled: false
      });
      popup = mainServiceController.restartAllRequired();
      popup.onPrimary();
      expect(App.showConfirmationPopup.args[0][1]).to.equal(Em.I18n.t('services.service.refreshAll.confirmMsg').format('displayName1, displayName2'));
      expect(mainServiceController.restartHostComponents.calledOnce).to.be.true;
    });

    it('should not open popup if isRestartAllRequiredDisabled is true', function(){
      mainServiceController.reopen({
        isRestartAllRequiredDisabled: true
      });
      expect(mainServiceController.restartAllRequired()).to.be.null;
    });

  });

  describe("#restartAllServices()", function() {

    beforeEach(function() {
      sinon.stub(mainServiceController, 'silentStopAllServices');
    });
    afterEach(function() {
      mainServiceController.silentStopAllServices.restore();
    });

    it("silentStopAllServices should be called", function() {
      mainServiceController.restartAllServices();
      expect(mainServiceController.silentStopAllServices.calledOnce).to.be.true;
    });
  });

  describe("#silentStopAllServices()", function() {

    it("App.ajax.send should be called", function() {
      mainServiceController.silentStopAllServices();
      var args = testHelpers.filterAjaxRequests('name', 'common.services.update');
      expect(args[0][0]).to.eql({
        name: 'common.services.update',
        sender: mainServiceController,
        data: {
          context: App.BackgroundOperationsController.CommandContexts.STOP_ALL_SERVICES,
          ServiceInfo: {
            state: 'INSTALLED'
          }
        },
        success: 'silentStopSuccess',
        showLoadingPopup: true
      });
    });
  });

  describe("#isStopAllServicesFailed()", function() {

    beforeEach(function() {
      this.mock = sinon.stub(App.Service, 'find');
    });
    afterEach(function() {
      this.mock.restore();
    });

    it("one INSTALLED service", function() {
      this.mock.returns([
        Em.Object.create({workStatus: 'INSTALLED'})
      ]);
      expect(mainServiceController.isStopAllServicesFailed()).to.be.false;
    });

    it("one STOPPING service", function() {
      this.mock.returns([
        Em.Object.create({workStatus: 'STOPPING'})
      ]);
      expect(mainServiceController.isStopAllServicesFailed()).to.be.false;
    });

    it("one STARTED service and one INSTALLED", function() {
      this.mock.returns([
        Em.Object.create({workStatus: 'STARTED'}),
        Em.Object.create({workStatus: 'INSTALLED'})
      ]);
      expect(mainServiceController.isStopAllServicesFailed()).to.be.true;
    });

    it("one STARTED service", function() {
      this.mock.returns([
        Em.Object.create({workStatus: 'STARTED'})
      ]);
      expect(mainServiceController.isStopAllServicesFailed()).to.be.true;
    });
  });

  describe("#silentStopSuccess()", function() {
    var mock = {
      dataLoading: function() {
        return {
          done: function(callback) {
            callback(true);
          }
        }
      },
      showPopup: Em.K
    };

    beforeEach(function() {
      sinon.stub(App.router, 'get').returns(mock);
      sinon.stub(Em.run, 'later', Em.clb);
      sinon.spy(mock, 'showPopup');
      sinon.stub(mainServiceController, 'silentStartAllServices');
      mainServiceController.silentStopSuccess();
    });
    afterEach(function() {
      App.router.get.restore();
      Em.run.later.restore();
      mock.showPopup.restore();
      mainServiceController.silentStartAllServices.restore();
    });

    it("showPopup should be called", function() {
      expect(mock.showPopup.calledOnce).to.be.true;
    });

    it("Em.run.later should be called", function() {
      expect(Em.run.later.calledOnce).to.be.true;
      expect(mainServiceController.get('shouldStart')).to.be.true;
    });
  });

  describe("#silentStartAllServices()", function() {

    beforeEach(function() {
      this.mockRouter = sinon.stub(App.router, 'get');
      this.mock = sinon.stub(mainServiceController, 'isStopAllServicesFailed');
      mainServiceController.removeObserver('shouldStart', mainServiceController, 'silentStartAllServices');
    });
    afterEach(function() {
      this.mockRouter.restore();
      this.mock.restore();
    });

    it("allOperationsCount is 1", function() {
      this.mockRouter.returns(Em.Object.create({
        allOperationsCount: 1
      }));
      mainServiceController.silentStartAllServices();
      expect(testHelpers.findAjaxRequest('name', 'common.services.update')).to.be.undefined;
    });

    it("shouldStart is false", function() {
      this.mockRouter.returns(Em.Object.create({
        allOperationsCount: 0
      }));
      mainServiceController.set('shouldStart', false);
      mainServiceController.silentStartAllServices();
      expect(testHelpers.findAjaxRequest('name', 'common.services.update')).to.be.undefined;
    });

    it("isStopAllServicesFailed returns true", function() {
      this.mockRouter.returns(Em.Object.create({
        allOperationsCount: 0
      }));
      mainServiceController.set('shouldStart', true);
      this.mock.returns(true);
      mainServiceController.silentStartAllServices();
      expect(testHelpers.findAjaxRequest('name', 'common.services.update')).to.be.undefined;
    });

    it("App.ajax.send should be called", function() {
      this.mockRouter.returns(Em.Object.create({
        allOperationsCount: 0
      }));
      mainServiceController.set('shouldStart', true);
      this.mock.returns(false);
      mainServiceController.silentStartAllServices();
      var args = testHelpers.filterAjaxRequests('name', 'common.services.update');
      expect(args[0][0]).to.be.eql({
        name: 'common.services.update',
        sender: mainServiceController,
        data: {
          context: App.BackgroundOperationsController.CommandContexts.START_ALL_SERVICES,
          ServiceInfo: {
            state: 'STARTED'
          }
        },
        success: 'silentCallSuccessCallback',
        showLoadingPopup: true
      });
      expect(mainServiceController.get('shouldStart')).to.be.false;
    });
  });

  describe("#silentCallSuccessCallback()", function () {
    var mock = {
      dataLoading: function () {
        return {
          done: function (callback) {
            callback(true);
          }
        }
      },
      showPopup: Em.K
    };

    beforeEach(function () {
      sinon.stub(App.router, 'get').returns(mock);
      sinon.spy(mock, 'showPopup');
    });
    afterEach(function () {
      App.router.get.restore();
      mock.showPopup.restore();
    });

    it("showPopup should be called", function () {
      mainServiceController.silentCallSuccessCallback();
      expect(mock.showPopup.calledOnce).to.be.true;
    });
  });

  describe("#allServicesCallSuccessCallback()", function () {
    var mock = {
      dataLoading: function () {
        return {
          done: function (callback) {
            callback(true);
          }
        }
      },
      showPopup: Em.K
    };

    beforeEach(function () {
      sinon.stub(App.router, 'get').returns(mock);
      sinon.spy(mock, 'showPopup');
    });
    afterEach(function () {
      App.router.get.restore();
      mock.showPopup.restore();
    });

    it("showPopup should be called", function () {
      var params = {
        query: Em.Object.create()
      };
      mainServiceController.allServicesCallSuccessCallback({}, {}, params);
      expect(mock.showPopup.calledOnce).to.be.true;
      expect(params.query.get('status')).to.be.equal('SUCCESS');
    });
  });

  describe("#restartAllRequiredSuccessCallback()", function () {
    var mock = {
      dataLoading: function () {
        return {
          done: function (callback) {
            callback(true);
          }
        }
      },
      showPopup: Em.K
    };

    beforeEach(function () {
      sinon.stub(App.router, 'get').returns(mock);
      sinon.spy(mock, 'showPopup');
    });
    afterEach(function () {
      App.router.get.restore();
      mock.showPopup.restore();
    });

    it("showPopup should be called", function () {
      mainServiceController.restartAllRequiredSuccessCallback();
      expect(mock.showPopup.calledOnce).to.be.true;
    });
  });
});

});

require.register("test/controllers/main/views_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/views_controller');
var testHelpers = require('test/helpers');

var mainViewsController;
describe('MainViewsController', function () {

  beforeEach(function () {
    mainViewsController = App.MainViewsController.create();
  });

  describe('#loadAmbariViews()', function () {
    beforeEach(function () {
      this.stub = sinon.stub(App.router, 'get');
    });
    afterEach(function () {
      App.router.get.restore();
    });

    it('should load views if the user is logged in', function () {
      this.stub.withArgs('loggedIn').returns(true);
      mainViewsController.loadAmbariViews();
      var args = testHelpers.findAjaxRequest('name', 'views.info');
      expect(args).to.exists;
    });

    it('should not load views if the user is not logged in', function () {
      this.stub.withArgs('loggedIn').returns(false);
      mainViewsController.loadAmbariViews();
      var args = testHelpers.findAjaxRequest('name', 'views.info');
      expect(args).to.not.exists;
    })
  });

  describe('#loadAmbariViewsSuccess()', function () {

    it('data has items', function () {
      mainViewsController.loadAmbariViewsSuccess({items: [{}]});
      var args = testHelpers.findAjaxRequest('name', 'views.instances');
      expect(args).to.exists;
    });

    it('data is empty', function () {
      mainViewsController.loadAmbariViewsSuccess({items: []});
      var args = testHelpers.findAjaxRequest('name', 'views.instances');
      expect(args).to.not.exists;
      expect(mainViewsController.get('ambariViews')).to.be.empty;
      expect(mainViewsController.get('isDataLoaded')).to.be.true;
    });
  });

  describe('#loadAmbariViewsError()', function () {

    it('ambariViews should be empty', function () {
      mainViewsController.loadAmbariViewsError();
      expect(mainViewsController.get('ambariViews')).to.be.empty;
      expect(mainViewsController.get('isDataLoaded')).to.be.true;
    });
  });

  describe("#loadViewInstancesSuccess()", function () {

    var data = {
      items: [
        {
          versions: [
            {
              instances: [
                {
                  ViewInstanceInfo: {
                    icon_path: 'icon_path1',
                    label: 'label1',
                    visible: true,
                    version: '1.0',
                    description: 'desc1',
                    viewName: 'view_name1',
                    instanceName: 'instance_name1',
                    context_path: 'path1'
                  }
                }
              ]
            }
          ]
        }
      ]
    };

    var viewInstanceFields = {
      iconPath: 'icon_path1',
      label: 'label1',
      visible: true,
      version: '1.0',
      description: 'desc1',
      href: 'path1/'
    };
    
    beforeEach(function () {
      mainViewsController.loadViewInstancesSuccess(data);
    });

    it('one view instance is parsed', function () {
      expect(mainViewsController.get('ambariViews.length')).to.be.equal(1);
    });


    Object.keys(viewInstanceFields).forEach(function (fieldName) {
      it(JSON.stringify(fieldName) + ' is set correctly', function () {
        expect(mainViewsController.get('ambariViews.firstObject.' + fieldName)).to.be.equal(viewInstanceFields[fieldName]);
      });
    });


    it('`isDataLoaded` is set `true` when view instances are parsed', function () {
      expect(mainViewsController.get('isDataLoaded')).to.be.true;
    });
  });

  describe('#loadViewInstancesError()', function () {

    it('ambariViews should be empty', function () {
      mainViewsController.loadViewInstancesError();
      expect(mainViewsController.get('ambariViews')).to.be.empty;
      expect(mainViewsController.get('isDataLoaded')).to.be.true;
    });
  });

  describe("#setView", function () {

    beforeEach(function () {
      sinon.stub(App.router, 'route');
    });
    afterEach(function () {
      App.router.route.restore();
    });

    it("no context", function () {
      mainViewsController.setView({});
      expect(App.router.route.called).to.be.false;
    });

    it("context exist", function () {
      mainViewsController.setView({
        context: App.ViewInstance.create({
          viewName: 'view1',
          version: '1',
          instanceName: 'instance1'
        })
      });
      expect(App.router.route.calledWith('main/views/view1/1/instance1')).to.be.true;
    });
  });

});

});

require.register("test/controllers/main_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');

describe('App.MainController', function () {
  var mainController = App.MainController.create();

  describe('#getServerVersionSuccessCallback', function () {

    var controller = App.MainController.create(),
      cases = [
        {
          osFamily: 'redhat5',
          expected: false
        },
        {
          osFamily: 'redhat6',
          expected: true
        },
        {
          osFamily: 'suse11',
          expected: false
        }
      ],
      title = 'App.isManagedMySQLForHiveEnabled should be {0} for {1}';

    cases.forEach(function (item) {
      it(title.format(item.expected, item.osFamily), function () {
        controller.getServerVersionSuccessCallback({
          'RootServiceComponents': {
            'component_version': '',
            'properties': {
              'server.os_family': item.osFamily
            }
          }
        });
        expect(App.get('isManagedMySQLForHiveEnabled')).to.equal(item.expected);
      });
    });
  });

  App.TestAliases.testAsComputedAlias(mainController, 'isClusterDataLoaded', 'App.router.clusterController.isLoaded', 'boolean');

  App.TestAliases.testAsComputedAlias(mainController, 'clusterDataLoadedPercent', 'App.router.clusterController.clusterDataLoadedPercent', 'string');

  describe('#initialize', function() {
    var initialize = false;
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns({
        loadClusterData: function() {
          initialize = true;
        }
      });
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it ('Should return true', function() {
      mainController.initialize();
      expect(initialize).to.be.true;
    });
  });

  describe('#dataLoading', function() {

    beforeEach(function () {
      this.stub = sinon.stub(App.router, 'get');
    });

    afterEach(function () {
      this.stub.restore();
    });

    it ('Should resolve promise', function() {
      this.stub.returns(true);
      var deffer = mainController.dataLoading();
      deffer.then(function(val){
        expect(val).to.be.undefined;
      });
    });
    it ('Should resolve promise (2)', function(done) {
      this.stub.returns(false);
      
      setTimeout(function() {
        mainController.set('isClusterDataLoaded', true);
      },150);

      var deffer = mainController.dataLoading();
      deffer.then(function(val){
        expect(val).to.be.undefined;
        done();
      });
    });
  });

  describe('#checkServerClientVersion', function() {
    beforeEach(function () {
      sinon.stub(mainController, 'getServerVersion').returns({
        done: function(func) {
          if (func) {
            func();
          }
        }
      });
    });
    afterEach(function () {
      mainController.getServerVersion.restore();
    });
    it ('Should resolve promise', function() {
      var deffer = mainController.checkServerClientVersion();
      deffer.then(function(val){
        expect(val).to.be.undefined;
      });
    });
  });

  describe('#getServerVersion', function() {

    it ('Should send data', function() {
      mainController.getServerVersion();
      var args = testHelpers.findAjaxRequest('name', 'ambari.service');
      expect(args[0]).to.exists;
      expect(args[0].sender).to.be.eql(mainController);
      expect(args[0].data.fields).to.be.equal('?fields=RootServiceComponents/component_version,RootServiceComponents/properties/server.os_family&minimal_response=true');
    });
  });

  describe('#updateTitle', function() {
    beforeEach(function () {
      sinon.stub(App.router, 'get').withArgs('clusterController.clusterName').returns('c1')
        .withArgs('clusterInstallCompleted').returns(true)
        .withArgs('clusterController').returns({
          get: function() {
            return true;
          }
        });
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it('Should update title', function() {
      $('body').append('<title id="title-id">text</title>');
      mainController.updateTitle();
      expect($('title').text()).to.be.equal('Ambari - c1');
      $('body').remove('#title-id');
    });
  });

});

});

require.register("test/controllers/wizard/step0_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/cluster_states');
require('controllers/wizard/step0_controller');
var wizardStep0Controller;

describe('App.WizardStep0Controller', function () {

  beforeEach(function() {
    wizardStep0Controller = App.WizardStep0Controller.create({content: {cluster: {}}});
    sinon.stub(App.clusterStatus, 'set', Em.K);
    sinon.stub(App.router, 'send', Em.K);
    App.set('router.nextBtnClickInProgress', false);
  });

  afterEach(function() {
    App.clusterStatus.set.restore();
    App.router.send.restore();
    App.set('router.nextBtnClickInProgress', false);
  });

  describe('#invalidClusterName', function () {
    it('should return true if no cluster name is present', function () {
      wizardStep0Controller.set('hasSubmitted', true);
      wizardStep0Controller.set('content', {'cluster':{'name':''}});
      expect(wizardStep0Controller.get('invalidClusterName')).to.equal(true);
    });
    it('should return true if cluster name contains white spaces', function () {
      wizardStep0Controller.set('hasSubmitted', true);
      wizardStep0Controller.set('content', {'cluster':{'name':'the cluster'}});
      expect(wizardStep0Controller.get('invalidClusterName')).to.equal(true);
    });
    it('should return true if cluster name contains special chars', function () {
      wizardStep0Controller.set('hasSubmitted', true);
      wizardStep0Controller.set('content', {'cluster':{'name':'$cluster'}});
      expect(wizardStep0Controller.get('invalidClusterName')).to.equal(true);
    })
  });

  describe('#loadStep', function() {
    it('should clear step data', function() {
      wizardStep0Controller.loadStep();
      expect(wizardStep0Controller.get('hasSubmitted')).to.equal(false);
      expect(wizardStep0Controller.get('clusterNameError')).to.equal('');
    });
  });

  describe('#submit', function() {
    it('if cluster name is valid should proceed', function() {
      wizardStep0Controller.set('content.cluster.name', 'tdk');
      wizardStep0Controller.submit();
      expect(wizardStep0Controller.get('content.cluster.status')).to.equal('PENDING');
      expect(wizardStep0Controller.get('content.cluster.isCompleted')).to.equal(false);
      expect(App.router.send.calledWith('next')).to.equal(true);
      expect(App.clusterStatus.set.calledWith('clusterName', 'tdk')).to.equal(true);
    });

    it('if cluster name isn\'t valid shouldn\'t proceed', function() {
      wizardStep0Controller.set('content.cluster.name', '@@@@');
      wizardStep0Controller.submit();
      expect(App.router.send.called).to.equal(false);
      expect(App.clusterStatus.set.called).to.equal(false);
    });
    it('if Next button is clicked multiple times before the next step renders, it must not be processed', function() {
      wizardStep0Controller.set('content.cluster.name', 'tdk');
      wizardStep0Controller.submit();
      expect(App.router.send.calledWith('next')).to.equal(true);

      App.router.send.reset();
      wizardStep0Controller.submit();
      expect(App.router.send.called).to.equal(false);
    });
  });

});

});

require.register("test/controllers/wizard/step10_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var App = require('app');
require('controllers/wizard/step10_controller');

var controller;

function getController() {
  return App.WizardStep10Controller.create({
    content: {cluster: {controllerName: '', status: 'INSTALL COMPLETE'}}
  });
}

describe('App.WizardStep10Controller', function () {

  beforeEach(function() {
    controller = getController();
  });

  afterEach(function() {
    controller.clearStep();
  });

  App.TestAliases.testAsComputedEqual(getController(), 'isAddServiceWizard', 'content.controllerName', 'addServiceController');

  describe('#clearStep', function() {
    it('should clear clusterInfo', function() {
      controller.get('clusterInfo').pushObject({});
      controller.clearStep();
      expect(controller.get('clusterInfo.length')).to.equal(0);
    });
  });

  describe('#loadStep', function() {
    beforeEach(function() {
      sinon.spy(controller, 'clearStep');
      sinon.stub(controller, 'loadRegisteredHosts', Em.K);
      sinon.stub(controller, 'loadInstalledHosts', Em.K);
      sinon.stub(controller, 'loadInstallTime', Em.K);
    });
    afterEach(function() {
      controller.clearStep.restore();
      controller.loadRegisteredHosts.restore();
      controller.loadInstalledHosts.restore();
      controller.loadInstallTime.restore();
    });
    it('should call clearStep', function() {
      controller.loadStep();
      expect(controller.clearStep.calledOnce).to.equal(true);
    });
    it('should call loadInstalledHosts', function() {
      controller.loadStep();
      expect(controller.loadInstalledHosts.calledOnce).to.equal(true);
    });
    it('should loadInstallTime if not installerController', function() {
      controller.set('content.controllerName', 'addServiceController');
      controller.loadStep();
      expect(controller.loadInstallTime.calledOnce).to.equal(true);
    });
    var testsForLoadInstallTime = Em.A([
      {
        loadMasterComponents: true,
        loadStartedServices: true,
        e: true
      },
      {
        loadMasterComponents: true,
        loadStartedServices: false,
        e: false
      },
      {
        loadMasterComponents: false,
        loadStartedServices: false,
        e: false
      },
      {
        loadMasterComponents: false,
        loadStartedServices: false,
        e: false
      }
    ]);
    testsForLoadInstallTime.forEach(function(test) {
      describe('loadMasterComponents: ' + test.loadMasterComponents.toString() + ' loadStartedServices: ' + test.loadStartedServices.toString(), function() {

        beforeEach(function () {
          controller.set('content.controllerName', 'installerController');
          sinon.stub(controller, 'loadMasterComponents', function() {return test.loadMasterComponents;});
          sinon.stub(controller, 'loadStartedServices', function() {return test.loadStartedServices;});
          controller.loadStep();
        });

        afterEach(function () {
          controller.loadMasterComponents.restore();
          controller.loadStartedServices.restore();
        });

        it('loadInstallTime was ' + (test.e ? '' : 'not') + ' called', function () {
          expect(controller.loadInstallTime.called).to.equal(test.e);
        });

      });
    });
  });

  describe('#loadInstalledHosts', function() {
    var tests = Em.A([
      {
        hosts: {
          'h1': Em.Object.create({status: 'success', tasks: []}),
          'h2': Em.Object.create({status: 'success', tasks: []}),
          'h3': Em.Object.create({status: 'success', tasks: []})
        },
        m: 'all success',
        e: Em.A([
          {id: 1, l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({status: 'warning', tasks: []}),
          'h2': Em.Object.create({status: 'failed', tasks: []}),
          'h3': Em.Object.create({status: 'failed', tasks: []})
        },
        m: 'some failed, some warning',
        e: Em.A([
          {id: 2, l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({status: 'failed', tasks: []}),
          'h2': Em.Object.create({status: 'success', tasks: []}),
          'h3': Em.Object.create({status: 'warning', tasks: []})
        },
        m: 'sone failed, some success, some warning',
        e: Em.A([
          {id: 1, l: 1},
          {id: 2, l: 2}
        ])
      }
    ]);
    tests.forEach(function(test) {
      describe(test.m, function() {

        beforeEach(function () {
          controller.set('content.hosts', test.hosts);
          controller.set('clusterInfo', Em.A([Em.Object.create({id: 1, status: []})]));
          controller.loadInstalledHosts();
        });

        test.e.forEach(function(ex) {
          it(JSON.stringify(test.e), function () {
            var displayStatement = controller.get('clusterInfo').findProperty('id', 1).get('status').findProperty('id', ex.id).get('displayStatement');
            expect(displayStatement.contains(ex.l)).to.equal(true);
          });
        });
      })
    });
    var testsForFailedTasks = Em.A([
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'FAILED'}},
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h3': Em.Object.create({status: 'failed', tasks: []})
        },
        m: 'only failed tasks',
        e: Em.A([
          {st: 'failed', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h3': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          })
        },
        m: 'only timedout tasks',
        e: Em.A([
          {st: 'timedout', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'failed',
            tasks: []
          }),
          'h2': Em.Object.create({
            status: 'failed',
            tasks: []
          }),
          'h3': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}}
            ]
          })
        },
        m: 'only aborted tasks',
        e: Em.A([
          {st: 'aborted', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'FAILED'}},
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h3': Em.Object.create({status: 'warning', tasks: []})
        },
        m: 'only failed tasks, warning hosts',
        e: Em.A([
          {st: 'failed', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h3': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          })
        },
        m: 'only timedout tasks, warning hosts',
        e: Em.A([
          {st: 'timedout', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'warning',
            tasks: []
          }),
          'h2': Em.Object.create({
            status: 'warning',
            tasks: []
          }),
          'h3': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}}
            ]
          })
        },
        m: 'only aborted tasks, warning hosts',
        e: Em.A([
          {st: 'aborted', l: 3}
        ])
      }
    ]);
    testsForFailedTasks.forEach(function(test) {
      describe(test.m, function() {

        beforeEach(function () {
          controller.set('content.hosts', test.hosts);
          controller.set('clusterInfo', Em.A([Em.Object.create({id: 1, status: []})]));
          controller.loadInstalledHosts();
        });

        test.e.forEach(function(ex) {
          it(JSON.stringify(test.e), function () {
            var tasksWithNeededStatements = controller.get('clusterInfo').findProperty('id', 1).get('status').findProperty('id', 2).get('statements').filterProperty('status', ex.st);
            expect(tasksWithNeededStatements.length).to.equal(ex.l);
          });
        });
      })
    });
  });

  describe('#loadMasterComponent', function() {
    var tests = Em.A([
      {
        component: Em.Object.create({hostName: 'h1'}),
        e: 1
      },
      {
        component: Em.Object.create({}),
        e: 0
      }
    ]);

    tests.forEach(function(test) {
      it(test.component.get('hostName') ? 'Has hosNBame' : 'Doesn\'t have hostName', function() {
        controller.clearStep();
        controller.get('clusterInfo').pushObject(Em.Object.create({id: 2, status: []}));
        controller.loadMasterComponent(test.component);
        expect(controller.get('clusterInfo').findProperty('id', 2).get('status').length).to.equal(test.e);
      })
    });
  });

  describe('#loadStartedServices', function() {
    var tests = Em.A([
      {
        status: 'STARTED',
        e: {
          ids: [3, 4],
          r: true
        }
      },
      {
        status: 'FAILED',
        e: {
          ids: [3],
          r: false
        }
      },
      {
        status: 'START_SKIPPED',
        e: {
          ids: [3],
          r: false
        }
      }
    ]);
    tests.forEach(function(test) {
      it(test.status, function() {
        controller.set('content', {cluster: {status: test.status}});
        var r = controller.loadStartedServices();
        expect(r).to.equal(test.e.r);
        expect(controller.get('clusterInfo').mapProperty('id')).to.eql(test.e.ids);
      });
    });
  });

  describe('#loadInstallTime', function() {
    var tests = Em.A([
      {
        installTime: 123,
        e: [5]
      },
      {
        installTime: null,
        e: []
      }
    ]);

    tests.forEach(function(test) {
      it('Install time' + test.installTime ? ' available' : ' not available', function() {
        controller.set('content', {cluster: {installTime: test.installTime}});
        controller.loadInstallTime();
        expect(controller.get('clusterInfo').mapProperty('id')).to.eql(test.e);
      });
    });
  });

  describe('#calculateInstallTime', function () {
    it('from "9.21" to 9 minutes 12 seconds', function () {
      expect(controller.calculateInstallTime('9.21')).to.eql({minutes: 9, seconds: 12});
    });
    it('from "0" to 0 minutes 0 seconds', function () {
      expect(controller.calculateInstallTime('0')).to.eql({minutes: 0, seconds: 0});
    });
    it('from "10" to 10 minutes 0 seconds', function () {
      expect(controller.calculateInstallTime('10')).to.eql({minutes: 10, seconds: 0});
    });
    it('from "0.5" to 0 minutes 30 seconds', function () {
      expect(controller.calculateInstallTime('0.5')).to.eql({minutes: 0, seconds: 30});
    });
  });

  describe('#loadMasterComponents', function() {

    var components = Em.A(['NAMENODE','SECONDARY_NAMENODE','JOBTRACKER','HISTORYSERVER','RESOURCEMANAGER','HBASE_MASTER','HIVE_SERVER','OOZIE_SERVER','GANGLIA_SERVER']);

    d3.range(1, components.length).forEach(function(i) {
      d3.range(1, i).forEach(function(j) {
        var c = components.slice(0, j);
        it(c.join(', '), function() {
          var m = c.map(function(component){return {component: component, displayName: component, hostName: 'h1'};});
          controller.set('content.masterComponentHosts', m);
          controller.loadMasterComponents();
          expect(controller.get('clusterInfo').findProperty('id', 2).get('status').length).to.equal(m.length);
        });
      });
    });

  });

  describe('#loadRegisteredHosts', function() {
    var masterComponentHosts = [{hostName: 'h1'}, {hostName: 'h2'}, {hostName: 'h3'}],
      slaveComponentHosts = [{hosts: [{hostName: 'h1'}, {hostName: 'h4'}]}, {hosts: [{hostName: 'h2'}, {hostName: 'h5'}]}],
      hosts = [{hostName: 'h6'}, {hostName: 'h3'}, {hostName: 'h7'}];
    var obj;
    beforeEach(function () {
      controller.set('content.masterComponentHosts', masterComponentHosts);
      controller.set('content.slaveComponentHosts', slaveComponentHosts);
      controller.set('clusterInfo', []);
      sinon.stub(App.Host, 'find', function() {
        return hosts;
      });
      obj = controller.loadRegisteredHosts();
    });

    afterEach(function () {
      App.Host.find.restore();
    });

    it('id  = 1', function() {
      expect(obj.id).to.equal(1);
    });
    it('color = text-info', function () {
      expect(obj.color).to.equal('text-info');
    });
    it('displayStatement is valid', function () {
      expect(obj.displayStatement).to.equal(Em.I18n.t('installer.step10.hostsSummary').format(7));
    });
    it('status is []', function () {
      expect(obj.status).to.eql([]);
    });
    it('clusterInfo.firstObject is valid', function () {
      expect(controller.get('clusterInfo.firstObject')).to.eql(obj);
    });
  });

});

});

require.register("test/controllers/wizard/step1_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var wizardStep1Controller;

var stacks = [
  App.Stack.createRecord({
    "id": "HDP-2.4",
    "stackName": "HDP",
    "stackVersion": "2.4"
  }),
  App.Stack.createRecord({
    "id": "HDP-2.5-2.5.0.0",
    "stackName": "HDP",
    "stackVersion": "2.5"
  }),
  App.Stack.createRecord({
    "id": "HDP-2.5",
    "stackName": "HDP",
    "stackVersion": "2.5"
  }),
  App.Stack.createRecord({
    "id": "HDP-2.3.ECS",
    "stackName": "HDP",
    "stackVersion": "2.3.ECS"
  }),
  App.Stack.createRecord({
    "id": "HDP-2.3",
    "stackName": "HDP",
    "stackVersion": "2.3"
  }),
  App.Stack.createRecord({
    "id": "HDP-2.2",
    "stackName": "HDP",
    "stackVersion": "2.2"
  }),
  App.Stack.createRecord({
    "id": "HDP-2.4-2.4.1.1-12345",
    "stackName": "HDP",
    "stackVersion": "2.4"
  })
];

function getController() {
  return App.WizardStep1Controller.create({content: Em.Object.create({stacks: stacks}), onNetworkIssuesExist: Em.K});
}

describe('App.WizardStep1Controller', function () {

  beforeEach(function() {
    wizardStep1Controller = getController();
  });

  App.TestAliases.testAsComputedFindBy(getController(), 'selectedStack', 'content.stacks', 'isSelected', true);

  App.TestAliases.testAsComputedFindBy(getController(), 'selectedStackType', 'availableStackTypes', 'isSelected', true);

  App.TestAliases.testAsComputedFilterBy(getController(), 'servicesForSelectedStack', 'selectedStack.stackServices', 'isHidden', false);

  App.TestAliases.testAsComputedEveryBy(getController(), 'networkIssuesExist', 'content.stacks', 'stackDefault', true);

  describe('#usePublicRepo', function () {

    beforeEach(function () {
      wizardStep1Controller.get('content.stacks').findProperty('id', 'HDP-2.5-2.5.0.0').setProperties({
        isSelected: true,
        useRedhatSatellite: true,
        usePublicRepo: false,
        useLocalRepo: true,
      });
      wizardStep1Controller.usePublicRepo();
    });

    it('correct stack is selected', function () {
      expect(wizardStep1Controller.get('selectedStack.id')).to.be.equal('HDP-2.5-2.5.0.0');
    });

    it('`useRedhatSatellite` is set `false`', function () {
      expect(wizardStep1Controller.get('selectedStack.useRedhatSatellite')).to.be.false;
    });

    it('`usePublicRepo` is set `true`', function () {
      expect(wizardStep1Controller.get('selectedStack.usePublicRepo')).to.be.true;
    });

    it('`useLocalRepo` is set `false`', function () {
      expect(wizardStep1Controller.get('selectedStack.useLocalRepo')).to.be.false;
    });

  });

  describe('#useLocalRepo', function () {

    beforeEach(function () {
      wizardStep1Controller.get('content.stacks').findProperty('id', 'HDP-2.5-2.5.0.0').setProperties({
        isSelected: true,
        usePublicRepo: true,
        useLocalRepo: false,
      });
      wizardStep1Controller.useLocalRepo();
    });

    it('correct stack is selected', function () {
      expect(wizardStep1Controller.get('selectedStack.id')).to.be.equal('HDP-2.5-2.5.0.0');
    });

    it('`usePublicRepo` is set `false`', function () {
      expect(wizardStep1Controller.get('selectedStack.usePublicRepo')).to.be.false;
    });

    it('`useLocalRepo` is set `true`', function () {
      expect(wizardStep1Controller.get('selectedStack.useLocalRepo')).to.be.true;
    });

  });

  describe('#selectStackBy', function () {

    it('select by `id`', function () {
      wizardStep1Controller.selectStackBy('id', 'HDP-2.5-2.5.0.0');
      expect(wizardStep1Controller.get('selectedStack.id')).to.be.equal('HDP-2.5-2.5.0.0');
      expect(wizardStep1Controller.get('content.stacks').filterProperty('isSelected')).to.have.property('length').equal(1);
    });

    it('select by `stackNameVersion`', function () {
      wizardStep1Controller.selectStackBy('stackNameVersion', 'HDP-2.5');
      expect(wizardStep1Controller.get('selectedStack.id')).to.be.equal('HDP-2.5-2.5.0.0'); // `HDP-2.5-2.5.0.0`-id is before `HDP-2.5`-id
      expect(wizardStep1Controller.get('content.stacks').filterProperty('isSelected')).to.have.property('length').equal(1);
    });

  });

  describe('#availableStackTypes', function () {

    it('stack types are sorted desc', function () {
      expect(wizardStep1Controller.get('availableStackTypes').mapProperty('stackName')).to.be.eql(['HDP-2.5', 'HDP-2.4', 'HDP-2.3.ECS', 'HDP-2.3', 'HDP-2.2']);
    });

  });

  describe('#readInfoIsNotProvided', function () {

    Em.A([
      {
        options: {
          uploadFile: {isSelected: false},
          enterUrl: {isSelected: false}
        },
        m: 'url and file are not selected',
        e: false
      },
      {
        options: {
          uploadFile: {isSelected: false},
          enterUrl: {isSelected: true, url: ''}
        },
        m: 'url is selected but not provided',
        e: true
      },
      {
        options: {
          uploadFile: {isSelected: false},
          enterUrl: {isSelected: true, url: ' url'}
        },
        m: 'url is selected and provided',
        e: false
      },
      {
        options: {
          uploadFile: {isSelected: true, file: ''},
          enterUrl: {isSelected: false}
        },
        m: 'file is selected but not provided',
        e: true
      },
      {
        options: {
          uploadFile: {isSelected: true, file: 'path'},
          enterUrl: {isSelected: false}
        },
        m: 'file is selected and provided',
        e: false
      }
    ]).forEach(function (test) {

      it(test.m, function () {
        wizardStep1Controller.set('optionsToSelect.useLocalRepo', test.options);
        expect(wizardStep1Controller.get('readInfoIsNotProvided')).to.be.equal(test.e);
      });

    });

  });

  describe('#uploadVdf', function () {

    function getModal() {
      var controller = getController();
      controller.set('optionsToSelect', Em.Object.create({
        useLocalRepo: {
          enterUrl: {isSelected: true, url: 'apache.org'},
          uploadFile: {isSelected: false, file: 'some_file'}
        }
      }));
      return controller.uploadVdf();
    }

    beforeEach(function () {
      this.modal = getModal();
    });

    describe('#restoreUploadOptions', function () {

      beforeEach(function () {
        wizardStep1Controller.set('optionsToSelect.useLocalRepo', {
          enterUrl: {isSelected: true, url: 'apache.org'},
          uploadFile: {isSelected: false, file: 'some_file'}
        });
        this.modal.restoreUploadOptions();
      });

      it('`enterUrl.isSelected`', function () {
        expect(this.modal.get('controller.optionsToSelect.useLocalRepo.enterUrl.isSelected')).to.be.false;
      });

      it('`enterUrl.url`', function () {
        expect(this.modal.get('controller.optionsToSelect.useLocalRepo.enterUrl.url')).to.be.equal('');
      });

      it('`uploadFile.isSelected`', function () {
        expect(this.modal.get('controller.optionsToSelect.useLocalRepo.uploadFile.isSelected')).to.be.true;
      });

      it('`uploadFile.file`', function () {
        expect(this.modal.get('controller.optionsToSelect.useLocalRepo.uploadFile.file')).to.be.equal('');
      });

    });

    describe('#bodyClass', function () {

      beforeEach(function () {
        this.body = this.modal.get('bodyClass').create();
      });

      describe('#uploadFileView', function () {

        beforeEach(function() {
          this.fileView = this.body.get('uploadFileView').create();
        });

        describe('#click', function () {

          beforeEach(function () {
            this.fileView.set('controller', getController());
            this.fileView.set('controller.optionsToSelect', {
              useLocalRepo: {
                enterUrl: {isSelected: true, hasError: true},
                uploadFile: {isSelected: false, hasError: true}
              }
            });
            this.fileView.click();
          });

          it('`enterUrl.isSelected`', function () {
            expect(this.fileView.get('controller.optionsToSelect.useLocalRepo.enterUrl.isSelected')).to.be.false;
          });

          it('`enterUrl.hasError`', function () {
            expect(this.fileView.get('controller.optionsToSelect.useLocalRepo.enterUrl.hasError')).to.be.false;
          });

          it('`uploadFile.isSelected`', function () {
            expect(this.fileView.get('controller.optionsToSelect.useLocalRepo.uploadFile.isSelected')).to.be.true;
          });

          it('`uploadFile.hasError`', function () {
            expect(this.fileView.get('controller.optionsToSelect.useLocalRepo.uploadFile.hasError')).to.be.false;
          });

        });

      });

      describe('#enterUrlView', function () {

        beforeEach(function() {
          this.fileView = this.body.get('enterUrlView').create();
        });

        describe('#click', function () {

          beforeEach(function () {
            this.fileView.set('controller', getController());
            this.fileView.set('controller.optionsToSelect', {
              useLocalRepo: {
                enterUrl: {isSelected: false, hasError: true},
                uploadFile: {isSelected: false, hasError: true}
              }
            });
            this.fileView.click();
          });

          it('`enterUrl.isSelected`', function () {
            expect(this.fileView.get('controller.optionsToSelect.useLocalRepo.enterUrl.isSelected')).to.be.true;
          });

          it('`enterUrl.hasError`', function () {
            expect(this.fileView.get('controller.optionsToSelect.useLocalRepo.enterUrl.hasError')).to.be.false;
          });

          it('`uploadFile.isSelected`', function () {
            expect(this.fileView.get('controller.optionsToSelect.useLocalRepo.uploadFile.isSelected')).to.be.false;
          });

          it('`uploadFile.hasError`', function () {
            expect(this.fileView.get('controller.optionsToSelect.useLocalRepo.uploadFile.hasError')).to.be.false;
          });

        });

      });

    });

  })

  describe('#removeOS', function() {

    beforeEach(function () {
      wizardStep1Controller.set('selectedStack', {useRedhatSatellite: null});
    });

    [
      {
        useRedhatSatellite: false,
        e: false,
      },
      {
        useRedhatSatellite: true,
        e: true
      }
    ].forEach(function (test) {
      it('useRedhatSatellite is ' + JSON.stringify(test.useRedhatSatellite), function () {
        wizardStep1Controller.set('selectedStack.useRedhatSatellite', test.useRedhatSatellite);
        var os = {isSelected: true};
        wizardStep1Controller.removeOS({context: os})
        expect(Ember.get(os, 'isSelected')).to.be.equal(test.e);
      });
    });

  });

  describe('#addOS', function() {

    it('should set `isSelected` to true', function () {
      var os = {isSelected: false};
      wizardStep1Controller.addOS({context: os})
      expect(Ember.get(os, 'isSelected')).to.be.true;
    });

  });

  describe('#onNetworkIssuesExist', function () {

    beforeEach(function () {
      this.controller = App.WizardStep1Controller.create({content: Em.Object.create({stacks: stacks})});
      this.controller.get('content.stacks').setEach('usePublicRepo', true);
      this.controller.get('content.stacks').setEach('useLocalRepo', false);
      this.controller.reopen({networkIssuesExist: true});
      this.controller.onNetworkIssuesExist();
    });

    it('each stack has `usePublicRepo` false', function() {
      expect(this.controller.get('content.stacks').everyProperty('usePublicRepo', false)).to.be.true;
    });

    it('each stack has `useLocalRepo` true', function() {
      expect(this.controller.get('content.stacks').everyProperty('useLocalRepo', true)).to.be.true;
    });

  });

});

});

require.register("test/controllers/wizard/step2_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/wizard/step2_controller');
require('models/host');
require('models/host_component');
require('messages');
var testHelpers = require('test/helpers');
var c;

function getController() {
  return App.WizardStep2Controller.create({content: {controllerName: ''}});
}

describe('App.WizardStep2Controller', function () {

  var userErrorTests = Em.A([
    {
      manualInstall: false,
      user: '',
      sshPort:'',
      e: ''
    },
    {
      manualInstall: true,
      user: '',
      sshPort:'',
      e: null
    },
    {
      manualInstall: true,
      user: 'nobody',
      sshPort:'123',
      e: null
    },
    {
      manualInstall: false,
      user: 'nobody',
      sshPort:'123',
      e: null
    }
  ]);


  beforeEach(function() {
    c = getController();
  });

  App.TestAliases.testAsComputedEqual(getController(), 'isInstaller', 'content.controllerName', 'installerController');

  App.TestAliases.testAsComputedAlias(getController(), 'manualInstall', 'content.installOptions.manualInstall', 'boolean');

  App.TestAliases.testAsComputedAlias(getController(), 'sshKey', 'content.installOptions.sshKey', 'string');

  App.TestAliases.testAsComputedAlias(getController(), 'sshUser', 'content.installOptions.sshUser', 'string');

  App.TestAliases.testAsComputedAlias(getController(), 'sshPort', 'content.installOptions.sshPort', 'string');

  App.TestAliases.testAsComputedAlias(getController(), 'agentUser', 'content.installOptions.agentUser', 'string');

  App.TestAliases.testAsComputedOr(getController(), 'isSubmitDisabled', ['hostsError', 'sshKeyError', 'sshUserError', 'sshPortError', 'agentUserError', 'App.router.btnClickInProgress']);

  describe('#hostNames', function() {
    it('should be equal to content.installOptions.hostNames', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {hostNames: 'A,b,C'}}});
      expect(controller.get('hostNames')).to.equal('a,b,c');
      controller.set('content.installOptions.hostNames', 'a,B');
      expect(controller.get('hostNames')).to.equal('a,b');
    });
  });

  App.TestAliases.testAsComputedIfThenElse(getController(), 'installType', 'manualInstall', 'manualDriven', 'ambariDriven');

  describe('#updateHostNameArr()', function () {

    var controller = App.WizardStep2Controller.create({
      hostNames: 'apache.ambari'
    });
    controller.updateHostNameArr();

    it('should push to hostNameArr only new host names', function(){
      expect(controller.get('hostNameArr').length).to.equal(1);
    });

    it('should push to inputtedAgainHostNames already installed host names', function(){
      expect(controller.get('inputtedAgainHostNames').length).to.equal(0);
    })
  });

  describe('#isAllHostNamesValid()', function () {

    var controller = App.WizardStep2Controller.create({
      hostNames: ''
    });

    it('should return true if all host names are valid', function(){
      controller.set('hostNames', 'amache.org ambari.com');
      expect(controller.isAllHostNamesValid()).to.equal(true);
    });

    var tests = Em.A([
      'hostname',
      '-hostname.com',
      'hostname-.com',
      'host_name.com',
      '123.123.123.123',
      'hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname',
      'hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostname'
    ]);
    tests.forEach(function (test) {
      it('should return false for invalid host names ' + test + ' ', function () {
        controller.set('hostNames', test);
        expect(controller.isAllHostNamesValid()).to.equal(false);
      });
    });
  });

  describe('#checkHostError()', function () {

    var controller = App.WizardStep2Controller.create();

    it('should set hostsError if hostNames is ""', function () {
      controller.set('content', {'installOptions': {'hostNames': ''}});
      controller.checkHostError();
      expect(controller.get('hostsError').length).to.be.above(2);
    });

    it('should set hostsError to null if hostNames is valid', function () {
      controller.set('content', {'installOptions': {'hostNames': 'ambari'}});
      controller.checkHostError();
      expect(controller.get('hostsError')).to.equal(null);
    })
  });

  describe('#checkHostAfterSubmitHandler()', function () {

    it('should be called after changing hasSubmitted', function (done) {
      var controller = App.WizardStep2Controller.create({
        checkHostError: function () {
          done();
        }
      });
      controller.set('hasSubmitted', true);
    });

    it('should be called after changing hostNames', function (done) {
      var controller = App.WizardStep2Controller.create({
        hasSubmitted: true,
        checkHostError: function () {
          done();
        }
      });
      controller.set('content', {'installOptions': {'hostNames': 'ambari'}});
    })
  });

  describe('#sshKeyError', function () {

    var tests = Em.A([
      {
        manualInstall: false,
        sshKey: '',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: true,
        sshKey: '',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: true,
        sshKey: 'nobody',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: false,
        sshKey: 'nobody',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: false,
        sshKey: '',
        hasSubmitted: true,
        e: null
      },
      {
        manualInstall: true,
        sshKey: '',
        hasSubmitted: true,
        e: null
      },
      {
        manualInstall: true,
        sshKey: 'nobody',
        hasSubmitted: true,
        e: null
      },
      {
        manualInstall: false,
        sshKey: 'nobody',
        hasSubmitted: true,
        e: null
      }
    ]);

    tests.forEach(function(test) {
      it(test.sshKey + ' ' + test.manualInstall.toString() + ' ' + test.hasSubmitted.toString(), function() {
        var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: test.manualInstall, sshKey: test.sshKey}}});
        if(Em.isNone(test.e)) {
          expect(controller.get('sshKeyError')).to.equal(null);
        }
        else {
          expect(controller.get('sshKeyError').length).to.be.above(2);
        }
      });
    });
  });

  describe('#sshUserError', function () {

    userErrorTests.forEach(function(test) {
      it(JSON.stringify(test), function() {
        var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: test.manualInstall, sshUser: test.user}}});
        if(Em.isNone(test.e)) {
          expect(controller.get('sshUserError')).to.equal(null);
        }
        else {
          expect(controller.get('sshUserError').length).to.be.above(2);
        }
      });
    });

  });

  describe('#sshPortError', function () {

      userErrorTests.forEach(function(test) {
          it(JSON.stringify(test), function() {
              var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: test.manualInstall, sshPort: test.sshPort}}});
              if(Em.isNone(test.e)) {
                  expect(controller.get('sshPortError')).to.equal(null);
              }
              else {
                  expect(controller.get('sshPortError').length).to.be.above(2);
              }
          });
      });

  });

  describe('#agentUserError', function () {

    beforeEach(function () {
      this.stub = sinon.stub(App, 'get');
    });

    afterEach(function () {
      App.get.restore();
    });

    userErrorTests.forEach(function(test) {
      it('Ambari Agent user account customize enabled', function() {
        this.stub.withArgs('supports.customizeAgentUserAccount').returns(true);
        var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: test.manualInstall, agentUser: test.user}}});
        if(Em.isNone(test.e)) {
          expect(controller.get('agentUserError')).to.be.null;
        }
        else {
          expect(controller.get('agentUserError').length).to.be.above(2);
        }
      });
    });

    userErrorTests.forEach(function(test) {
      it('Ambari Agent user account customize disabled', function() {
        this.stub.withArgs('supports.customizeAgentUserAccount').returns(false);
        var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: test.manualInstall, agentUser: test.user}}});
        expect(controller.get('agentUserError')).to.be.null;
      });
    });

  });

  describe('#getHostInfo()', function () {

    it('should return object with bootStatus, installType and name for every element in hostNameArr', function () {
      var controller = App.WizardStep2Controller.create({
        hostNameArr: ['apache', 'ambari'],
        installType: 'manualDriven'
      });

      var test = controller.getHostInfo();
      expect(test).to.eql({
        'apache':{'name':'apache', 'installType': 'manualDriven', 'bootStatus': 'PENDING', isInstalled: false},
        'ambari':{'name':'ambari', 'installType': 'manualDriven', 'bootStatus': 'PENDING', isInstalled: false}
      });
    })
  });

  describe('#setSshKey()', function () {

    it('should set content.installOptions.sshKey', function () {
      var controller = App.WizardStep2Controller.create({
        content: {'installOptions': {'sshKey': '111'}}
      });
      controller.setSshKey('222');
      expect(controller.get('content.installOptions.sshKey')).to.equal('222');
    })
  });

  describe('#evaluateStep()', function () {

    it('should return false if isSubmitDisabled is true', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        parseHostNamesAsPatternExpression: Em.K
      });
      controller.reopen({isSubmitDisabled: true});
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if hostsError is not empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        parseHostNamesAsPatternExpression: Em.K
      });
      controller.set('hostsError', 'error');
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if sshKeyError is not empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        parseHostNamesAsPatternExpression: Em.K
      });
      controller.reopen({sshKeyError: 'error'});
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if sshUserError is not empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        parseHostNamesAsPatternExpression: Em.K
      });
      controller.reopen({sshUserError: 'error'});
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if sshPortError is not empty', function () {
        var controller = App.WizardStep2Controller.create({
            hostNames: 'apache.ambari',
            parseHostNamesAsPatternExpression: Em.K
        });
        controller.reopen({sshPortError: 'error'});
        expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if agentUserError is not empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        parseHostNamesAsPatternExpression: Em.K
      });
      controller.reopen({agentUserError: 'error'});
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if hostNameArr is empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: '',
        parseHostNamesAsPatternExpression: Em.K
      });
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if isPattern is true', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        isPattern: true,
        parseHostNamesAsPatternExpression: Em.K
      });
      expect(controller.evaluateStep()).to.equal(false);
    })
  });

  describe('#parseHostNamesAsPatternExpression()', function () {

    it('should parse hosts from pattern expression to hostNameArr', function () {
      var controller = App.WizardStep2Controller.create({
        hostNameArr: ['host[001-011]']
      });
      controller.parseHostNamesAsPatternExpression();
      var result = true;
      var hosts = controller.get('hostNameArr');
      for (var i = 1; i<12; i++) {
        var extra = i.toString().length === 1 ? 0 : '';
        if (hosts[i-1] !== 'host0' + extra + i) {
          result = false;
        }
      }
      expect(result).to.equal(true);
    });

    it('should parse hosts from multiple pattern expression to hostNameArr', function () {
      var controller = App.WizardStep2Controller.create({
        hostNameArr: ['test[1-2]host[01-05]']
      });
      controller.parseHostNamesAsPatternExpression();
      var hosts = controller.get('hostNameArr');
      expect(hosts).eql([
          'test1host01',
          'test1host02',
          'test1host03',
          'test1host04',
          'test1host05',
          'test2host01',
          'test2host02',
          'test2host03',
          'test2host04',
          'test2host05'
      ]);
    });

    it('should skip duplicates', function () {
      var controller = App.WizardStep2Controller.create({
        hostNameArr: ['host[1-3]', 'host2']
      });
      controller.parseHostNamesAsPatternExpression();
      expect(controller.get('hostNameArr')).to.eql(['host1', 'host2', 'host3']);
    });

  });

  describe('#proceedNext()', function () {

    beforeEach(function () {
      sinon.stub(c, 'warningPopup', Em.K);
      sinon.stub(c, 'manualInstallPopup', Em.K);
      sinon.stub(App.router, 'send', Em.K);
    });

    afterEach(function () {
      c.warningPopup.restore();
      c.manualInstallPopup.restore();
      App.router.send.restore();
    });

    it('should call warningPopup if not isAllHostNamesValid and no warningConfirmed', function() {
      c.reopen({
        isAllHostNamesValid: function() {
          return false;
        }
      });
      var r = c.proceedNext(false);
      expect(r).to.equal(false);
      expect(c.warningPopup.calledOnce).to.equal(true);
    });

    it('should call manualInstallPopup if manualInstall is true', function () {
      c.reopen({
        hostNames: '',
        manualInstall: true
      });
      var r = c.proceedNext(true);
      expect(r).to.equal(false);
      expect(c.manualInstallPopup.calledOnce).to.equal(true);
    });

    it ('should save hosts and proceed next if manualInstall is false', function() {
      c.reopen({
        hostNameArr: ['h1'],
        manualInstall: false,
        isAllHostNamesValid: function() {return true;},
        content: {
          installOptions: {},
          hosts: null
        }
      });
      var r = c.proceedNext();
      expect(r).to.equal(true);
      expect(Em.keys(c.get('content.hosts'))).to.eql(['h1']);
      expect(App.router.send.calledWith('next')).to.equal(true);
    });

  });

  describe('#installedHostsPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(c, 'proceedNext', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      c.proceedNext.restore();
    });
    it('should call App.ModalPopup.show', function() {
      c.installedHostsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should proceed next on primary', function() {
      c.installedHostsPopup().onPrimary();
      expect(c.proceedNext.calledOnce).to.equal(true);
    });
  });

  describe('#warningPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(c, 'proceedNext', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      c.proceedNext.restore();

    });
    it('should call App.ModalPopup.show', function() {
      c.warningPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should proceed next on primary', function() {
      c.warningPopup().onPrimary();
      expect(c.proceedNext.calledWith(true)).to.equal(true);
    });
  });

  describe('#hostNamePatternPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(c, 'proceedNext', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      c.proceedNext.restore();
    });
    it('should call App.ModalPopup.show', function() {
      c.hostNamePatternPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should proceed next on primary', function() {
      c.hostNamePatternPopup().onPrimary();
      expect(c.proceedNext.calledOnce).to.equal(true);
    });
  });

  describe('#manualInstallPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(App.router, 'send', Em.K);
      sinon.stub(c, 'saveHosts', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      App.router.send.restore();
      c.saveHosts.restore();
    });
    it('should call App.ModalPopup.show', function() {
      c.manualInstallPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should save hosts and go next on primary', function() {
      c.manualInstallPopup().onPrimary();
      expect(c.saveHosts.calledOnce).to.equal(true);
      expect(App.router.send.calledWith('next')).to.equal(true);
    });
  });

  describe('#manualInstallWarningPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
    });
    it('should call App.ModalPopup.show if content.installOptions.useSsh is false', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {useSsh: false}}});
      controller.manualInstallWarningPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('shouldn\'t call App.ModalPopup.show if content.installOptions.useSsh is true', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {useSsh: true}}});
      controller.manualInstallWarningPopup();
      expect(App.ModalPopup.show.called).to.equal(false);
    });
  });

  describe('#setAmbariJavaHome', function() {

    it('should do ajax-request', function() {
      var controller = App.WizardStep2Controller.create({onGetAmbariJavaHomeSuccess: Em.K, onGetAmbariJavaHomeError: Em.K});
      controller.setAmbariJavaHome();
      var args = testHelpers.findAjaxRequest('name', 'ambari.service');
      expect(args).exists;
    });
  });

  describe('#onGetAmbariJavaHomeSuccess', function() {
    it('should set java.home value receiced from server', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {}}});
      var test = {RootServiceComponents: {properties: {'java.home': '/root'}}};
      controller.onGetAmbariJavaHomeSuccess(test);
      expect(controller.content.installOptions.javaHome).to.equal('/root');
    });
  });

  describe('#onGetAmbariJavaHomeError', function() {
    it('should set default java.home value', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {}}});
      controller.onGetAmbariJavaHomeError();
      expect(controller.content.installOptions.javaHome).to.equal(App.get('defaultJavaHome'));
    });
  });

  describe('#saveHosts', function() {
    beforeEach(function() {
      sinon.stub(c, 'setAmbariJavaHome', Em.K);
      c.reopen({
        hostNameArr: ['h1'],
        content: {
          hosts: null
        }
      });
    });
    afterEach(function() {
      c.setAmbariJavaHome.restore();
    });
    it('should call setAmbariJavaHome', function() {
      c.saveHosts();
      expect(c.setAmbariJavaHome.calledOnce).to.equal(true);
    });
    it('should set content.hosts', function() {
      c.saveHosts();
      expect(Em.keys(c.get('content.hosts'))).to.eql(['h1']);
    });
  });

});

});

require.register("test/controllers/wizard/step3_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var c;
require('utils/ajax/ajax');
require('utils/http_client');
require('models/host');
require('controllers/wizard/step3_controller');
var testHelpers = require('test/helpers');

function getController() {
  return App.WizardStep3Controller.create({
    content: Em.Object.create({installedHosts: Em.A([]), installOptions: {}, controllerName: ''}),
    wizardController: App.InstallerController.create(),
    setRegistrationInProgressOnce: Em.K,
    disablePreviousSteps: Em.K
  });
}

describe('App.WizardStep3Controller', function () {

  beforeEach(function () {

    c = getController();

    sinon.stub(App.db, 'getDisplayLength', Em.K);
    sinon.stub(App.db, 'getFilterConditions').returns([]);
    sinon.stub(App.router, 'send', Em.K);
    App.set('router.nextBtnClickInProgress', false);
  });

  afterEach(function () {
    App.db.getDisplayLength.restore();
    App.router.send.restore();
    App.db.getFilterConditions.restore();
    App.set('router.nextBtnClickInProgress', false);
  });

  App.TestAliases.testAsComputedGt(getController(), 'isHostHaveWarnings', 'warnings.length', 0);

  App.TestAliases.testAsComputedEqual(getController(), 'isAddHostWizard', 'content.controllerName', 'addHostController');

  App.TestAliases.testAsComputedIfThenElse(getController(), 'registrationTimeoutSecs', 'content.installOptions.manualInstall', 15, 120);

  App.TestAliases.testAsComputedAnd(getController(), 'isWarningsLoaded', ['isJDKWarningsLoaded', 'isHostsWarningsLoaded']);

  describe('#getAllRegisteredHostsCallback', function () {

    it('One host is already in the cluster, one host is registered', function () {
      c.get('content.installedHosts').pushObject({
        name: 'wst3_host1'
      });
      c.reopen({
        bootHosts: [
          Em.Object.create({name: 'wst3_host1'}),
          Em.Object.create({name: 'wst3_host2'})
        ]
      });
      var testData = {
        items: [
          {
            Hosts: {
              host_name: 'wst3_host1'
            }
          },
          {
            Hosts: {
              host_name: 'wst3_host2'
            }
          },
          {
            Hosts: {
              host_name: 'wst3_host3'
            }
          }
        ]
      };
      c.getAllRegisteredHostsCallback(testData);
      expect(c.get('hasMoreRegisteredHosts')).to.equal(true);
      expect(c.get('registeredHosts').length).to.equal(1);
    });

    it('All hosts are new', function () {
      c.get('content.installedHosts').pushObject({
        name: 'wst3_host1'
      });
      c.reopen({
        bootHosts: [
          {name: 'wst3_host3'},
          {name: 'wst3_host4'}
        ]
      });
      var testData = {
        items: [
          {
            Hosts: {
              host_name: 'wst3_host3'
            }
          },
          {
            Hosts: {
              host_name: 'wst3_host4'
            }
          }
        ]
      };
      c.getAllRegisteredHostsCallback(testData);
      expect(c.get('hasMoreRegisteredHosts')).to.equal(false);
      expect(c.get('registeredHosts')).to.equal('');
    });

    it('No new hosts', function () {
      c.get('content.installedHosts').pushObject({
        name: 'wst3_host1'
      });
      c.reopen({
        bootHosts: [
          {name: 'wst3_host1'}
        ]
      });
      var testData = {
        items: [
          {
            Hosts: {
              host_name: 'wst3_host1'
            }
          }
        ]
      };
      c.getAllRegisteredHostsCallback(testData);
      expect(c.get('hasMoreRegisteredHosts')).to.equal(false);
      expect(c.get('registeredHosts')).to.equal('');
    });

  });

  describe('#isWarningsBoxVisible', function () {

    it('for "real" mode should be based on isRegistrationInProgress', function () {
      c.set('isRegistrationInProgress', false);
      expect(c.get('isWarningsBoxVisible')).to.equal(true);
      c.set('isRegistrationInProgress', true);
      expect(c.get('isWarningsBoxVisible')).to.equal(false);
    });

  });

  describe('#clearStep', function () {

    it('should clear hosts', function () {
      c.set('hosts', [
        {},
        {}
      ]);
      c.clearStep();
      expect(c.get('hosts')).to.eql([]);
    });

    it('should clear bootHosts', function () {
      c.set('bootHosts', [
        {},
        {}
      ]);
      c.clearStep();
      expect(c.get('bootHosts').length).to.equal(0);
    });

    it('should set stopBootstrap to false', function () {
      c.set('stopBootstrap', true);
      c.clearStep();
      expect(c.get('stopBootstrap')).to.equal(false);
    });

    it('should set wizardController DBProperty bootStatus to false', function () {
      c.get('wizardController').setDBProperty('bootStatus', true);
      c.clearStep();
      expect(c.get('wizardController').getDBProperty('bootStatus')).to.equal(false);
    });

    it('should set isSubmitDisabled to true', function () {
      c.set('isSubmitDisabled', false);
      c.clearStep();
      expect(c.get('isSubmitDisabled')).to.equal(true);
    });

  });

  describe('#loadStep', function () {

    beforeEach(function () {
      sinon.stub(App.router, 'get').withArgs('clusterController').returns({
        loadAmbariProperties: Em.K
      });
      sinon.spy(c, 'clearStep');
      sinon.stub(c, 'loadHosts', Em.K);
      sinon.stub(c, 'disablePreviousSteps', Em.K);
    });

    afterEach(function () {
      App.router.get.restore();
      c.clearStep.restore();
      c.disablePreviousSteps.restore();
      c.loadHosts.restore();
    });

    it('should set registrationStartedAt to null', function () {
      c.set('registrationStartedAt', {});
      c.loadStep();
      expect(c.get('registrationStartedAt')).to.be.null;
    });

    it('should call clearStep', function () {
      c.loadStep();
      expect(c.get('clearStep').calledOnce).to.equal(true);
    });

    it('should call loadHosts', function () {
      c.loadStep();
      expect(c.get('loadHosts').calledOnce).to.equal(true);
    });

    it('should call disablePreviousSteps', function () {
      c.loadStep();
      expect(c.get('disablePreviousSteps').calledOnce).to.equal(true);
    });

  });

  describe('#loadHosts', function () {

    beforeEach(function () {
      sinon.stub(c, 'navigateStep');
    });

    afterEach(function () {
      c.navigateStep.restore();
    });

    it('should set bootStatus DONE on "real" mode and when installOptions.manualInstall is selected', function () {
      c.set('content.installOptions', {manualInstall: true});
      c.set('content.hosts', {c: {name: 'name'}});
      c.loadHosts();
      expect(c.get('hosts').everyProperty('bootStatus', 'DONE')).to.equal(true);
    });

    it('should set bootStatus PENDING on "real" mode and when installOptions.manualInstall is not selected', function () {
      c.set('content', {installOptions: {manualInstall: false}, hosts: {c: {name: 'name'}}});
      c.loadHosts();
      expect(c.get('hosts').everyProperty('bootStatus', 'PENDING')).to.equal(true);
    });

    it('should set bootStatus PENDING on "real" mode and when installOptions.manualInstall is not selected (2)', function () {
      c.set('content', {hosts: {c: {name: 'name'}, d: {name: 'name1'}}});
      c.loadHosts();
      expect(c.get('hosts').everyProperty('isChecked', false)).to.equal(true);
    });

  });

  describe('#parseHostInfo', function () {

    var tests = Em.A([
      {
        bootHosts: Em.A([
          Em.Object.create({name: 'c1', bootStatus: 'REGISTERED', bootLog: ''}),
          Em.Object.create({name: 'c2', bootStatus: 'REGISTERING', bootLog: ''}),
          Em.Object.create({name: 'c3', bootStatus: 'RUNNING', bootLog: ''})
        ]),
        hostsStatusFromServer: Em.A([
          {hostName: 'c1', status: 'REGISTERED', log: 'c1'},
          {hostName: 'c2', status: 'REGISTERED', log: 'c2'},
          {hostName: 'c3', status: 'RUNNING', log: 'c3'}
        ]),
        m: 'bootHosts not empty, hostsStatusFromServer not empty, one is RUNNING',
        e: {
          c: true,
          r: true
        }
      },
      {
        bootHosts: Em.A([]),
        hostsStatusFromServer: Em.A([
          {hostName: 'c1', status: 'REGISTERED', log: 'c1'},
          {hostName: 'c2', status: 'REGISTERED', log: 'c2'},
          {hostName: 'c3', status: 'RUNNING', log: 'c3'}
        ]),
        m: 'bootHosts is empty',
        e: {
          c: false,
          r: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({name: 'c1', bootStatus: 'REGISTERED', bootLog: ''}),
          Em.Object.create({name: 'c2', bootStatus: 'REGISTERING', bootLog: ''}),
          Em.Object.create({name: 'c3', bootStatus: 'REGISTERED', bootLog: ''})
        ]),
        hostsStatusFromServer: Em.A([
          {hostName: 'c1', status: 'REGISTERED', log: 'c1'},
          {hostName: 'c2', status: 'REGISTERED', log: 'c2'},
          {hostName: 'c3', status: 'REGISTERED', log: 'c3'}
        ]),
        m: 'bootHosts not empty, hostsStatusFromServer not empty, no one is RUNNING',
        e: {
          c: true,
          r: false
        }
      }
    ]);

    tests.forEach(function (test) {
      describe(test.m, function () {
        var r;
        beforeEach(function () {
          c.set('bootHosts', test.bootHosts);
          r = c.parseHostInfo(test.hostsStatusFromServer);
        });

        it('parsed hosts info is valid', function () {
          expect(r).to.equal(test.e.r);
        });

        if (test.e.c) {
          test.hostsStatusFromServer.forEach(function (h) {

            it('bootStatus and bootLog are valid', function () {
              var bootHosts = c.get('bootHosts').findProperty('name', h.hostName);
              if (!['REGISTERED', 'REGISTERING'].contains(bootHosts.get('bootStatus'))) {
                expect(bootHosts.get('bootStatus')).to.equal(h.status);
                expect(bootHosts.get('bootLog')).to.equal(h.log);
              }
            });

          });
        }
      });
    });
  });

  describe('#removeHosts', function () {

    beforeEach(function () {
      sinon.spy(App, 'showConfirmationPopup');
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it('should call App.showConfirmationPopup', function () {
      c.removeHosts(Em.A([]));
      expect(App.showConfirmationPopup.calledOnce).to.equal(true);
    });

    it('primary should disable Submit if no more hosts', function () {
      var hosts = [
        {}
      ];
      c.set('hosts', hosts);
      c.removeHosts(hosts).onPrimary();
      expect(c.get('isSubmitDisabled')).to.equal(true);
    });

  });

  describe('#removeSelectedHosts', function () {

    beforeEach(function () {
      sinon.stub(c, 'removeHosts', Em.K);
    });

    afterEach(function () {
      c.removeHosts.restore();
    });

    it('should remove selected hosts', function () {
      c.set('hosts', [
        {isChecked: true, name: 'c1'},
        {isChecked: false, name: 'c2'}
      ]);
      c.removeSelectedHosts();
      expect(c.removeHosts.calledWith([
        {isChecked: true, name: 'c1'}
      ])).to.be.true;
    });

  });

  describe('#selectedHostsPopup', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('should show App.ModalPopup', function () {
      c.selectedHostsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });

  });

  describe('#retryHosts', function () {
    var s;
    var agentUserCases = [
      {
        customizeAgentUserAccount: true,
        userRunAs: 'user',
        title: 'Ambari Agent user account customize enabled'
      },
      {
        customizeAgentUserAccount: false,
        userRunAs: 'root',
        title: 'Ambari Agent user account customize disabled'
      }
    ];
    var installer = {launchBootstrap: Em.K};

    beforeEach(function () {
      sinon.spy(installer, "launchBootstrap");
      s = sinon.stub(App.router, 'get', function () {
        return installer;
      });
      sinon.stub(c, 'doBootstrap', Em.K);
      sinon.spy(c, 'startRegistration');
    });

    afterEach(function () {
      c.doBootstrap.restore();
      s.restore();
      installer.launchBootstrap.restore();
      c.startRegistration.restore();
    });

    it('should set numPolls to 0', function () {
      c.set('content', {installOptions: {}});
      c.set('numPolls', 123);
      c.retryHosts(Em.A([]));
      expect(c.get('numPolls')).to.equal(0);
    });

    it('should set registrationStartedAt to null', function () {
      c.set('content', {installOptions: {}});
      c.retryHosts(Em.A([]));
      expect(c.get('registrationStartedAt')).to.be.null;
    });

    it('should startRegistration if installOptions.manualInstall is true', function () {
      c.set('content', {installOptions: {manualInstall: true}});
      c.retryHosts(Em.A([]));
      expect(c.startRegistration.calledOnce).to.equal(true);
    });

    it('should launchBootstrap if installOptions.manualInstall is false', function () {
      c.set('content', {installOptions: {manualInstall: false}});
      c.retryHosts(Em.A([]));
      expect(installer.launchBootstrap.calledOnce).to.be.true;
    });

    agentUserCases.forEach(function (item) {
      describe(item.title, function () {
        var controller;
        beforeEach(function () {
          controller = App.WizardStep3Controller.create({
            content: {
              installOptions: {
                sshKey: 'key',
                sshUser: 'root',
                sshPort: '123',
                agentUser: 'user'
              },
              hosts: { "host0": { "name": "host0" }, "host1": { "name": "host1" } }
            }
          });
          sinon.stub(App, 'get').withArgs('supports.customizeAgentUserAccount').returns(item.customizeAgentUserAccount);
          controller.setupBootStrap();
        });

        afterEach(function () {
          App.get.restore();
        });

        it('launchBootstrap is called with correct arguments', function () {
          expect(installer.launchBootstrap.firstCall.args[0]).to.equal(JSON.stringify({
            verbose: true,
            sshKey: 'key',
            hosts: ['host0', 'host1'],
            user: 'root',
            sshPort: '123',
            userRunAs: item.userRunAs
          }));
        });

      });
    });
  });

  describe('#retryHost', function () {

    beforeEach(function () {
      sinon.spy(c, 'retryHosts');
      sinon.stub(App.router, 'get', function () {
        return {launchBootstrap: Em.K}
      });
      sinon.stub(c, 'doBootstrap', Em.K);
    });

    afterEach(function () {
      c.retryHosts.restore();
      App.router.get.restore();
      c.doBootstrap.restore();
    });

    it('should callretryHosts with array as arg', function () {
      var host = {n: 'c'};
      c.set('content', {installOptions: {}});
      c.retryHost(host);
      expect(c.retryHosts.calledWith([host])).to.equal(true);
    });

  });

  describe('#retrySelectedHosts', function () {

    beforeEach(function () {
      sinon.spy(c, 'retryHosts');
      sinon.stub(App.router, 'get', function () {
        return {launchBootstrap: Em.K}
      });
      sinon.stub(c, 'doBootstrap', Em.K);
    });

    afterEach(function () {
      c.retryHosts.restore();
      App.router.get.restore();
      c.doBootstrap.restore();
    });

    it('shouldn\'t do nothing if isRetryDisabled is true', function () {
      c.set('isRetryDisabled', true);
      c.retrySelectedHosts();
      expect(c.retryHosts.called).to.be.false;
    });

    it('should retry hosts with FAILED bootStatus', function () {
      c.set('bootHosts', Em.A([
        Em.Object.create({
          name: 'c1',
          bootStatus: 'FAILED'
        }),
        Em.Object.create({
          name: 'c2',
          bootStatus: 'REGISTERED'
        })
      ]));
      c.reopen({isRetryDisabled: false});
      c.retrySelectedHosts();
      expect(c.retryHosts.calledWith([
        Em.Object.create({name: 'c1', bootStatus: 'DONE', bootLog: 'Retrying ...'})
      ])).to.be.true;
    });

  });

  describe('#startBootstrap', function () {

    beforeEach(function () {
      sinon.stub(c, 'doBootstrap', Em.K);
    });

    afterEach(function () {
      c.doBootstrap.restore();
    });

    it('should drop numPolls and registrationStartedAt', function () {
      c.set('numPolls', 123);
      c.set('registrationStartedAt', 1234);
      c.startBootstrap();
      expect(c.get('numPolls')).to.equal(0);
      expect(c.get('registrationStartedAt')).to.be.null;
    });

    it('should drop numPolls and registrationStartedAt (2)', function () {
      c.set('hosts', Em.A([
        {name: 'c1'},
        {name: 'c2'}
      ]));
      c.startBootstrap();
      expect(c.get('bootHosts').mapProperty('name')).to.eql(['c1', 'c2']);
    });

  });

  describe('#setRegistrationInProgress', function () {

    var tests = Em.A([
      {
        bootHosts: [],
        isLoaded: false,
        e: true,
        m: 'no bootHosts and isLoaded is false'
      },
      {
        bootHosts: [],
        isLoaded: true,
        e: false,
        m: 'no bootHosts and isLoaded is true'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'RUNNING'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: true,
        e: true,
        m: 'bootHosts without REGISTERED/FAILED and isLoaded is true'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'RUNNING'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: false,
        e: true,
        m: 'bootHosts without REGISTERED/FAILED and isLoaded is false'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'REGISTERED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: false,
        e: true,
        m: 'bootHosts with one REGISTERED and isLoaded is false'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'FAILED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: false,
        e: true,
        m: 'bootHosts with one FAILED and isLoaded is false'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'REGISTERED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: true,
        e: true,
        m: 'bootHosts with one REGISTERED and isLoaded is true'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'FAILED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: true,
        e: true,
        m: 'bootHosts with one FAILED and isLoaded is true'
      }
    ]);

    beforeEach(function () {
      sinon.stub(c, 'getAllRegisteredHosts', Em.K);
      sinon.stub(c, 'disablePreviousSteps', Em.K);
      sinon.stub(c, 'navigateStep', Em.K);
    });

    afterEach(function () {
      c.disablePreviousSteps.restore();
      c.getAllRegisteredHosts.restore();
      c.navigateStep.restore();
    });

    tests.forEach(function (test) {
      it(test.m, function () {
        c.set('bootHosts', test.bootHosts);
        c.set('isLoaded', test.isLoaded);
        c.setRegistrationInProgress();
        expect(c.get('isRegistrationInProgress')).to.equal(test.e);
      });
    });
  });

  describe('#doBootstrap()', function () {

    it('shouldn\'t do nothing if stopBootstrap is true', function () {
      c.set('stopBootstrap', true);
      c.doBootstrap();
      var args = testHelpers.findAjaxRequest('name', 'wizard.step3.bootstrap');
      expect(args).not.exists;
    });

    it('should increment numPolls if stopBootstrap is false', function () {
      c.set('numPolls', 0);
      c.set('stopBootstrap', false);
      c.doBootstrap();
      var args = testHelpers.findAjaxRequest('name', 'wizard.step3.bootstrap');
      expect(args).exists;
      expect(c.get('numPolls')).to.equal(1);
    });

  });

  describe('#startRegistration', function () {

    beforeEach(function () {
      sinon.spy(c, 'isHostsRegistered');
    });

    afterEach(function () {
      c.isHostsRegistered.restore();
    });

    it('shouldn\'t do nothing if registrationStartedAt isn\'t null', function () {
      c.set('registrationStartedAt', 1234);
      c.startRegistration();
      expect(c.isHostsRegistered.called).to.equal(false);
      expect(c.get('registrationStartedAt')).to.equal(1234);
    });

    it('shouldn\'t do nothing if registrationStartedAt isn\'t null (2)', function () {
      c.set('registrationStartedAt', null);
      c.startRegistration();
      expect(c.isHostsRegistered.calledOnce).to.equal(true);
    });
  });

  describe('#isHostsRegistered', function () {

    it('shouldn\'t do nothing if stopBootstrap is true', function () {
      c.set('stopBootstrap', true);
      c.isHostsRegistered();
      var args = testHelpers.findAjaxRequest('name', 'wizard.step3.is_hosts_registered');
      expect(args).not.exists;
    });

    it('should do ajax call if stopBootstrap is false', function () {
      c.set('stopBootstrap', false);
      c.isHostsRegistered();
      var args = testHelpers.findAjaxRequest('name', 'wizard.step3.is_hosts_registered');
      expect(args).exists;

    });
  });

  describe('#isHostsRegisteredSuccessCallback', function () {

    var tests = Em.A([
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'DONE'})
        ]),
        data: {items: []},
        registrationStartedAt: 1000000,
        m: 'one host DONE',
        e: {
          bs: 'REGISTERING',
          getHostInfoCalled: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'REGISTERING', name: 'c1'})
        ]),
        data: {items: [
          {Hosts: {host_name: 'c1'}}
        ]},
        m: ' one host REGISTERING',
        e: {
          bs: 'REGISTERED',
          getHostInfoCalled: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'REGISTERING', name: 'c1'})
        ]),
        data: {items: [
          {Hosts: {host_name: 'c2'}}
        ]},
        registrationStartedAt: 0,
        m: 'one host REGISTERING but data missing info about it, timeout',
        e: {
          bs: 'FAILED',
          getHostInfoCalled: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'REGISTERING', name: 'c1'})
        ]),
        data: {items: [
          {Hosts: {host_name: 'c2'}}
        ]},
        registrationStartedAt: 1000000,
        m: 'one host REGISTERING but data missing info about it',
        e: {
          bs: 'REGISTERING',
          getHostInfoCalled: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'RUNNING', name: 'c1'})
        ]),
        data: {items: [
          {Hosts: {host_name: 'c1'}}
        ]},
        m: ' one host RUNNING',
        e: {
          bs: 'RUNNING',
          getHostInfoCalled: false
        }
      }
    ]);

    beforeEach(function () {
      sinon.spy(c, 'getHostInfo');
      sinon.stub(App, 'dateTime').returns(1000000);
    });

    afterEach(function () {
      c.getHostInfo.restore();
      App.dateTime.restore();
    });

    tests.forEach(function (test) {
      it(test.m, function () {
        c.set('content.installedHosts', []);
        c.set('bootHosts', test.bootHosts);
        c.set('registrationStartedAt', test.registrationStartedAt);
        c.isHostsRegisteredSuccessCallback(test.data);
        expect(c.get('bootHosts')[0].get('bootStatus')).to.equal(test.e.bs);
        expect(c.getHostInfo.called).to.equal(test.e.getHostInfoCalled);
      });
    });

  });

  describe('#getAllRegisteredHosts', function () {

    it('should call App.ajax.send', function () {
      c.getAllRegisteredHosts();
      var args = testHelpers.findAjaxRequest('name', 'wizard.step3.is_hosts_registered');
      expect(args).exists;
    });
  });

  describe('#getAllRegisteredHostsCallback', function () {

    var tests = Em.A([
      {
        hostsInCluster: ['c3'],
        bootHosts: [
          {name: 'c1'},
          {name: 'c2'}
        ],
        hosts: Em.A([
          {Hosts: {host_name: 'c1'}},
          {Hosts: {host_name: 'c2'}}
        ]),
        m: 'No registered hosts',
        e: {
          hasMoreRegisteredHosts: false,
          registeredHosts: ''
        }
      },
      {
        hostsInCluster: ['c4'],
        bootHosts: [
          {name: 'c3'},
          {name: 'c5'}
        ],
        hosts: Em.A([
          {Hosts: {host_name: 'c1'}},
          {Hosts: {host_name: 'c2'}}
        ]),
        m: '2 registered hosts',
        e: {
          hasMoreRegisteredHosts: true,
          registeredHosts: ['c1', 'c2']
        }
      },
      {
        hostsInCluster: ['c4'],
        bootHosts: [
          {name: 'c1'},
          {name: 'c5'}
        ],
        hosts: Em.A([
          {Hosts: {host_name: 'c1'}},
          {Hosts: {host_name: 'c2'}}
        ]),
        m: '1 registered host',
        e: {
          hasMoreRegisteredHosts: true,
          registeredHosts: ['c2']
        }
      },
      {
        hostsInCluster: ['c1'],
        bootHosts: [
          {name: 'c3'},
          {name: 'c5'}
        ],
        hosts: Em.A([
          {Hosts: {host_name: 'c1'}},
          {Hosts: {host_name: 'c2'}}
        ]),
        m: '1 registered host (2)',
        e: {
          hasMoreRegisteredHosts: true,
          registeredHosts: ['c2']
        }
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({setRegistrationInProgress: Em.K, hostsInCluster: test.hostsInCluster});
        c.set('bootHosts', test.bootHosts);
        c.getAllRegisteredHostsCallback({items: test.hosts});
        expect(c.get('hasMoreRegisteredHosts')).to.equal(test.e.hasMoreRegisteredHosts);
        expect(c.get('registeredHosts')).to.eql(test.e.registeredHosts);
      });
    });

  });

  describe('#registerErrPopup', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('should call App.ModalPopup.show', function () {
      c.registerErrPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
  });

  describe('#getHostInfo', function () {

    it('should do ajax request', function () {
      c.getHostInfo();
      var args = testHelpers.findAjaxRequest('name', 'wizard.step3.host_info');
      expect(args).exists;
    });

  });

  describe('#getHostInfoErrorCallback', function () {

    beforeEach(function () {
      sinon.spy(c, 'registerErrPopup');
    });

    afterEach(function () {
      c.registerErrPopup.restore();
    });

    it('should call registerErrPopup', function () {
      c.getHostInfoErrorCallback();
      expect(c.registerErrPopup.calledOnce).to.equal(true);
    });

  });

  describe('#stopRegistration', function () {

    var tests = Em.A([
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'REGISTERED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        e: {isSubmitDisabled: false}
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'FAILED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        e: {isSubmitDisabled: true}
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'FAILED'}),
          Em.Object.create({bootStatus: 'REGISTERED'})
        ],
        e: {isSubmitDisabled: false}
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'RUNNING'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        e: {isSubmitDisabled: true}
      }
    ]);
    tests.forEach(function (test) {
      it(test.bootHosts.mapProperty('bootStatus').join(', '), function () {
        c.reopen({bootHosts: test.bootHosts});
        c.stopRegistration();
        expect(c.get('isSubmitDisabled')).to.equal(test.e.isSubmitDisabled);
      });
    });

  });

  describe('#submit', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('if isHostHaveWarnings should show confirmation popup', function () {
      c.reopen({isHostHaveWarnings: true});
      c.submit();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });

    it('if isHostHaveWarnings should show confirmation popup. on Primary should set bootHosts to content.hosts', function () {
      var bootHosts = [
        Em.Object.create({name: 'c1'})
      ];
      c.reopen({isHostHaveWarnings: true, bootHosts: bootHosts, hosts: []});
      c.submit().onPrimary();
      expect(c.get('confirmedHosts')).to.eql(bootHosts);
    });

    it('if isHostHaveWarnings is false should set bootHosts to content.hosts', function () {
      var bootHosts = [
        Em.Object.create({name: 'c1'})
      ];
      c.reopen({isHostHaveWarnings: false, bootHosts: bootHosts, hosts: []});
      c.submit();
      expect(c.get('confirmedHosts')).to.eql(bootHosts);
    });

  });

  describe('#hostLogPopup', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('should show App.ModalPopup', function () {
      c.hostLogPopup({context: Em.Object.create({})});
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });

  });

  describe('#rerunChecksSuccessCallback', function () {

    beforeEach(function () {
      sinon.stub(c, 'parseWarnings', Em.K);
    });

    afterEach(function () {
      c.parseWarnings.restore();
    });

    it('should set checksUpdateProgress to 100', function () {
      c.set('checksUpdateProgress', 0);
      c.rerunChecksSuccessCallback({items: []});
      expect(c.get('checksUpdateProgress')).to.equal(100);
    });

    it('should set checksUpdateStatus to SUCCESS', function () {
      c.set('checksUpdateStatus', '');
      c.rerunChecksSuccessCallback({items: []});
      expect(c.get('checksUpdateStatus')).to.equal('SUCCESS');
    });

    it('should call parseWarnings', function () {
      c.rerunChecksSuccessCallback({items: []});
      expect(c.parseWarnings.calledOnce).to.equal(true);
    });

  });

  describe('#rerunChecksErrorCallback', function () {

    it('should set checksUpdateProgress to 100', function () {
      c.set('checksUpdateProgress', 0);
      c.rerunChecksErrorCallback({});
      expect(c.get('checksUpdateProgress')).to.equal(100);
    });

    it('should set checksUpdateStatus to FAILED', function () {
      c.set('checksUpdateStatus', '');
      c.rerunChecksErrorCallback({});
      expect(c.get('checksUpdateStatus')).to.equal('FAILED');
    });

  });

  describe('#filterBootHosts', function () {
    var tests = Em.A([
      {
        bootHosts: [
          Em.Object.create({name: 'c1'}),
          Em.Object.create({name: 'c2'})
        ],
        data: {
          items: [
            {Hosts: {host_name: 'c1'}}
          ]
        },
        m: 'one host',
        e: ['c1']
      },
      {
        bootHosts: [
          Em.Object.create({name: 'c1'}),
          Em.Object.create({name: 'c2'})
        ],
        data: {
          items: [
            {Hosts: {host_name: 'c3'}}
          ]
        },
        m: 'no hosts',
        e: []
      },
      {
        bootHosts: [
          Em.Object.create({name: 'c1'}),
          Em.Object.create({name: 'c2'})
        ],
        data: {
          items: [
            {Hosts: {host_name: 'c1'}},
            {Hosts: {host_name: 'c2'}}
          ]
        },
        m: 'many hosts',
        e: ['c1', 'c2']
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({bootHosts: test.bootHosts});
        var filteredData = c.filterBootHosts(test.data);
        expect(filteredData.items.mapProperty('Hosts.host_name')).to.eql(test.e);
      });
    });
  });

  describe('#hostWarningsPopup', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(c, 'rerunChecks', Em.K);
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
      c.rerunChecks.restore();
    });

    it('should show App.ModalPopup', function () {
      c.hostWarningsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });

    it('should clear checksUpdateStatus on primary', function () {
      c.set('checksUpdateStatus', 'not null value');
      c.hostWarningsPopup().onPrimary();
      expect(c.get('checksUpdateStatus')).to.be.null;
    });

    it('should clear checksUpdateStatus on close', function () {
      c.set('checksUpdateStatus', 'not null value');
      c.hostWarningsPopup().onClose();
      expect(c.get('checksUpdateStatus')).to.be.null;
    });

    it('should rerunChecks onSecondary', function () {
      c.hostWarningsPopup().onSecondary();
      expect(c.rerunChecks.calledOnce).to.equal(true);
    });
  });

  describe('#registeredHostsPopup', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('should show App.ModalPopup', function () {
      c.registeredHostsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
  });

  describe('#parseHostCheckWarnings', function () {

    beforeEach(function () {
      sinon.stub(c, 'filterHostsData', function (k) {
        return k;
      });
    });

    afterEach(function () {
      c.filterHostsData.restore();
    });

    it('no warnings if last_agent_env isn\'t specified', function () {
      c.set('warnings', [
        {}
      ]);
      c.set('warningsByHost', [
        {},
        {}
      ]);
      c.parseHostCheckWarnings({tasks: [
        {Tasks: {host_name: 'c1'}}
      ]});
      expect(c.get('warnings')).to.eql([]);
      expect(c.get('warningsByHost.length')).to.equal(1); // default group
    });

    Em.A([
        {
          m: 'parse stackFoldersAndFiles',
          tests: Em.A([
            {
              tasks: [
                {Tasks: {host_name: 'c1',
                         structured_out:{last_agent_env_check: {stackFoldersAndFiles: []}}
                        }
                }
              ],
              m: 'empty stackFoldersAndFiles',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              tasks: [
                {Tasks: {host_name: 'c1',
                         structured_out: {last_agent_env_check: {stackFoldersAndFiles: [{name: 'n1'}]}}
                        }
                }
              ],
              m: 'not empty stackFoldersAndFiles',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1'],
                    onSingleHost: true,
                    category: 'fileFolders'
                  }
                ],
                warningsByHost: [1]
              }
            },
            {
              tasks: [
                {Tasks: {host_name: 'c1', structured_out:{last_agent_env_check: {stackFoldersAndFiles: [
                  {name: 'n1'}
                ]}}}},
                {Tasks: {host_name: 'c2', structured_out: {last_agent_env_check: {stackFoldersAndFiles: [
                  {name: 'n1'}
                ]}}}}
              ],
              m: 'not empty stackFoldersAndFiles on two hosts',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1', 'c2'],
                    onSingleHost: false,
                    category: 'fileFolders'
                  }
                ],
                warningsByHost: [1]
              }
            }
          ])
        },
        {
          m: 'parse hostHealth.liveServices',
          tests: Em.A([
            {
              tasks: [
                {Tasks: {host_name: 'c1', structured_out: {last_agent_env_check: {hostHealth: []}}}}
              ],
              m: 'empty hostHealth',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              tasks: [
                {Tasks: {host_name: 'c1', structured_out: {last_agent_env_check: {hostHealth: {liveServices: []}}}}}
              ],
              m: 'empty liveServices',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              tasks: [
                {Tasks: {host_name: 'c1',
                         structured_out: {last_agent_env_check: {hostHealth: {liveServices: [{status: 'Unhealthy', name: 'n1'}]}}}
                        }
                }
              ],
              m: 'not empty hostHealth.liveServices',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1'],
                    onSingleHost: true,
                    category: 'services'
                  }
                ],
                warningsByHost: [1]
              }
            },
            {
              tasks: [
                {Tasks: {host_name: 'c1',
                         structured_out:{last_agent_env_check: {hostHealth: {liveServices: [{status: 'Unhealthy', name: 'n1'}]}}}
                        }
                },

                {Tasks: {host_name: 'c2',
                         structured_out:{last_agent_env_check: {hostHealth: {liveServices: [{status: 'Unhealthy', name: 'n1'}]}}}
                        }
                }
              ],
              m: 'not empty hostHealth.liveServices on two hosts',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1', 'c2'],
                    onSingleHost: false,
                    category: 'services'
                  }
                ],
                warningsByHost: [1, 1]
              }
            }
          ])
        },
        {
          m: 'parse existingUsers',
          tests: Em.A([
            {
              tasks: [
                {Tasks: {host_name: 'c1',
                         structured_out: {last_agent_env_check: {existingUsers: []}}
                        }
                }
              ],
              m: 'empty existingUsers',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              tasks: [
                {Tasks: {host_name: 'c1',
                         structured_out: {last_agent_env_check: {existingUsers: [{name: 'n1'}]}}
                        }
                }
              ],
              m: 'not empty existingUsers',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1'],
                    onSingleHost: true,
                    category: 'users'
                  }
                ],
                warningsByHost: [1]
              }
            },
            {
              tasks: [
                {Tasks: {host_name: 'c1',
                         structured_out:{last_agent_env_check: {existingUsers: [{name: 'n1'}]}}
                        }
                },
                {Tasks: {host_name: 'c2',
                         structured_out:{last_agent_env_check: {existingUsers: [{name: 'n1'}]}}
                        }
                }
              ],
              m: 'not empty existingUsers on two hosts',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1', 'c2'],
                    onSingleHost: false,
                    category: 'users'
                  }
                ],
                warningsByHost: [1, 1]
              }
            }
          ])
        },
        {
          m: 'parse alternatives',
          tests: Em.A([
            {
              tasks: [
                {Tasks: {host_name: 'c1',
                         structured_out:{last_agent_env_check: {alternatives: []}}
                        }
                }
              ],
              m: 'empty alternatives',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              tasks: [
                {Tasks: {host_name: 'c1',
                         structured_out: {last_agent_env_check: {alternatives: [{name: 'n1'}]}}
                        }
                }
              ],
              m: 'not empty alternatives',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1'],
                    onSingleHost: true,
                    category: 'alternatives'
                  }
                ],
                warningsByHost: [1]
              }
            },
            {
              tasks: [
                {Tasks: {host_name: 'c1',
                         structured_out:{last_agent_env_check: {alternatives: [{name: 'n1'}]}}
                        }
                },
                {Tasks: {host_name: 'c2',
                         structured_out:{last_agent_env_check: {alternatives: [{name: 'n1'}]}}
                        }
                }
              ],
              m: 'not empty alternatives on two hosts',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1', 'c2'],
                    onSingleHost: false,
                    category: 'alternatives'
                  }
                ],
                warningsByHost: [1, 1]
              }
            }
          ])
        },
        {
          m: 'parse hostHealth.activeJavaProcs',
          tests: Em.A([
            {
              tasks: [
                {Tasks: {host_name: 'c1',
                         structured_out:{last_agent_env_check: {hostHealth: [], javaProcs: []}}
                        }
                }
              ],
              m: 'empty hostHealth',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              tasks: [
                {Tasks: {host_name: 'c1', structured_out:{last_agent_env_check: {hostHealth: {activeJavaProcs: []}}}}}
              ],
              m: 'empty activeJavaProcs',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              tasks: [
                {Tasks: {host_name: 'c1',
                         structured_out:{last_agent_env_check: {hostHealth: {activeJavaProcs: [{pid: 'n1', command: ''}]}}}
                        }
                }
              ],
              m: 'not empty hostHealth.activeJavaProcs',
              e: {
                warnings: [
                  {
                    pid: 'n1',
                    hosts: ['c1'],
                    onSingleHost: true,
                    category: 'processes'
                  }
                ],
                warningsByHost: [1]
              }
            },
            {
              tasks: [
                {Tasks: {host_name: 'c1',
                         structured_out:{last_agent_env_check: {hostHealth: {activeJavaProcs: [{pid: 'n1', command: ''}]}}}
                        }
                },
                {Tasks: {host_name: 'c2',
                         structured_out:{last_agent_env_check: {hostHealth: {activeJavaProcs: [{pid: 'n1', command: ''}]}}}
                        }
                }
              ],
              m: 'not empty hostHealth.activeJavaProcs on two hosts',
              e: {
                warnings: [
                  {
                    pid: 'n1',
                    hosts: ['c1', 'c2'],
                    onSingleHost: false,
                    category: 'processes'
                  }
                ],
                warningsByHost: [1, 1]
              }
            }
          ])
        }
      ]).forEach(function (category) {
      describe(category.m, function () {
        category.tests.forEach(function (test) {

          describe(test.m, function () {

            beforeEach(function () {
              c.parseHostCheckWarnings({tasks: test.tasks});
            });

            it('warnings count is valid', function () {
              expect(c.get('warnings.length')).to.be.equal(test.e.warnings.length);
            });

            test.e.warnings.forEach(function (warning, index) {
              Object.keys(warning).forEach(function (warningKey) {
                it('warning #' + (index + 1) + ' key: ' + warningKey, function () {
                  expect(c.get('warnings')[index][warningKey]).to.be.eql(warning[warningKey]);
                });
              });
            });

            Object.keys(test.e.warningsByHost).forEach(function (warningByHostKey, index) {
              it ('warningsByHost #' + (index + 1), function () {
                expect(c.get('warningsByHost')[index].warnings.length).to.equal(test.e.warningsByHost[warningByHostKey]);
              });
            });

          });
        });
      });
      });

    it('should parse umask warnings', function () {

      var tasks = [
        {Tasks: {host_name: 'c1', structured_out:{last_agent_env_check: {umask: 24}}}},
        {Tasks: {host_name: 'c2', structured_out:{last_agent_env_check: {umask: 1}}}}
      ];

      c.parseHostCheckWarnings({tasks: tasks});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1']);
      expect(warnings[0].hostsLong).to.eql(['c1']);
      expect(warnings[0].onSingleHost).to.equal(true);

    });

    it('should parse umask warnings (2)', function () {

      var tasks = [
        {Tasks: {host_name: 'c1', structured_out:{last_agent_env_check: {umask: 24}}}},
        {Tasks: {host_name: 'c2', structured_out:{last_agent_env_check: {umask: 25}}}}
      ];

      c.parseHostCheckWarnings({tasks: tasks});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(2);
      expect(warnings.mapProperty('hosts')).to.eql([
        ['c1'],
        ['c2']
      ]);

    });

    it('should parse firewall warnings', function () {

      var tasks = [
        {Tasks: {host_name: 'c1', structured_out:{last_agent_env_check: {firewallRunning: true, firewallName: "iptables"}}}},
        {Tasks: {host_name: 'c2', structured_out:{last_agent_env_check: {firewallRunning: false, firewallName: "iptables"}}}}
      ];

      c.parseHostCheckWarnings({tasks: tasks});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1']);
      expect(warnings[0].hostsLong).to.eql(['c1']);
      expect(warnings[0].onSingleHost).to.equal(true);

    });

    it('should parse firewall warnings (2)', function () {

      var tasks = [
        {Tasks: {host_name: 'c1', structured_out:{last_agent_env_check: {firewallRunning: true, firewallName: "iptables"}}}},
        {Tasks: {host_name: 'c2', structured_out:{last_agent_env_check: {firewallRunning: true, firewallName: "iptables"}}}}
      ];

      c.parseHostCheckWarnings({tasks: tasks});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1', 'c2']);
      expect(warnings[0].hostsLong).to.eql(['c1', 'c2']);
      expect(warnings[0].onSingleHost).to.equal(false);

    });

    it('should parse reverseLookup warnings', function () {

      var tasks = [
        {Tasks: {host_name: 'c1', structured_out:{last_agent_env_check: {reverseLookup: true}}}}
      ];

      c.parseHostCheckWarnings({tasks: tasks});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(0);

    });

    it('should parse reverseLookup warnings (2)', function () {

      var tasks = [
        {Tasks: {host_name: 'c1', structured_out:{last_agent_env_check: {reverseLookup: false}}}}
      ];

      c.parseHostCheckWarnings({tasks: tasks});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1']);
      expect(warnings[0].hostsLong).to.eql(['c1']);
      expect(warnings[0].onSingleHost).to.equal(true);

    });

    it('should parse reverseLookup warnings (3)', function () {

      var tasks = [
        {Tasks: {host_name: 'c1', structured_out:{last_agent_env_check: {reverseLookup: false}}}},
        {Tasks: {host_name: 'c2', structured_out:{last_agent_env_check: {reverseLookup: false}}}}
      ];

      c.parseHostCheckWarnings({tasks: tasks});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1', 'c2']);
      expect(warnings[0].hostsLong).to.eql(['c1', 'c2']);
      expect(warnings[0].onSingleHost).to.equal(false);

    });
  });

  describe('#parseWarnings', function () {

    beforeEach(function () {
      sinon.stub(c, 'filterBootHosts', function (k) {
        return k;
      });
    });

    afterEach(function () {
      c.filterBootHosts.restore();
    });

    it('no warnings if last_agent_env isn\'t specified', function () {
      c.set('warnings', [
        {}
      ]);
      c.set('warningsByHost', [
        {},
        {}
      ]);
      c.parseWarnings({items: [
        {Hosts: {host_name: 'c1'}}
      ]});
      expect(c.get('warnings')).to.eql([]);
      expect(c.get('warningsByHost.length')).to.equal(1); // default group
    });

    Em.A([
        {
          m: 'parse stackFoldersAndFiles',
          tests: Em.A([
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {stackFoldersAndFiles: []}}}
              ],
              m: 'empty stackFoldersAndFiles',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {stackFoldersAndFiles: [
                  {name: 'n1'}
                ]}}}
              ],
              m: 'not empty stackFoldersAndFiles',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1'],
                    onSingleHost: true,
                    category: 'fileFolders'
                  }
                ],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {stackFoldersAndFiles: [
                  {name: 'n1'}
                ]}}},
                {Hosts: {host_name: 'c2', last_agent_env: {stackFoldersAndFiles: [
                  {name: 'n1'}
                ]}}}
              ],
              m: 'not empty stackFoldersAndFiles on two hosts',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1', 'c2'],
                    onSingleHost: false,
                    category: 'fileFolders'
                  }
                ],
                warningsByHost: [1]
              }
            }
          ])
        },
        {
          m: 'parse hostHealth.liveServices',
          tests: Em.A([
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: []}}}
              ],
              m: 'empty hostHealth',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: {liveServices: []}}}}
              ],
              m: 'empty liveServices',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: {liveServices: [
                  {status: 'Unhealthy', name: 'n1'}
                ]}}}}
              ],
              m: 'not empty hostHealth.liveServices',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1'],
                    onSingleHost: true,
                    category: 'services'
                  }
                ],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: {liveServices: [
                  {status: 'Unhealthy', name: 'n1'}
                ]}}}},
                {Hosts: {host_name: 'c2', last_agent_env: {hostHealth: {liveServices: [
                  {status: 'Unhealthy', name: 'n1'}
                ]}}}}
              ],
              m: 'not empty hostHealth.liveServices on two hosts',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1', 'c2'],
                    onSingleHost: false,
                    category: 'services'
                  }
                ],
                warningsByHost: [1, 1]
              }
            }
          ])
        },
        {
          m: 'parse existingUsers',
          tests: Em.A([
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {existingUsers: []}}}
              ],
              m: 'empty existingUsers',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {existingUsers: [
                  {name: 'n1'}
                ]}}}
              ],
              m: 'not empty existingUsers',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1'],
                    onSingleHost: true,
                    category: 'users'
                  }
                ],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {existingUsers: [
                  {name: 'n1'}
                ]}}},
                {Hosts: {host_name: 'c2', last_agent_env: {existingUsers: [
                  {name: 'n1'}
                ]}}}
              ],
              m: 'not empty existingUsers on two hosts',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1', 'c2'],
                    onSingleHost: false,
                    category: 'users'
                  }
                ],
                warningsByHost: [1, 1]
              }
            }
          ])
        },
        {
          m: 'parse alternatives',
          tests: Em.A([
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {alternatives: []}}}
              ],
              m: 'empty alternatives',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {alternatives: [
                  {name: 'n1'}
                ]}}}
              ],
              m: 'not empty alternatives',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1'],
                    onSingleHost: true,
                    category: 'alternatives'
                  }
                ],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {alternatives: [
                  {name: 'n1'}
                ]}}},
                {Hosts: {host_name: 'c2', last_agent_env: {alternatives: [
                  {name: 'n1'}
                ]}}}
              ],
              m: 'not empty alternatives on two hosts',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1', 'c2'],
                    onSingleHost: false,
                    category: 'alternatives'
                  }
                ],
                warningsByHost: [1, 1]
              }
            }
          ])
        },
        {
          m: 'parse hostHealth.activeJavaProcs',
          tests: Em.A([
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: [], javaProcs: []}}}
              ],
              m: 'empty hostHealth',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: {activeJavaProcs: []}}}}
              ],
              m: 'empty activeJavaProcs',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: {activeJavaProcs: [
                  {pid: 'n1', command: ''}
                ]}}}}
              ],
              m: 'not empty hostHealth.activeJavaProcs',
              e: {
                warnings: [
                  {
                    pid: 'n1',
                    hosts: ['c1'],
                    onSingleHost: true,
                    category: 'processes'
                  }
                ],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: {activeJavaProcs: [
                  {pid: 'n1', command: ''}
                ]}}}},
                {Hosts: {host_name: 'c2', last_agent_env: {hostHealth: {activeJavaProcs: [
                  {pid: 'n1', command: ''}
                ]}}}}
              ],
              m: 'not empty hostHealth.activeJavaProcs on two hosts',
              e: {
                warnings: [
                  {
                    pid: 'n1',
                    hosts: ['c1', 'c2'],
                    onSingleHost: false,
                    category: 'processes'
                  }
                ],
                warningsByHost: [1, 1]
              }
            }
          ])
        }
      ]).forEach(function (category) {
        describe(category.m, function () {
          category.tests.forEach(function (test) {
            describe(test.m, function () {

              beforeEach(function () {
                c.parseWarnings({items: test.items});
              });

              test.e.warnings.forEach(function (warning, index) {
                Object.keys(warning).forEach(function (warningKey) {
                  it('warning #' + (index + 1) + ' key: ' + warningKey, function () {
                    expect(c.get('warnings')[index][warningKey]).to.be.eql(warning[warningKey]);
                  });
                });
              });

              Object.keys(test.e.warningsByHost).forEach(function (warningByHostKey, index) {
                it ('warningsByHost #' + (index + 1), function () {
                  expect(c.get('warningsByHost')[index].warnings.length).to.equal(test.e.warningsByHost[warningByHostKey]);
                });
              });

            });
          });
        });
      });

    it('should parse umask warnings', function () {

      var items = [
        {Hosts: {host_name: 'c1', last_agent_env: {umask: 24}}},
        {Hosts: {host_name: 'c2', last_agent_env: {umask: 1}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1']);
      expect(warnings[0].hostsLong).to.eql(['c1']);
      expect(warnings[0].onSingleHost).to.equal(true);

    });

    it('should parse umask warnings (2)', function () {

      var items = [
        {Hosts: {host_name: 'c1', last_agent_env: {umask: 24}}},
        {Hosts: {host_name: 'c2', last_agent_env: {umask: 25}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(2);
      expect(warnings.mapProperty('hosts')).to.eql([
        ['c1'],
        ['c2']
      ]);

    });

    it('should parse firewall warnings', function () {

      var items = [
        {Hosts: {host_name: 'c1', last_agent_env: {firewallRunning: true, firewallName: "iptables"}}},
        {Hosts: {host_name: 'c2', last_agent_env: {firewallRunning: false, firewallName: "iptables"}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1']);
      expect(warnings[0].hostsLong).to.eql(['c1']);
      expect(warnings[0].onSingleHost).to.equal(true);

    });

    it('should parse firewall warnings (2)', function () {

      var items = [
        {Hosts: {host_name: 'c1', last_agent_env: {firewallRunning: true, firewallName: "iptables"}}},
        {Hosts: {host_name: 'c2', last_agent_env: {firewallRunning: true, firewallName: "iptables"}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1', 'c2']);
      expect(warnings[0].hostsLong).to.eql(['c1', 'c2']);
      expect(warnings[0].onSingleHost).to.equal(false);

    });

    it('should parse reverseLookup warnings', function () {

      var items = [
        {Hosts: {host_name: 'c1', last_agent_env: {reverseLookup: true}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(0);

    });

    it('should parse reverseLookup warnings (2)', function () {

      var items = [
        {Hosts: {host_name: 'c1', last_agent_env: {reverseLookup: false}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1']);
      expect(warnings[0].hostsLong).to.eql(['c1']);
      expect(warnings[0].onSingleHost).to.equal(true);

    });

    it('should parse reverseLookup warnings (3)', function () {

      var items = [
        {Hosts: {host_name: 'c1', last_agent_env: {reverseLookup: false}}},
        {Hosts: {host_name: 'c2', last_agent_env: {reverseLookup: false}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1', 'c2']);
      expect(warnings[0].hostsLong).to.eql(['c1', 'c2']);
      expect(warnings[0].onSingleHost).to.equal(false);

    });

  });

  describe('#navigateStep', function () {

    beforeEach(function () {
      sinon.stub(c, 'setupBootStrap', Em.K);
    });

    afterEach(function () {
      c.setupBootStrap.restore();
    });

    Em.A([
        {
          isLoaded: true,
          manualInstall: false,
          bootStatus: false,
          m: 'should call setupBootStrap',
          e: true
        },
        {
          isLoaded: true,
          manualInstall: false,
          bootStatus: true,
          m: 'shouldn\'t call setupBootStrap (1)',
          e: false
        },
        {
          isLoaded: false,
          manualInstall: false,
          bootStatus: false,
          m: 'shouldn\'t call setupBootStrap (2)',
          e: false
        },
        {
          isLoaded: false,
          manualInstall: true,
          bootStatus: false,
          m: 'shouldn\'t call setupBootStrap (3)',
          e: false
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          c.reopen({
            isLoaded: test.isLoaded,
            content: {
              installedHosts: [],
              installOptions: {
                manualInstall: test.manualInstall
              }
            },
            wizardController: Em.Object.create({
              getDBProperty: function () {
                return test.bootStatus
              }
            })
          });
          c.navigateStep();
          if (test.e) {
            expect(c.setupBootStrap.calledOnce).to.equal(true);
          }
          else {
            expect(c.setupBootStrap.called).to.equal(false);
          }
        });
      });

    describe('should start registration', function () {

      beforeEach(function () {
        c.reopen({
          isLoaded: true,
          hosts: [
            {},
            {},
            {}
          ],
          content: {
            installedHosts: [],
            installOptions: {
              manualInstall: true
            }
          },
          setRegistrationInProgress: Em.K,
          startRegistration: Em.K
        });
        sinon.spy(c, 'startRegistration');
        c.navigateStep();
      });


      afterEach(function () {
        c.startRegistration.restore();
      });

      it('startRegistration is called once', function () {
        expect(c.startRegistration.calledOnce).to.equal(true);
      });

      it('all hosts are bootHosts', function () {
        expect(c.get('bootHosts.length')).to.equal(c.get('hosts.length'));
      });

      it('registrationStartedAt is null', function () {
        expect(c.get('registrationStartedAt')).to.be.null;
      });
    });

  });

  describe('#setupBootStrap', function () {

    var cases = [
        {
          customizeAgentUserAccount: true,
          userRunAs: 'user',
          title: 'Ambari Agent user account customize enabled'
        },
        {
          customizeAgentUserAccount: false,
          userRunAs: 'root',
          title: 'Ambari Agent user account customize disabled'
        }
      ],

      controller = App.WizardStep3Controller.create({
        content: {
          installOptions: {
            sshKey: 'key',
            sshUser: 'root',
            sshPort: '123',
            agentUser: 'user'
          },
          hosts: { "host0": { "name": "host0" }, "host1": { "name": "host1" } },
          controllerName: 'installerController'
        }
      });

    beforeEach(function () {
      sinon.stub(App.router.get('installerController'), 'launchBootstrap', Em.K);
      this.mock = sinon.stub(App, 'get');
    });

    afterEach(function () {
      App.router.get('installerController').launchBootstrap.restore();
      this.mock.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        this.mock.withArgs('supports.customizeAgentUserAccount').returns(item.customizeAgentUserAccount);
        controller.setupBootStrap();
        expect(App.router.get('installerController.launchBootstrap').firstCall.args[0]).to.equal(JSON.stringify({
          verbose: true,
          sshKey: 'key',
          hosts: ['host0', 'host1'],
          user: 'root',
          sshPort: '123',
          userRunAs: item.userRunAs
        }));
      });
    });

  });

  describe('#checkHostDiskSpace', function () {
    Em.A([
        {
          diskInfo: [
            {
              available: App.minDiskSpace * 1024 * 1024 - 1024,
              mountpoint: '/'
            }
          ],
          m: 'available less than App.minDiskSpace',
          e: false
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 - 1024,
              mountpoint: '/usr'
            }
          ],
          m: 'available less than App.minDiskSpaceUsrLib (1)',
          e: false
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 - 1024,
              mountpoint: '/usr/lib'
            }
          ],
          m: 'available less than App.minDiskSpaceUsrLib (2)',
          e: false
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpace * 1024 * 1024 + 1024,
              mountpoint: '/'
            }
          ],
          m: 'available greater than App.minDiskSpace',
          e: true
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 + 1024,
              mountpoint: '/usr'
            }
          ],
          m: 'available greater than App.minDiskSpaceUsrLib (1)',
          e: true
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 + 1024,
              mountpoint: '/usr/lib'
            }
          ],
          m: 'available greater than App.minDiskSpaceUsrLib (2)',
          e: true
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 + 1024,
              mountpoint: '/home/tdk'
            }
          ],
          m: 'mount point without free space checks',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          var r = c.checkHostDiskSpace('', test.diskInfo);
          expect(Em.isEmpty(r)).to.equal(test.e);
        });
      });
  });

  describe('#checkHostOSType', function () {

    it('should return empty string if no stacks provided', function () {
      c.reopen({content: {stacks: null}});
      expect(c.checkHostOSType()).to.equal('');
    });

    it('os type is valid', function () {
      var osType = 'redhat6';
      c.reopen({
        content: {
          stacks: [
            Em.Object.create({isSelected: true, operatingSystems: [Em.Object.create({isSelected: true, osType: osType})]})
          ]
        }
      });
      expect(c.checkHostOSType(osType, '')).to.equal('');
    });

    it('os type is invalid', function () {
      var osType = 'os2';
      c.reopen({
        content: {
          stacks: [
            Em.Object.create({isSelected: true, operatingSystems: [Em.Object.create({isSelected: true, osType: 'os1'})]})
          ]
        }
      });
      expect(Em.isEmpty(c.checkHostOSType(osType, ''))).to.equal(false);
    });

  });

  describe('#getHostInfoSuccessCallback', function () {

    var jsonData = {items: [
      {Hosts: {host_name: 'h1'}}
    ]};

    var skipBootstrap = false;

    beforeEach(function () {
      sinon.stub(c, 'parseWarnings', Em.K);
      sinon.stub(c, 'stopRegistration', Em.K);
      sinon.stub(c, 'checkHostDiskSpace', Em.K);
      sinon.stub(c, '_setHostDataFromLoadedHostInfo', Em.K);
      sinon.spy(c, '_setHostDataWithSkipBootstrap');
      sinon.stub(App, 'get', function (k) {
        if ('skipBootstrap' === k) return skipBootstrap;
        return Em.get(App, k);
      });
      c.reopen({
        bootHosts: [Em.Object.create({name: 'h1'})]
      });
      sinon.stub(c, 'checkHostOSType', function () {
        return 'not_null_value';
      });
    });

    afterEach(function () {
      c.parseWarnings.restore();
      c.stopRegistration.restore();
      c.checkHostDiskSpace.restore();
      c._setHostDataFromLoadedHostInfo.restore();
      c._setHostDataWithSkipBootstrap.restore();
      App.get.restore();
      c.checkHostOSType.restore();
    });

    it('should call _setHostDataWithSkipBootstrap if skipBootstrap is true', function () {
        skipBootstrap = true;
        c.getHostInfoSuccessCallback(jsonData);
        expect(c._setHostDataWithSkipBootstrap.calledOnce).to.equal(true);
    });

    it('should add repo warnings', function () {
      skipBootstrap = false;
      c.getHostInfoSuccessCallback(jsonData);
      expect(c.get('repoCategoryWarnings.length')).to.equal(1);
      expect(c.get('repoCategoryWarnings.firstObject.hostsNames').contains('h1')).to.equal(true);
    });

    it('should add disk warnings', function () {
      skipBootstrap = false;
      c.getHostInfoSuccessCallback(jsonData);
      expect(c.get('diskCategoryWarnings.length')).to.equal(1);
      expect(c.get('diskCategoryWarnings.firstObject.hostsNames').contains('h1')).to.equal(true);
    });

  });

  describe('#_setHostDataWithSkipBootstrap', function () {

    it('should set mock-data', function () {
      var host = Em.Object.create({});
      c._setHostDataWithSkipBootstrap(host);
      expect(host.get('cpu')).to.equal(2);
      expect(host.get('memory')).to.equal('2000000.00');
      expect(host.get('disk_info.length')).to.equal(4);
    });

  });

  describe('#_setHostDataFromLoadedHostInfo', function () {
    var host;
    beforeEach(function () {
      host = Em.Object.create();
      var hostInfo = {
        Hosts: {
          cpu_count: 2,
          total_mem: 12345,
          os_type: 't1',
          os_arch: 'os1',
          os_family: 'osf1',
          ip: '0.0.0.0',
          disk_info: [
            {mountpoint: '/boot'},
            {mountpoint: '/usr'},
            {mountpoint: '/no-boot'},
            {mountpoint: '/boot'}
          ]
        }
      };
      c._setHostDataFromLoadedHostInfo(host, hostInfo);
    });

    it('cpu', function () {
      expect(host.get('cpu')).to.equal(2);
    });
    it('os_type', function () {
      expect(host.get('os_type')).to.equal('t1');
    });
    it('os_arch', function () {
      expect(host.get('os_arch')).to.equal('os1');
    });
    it('os_family', function () {
      expect(host.get('os_family')).to.equal('osf1');
    });
    it('ip', function () {
      expect(host.get('ip')).to.equal('0.0.0.0');
    });
    it('memory', function () {
      expect(host.get('memory')).to.equal('12345.00');
    });
    it('disk_info.length', function () {
      expect(host.get('disk_info.length')).to.equal(2);
    });

  });

  describe('#getJDKNameSuccessCallback', function () {

    it('should set proper data to controller properties', function () {

      var expected = {
          name: 'name',
          home: 'home',
          location: 'location'
        },
        data = {
          RootServiceComponents: {
            properties: {
              'jdk.name': expected.name,
              'java.home': expected.home,
              'jdk_location': expected.location
            }
          }
        };

      c.getJDKNameSuccessCallback(data);
      expect(c.get('needJDKCheckOnHosts')).to.equal(false);
      expect(c.get('jdkLocation')).to.equal(expected.location);
      expect(c.get('javaHome')).to.equal(expected.home);
    });

  });

  describe('#doCheckJDK', function () {

    it('should do request to the ambari-server', function () {

      var bootHosts = [
          Em.Object.create({name: 'n1', bootStatus: 'REGISTERED'}),
          Em.Object.create({name: 'n2', bootStatus: 'REGISTERED'})
        ],
        javaHome = '/java',
        jdkLocation = '/jdk';
      c.reopen({
        bootHosts: bootHosts,
        javaHome: javaHome,
        jdkLocation: jdkLocation
      });
      c.doCheckJDK();
      var args = testHelpers.findAjaxRequest('name', 'wizard.step3.jdk_check');
      expect(args).exists;
    });

  });

  describe('#doCheckJDKsuccessCallback', function () {

    it('should set jdkRequestIndex if data provided', function () {

      var data = {
          href: '/a/b/c'
        },
        expected = 'c';
      c.set('jdkRequestIndex', null);
      c.doCheckJDKsuccessCallback(data);
      expect(c.get('jdkRequestIndex')).to.equal(expected);
    });

    it('should set isJDKWarningsLoaded to true if jdkCategoryWarnings is not null', function () {

      var data = null,
        expected = true;
      c.set('isJDKWarningsLoaded', false);
      c.set('jdkCategoryWarnings', {});
      c.doCheckJDKsuccessCallback(data);
      expect(c.get('isJDKWarningsLoaded')).to.equal(expected);
    });

    it('should do request to ambari-server', function () {

      var data = null,
        jdkRequestIndex = 'jdkRequestIndex';
      c.set('jdkRequestIndex', jdkRequestIndex);
      c.set('jdkCategoryWarnings', null);
      c.doCheckJDKsuccessCallback(data);
      var args = testHelpers.findAjaxRequest('name', 'wizard.step3.jdk_check.get_results');
      expect(args).exists;
    });

  });

  describe('#doCheckJDKerrorCallback', function () {

    it('should set isJDKWarningsLoaded to true', function () {
      c.set('isJDKWarningsLoaded', false);
      c.doCheckJDKerrorCallback();
      expect(c.get('isJDKWarningsLoaded')).to.be.true;
    });

  });

  describe('#parseJDKCheckResults', function () {

    beforeEach(function () {
      sinon.stub(c, 'doCheckJDKsuccessCallback', Em.K);
    });

    afterEach(function () {
      c.doCheckJDKsuccessCallback.restore();
    });

    it('should set jdkCategoryWarnings to null if no data', function () {

      var data = {Requests: {}};
      c.set('jdkCategoryWarnings', {});
      c.parseJDKCheckResults(data);
      expect(c.get('jdkCategoryWarnings')).to.be.null;

    });

    it('should parse warnings (1)', function () {

      var data = {
        Requests: {
          end_time: 1
        },
        tasks: []
      };

      c.set('jdkCategoryWarnings', {});
      c.parseJDKCheckResults(data);
      expect(c.get('jdkCategoryWarnings')).to.eql([]);

    });

    it('should parse warnings (2)', function () {

      var data = {
        Requests: {
          end_time: 1
        },
        tasks: [
          {
            Tasks: {
              host_name: 'h1',
              structured_out: {
                java_home_check: {
                  exit_code: 1
                }
              }
            }
          },
          {
            Tasks: {
              host_name: 'h2',
              structured_out: {
                java_home_check: {
                  exit_code: 0
                }
              }
            }
          }
        ]
      };

      c.set('jdkCategoryWarnings', {});
      c.parseJDKCheckResults(data);
      var result = c.get('jdkCategoryWarnings');
      expect(result.length).to.equal(1);
      expect(result[0].hostsNames).to.eql(['h1']);

    });

  });

  describe('#getHostCheckTasksSuccess', function() {

    beforeEach(function() {
      sinon.stub(c, 'getHostInfo', Em.K);
      sinon.stub(c, 'parseHostNameResolution', Em.K);
      sinon.stub(c, 'getGeneralHostCheck', Em.K);
      sinon.stub(c, 'getHostCheckTasks', Em.K);

    });

    afterEach(function() {
      c.getHostInfo.restore();
      c.parseHostNameResolution.restore();
      c.getGeneralHostCheck.restore();
      c.getHostCheckTasks.restore();
    });

    var dataInProgress = {
      Requests: {
        request_status: "IN_PROGRESS"
      }
    };
    it('run getHostCheckTasks', function() {
      c.getHostCheckTasksSuccess(dataInProgress);
      expect(c.getHostCheckTasks.calledOnce).to.be.true;
    });

    var hostResolutionCheckComplete = {
      Requests: {
        request_status: "COMPLETED",
        inputs: "host_resolution_check"
      }
    };
    it('run parseHostNameResolution and getGeneralHostCheck', function() {
      c.getHostCheckTasksSuccess(hostResolutionCheckComplete);
      expect(c.parseHostNameResolution.calledWith(hostResolutionCheckComplete)).to.be.true;
      expect(c.getGeneralHostCheck.calledOnce).to.be.true;
    });

    var lastAgentEnvCheckComplete = {
      Requests: {
        request_status: "COMPLETED",
        inputs: "last_agent_env_check"
      },
      tasks: [
        {
          Tasks: {
            host_name: 'h1',
            structured_out: {
              "installed_packages": [
                {
                  "version": "b1",
                  "name": "n1",
                  "repoName": "r1"
                },
                {
                  "version": "b2",
                  "name": "n2",
                  "repoName": "r2"
                }
              ]
            }
          }
        }
      ]
    };
    it('run getHostInfo', function() {
      c.getHostCheckTasksSuccess(lastAgentEnvCheckComplete);
      expect(c.get('stopChecking')).to.be.true;
      expect(c.getHostInfo.calledOnce).to.be.true;
      expect(JSON.parse(JSON.stringify(c.get('hostsPackagesData')))).eql([
        {
          hostName: 'h1',
          installedPackages: [
            {
              "version": "b1",
              "name": "n1",
              "repoName": "r1"
            },
            {
              "version": "b2",
              "name": "n2",
              "repoName": "r2"
            }
          ]
        }
      ]);
    });

  });

  describe('#getDataForCheckRequest', function() {
    var tests = [
      {
        bootHosts: [
          Em.Object.create({'bootStatus': 'REGISTERED', 'name': 'h1'}),
          Em.Object.create({'bootStatus': 'FAILED', 'name': 'h2'})
        ],
        addHosts: true,
        rez: {
          RequestInfo: {
            "action": "check_host",
            "context": "Check host",
            "parameters": {
              "check_execute_list": 'checkExecuteList',
              "jdk_location" : "jdk_location",
              "threshold": "20",
              "hosts": "h1"
            }
          },
          resource_filters: {
              "hosts": "h1"
          }
        },
        m: 'with add host param'
      },
      {
        bootHosts: [
          Em.Object.create({'bootStatus': 'REGISTERED', 'name': 'h1'}),
          Em.Object.create({'bootStatus': 'FAILED', 'name': 'h2'})
        ],
        addHosts: false,
        rez: {
          RequestInfo: {
            "action": "check_host",
            "context": "Check host",
            "parameters": {
              "check_execute_list": 'checkExecuteList',
              "jdk_location" : "jdk_location",
              "threshold": "20"
            }
          },
          resource_filters: {
            "hosts": "h1"
          }
        },
        m: 'without add host param'
      },
      {
        bootHosts: [
          Em.Object.create({'bootStatus': 'FAILED', 'name': 'h1'}),
          Em.Object.create({'bootStatus': 'FAILED', 'name': 'h2'})
        ],
        rez: null,
        m: 'with all hosts failed'
      }
    ];

    beforeEach(function() {
      sinon.stub(App.get('router'), 'get' , function(p) {
        return p === 'clusterController.ambariProperties.jdk_location' ? 'jdk_location' : Em.get(App.get('router'), p);
      })
    });
    afterEach(function() {
      App.get('router').get.restore();
    });
    tests.forEach(function(t) {
      it(t.m, function() {
        c.set('bootHosts', t.bootHosts);
        expect(c.getDataForCheckRequest('checkExecuteList', t.addHosts)).to.be.eql(t.rez);
      });
    })
  });

  describe('#isBackDisabled', function () {

    var cases = [
      {
        inputData: {
          isRegistrationInProgress: true,
          isWarningsLoaded: true,
          isBootstrapFailed: true
        },
        isBackDisabled: false
      },
      {
        inputData: {
          isRegistrationInProgress: true,
          isWarningsLoaded: false,
          isBootstrapFailed: false
        },
        isBackDisabled: true
      },
      {
        inputData: {
          isRegistrationInProgress: true,
          isWarningsLoaded: true,
          isBootstrapFailed: false
        },
        isBackDisabled: true
      },
      {
        inputData: {
          isRegistrationInProgress: true,
          isWarningsLoaded: false,
          isBootstrapFailed: true
        },
        isBackDisabled: false
      },
      {
        inputData: {
          isRegistrationInProgress: false,
          isWarningsLoaded: true,
          isBootstrapFailed: true
        },
        isBackDisabled: false
      },
      {
        inputData: {
          isRegistrationInProgress: false,
          isWarningsLoaded: false,
          isBootstrapFailed: false
        },
        isBackDisabled: true
      },
      {
        inputData: {
          isRegistrationInProgress: false,
          isWarningsLoaded: true,
          isBootstrapFailed: false
        },
        isBackDisabled: false
      },
      {
        inputData: {
          isRegistrationInProgress: false,
          isWarningsLoaded: false,
          isBootstrapFailed: true
        },
        isBackDisabled: false
      }
    ];

    cases.forEach(function (item) {
      var title = Em.keys(item.inputData).map(function (key) {
        return key + ':' + item.inputData[key];
      }).join(', ');
      it(title, function () {
        c.setProperties({
          isRegistrationInProgress: item.inputData.isRegistrationInProgress,
          isBootstrapFailed: item.inputData.isBootstrapFailed
        });
        c.reopen({
          isWarningsLoaded: item.inputData.isWarningsLoaded
        });
        expect(c.get('isBackDisabled')).to.equal(item.isBackDisabled);
      });
    });

  });

  describe('#hostsInCluster', function () {

    var hosts = {
      host1: {isInstalled: true},
      host2: {isInstalled: false},
      host3: {isInstalled: true},
      host4: {isInstalled: false}
    };

    beforeEach(function () {
      c.set('content', {hosts: hosts});
      c.propertyDidChange('hostsInCluster');
    });

    it('should take only installed hosts', function () {
      expect(c.get('hostsInCluster')).to.be.eql(['host1', 'host3']);
    });

  });

  describe('#filterHostsData', function () {

    var bootHosts = [
      Em.Object.create({name: 'c1'}),
      Em.Object.create({name: 'c2'}),
      Em.Object.create({name: 'c3'})
    ];

    var data = {
      href: 'abc',
      tasks: [
        {Tasks: {host_name: 'c1'}},
        {Tasks: {host_name: 'c2'}},
        {Tasks: {host_name: 'c3'}},
        {Tasks: {host_name: 'c2'}},
        {Tasks: {host_name: 'c3'}},
        {Tasks: {host_name: 'c4'}}
      ]
    };

    beforeEach(function() {
      c.set('bootHosts', bootHosts);
      this.result = c.filterHostsData(data);
    });

    it('href is valid', function () {
      expect(this.result.href).to.be.equal('abc');
    });

    it('tasks are valid', function () {
      expect(this.result.tasks).to.be.eql([
        {Tasks: {host_name: 'c1'}},
        {Tasks: {host_name: 'c2'}},
        {Tasks: {host_name: 'c3'}},
        {Tasks: {host_name: 'c2'}},
        {Tasks: {host_name: 'c3'}}
      ]);
    });


  });

  describe('#parseHostNameResolution', function () {

    var data = {
      tasks: [
        {Tasks: {status: 'COMPLETED', host_name: 'h1', structured_out: {host_resolution_check: {failed_count: 2, hosts_with_failures: ['h2', 'h3']}}}},
        {Tasks: {status: 'COMPLETED', host_name: 'h4', structured_out: {host_resolution_check: {failed_count: 2, hosts_with_failures: ['h5', 'h6']}}}},
        {Tasks: {status: 'COMPLETED', host_name: 'h7', structured_out: {host_resolution_check: {failed_count: 1, hosts_with_failures: ['h8']}}}}
      ]
    };
    var hostCheckWarnings = [];

    beforeEach(function () {
      c.set('hostCheckWarnings', hostCheckWarnings);
      c.parseHostNameResolution(data);
      this.warnings = c.get('hostCheckWarnings').findProperty('name', Em.I18n.t('installer.step3.hostWarningsPopup.resolution.validation.error'));
    });

    it('Host check warnings for hostname resolutions exist', function () {
      expect(this.warnings).to.exist;
    });

    it('hostsNames are ["h1", "h4", "h7"]', function () {
      expect(this.warnings.hostsNames.toArray()).to.be.eql(['h1', 'h4', 'h7']);
    });

    it('warning appears on many hosts', function () {
      expect(this.warnings.onSingleHost).to.be.false;
    });

    it('validation context for hosts is valid', function () {
      var hosts = this.warnings.hosts;
      var expected = [
        Em.I18n.t('installer.step3.hostWarningsPopup.resolution.validation.context').format('h1', 2 + ' ' + Em.I18n.t('installer.step3.hostWarningsPopup.hosts')),
        Em.I18n.t('installer.step3.hostWarningsPopup.resolution.validation.context').format('h4', 2 + ' ' + Em.I18n.t('installer.step3.hostWarningsPopup.hosts')),
        Em.I18n.t('installer.step3.hostWarningsPopup.resolution.validation.context').format('h7', 1 + ' ' + Em.I18n.t('installer.step3.hostWarningsPopup.host'))
      ];
      expect(hosts).to.be.eql(expected);
    });

    it('validation context (long) for hosts is valid', function () {
      var hostsLong = this.warnings.hostsLong;
      var expected = [
        Em.I18n.t('installer.step3.hostWarningsPopup.resolution.validation.context').format('h1', 'h2, h3'),
        Em.I18n.t('installer.step3.hostWarningsPopup.resolution.validation.context').format('h4', 'h5, h6'),
        Em.I18n.t('installer.step3.hostWarningsPopup.resolution.validation.context').format('h7', 'h8')
      ];
      expect(hostsLong).to.be.eql(expected);
    });

  });

  describe('#getHostCheckTasksError', function () {

    beforeEach(function () {
      c.set('stopChecking', false);
    });

    it('should set `stopChecking` to true', function () {
      c.getHostCheckTasksError();
      expect(c.get('stopChecking')).to.be.true;
    });

  });

  describe('#closeReloadPopupOnExit', function () {

    var cases = [
      {
        stopBootstrap: true,
        closeReloadPopupCallCount: 1,
        title: 'bootstrap should be stopped'
      },
      {
        stopBootstrap: false,
        closeReloadPopupCallCount: 0,
        title: 'bootstrap should not be stopped'
      }
    ];

    beforeEach(function () {
      sinon.stub(c, 'closeReloadPopup', Em.K);
    });

    afterEach(function () {
      c.closeReloadPopup.restore();
    });

    cases.forEach(function (item) {

      it(item.title, function () {
        if (c.get('stopBootstrap') === item.stopBootstrap) {
          c.propertyDidChange('stopBootstrap');
        } else {
          c.set('stopBootstrap', item.stopBootstrap);
        }
        expect(c.closeReloadPopup.callCount).to.equal(item.closeReloadPopupCallCount);
      });

    });

  });

  describe('#isNextButtonDisabled', function () {

    var cases = [
      {
        btnClickInProgress: true,
        isSubmitDisabled: true,
        isNextButtonDisabled: true,
        description: 'button clicked, submit disabled',
        title: 'next button disabled'
      },
      {
        btnClickInProgress: true,
        isSubmitDisabled: false,
        isNextButtonDisabled: true,
        description: 'button clicked, submit not disabled',
        title: 'next button disabled'
      },
      {
        btnClickInProgress: false,
        isSubmitDisabled: true,
        isNextButtonDisabled: true,
        description: 'no button clicked, submit disabled',
        title: 'next button disabled'
      },
      {
        btnClickInProgress: false,
        isSubmitDisabled: false,
        isNextButtonDisabled: false,
        description: 'no button clicked, submit not disabled',
        title: 'next button enabled'
      }
    ];

    cases.forEach(function (item) {

      describe(item.description, function () {

        beforeEach(function () {
          c.set('isSubmitDisabled', item.isSubmitDisabled);
          sinon.stub(App, 'get').withArgs('router.btnClickInProgress').returns(item.btnClickInProgress);
          c.propertyDidChange('isSubmitDisabled');
          c.propertyDidChange('App.router.btnClickInProgress');
        });

        afterEach(function () {
          App.get.restore();
        });

        it(item.title, function () {
          expect(c.get('isNextButtonDisabled')).to.equal(item.isNextButtonDisabled);
        });

      });

    });

  });

  describe('#isBackButtonDisabled', function () {

    var cases = [
      {
        btnClickInProgress: true,
        isBackDisabled: true,
        isBackButtonDisabled: true,
        description: 'button clicked, stepping back disabled',
        title: 'back button disabled'
      },
      {
        btnClickInProgress: true,
        isBackDisabled: false,
        isBackButtonDisabled: true,
        description: 'button clicked, stepping back not disabled',
        title: 'back button disabled'
      },
      {
        btnClickInProgress: false,
        isBackDisabled: true,
        isBackButtonDisabled: true,
        description: 'no button clicked, stepping back disabled',
        title: 'back button disabled'
      },
      {
        btnClickInProgress: false,
        isBackDisabled: false,
        isBackButtonDisabled: false,
        description: 'no button clicked, stepping back not disabled',
        title: 'back button enabled'
      }
    ];

    cases.forEach(function (item) {

      describe(item.description, function () {

        beforeEach(function () {
          c.reopen({
            isBackDisabled: item.isBackDisabled
          });
          sinon.stub(App, 'get').withArgs('router.btnClickInProgress').returns(item.btnClickInProgress);
          c.propertyDidChange('isBackDisabled');
          c.propertyDidChange('App.router.btnClickInProgress');
        });

        afterEach(function () {
          App.get.restore();
        });

        it(item.title, function () {
          expect(c.get('isBackButtonDisabled')).to.equal(item.isBackButtonDisabled);
        });

      });

    });

  });

});

});

require.register("test/controllers/wizard/step4_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');
var modelSetup = require('test/init_model_test');

require('controllers/wizard/step4_controller');
describe('App.WizardStep4Controller', function () {

  var services = [
    'HDFS', 'GANGLIA', 'OOZIE', 'HIVE', 'HBASE', 'PIG', 'SCOOP', 'ZOOKEEPER', 'SMARTSENSE', 'LOGSEARCH',
    'YARN', 'MAPREDUCE2', 'FALCON', 'TEZ', 'STORM', 'AMBARI_METRICS', 'RANGER', 'SPARK', 'SLIDER', 'ATLAS', 'AMBARI_INFRA'
  ];
  var controller;

  beforeEach(function() {
    controller = App.WizardStep4Controller.create();
    services.forEach(function(serviceName) {
      controller.pushObject(Ember.Object.create({
        'serviceName':serviceName, 'isSelected': true, 'isHiddenOnSelectServicePage': false, 'isInstalled': false, 'isDisabled': 'HDFS' === serviceName, isDFS: 'HDFS' === serviceName
      }));
    });
  });

  var generateSelectedServicesContent = function(selectedServiceNames) {
    var allServices = services.slice(0);
    modelSetup.setupStackServiceComponent();
    if (selectedServiceNames.contains('GLUSTERFS')) allServices.push('GLUSTERFS');
    allServices = allServices.map(function(serviceName) {
      return [Ember.Object.create({
        'serviceName': serviceName,
        'isSelected': false,
        'canBeSelected': true,
        'isInstalled': false,
        isPrimaryDFS: serviceName === 'HDFS',
        isDFS: ['HDFS','GLUSTERFS'].contains(serviceName),
        isMonitoringService: ['GANGLIA'].contains(serviceName),
        requiredServices: App.StackService.find(serviceName).get('requiredServices'),
        displayNameOnSelectServicePage: App.format.role(serviceName, true),
        coSelectedServices: function() {
          return App.StackService.coSelected[this.get('serviceName')] || [];
        }.property('serviceName')
      })];
    }).reduce(function(current, prev) { return current.concat(prev); });

    selectedServiceNames.forEach(function(serviceName) {
      allServices.findProperty('serviceName', serviceName).set('isSelected', true);
    });

    return allServices;
  };

  describe('#isSubmitDisabled', function () {
    it('should return false if at least one selected service is not installed', function () {
      expect(controller.get('isSubmitDisabled')).to.equal(false);
    });
    it('should return true if all selected services are already installed', function () {
      controller.setEach('isInstalled', true);
      controller.findProperty('serviceName', 'HDFS').set('isSelected', false);
      expect(controller.get('isSubmitDisabled')).to.equal(true);
    });
  });

  describe('#isAllChecked', function () {
    it('should return true if all services are selected', function () {
      controller.setEach('isInstalled', false);
      controller.findProperty('serviceName', 'HDFS').set('isSelected', true);
      expect(controller.get('isAllChecked')).to.equal(true);
    });

    it('should return false if at least one service is not selected', function () {
      controller.findProperty('serviceName', 'HDFS').set('isSelected', false);
      expect(controller.get('isAllChecked')).to.equal(false);
    });
  });

  describe('#multipleDFSs()', function () {
    it('should return true if HDFS is selected and GLUSTERFS is selected', function () {
      controller.set('content', generateSelectedServicesContent(['HDFS', 'GLUSTERFS']));
      expect(controller.multipleDFSs()).to.equal(true);
    });
    it('should return false if HDFS is not selected and GLUSTERFS is selected', function () {
      controller.set('content', generateSelectedServicesContent(['GLUSTERFS']));
      expect(controller.multipleDFSs()).to.equal(false);
    });
    it('should return false if HDFS is selected and GLUSTERFS is not selected', function () {
      controller.set('content', generateSelectedServicesContent(['HDFS']));
      expect(controller.multipleDFSs()).to.equal(false);
    });
  });

  describe('#setGroupedServices()', function () {
    var testCases = [
      {
        title: 'should set MapReduce2 isSelected to true when YARN is selected',
        condition: {
          'YARN': true,
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': true,
          'MAPREDUCE2': true
        },
        result: {
          'MAPREDUCE2': true
        }
      },
      {
        title: 'should set MapReduce2 isSelected to false when YARN is not selected',
        condition: {
          'YARN': false,
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': false,
          'MAPREDUCE2': true
        },
        result: {
          'MAPREDUCE2': false
        }
      },
      {
        title: 'should set MAPREDUCE2 isSelected to true when YARN is selected',
        condition: {
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': false,
          'YARN': true,
          'MAPREDUCE2': true
        },
        result: {
          'MAPREDUCE2': true
        }
      },
      {
        title: 'should set MAPREDUCE2 isSelected to false when YARN is not selected',
        condition: {
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': true,
          'YARN': false,
          'MAPREDUCE2': true
        },
        result: {
          'MAPREDUCE2': false
        }
      }
    ];

    testCases.forEach(function(testCase){
      describe(testCase.title, function () {

        beforeEach(function () {
          controller.clear();
          Object.keys(testCase.condition).forEach(function (id) {
            controller.pushObject(Ember.Object.create({
              serviceName: id,
              isSelected: testCase.condition[id],
              canBeSelected: true,
              isInstalled: false,
              coSelectedServices: function() {
                return App.StackService.coSelected[this.get('serviceName')] || [];
              }.property('serviceName')
            }));
          });
          controller.setGroupedServices();
        });

        Object.keys(testCase.result).forEach(function (service) {
          it(service, function () {
            expect(controller.findProperty('serviceName', service).get('isSelected')).to.equal(testCase.result[service]);
          });
        });
      });
    }, this);
  });

  describe('#addValidationError()', function() {
    var tests = [
      {
        errorObjects: [
          {
            id: 'serviceCheck_ZOOKEEPER',
            shouldBeAdded: true
          },
          {
            id: 'serviceCheck_YARN',
            shouldBeAdded: true
          }
        ],
        expectedIds: ['serviceCheck_ZOOKEEPER', 'serviceCheck_YARN']
      },
      {
        errorObjects: [
          {
            id: 'fsCheck',
            shouldBeAdded: true
          },
          {
            id: 'fsCheck',
            shouldBeAdded: false
          }
        ],
        expectedIds: ['fsCheck']
      }
    ];

    beforeEach(function() {
      controller.clear();
      controller.set('errorStack', []);
    });

    tests.forEach(function(test) {
      var message = 'Erorrs {0} thrown. errorStack property should contains ids: {1}'
        .format(test.errorObjects.mapProperty('id').join(', '), test.expectedIds.join(', '));
      describe(message, function() {

        beforeEach(function () {
          this.added = [];
          test.errorObjects.forEach(function(errorObject) {
            this.added.push(controller.addValidationError(errorObject));
          }, this);
        });

        it('shouldBeAdded', function() {
          expect(this.added).to.be.eql(test.errorObjects.mapProperty('shouldBeAdded'));
        });

        it('expectedIds', function() {
          expect(controller.get('errorStack').mapProperty('id')).to.eql(test.expectedIds);
        });
      });
    })
  });

  describe('#validate()', function() {
    var tests = [
        {
          services: ['HDFS', 'ZOOKEEPER'],
          errorsExpected: ['ambariMetricsCheck', 'smartSenseCheck']
        },
        {
          services: ['ZOOKEEPER'],
          errorsExpected: ['ambariMetricsCheck', 'smartSenseCheck']
        },
        {
          services: ['HDFS'],
          errorsExpected: ['serviceCheck_ZOOKEEPER', 'ambariMetricsCheck', 'smartSenseCheck']
        },
        {
          services: ['HDFS', 'TEZ', 'ZOOKEEPER'],
          errorsExpected: ['serviceCheck_YARN', 'ambariMetricsCheck' , 'smartSenseCheck']
        },
        {
          services: ['HDFS', 'ZOOKEEPER', 'FALCON'],
          errorsExpected: ['serviceCheck_OOZIE', 'ambariMetricsCheck' , 'smartSenseCheck']
        },
        {
          services: ['HDFS', 'ZOOKEEPER', 'GANGLIA', 'HIVE'],
          errorsExpected: ['serviceCheck_YARN', 'ambariMetricsCheck' , 'smartSenseCheck']
        },
        {
          services: ['HDFS', 'GLUSTERFS', 'ZOOKEEPER', 'HIVE'],
          errorsExpected: ['serviceCheck_YARN', 'multipleDFS', 'ambariMetricsCheck', 'smartSenseCheck']
        },
        {
          services: ['HDFS','ZOOKEEPER', 'GANGLIA'],
          errorsExpected: ['ambariMetricsCheck', 'smartSenseCheck']
        },
        {
          services: ['HDFS','ZOOKEEPER', 'AMBARI_METRICS'],
          errorsExpected: ['smartSenseCheck']
        },
        {
          services: ['ZOOKEEPER', 'AMBARI_METRICS'],
          errorsExpected: ['smartSenseCheck']
        },
        {
          services: ['HDFS', 'AMBARI_METRICS'],
          errorsExpected: ['serviceCheck_ZOOKEEPER', 'smartSenseCheck']
        },
        {
          services: ['HDFS', 'TEZ', 'ZOOKEEPER', 'AMBARI_METRICS'],
          errorsExpected: ['serviceCheck_YARN', 'smartSenseCheck']
        },
        {
          services: ['HDFS', 'ZOOKEEPER', 'FALCON', 'AMBARI_METRICS'],
          errorsExpected: ['serviceCheck_OOZIE', 'smartSenseCheck']
        },
        {
          services: ['HDFS', 'ZOOKEEPER', 'GANGLIA', 'HIVE', 'AMBARI_METRICS'],
          errorsExpected: ['serviceCheck_YARN', 'smartSenseCheck']
        },
        {
          services: ['HDFS', 'GLUSTERFS', 'ZOOKEEPER', 'HIVE', 'AMBARI_METRICS'],
          errorsExpected: ['serviceCheck_YARN', 'multipleDFS', 'smartSenseCheck']
        },
        {
          services: ['HDFS','ZOOKEEPER', 'GANGLIA', 'AMBARI_METRICS'],
          errorsExpected: ['smartSenseCheck']
        },
        {
          services: ['RANGER'],
          errorsExpected: ['ambariMetricsCheck', 'smartSenseCheck', 'rangerRequirements']
        },
        {
          services: ['SMARTSENSE'],
          errorsExpected: ['ambariMetricsCheck']
        },
        {
          services: ['ATLAS', 'AMBARI_METRICS', 'SMARTSENSE'],
          errorsExpected: ['ambariInfraCheck']
        },
        {
          services: ['LOGSEARCH', 'AMBARI_METRICS', 'SMARTSENSE'],
          errorsExpected: ['ambariLogsearchCheck']
        }
      ],
      controllerNames = ['installerController', 'addServiceController'],
      wizardNames = {
        installerController: 'Install Wizard',
        addServiceController: 'Add Service Wizard'
      },
      sparkCases = [
        {
          currentStackName: 'HDP',
          currentStackVersionNumber: '2.2',
          sparkWarningExpected: true,
          title: 'HDP 2.2'
        },
        {
          currentStackName: 'HDP',
          currentStackVersionNumber: '2.3',
          sparkWarningExpected: false,
          title: 'HDP 2.3'
        },
        {
          currentStackName: 'BIGTOP',
          currentStackVersionNumber: '0.8',
          sparkWarningExpected: false,
          title: 'Non-HDP stack'
        }
      ];

    beforeEach(function () {
      controller.clear();
    });

    controllerNames.forEach(function (name) {
      tests.forEach(function(test) {
        var errorsExpected = test.errorsExpected;
        if (name !== 'installerController') {
          errorsExpected = test.errorsExpected.without('ambariMetricsCheck').without('smartSenseCheck');
        }
        var message = '{0}, {1} selected validation should be {2}, errors: {3}'
          .format(wizardNames[name], test.services.join(','), errorsExpected.length ? 'passed' : 'failed',
            errorsExpected.length ? errorsExpected.join(',') : 'absent');
        it(message, function() {
          controller.setProperties({
            content: generateSelectedServicesContent(test.services),
            errorStack: [],
            wizardController: Em.Object.create({
              name: name
            })
          });
          controller.validate();
          expect(controller.get('errorStack').mapProperty('id')).to.eql(errorsExpected.toArray());
        });
      })
    });

    sparkCases.forEach(function (item) {
      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(App, 'get').withArgs('currentStackName').returns(item.currentStackName).
            withArgs('currentStackVersionNumber').returns(item.currentStackVersionNumber);
          controller.set('errorStack', []);
          controller.set('content', generateSelectedServicesContent(['SPARK']));
          controller.validate();
        });

        afterEach(function () {
          App.get.restore();
        });

        it('sparkWarning ' + (item.sparkWarningExpected ? 'exists' : 'not exists'), function () {
          expect(controller.get('errorStack').someProperty('id', 'sparkWarning')).to.equal(item.sparkWarningExpected);
        });
      });
    });

  });

  describe('#onPrimaryPopupCallback()', function() {
    var c;
    var tests = [
      {
        services: ['HDFS','ZOOKEEPER'],
        confirmPopupCount: 0,
        errorsExpected: []
      },
      {
        services: ['ZOOKEEPER'],
        confirmPopupCount: 0,
        errorsExpected: []
      },
      {
        services: ['HDFS', 'GLUSTERFS', 'ZOOKEEPER', 'HIVE'],
        confirmPopupCount: 2,
        errorsExpected: ['serviceCheck_YARN', 'serviceCheck_TEZ', 'multipleDFS']
      },
      {
        services: ['HDFS','ZOOKEEPER', 'GANGLIA'],
        confirmPopupCount: 0,
        errorsExpected: []
      }
    ];

    beforeEach(function() {
      c = App.WizardStep4Controller.create({});
      sinon.stub(App.router, 'send', Em.K);
      sinon.stub(c, 'submit', Em.K);
      sinon.spy(c, 'onPrimaryPopupCallback');
    });

    afterEach(function() {
      App.router.send.restore();
      c.submit.restore();
      c.onPrimaryPopupCallback.restore();
    });


    tests.forEach(function(test) {
      var message = 'Selected services: {0}. {1} errors should be confirmed'
        .format(test.services.join(', '), test.confirmPopupCount);

      describe(message, function() {
        var runValidations = function() {
          c.serviceDependencyValidation();
          c.fileSystemServiceValidation();
        };

        beforeEach(function () {
          c.set('content', generateSelectedServicesContent(test.services));
          runValidations();
        });

        it('errors count validation', function () {
          expect(c.get('errorStack.length')).to.equal(test.confirmPopupCount);
        });

        if (test.errorsExpected) {
          describe('if errors detected than it should be shown', function () {
            var currentErrorObject;
            beforeEach(function () {
              currentErrorObject = c.get('errorStack').findProperty('isShown', false);
            });
            test.errorsExpected.forEach(function(error) {
              it(error, function () {
                // validate current error
                if (currentErrorObject) {
                  expect(test.errorsExpected).to.contain(currentErrorObject.id);
                  // show current error
                  var popup = c.showError(currentErrorObject);
                  // submit popup
                  popup.onPrimary();
                  // onPrimaryPopupCallback should be called
                  expect(c.onPrimaryPopupCallback.called).to.equal(true);
                  // submit called
                  expect(c.submit.called).to.equal(true);
                  if (c.get('errorStack').length) {
                    // current error isShown flag changed to true
                    expect(currentErrorObject.isShown).to.equal(true);
                  }
                  runValidations();
                }
              });
            });
          });
        }
      });
    });

  });

  describe('#needToAddServicePopup', function() {

    beforeEach(function () {
      sinon.stub(controller, 'submit', Em.K);
    });

    afterEach(function () {
      controller.submit.restore();
    });

    Em.A([
        {
          m: 'one service',
          services: {selected: true, serviceName: 's1'},
          content: [Em.Object.create({serviceName: 's1', isSelected: false})],
          e: [true]
        },
        {
          m: 'many services',
          services: [{selected: true, serviceName: 's1'}, {selected: false, serviceName: 's2'}],
          content: [Em.Object.create({serviceName: 's1', isSelected: false}),
            Em.Object.create({serviceName: 's2', isSelected: true})],
          e: [true, false]
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          controller.set('content', test.content);
          controller.needToAddServicePopup(test.services, '').onPrimary();
          expect(controller.submit.calledOnce).to.equal(true);
          expect(controller.mapProperty('isSelected')).to.eql(test.e);
        });
      });
  });

  describe('#submit', function() {
    var c;
    var tests = [
      {
        isSubmitDisabled: true,
        validate: false,
        userCanProceed: false
      },
      {
        isSubmitDisabled: false,
        validate: false,
        userCanProceed: false
      },
      {
        isSubmitDisabled: false,
        validate: true,
        userCanProceed: true
      }
    ];

    beforeEach(function() {
      c = App.WizardStep4Controller.create();
      sinon.stub(App.router, 'send', Em.K);
    });

    afterEach(function() {
      App.router.send.restore();
    });

    tests.forEach(function(test) {
      var messageFormat = [
        test.isSubmitDisabled ? 'disabled' : 'enabled',
        test.validate ? 'success' : 'failed',
        test.userCanProceed ? '' : 'not'
      ];
      var message = String.prototype.format.apply('Submit btn: {0}. Validation: {1}. Can{2} move to the next step.', messageFormat);

      it(message, function() {
        c.reopen({
          isSubmitDisabled: test.isSubmitDisabled,
          validate: function() { return test.validate; }
        });
        c.clear();
        c.submit();

        expect(App.router.send.calledOnce).to.equal(test.userCanProceed);
      });

    })
  });

  describe('#dependencies', function() {
    var tests = [
      {
        services: ['HDFS'],
        dependencies: ['ZOOKEEPER'] 
      },
      {
        services: ['STORM'],
        dependencies: ['ZOOKEEPER'] 
      }
    ];
    tests.forEach(function(test) {
      var message = '{0} dependency should be {1}'.format(test.services.join(','), test.dependencies.join(','));
      it(message, function() {
        
        controller.clear();
        controller.set('content', generateSelectedServicesContent(test.services));
        
        var dependentServicesTest = [];
        
        test.services.forEach(function(serviceName) {
          var service = controller.filterProperty('serviceName', serviceName);
          service.forEach(function(item) {
            var dependencies = item.get('requiredServices');
            if(!!dependencies) {
              dependentServicesTest = dependentServicesTest.concat(dependencies);
            }
          });
        });

        expect(dependentServicesTest).to.be.eql(test.dependencies);
      });
    })
  });

  describe('#serviceDependencyValidation', function () {

    var cases = [
      {
        services: ['HBASE'],
        dependentServices: ['HDFS', 'ZOOKEEPER'],
        title: 'HBASE selected and HDFS not selected initially'
      },
      {
        services: ['TEZ', 'HDFS'],
        dependentServices: ['ZOOKEEPER', 'YARN'],
        title: 'TEZ selected and ZOOKEEPER not selected initially'
      }
    ];

    beforeEach(function() {
      controller.clear();
      controller.set('errorStack', []);
    });

    cases.forEach(function (item) {
      describe(item.title, function () {

        beforeEach(function () {
          controller.set('content', generateSelectedServicesContent(item.services));
          controller.serviceDependencyValidation();
        });

        it('check errors in the stack', function () {
          var ids = controller.get('errorStack').mapProperty('id');
          expect(ids.contains("serviceCheck_" + item.dependentServices[0])).to.be.true;
          expect(ids.contains("serviceCheck_" + item.dependentServices[1])).to.be.true;
        });

        it('simulate situation where user clicks cancel on error for first dependent service and then selects it in which case', function () {
          controller.findProperty('serviceName', item.dependentServices[0]).set('isSelected', true);
          //serviceDependencyValidation() will be called again
          controller.serviceDependencyValidation();
          //error for first dependent service must be removed from errorStack array
          var ids = controller.get('errorStack').mapProperty('id');
          expect(ids.contains("serviceCheck_" + item.dependentServices[0])).to.be.false;
          expect(ids.contains("serviceCheck_" + item.dependentServices[1])).to.be.true;
        });

      });
    });
  });

  describe('#serviceValidation', function () {

    var cases = [
      {
        services: ['HDFS'],
        isAmbariMetricsWarning: false,
        title: 'Ambari Metrics not available'
      },
      {
        services: ['AMBARI_METRICS'],
        isAmbariMetricsSelected: false,
        isAmbariMetricsWarning: true,
        title: 'Ambari Metrics not selected'
      },
      {
        services: ['AMBARI_METRICS'],
        isAmbariMetricsSelected: true,
        isAmbariMetricsWarning: false,
        title: 'Ambari Metrics selected'
      }
    ];

    beforeEach(function() {
      controller.clear();
      controller.set('errorStack', []);
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('content', generateSelectedServicesContent(item.services));
        var ams = controller.findProperty('serviceName', 'AMBARI_METRICS');
        if (item.services.contains('AMBARI_METRICS')) {
          ams.set('isSelected', item.isAmbariMetricsSelected);
        } else {
          controller.removeObject(ams);
        }
        controller.serviceValidation(Em.K, 'AMBARI_METRICS', 'ambariMetricsCheck');
        expect(controller.get('errorStack').mapProperty('id').contains('ambariMetricsCheck')).to.equal(item.isAmbariMetricsWarning);
      });
    });

  });

  describe('#rangerValidation', function () {

    var cases = [
      {
        services: ['HDFS'],
        isRangerWarning: false,
        title: 'Ranger not available'
      },
      {
        services: ['RANGER'],
        isRangerSelected: false,
        isRangerInstalled: false,
        isRangerWarning: false,
        title: 'Ranger not selected'
      },
      {
        services: ['RANGER'],
        isRangerSelected: true,
        isRangerInstalled: false,
        isRangerWarning: true,
        title: 'Ranger selected'
      },
      {
        services: ['RANGER'],
        isRangerSelected: true,
        isRangerInstalled: true,
        isRangerWarning: false,
        title: 'Ranger installed'
      }
    ];

    beforeEach(function() {
      controller.clear();
      controller.set('errorStack', []);
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('content', generateSelectedServicesContent(item.services));
        var ranger = controller.findProperty('serviceName', 'RANGER');
        if (item.services.contains('RANGER')) {
          ranger.setProperties({
            isSelected: item.isRangerSelected,
            isInstalled: item.isRangerInstalled
          });
        } else {
          controller.removeObject(ranger);
        }
        controller.rangerValidation();
        expect(controller.get('errorStack').mapProperty('id').contains('rangerRequirements')).to.equal(item.isRangerWarning);
      });
    });

  });

  describe('#sparkValidation', function () {

    var cases = [
      {
        services: ['HDFS'],
        isSparkWarning: false,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.2',
        title: 'HDP 2.2, Spark not available'
      },
      {
        services: ['HDFS'],
        isSparkWarning: false,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.3',
        title: 'HDP 2.3, Spark not available'
      },
      {
        services: ['HDFS'],
        isSparkWarning: false,
        currentStackName: 'BIGTOP',
        currentStackVersionNumber: '0.8',
        title: 'Non-HDP stack, Spark not available'
      },
      {
        services: ['SPARK'],
        isSparkSelected: false,
        isSparkInstalled: false,
        isSparkWarning: false,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.2',
        title: 'HDP 2.2, Spark not selected'
      },
      {
        services: ['SPARK'],
        isSparkSelected: true,
        isSparkInstalled: false,
        isSparkWarning: true,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.2',
        title: 'HDP 2.2, Spark selected'
      },
      {
        services: ['SPARK'],
        isSparkSelected: true,
        isSparkInstalled: true,
        isSparkWarning: false,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.2',
        title: 'HDP 2.2, Spark installed'
      },
      {
        services: ['SPARK'],
        isSparkSelected: false,
        isSparkInstalled: false,
        isSparkWarning: false,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.3',
        title: 'HDP 2.3, Spark not selected'
      },
      {
        services: ['SPARK'],
        isSparkSelected: true,
        isSparkInstalled: false,
        isSparkWarning: false,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.3',
        title: 'HDP 2.3, Spark selected'
      },
      {
        services: ['SPARK'],
        isSparkSelected: true,
        isSparkInstalled: true,
        isSparkWarning: false,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.3',
        title: 'HDP 2.3, Spark installed'
      },
      {
        services: ['SPARK'],
        isSparkSelected: false,
        isSparkInstalled: false,
        isSparkWarning: false,
        currentStackName: 'BIGTOP',
        currentStackVersionNumber: '0.8',
        title: 'Non-HDP stack, Spark not selected'
      },
      {
        services: ['SPARK'],
        isSparkSelected: true,
        isSparkInstalled: false,
        isSparkWarning: false,
        currentStackName: 'BIGTOP',
        currentStackVersionNumber: '0.8',
        title: 'Non-HDP stack, Spark selected'
      },
      {
        services: ['SPARK'],
        isSparkSelected: true,
        isSparkInstalled: true,
        isSparkWarning: false,
        currentStackName: 'BIGTOP',
        currentStackVersionNumber: '0.8',
        title: 'Non-HDP stack, Spark installed'
      }
    ];

    beforeEach(function() {
      controller.clear();
      controller.set('errorStack', []);
      this.stub = sinon.stub(App, 'get');
    });

    afterEach(function () {
      App.get.restore();
    });

    cases.forEach(function (item) {
      describe(item.title, function () {
        beforeEach(function () {
          this.stub.withArgs('currentStackName').returns(item.currentStackName).
            withArgs('currentStackVersionNumber').returns(item.currentStackVersionNumber);
          controller.set('content', generateSelectedServicesContent(item.services));
          var spark = controller.findProperty('serviceName', 'SPARK');
          if (item.services.contains('SPARK')) {
            spark.setProperties({
              isSelected: item.isSparkSelected,
              isInstalled: item.isSparkInstalled
            });
          } else {
            controller.removeObject(spark);
          }
          controller.sparkValidation();
        });

        it('sparkWarning is ' + item.sparkWarning, function () {
          expect(controller.get('errorStack').mapProperty('id').contains('sparkWarning')).to.equal(item.isSparkWarning);
        });
      });
    });

  });

  describe('#clearErrors', function () {

    var cases = [
      {
        errorStack: [{
          isAccepted: false
        }],
        resultingErrorStack: [{
          isAccepted: false
        }],
        title: 'error stack shouldn\'t be cleared during validation'
      },
      {
        errorStack: [{
          isAccepted: true
        }],
        resultingErrorStack: [],
        title: 'error stack should be cleared'
      }
    ];

    beforeEach(function () {
      controller.set('errorStack', [{}]);
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('errorStack', item.errorStack);
        controller.propertyDidChange('@each.isSelected');
        expect(controller.get('errorStack')).to.eql(item.resultingErrorStack);
      });
    });

  });

  describe('Service warnings popup', function () {

    var target = {
      clb: Em.K
    };
    var id = 1;

    beforeEach(function () {
      sinon.spy(target, 'clb');
      sinon.stub(controller, 'onPrimaryPopupCallback', Em.K);
    });

    afterEach(function () {
      target.clb.restore();
      controller.onPrimaryPopupCallback.restore();
    });

    Em.A([
      'serviceCheckPopup',
      'rangerRequirementsPopup',
      'sparkWarningPopup'
    ]).forEach(function (methodName) {

      describe('#' + methodName, function () {

        beforeEach(function () {
          this.popup = controller[methodName](target.clb, id);
        });

        it('#onPrimary', function () {
          this.popup.onPrimary();
          expect(controller.onPrimaryPopupCallback.calledWith(target.clb)).to.be.true;
        });

        it('#onSecondary', function () {
          this.popup.onSecondary();
          expect(target.clb.calledWith(id)).to.be.true;
        });

        it('#onClose', function () {
          this.popup.onClose();
          expect(target.clb.calledWith(id)).to.be.true;
        });
      });
    });
  });

  describe('#dependentServiceValidation', function() {

    beforeEach(function() {
      sinon.stub(controller, 'serviceValidation');
    });

    afterEach(function() {
      controller.serviceValidation.restore();
      controller.clear();
    });

    it('serviceValidation should not be called when selected service does not exist', function() {
      controller.dependentServiceValidation('S1', 'S2', 'check', Em.K);
      expect(controller.serviceValidation.called).to.be.false;
    });

    it('serviceValidation should not be called when service not selected', function() {
      controller.pushObject(Em.Object.create({
        serviceName: 'S1',
        isSelected: false
      }));
      controller.dependentServiceValidation('S1', 'S2', 'check', Em.K);
      expect(controller.serviceValidation.called).to.be.false;
    });

    it('serviceValidation should not be called when dependent service does not exist', function() {
      controller.pushObjects([
        Em.Object.create({
          serviceName: 'S1',
          isSelected: true
        })
      ]);
      controller.dependentServiceValidation('S1', 'S2', 'check', Em.K);
      expect(controller.serviceValidation.called).to.be.false;
    });

    it('serviceValidation should not be called when dependent service is selected', function() {
      controller.pushObjects([
        Em.Object.create({
          serviceName: 'S1',
          isSelected: true
        }),
        Em.Object.create({
          serviceName: 'S2',
          isSelected: true
        })
      ]);
      controller.dependentServiceValidation('S1', 'S2', 'check', Em.K);
      expect(controller.serviceValidation.called).to.be.false;
    });

    it('serviceValidation should be called when dependent service is not selected', function() {
      controller.pushObjects([
        Em.Object.create({
          serviceName: 'S1',
          isSelected: true
        }),
        Em.Object.create({
          serviceName: 'S2',
          isSelected: false
        })
      ]);
      controller.dependentServiceValidation('S1', 'S2', 'check', Em.K);
      expect(controller.serviceValidation.calledOnce).to.be.true;
    });
  });

});

});

require.register("test/controllers/wizard/step5_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/wizard/step5_controller');
var modelSetup = require('test/init_model_test');
require('utils/ajax/ajax');
var c;
describe('App.WizardStep5Controller', function () {

  beforeEach(function () {
    c = App.WizardStep5Controller.create();
    sinon.stub(App.router, 'send', Em.K);
    App.set('router.nextBtnClickInProgress', false);
  });

  afterEach(function () {
    App.router.send.restore();
    App.set('router.nextBtnClickInProgress', false);
  });

  var controller = App.WizardStep5Controller.create();
  controller.set('content', {});

  controller.set('content', {});

  describe('#sortHosts', function () {

    var tests = Em.A([
      {
        hosts: [
          Em.Object.create({memory: 4, cpu: 1, host_name: 'host1', id: 1}),
          Em.Object.create({memory: 3, cpu: 1, host_name: 'host2', id: 2}),
          Em.Object.create({memory: 2, cpu: 1, host_name: 'host3', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 4})
        ],
        m: 'memory',
        e: [1, 2, 3, 4]
      },
      {
        hosts: [
          Em.Object.create({memory: 1, cpu: 4, host_name: 'host1', id: 1}),
          Em.Object.create({memory: 1, cpu: 3, host_name: 'host2', id: 2}),
          Em.Object.create({memory: 1, cpu: 2, host_name: 'host3', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 4})
        ],
        m: 'cpu',
        e: [1, 2, 3, 4]
      },
      {
        hosts: [
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 1}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host2', id: 2}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host3', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host1', id: 4})
        ],
        m: 'host_name',
        e: [4, 2, 3, 1]
      },
      {
        hosts: [
          Em.Object.create({memory: 2, cpu: 1, host_name: 'host1', id: 1}),
          Em.Object.create({memory: 1, cpu: 2, host_name: 'host3', id: 2}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host2', id: 4})
        ],
        m: 'mix',
        e: [1, 2, 4, 3]
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        var hosts = Em.copy(test.hosts);
        controller.sortHosts(hosts);
        expect(Em.A(hosts).mapProperty('id')).to.eql(test.e);
      });
    });

  });

  describe('#renderHostInfo', function () {

    var tests = Em.A([
      {
        hosts: {
          h1: {memory: 4, cpu: 1, name: 'host1', bootStatus: 'INIT'},
          h2: {memory: 3, cpu: 1, name: 'host2', bootStatus: 'INIT'},
          h3: {memory: 2, cpu: 1, name: 'host3', bootStatus: 'INIT'},
          h4: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'INIT'}
        },
        m: 'no one host is REGISTERED',
        e: []
      },
      {
        hosts: {
          h1: {memory: 4, cpu: 1, name: 'host1', bootStatus: 'REGISTERED'},
          h2: {memory: 3, cpu: 1, name: 'host2', bootStatus: 'REGISTERED'},
          h3: {memory: 2, cpu: 1, name: 'host3', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'}
        },
        m: 'all hosts are REGISTERED, memory',
        e: ['host1', 'host2', 'host3', 'host4']
      },
      {
        hosts: {
          h1: {memory: 1, cpu: 4, name: 'host1', bootStatus: 'REGISTERED'},
          h2: {memory: 1, cpu: 3, name: 'host2', bootStatus: 'REGISTERED'},
          h3: {memory: 1, cpu: 2, name: 'host3', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'}
        },
        m: 'all hosts are REGISTERED, cpu',
        e: ['host1', 'host2', 'host3', 'host4']
      },
      {
        hosts: {
          h1: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'},
          h2: {memory: 1, cpu: 1, name: 'host2', bootStatus: 'REGISTERED'},
          h3: {memory: 1, cpu: 1, name: 'host3', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host1', bootStatus: 'REGISTERED'}
        },
        m: 'all hosts are REGISTERED, host_name',
        e: ['host1', 'host2', 'host3', 'host4']
      },
      {
        hosts: {
          h1: {memory: 2, cpu: 1, name: 'host1', bootStatus: 'REGISTERED'},
          h2: {memory: 1, cpu: 2, name: 'host3', bootStatus: 'INIT'},
          h3: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host2', bootStatus: 'INIT'}
        },
        m: 'mix',
        e: ['host1', 'host4']
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content', {hosts: test.hosts});
        controller.renderHostInfo();
        var r = controller.get('hosts');
        expect(Em.A(r).mapProperty('host_name')).to.eql(test.e);
      });
    });

  });

  describe('#last', function () {

    var tests = Em.A([
      {
        selectedServicesMasters: Em.A([
          {component_name: 'c1', indx: 1},
          {component_name: 'c2', indx: 2},
          {component_name: 'c1', indx: 2}
        ]),
        m: 'Components exists',
        c: 'c1',
        e: 2
      },
      {
        selectedServicesMasters: Em.A([
          {component_name: 'c1', indx: 1},
          {component_name: 'c2', indx: 2},
          {component_name: 'c1', indx: 2}
        ]),
        m: 'Components don\'t exists',
        c: 'c3',
        e: null
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('selectedServicesMasters', test.selectedServicesMasters);
        if (!Em.isNone(test.e)) {
          expect(controller.last(test.c).indx).to.equal(test.e);
        }
        else {
          expect(Em.isNone(controller.last(test.c))).to.equal(true);
        }
      })
    });

  });

  describe('#remainingHosts', function () {
    it('should show count of hosts without masters', function () {
      c.reopen({masterHostMapping: [
        {}
      ]});
      c.set('hosts', [
        {},
        {},
        {}
      ]);
      expect(c.get('remainingHosts')).to.equal(2);
    });
  });

  describe('#clearStep', function () {
    var tests = Em.A([
      {p: 'hosts'},
      {p: 'selectedServicesMasters'},
      {p: 'servicesMasters'}
    ]);
    tests.forEach(function (test) {
      it('should cleanup ' + test.p, function () {
        c.set(test.p, [Em.Object.create({}), Em.Object.create({})]);
        c.clearStep();
        expect(c.get(test.p).length).to.equal(0);
      });
    });
  });

  describe('#updateComponent', function () {
    var tests = Em.A([
      {
        componentName: 'HBASE_SERVER',
        serviceComponents: [
          Em.Object.create({
            componentName: 'HBASE_SERVER',
            stackService: Em.Object.create({isInstalled: true, serviceName: 'HBASE'})
          })
        ],
        selectedServicesMasters: Em.A([
          Em.Object.create({showAddControl: false, showRemoveControl: true, component_name: 'HBASE_SERVER'}),
          Em.Object.create({showAddControl: true, showRemoveControl: false, component_name: 'HBASE_SERVER'})
        ]),
        hosts: Em.A([
          Em.Object.create({})
        ]),
        controllerName: 'addServiceController',
        m: 'service is installed',
        e: {
          showAddControl: true,
          showRemoveControl: false
        }
      },
      {
        componentName: 'HBASE_SERVER',
        serviceComponents: [
          Em.Object.create({
            componentName: 'HBASE_SERVER',
            stackService: Em.Object.create({isInstalled: false, serviceName: 'HBASE'})
          })
        ],
        selectedServicesMasters: Em.A([
          Em.Object.create({showAddControl: true, showRemoveControl: false, component_name: 'HBASE_SERVER'})
        ]),
        hosts: Em.A([
          Em.Object.create({})
        ]),
        controllerName: 'addServiceController',
        m: 'service not installed, but all host already have provided component',
        e: {
          showAddControl: true,
          showRemoveControl: false
        }
      },
      {
        componentName: 'HBASE_SERVER',
        serviceComponents: [
          Em.Object.create({
            componentName: 'HBASE_SERVER',
            stackService:  Em.Object.create({isInstalled: false, serviceName: 'HBASE'})
          })
        ],
        selectedServicesMasters: Em.A([
          Em.Object.create({showAddControl: false, showRemoveControl: true, component_name: 'HBASE_SERVER'})
        ]),
        hosts: Em.A([
          Em.Object.create({}),
          Em.Object.create({})
        ]),
        controllerName: 'reassignMasterController',
        m: 'service not installed, not all host already have provided component, but is reassignMasterController',
        e: {
          showAddControl: false,
          showRemoveControl: false
        }
      }
    ]);

    tests.forEach(function (test) {
      describe(test.m, function () {

        beforeEach(function () {
          sinon.stub(App.StackServiceComponent, 'find', function () {
            return test.serviceComponents;
          });
          c.reopen({
            content: Em.Object.create({
              controllerName: test.controllerName
            }),
            selectedServicesMasters: test.selectedServicesMasters,
            hosts: test.hosts
          });
          c.updateComponent(test.componentName);
        });

        afterEach(function () {
          App.StackServiceComponent.find.restore();
        });

        Em.keys(test.e).forEach(function (k) {
          it(k, function () {
            expect(c.last(test.componentName).get(k)).to.equal(test.e[k]);
          });
        });

      });
    });
  });

  describe('#renderComponents', function () {
    var tests = Em.A([
      {
        masterComponents: Em.A([
          {component_name: 'ZOOKEEPER_SERVER'}
        ]),
        services: Em.A([
          Em.Object.create({serviceName: 'ZOOKEEPER', isInstalled: false, isSelected: true})
        ]),
        controllerName: 'reassignMasterController',
        m: 'One component',
        isHaEnabled: false,
        component_name: 'ZOOKEEPER_SERVER',
        e: {
          selectedServicesMasters: ['ZOOKEEPER_SERVER'],
          servicesMasters: ['ZOOKEEPER_SERVER'],
          showRemoveControl: [false],
          isInstalled: [false],
          serviceComponentId: [1]
        }
      },
      {
        masterComponents: Em.A([
          {component_name: 'ZOOKEEPER_SERVER'}
        ]),
        services: Em.A([
          Em.Object.create({serviceName: 'ZOOKEEPER', isInstalled: false, isSelected: true})
        ]),
        controllerName: 'addServiceController',
        m: 'One component, service is not installed',
        component_name: 'ZOOKEEPER_SERVER',
        e: {
          selectedServicesMasters: ['ZOOKEEPER_SERVER'],
          servicesMasters: ['ZOOKEEPER_SERVER'],
          showRemoveControl: [false],
          serviceComponentId: [1]
        }
      },
      {
        masterComponents: Em.A([
          {component_name: 'ZOOKEEPER_SERVER'},
          {component_name: 'ZOOKEEPER_SERVER'}
        ]),
        services: Em.A([
          Em.Object.create({serviceName: 'ZOOKEEPER', isInstalled: true})
        ]),
        controllerName: 'addServiceController',
        m: 'Two components, but service is installed',
        component_name: 'ZOOKEEPER_SERVER',
        e: {
          selectedServicesMasters: ['ZOOKEEPER_SERVER', 'ZOOKEEPER_SERVER'],
          servicesMasters: ['ZOOKEEPER_SERVER', 'ZOOKEEPER_SERVER'],
          showRemoveControl: [false, false],
          serviceComponentId: [1, 2]
        }
      }
    ]);
    tests.forEach(function (test) {
      describe(test.m, function () {

        beforeEach(function () {
          sinon.stub(App, 'get').withArgs('isHaEnabled').returns(test.isHaEnabled);
          sinon.stub(App.StackService, 'find', function () {
            return test.services;
          });
          modelSetup.setupStackServiceComponent();
          c.reopen({
            content: Em.Object.create({
              services: test.services,
              controllerName: test.controllerName,
              reassign: {component_name: test.component_name}
            })
          });
          c.renderComponents(test.masterComponents);
        });

        afterEach(function () {
          App.get.restore();
          App.StackService.find.restore();
          modelSetup.cleanStackServiceComponent();
        });

        it('all selectedServicesMasters.component_name are valid', function () {
          expect(c.get('selectedServicesMasters').mapProperty('component_name')).to.eql(test.e.selectedServicesMasters);
        });

        it('all servicesMasters.component_name are valid', function () {
          expect(c.get('servicesMasters').mapProperty('component_name')).to.eql(test.e.servicesMasters);
        });

        it('all showRemoveControl are valid', function () {
          expect(c.get('selectedServicesMasters').mapProperty('showRemoveControl')).to.eql(test.e.showRemoveControl);
        });

        it('all serviceComponentId are valid', function () {
          expect(c.get('selectedServicesMasters').mapProperty('serviceComponentId')).to.eql(test.e.serviceComponentId);
        });

        it('servicesMasters.@each.isInstalled is valid', function () {
          if (c.get('isReasignController')) {
            expect(c.get('servicesMasters').mapProperty('isInstalled')).to.eql(test.e.isInstalled);
          }
        });

      });
    });
  });

  describe('#assignHostToMaster', function () {
    var tests = Em.A([
        {
          componentName: 'c1',
          selectedHost: 'h2',
          serviceComponentId: '1',
          e: {
            indx: 0
          }
        },
        {
          componentName: 'c2',
          selectedHost: 'h3',
          serviceComponentId: '2',
          e: {
            indx: 3
          }
        },
        {
          componentName: 'c3',
          selectedHost: 'h1',
          e: {
            indx: 2
          }
        },
        {
          componentName: 'c2',
          selectedHost: 'h4',
          e: {
            indx: 1
          }
        }
      ]),
      selectedServicesMasters = Em.A([
        Em.Object.create({component_name: 'c1', serviceComponentId: '1', selectedHost: 'h1'}),
        Em.Object.create({component_name: 'c2', serviceComponentId: '1', selectedHost: 'h1'}),
        Em.Object.create({component_name: 'c3', serviceComponentId: '1', selectedHost: 'h3'}),
        Em.Object.create({component_name: 'c2', serviceComponentId: '2', selectedHost: 'h2'})
      ]);

    tests.forEach(function (test) {
      it(test.componentName + ' ' + test.selectedHost + ' ' + test.serviceComponentId, function () {
        c.set('selectedServicesMasters', selectedServicesMasters);
        c.assignHostToMaster(test.componentName, test.selectedHost, test.serviceComponentId);
        expect(c.get('selectedServicesMasters').objectAt(test.e.indx).get('selectedHost')).to.equal(test.selectedHost);
      })
    });
  });

  describe('#removeComponent', function () {

    beforeEach(function () {
      sinon.stub(c, 'getMaxNumberOfMasters', function () {
        return Infinity;
      });
    });

    afterEach(function(){
      c.getMaxNumberOfMasters.restore();
    });

    var tests = Em.A([
      {
        componentName: 'c1',
        serviceComponentId: 1,
        selectedServicesMasters: Em.A([]),
        hosts: [],
        m: 'empty selectedServicesMasters',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        serviceComponentId: 1,
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'HBASE_SERVER'})
        ]),
        hosts: [],
        m: 'no such components',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        serviceComponentId: 1,
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER'})
        ]),
        hosts: [],
        m: 'component is only 1',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        serviceComponentId: 2,
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false})
        ]),
        hosts: [
          {},
          {}
        ],
        m: 'two components, add allowed, remove not allowed',
        e: true,
        showAddControl: true,
        showRemoveControl: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        serviceComponentId: 2,
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 3, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: true})
        ]),
        hosts: [
          {},
          {},
          {}
        ],
        m: 'three components, add allowed, remove allowed',
        e: true,
        showAddControl: true,
        showRemoveControl: true
      }
    ]);
    tests.forEach(function (test) {
      describe(test.m, function () {

        beforeEach(function () {
          c.set('selectedServicesMasters', JSON.parse(JSON.stringify(test.selectedServicesMasters)));
          c.set('hosts', test.hosts);
          this.result = c.removeComponent(test.componentName, test.serviceComponentId);
        });

        it('removeComponent returns ' + test.e, function () {
          expect(this.result).to.equal(test.e);
        });

        if (test.e) {
          it('showRemoveControl is correct', function () {
            expect(c.get('selectedServicesMasters.lastObject.showRemoveControl')).to.equal(test.showRemoveControl);
          });

          it('showAddControl is correct', function () {
            expect(c.get('selectedServicesMasters.lastObject.showAddControl')).to.equal(test.showAddControl);
          });

          it('componentToRebalance is correct', function () {
            expect(c.get('componentToRebalance')).to.equal(test.componentName);
          });

          it('lastChangedComponent is correct', function () {
            expect(c.get('lastChangedComponent')).to.equal(test.componentName);
          });
        }
      })
    });
  });

  describe('#addComponent', function () {

    beforeEach(function () {
      sinon.stub(c, 'getMaxNumberOfMasters', function () {
        return Infinity;
      });
    });

    afterEach(function(){
      c.getMaxNumberOfMasters.restore();
    });

    var tests = Em.A([
      {
        componentName: 'c1',
        selectedServicesMasters: Em.A([]),
        hosts: [],
        m: 'empty selectedServicesMasters',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'HBASE_SERVER'})
        ]),
        hosts: [],
        m: 'no such components',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false})
        ]),
        hosts: [Em.Object.create({}), Em.Object.create({}), Em.Object.create({})],
        m: 'two components, 3 hosts',
        e: true
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.set('selectedServicesMasters', test.selectedServicesMasters);
        c.set('hosts', test.hosts);
        expect(c.addComponent(test.componentName)).to.equal(test.e);
        if (test.e) {
          expect(c.get('componentToRebalance')).to.equal(test.componentName);
          expect(c.get('lastChangedComponent')).to.equal(test.componentName);
        }
      });
    });
  });

  describe('#masterHostMapping', function () {
    Em.A([
        {
          selectedServicesMasters: [
            Em.Object.create({selectedHost: 'h1'}),
            Em.Object.create({selectedHost: 'h2'}),
            Em.Object.create({selectedHost: 'h1'})
          ],
          hosts: [
            Em.Object.create({host_name: 'h1', host_info: {}}),
            Em.Object.create({host_name: 'h2', host_info: {}})
          ],
          m: 'Two hosts',
          e: [
            {host_name: 'h1', hostInfo: {}, masterServices: [
              {},
              {}
            ]},
            {host_name: 'h2', hostInfo: {}, masterServices: [
              {}
            ]}
          ]
        },
        {
          selectedServicesMasters: [],
          hosts: [],
          m: 'No hosts',
          e: []
        },
        {
          selectedServicesMasters: [
            Em.Object.create({selectedHost: 'h1'}),
            Em.Object.create({selectedHost: 'h1'})
          ],
          hosts: [
            Em.Object.create({host_name: 'h1', host_info: {}})
          ],
          m: 'One host',
          e: [
            {host_name: 'h1', hostInfo: {}, masterServices: [
              {},
              {}
            ]}
          ]
        }
      ]).forEach(function (test) {
        describe(test.m, function () {
          var result;
          beforeEach(function () {
            c.reopen({
              selectedServicesMasters: test.selectedServicesMasters,
              hosts: test.hosts
            });
            result = c.get('masterHostMapping');
          });

          it('all needed hosts are mapped', function () {
            expect(result.length).to.equal(test.e.length);
          });

          it('all needed hosts have valid data', function () {
            expect(result.mapProperty('host_name')).to.be.eql(test.e.mapProperty('host_name'));
            expect(result.mapProperty('masterServices.length')).to.be.eql(test.e.mapProperty('masterServices.length'));
          });
        });
      });
  });

  describe('#anyError', function () {

    Em.A([
        {
          servicesMasters: [
            Em.Object.create({errorMessage: 'some message'}),
            Em.Object.create({errorMessage: ''})
          ],
          generalErrorMessages: [],
          e: true
        },
        {
          servicesMasters: [
            Em.Object.create({errorMessage: ''}),
            Em.Object.create({errorMessage: ''})
          ],
          generalErrorMessages: [],
          e: false
        },
        {
          servicesMasters: [
            Em.Object.create({errorMessage: 'some message'}),
            Em.Object.create({errorMessage: 'some message 2'})
          ],
          generalErrorMessages: ['some message'],
          e: true
        },
        {
          servicesMasters: [
            Em.Object.create({errorMessage: ''}),
            Em.Object.create({errorMessage: ''})
          ],
          generalErrorMessages: ['some message'],
          e: true
        }
      ]).forEach(function (test, i) {
        it('test #' + i.toString(), function () {
          c.setProperties({
            servicesMasters: test.servicesMasters,
            generalErrorMessages: test.generalErrorMessages
          });
          expect(c.get('anyError')).to.equal(test.e);
        });
      });

  });

  describe('#anyWarning', function () {

    Em.A([
        {
          servicesMasters: [
            Em.Object.create({warnMessage: 'some message'}),
            Em.Object.create({warnMessage: ''})
          ],
          generalWarningMessages: [],
          e: true
        },
        {
          servicesMasters: [
            Em.Object.create({warnMessage: ''}),
            Em.Object.create({warnMessage: ''})
          ],
          generalWarningMessages: [],
          e: false
        },
        {
          servicesMasters: [
            Em.Object.create({warnMessage: 'some message'}),
            Em.Object.create({warnMessage: 'some message 2'})
          ],
          generalWarningMessages: ['some message'],
          e: true
        },
        {
          servicesMasters: [
            Em.Object.create({warnMessage: ''}),
            Em.Object.create({warnMessage: ''})
          ],
          generalWarningMessages: ['some message'],
          e: true
        }
      ]).forEach(function (test, i) {
        it('test #' + i.toString(), function () {
          c.setProperties({
            servicesMasters: test.servicesMasters,
            generalWarningMessages: test.generalWarningMessages
          });
          expect(c.get('anyWarning')).to.equal(test.e);
        });
      });

  });

  describe('#clearRecommendations', function () {

    it('should clear content.recommendations', function () {

      c.set('content', {recommendations: {'s': {}}});
      c.clearRecommendations();
      expect(c.get('content.recommendations')).to.be.null;

    });

  });

  describe('#updateIsSubmitDisabled', function () {

    var clearCases = [
      {
        isHostNameValid: true,
        isInitialLayout: true,
        isInitialLayoutResulting: false,
        clearRecommendationsCallCount: 0,
        recommendAndValidateCallCount: 1,
        title: 'initial masters-hosts layout'
      },
      {
        isHostNameValid: true,
        isInitialLayout: false,
        isInitialLayoutResulting: false,
        clearRecommendationsCallCount: 1,
        recommendAndValidateCallCount: 1,
        title: 'master-hosts layout changed'
      },
      {
        isHostNameValid: false,
        isInitialLayout: false,
        isInitialLayoutResulting: false,
        clearRecommendationsCallCount: 0,
        recommendAndValidateCallCount: 0,
        title: 'invalid host name specified'
      }
    ];

    beforeEach(function () {
      c.set('selectedServicesMasters', [
        {isInstalled: false}
      ]);
      sinon.stub(c, 'clearRecommendations', Em.K);
      sinon.stub(c, 'recommendAndValidate', Em.K);
    });

    afterEach(function () {
      c.clearRecommendations.restore();
      c.recommendAndValidate.restore();
    });

    it('shouldn\'t change submitDisabled if thereIsNoMasters returns false', function () {

      c.set('selectedServicesMasters', [
        {isInstalled: true}
      ]);
      c.set('submitDisabled', false);
      c.updateIsSubmitDisabled();
      expect(c.get('submitDisabled')).to.equal(false);

    });

    it('should check servicesMasters.@each.isHostNameValid if useServerValidation is false', function () {

      c.set('useServerValidation', false);
      c.set('servicesMasters', [
        {isHostNameValid: false},
        {isHostNameValid: true}
      ]);
      c.updateIsSubmitDisabled();
      expect(c.get('submitDisabled')).to.equal(true);

      c.set('servicesMasters', [
        {isHostNameValid: true},
        {isHostNameValid: true}
      ]);
      c.updateIsSubmitDisabled();
      expect(c.get('submitDisabled')).to.equal(false);

    });

    clearCases.forEach(function (item) {
      it(item.title, function () {
        c.setProperties({
          isInitialLayout: item.isInitialLayout,
          servicesMasters: [{
            isHostNameValid: item.isHostNameValid
          }]
        });
        expect(c.get('isInitialLayout')).to.equal(item.isInitialLayoutResulting);
        expect(c.clearRecommendations.callCount).to.equal(item.clearRecommendationsCallCount);
        expect(c.recommendAndValidate.callCount).to.equal(item.recommendAndValidateCallCount);
      });
    });

  });

  describe('#isHostNameValid', function () {

    beforeEach(function () {
      c.setProperties({
        hosts: [
          {host_name: 'h1', isInstalled: false},
          {host_name: 'h2', isInstalled: true, maintenance_state: 'ON'},
          {host_name: 'h3', isInstalled: true, maintenance_state: 'OFF'}
        ],
        selectedServicesMasters: [
          {component_name: 'c1', selectedHost: 'h1'},
          {component_name: 'c2', selectedHost: 'h2'},
          {component_name: 'c3', selectedHost: 'h3'},
          {component_name: 'c3', selectedHost: 'h1'}
        ]
      });
    });

    Em.A([
      {
        componentName: 'c1',
        selectedHost: '   ',
        m: 'empty hostName is invalid',
        e: false
      },
      {
        componentName: 'c1',
        selectedHost: 'h4',
        m: 'hostName not exists',
        e: false
      },
      {
        componentName: 'c1',
        selectedHost: 'h1',
        m: 'not installed host',
        e: true
      },
      {
        componentName: 'c1',
        selectedHost: 'h2',
        m: 'installed host with maintenance ON',
        e: false
      },
      {
        componentName: 'c1',
        selectedHost: 'h3',
        m: 'installed host with maintenance OFF',
        e: true
      },
      {
        componentName: 'c4',
        selectedHost: 'h3',
        m: 'component not exists on host',
        e: true
      }
    ]).forEach(function (test) {
      it(test.m, function () {
        expect(c.isHostNameValid(test.componentName, test.selectedHost)).to.equal(test.e);
      });
    });

  });

  describe('#createComponentInstallationObject', function () {

    afterEach(function () {
      App.StackServiceComponent.find.restore();
    });

    Em.A([
        {
          fullComponent: Em.Object.create({
            componentName: 'c1',
            serviceName: 's1'
          }),
          hostName: 'h1',
          mastersToMove: ['c1'],
          savedComponent: {
            hostName: 'h2',
            isInstalled: true
          },
          stackServiceComponents: [Em.Object.create({componentName: 'c1', isCoHostedComponent: true})],
          e: {
            component_name: 'c1',
            display_name: 'C1',
            serviceId: 's1',
            selectedHost: 'h2',
            isInstalled: true,
            isServiceCoHost: false
          }
        },
        {
          fullComponent: Em.Object.create({
            componentName: 'c1',
            serviceName: 's1'
          }),
          hostName: 'h1',
          mastersToMove: [],
          stackServiceComponents: [Em.Object.create({componentName: 'c1', isCoHostedComponent: false})],
          e: {
            component_name: 'c1',
            display_name: 'C1',
            serviceId: 's1',
            selectedHost: 'h1',
            isInstalled: false,
            isServiceCoHost: false
          }
        },
        {
          fullComponent: Em.Object.create({
            componentName: 'c1',
            serviceName: 's1'
          }),
          hostName: 'h1',
          mastersToMove: [],
          stackServiceComponents: [Em.Object.create({componentName: 'c1', isCoHostedComponent: true})],
          e: {
            component_name: 'c1',
            display_name: 'C1',
            serviceId: 's1',
            selectedHost: 'h1',
            isInstalled: false,
            isServiceCoHost: true
          }
        }
      ]).forEach(function (test, i) {
        describe('test #' + i, function () {

          beforeEach(function () {
            sinon.stub(App.StackServiceComponent, 'find', function () {
              return test.stackServiceComponents;
            });
            c.set('mastersToMove', test.mastersToMove);
            c.set('content', {controllerName: test.controllerName});
          });

          it('component-object is valid', function () {
            expect(c.createComponentInstallationObject(test.fullComponent, test.hostName, test.savedComponent)).to.eql(test.e);
          });

        });
      });

  });

  describe('#createComponentInstallationObjects', function () {

    beforeEach(function() {
      sinon.stub(App.StackServiceComponent, 'find', function() {
        return [
          Em.Object.create({isShownOnAddServiceAssignMasterPage: true, componentName: 'c1', serviceName: 's1'}),
          Em.Object.create({isShownOnAddServiceAssignMasterPage: true, componentName: 'c2', serviceName: 's2'}),
          Em.Object.create({isShownOnAddServiceAssignMasterPage: true, componentName: 'c4', serviceName: 's2'}),
          Em.Object.create({isShownOnInstallerAssignMasterPage: true, componentName: 'c1', serviceName: 's1'}),
          Em.Object.create({isShownOnInstallerAssignMasterPage: true, componentName: 'c2', serviceName: 's2'}),
          Em.Object.create({isShownOnInstallerAssignMasterPage: true, componentName: 'c4', serviceName: 's2'})
        ];
      });

      var recommendations = {
        "blueprint": {
          "host_groups": [
            {
              "name": "host-group-1",
              "components": [ {"name": "c1"}, {"name": "c2"} ]
            },
            {
              "name": "host-group-2",
              "components": [ {"name": "c1"}, {"name": "c2"} ]
            },
            {
              "name": "host-group-3",
              "components": [ {"name": "c1"} ]
            }
          ]
        },
        "blueprint_cluster_binding": {
          "host_groups": [
            {
              "name": "host-group-1",
              "hosts": [ {"fqdn": "h1"} ]
            },
            {
              "name": "host-group-2",
              "hosts": [ {"fqdn": "h2"} ]
            },
            {
              "name": "host-group-3",
              "hosts": [ {"fqdn": "h3"} ]
            }
          ]
        }
      };

      c.set('recommendations', recommendations);
      c.set('content', {
        masterComponentHosts: [],
        services: [
          {serviceName: 's1', isSelected: true, isInstalled: false},
          {serviceName: 's2', isSelected: true, isInstalled: false}
        ],
        recommendations: recommendations
      });

    });

    afterEach(function() {
      App.StackServiceComponent.find.restore();
    });

    it('simple map without nothing stored/saved etc', function() {
      var r = c.createComponentInstallationObjects();
      expect(r.mapProperty('component_name')).to.eql(['c1', 'c2', 'c1', 'c2', 'c1']);
      expect(r.mapProperty('serviceId')).to.eql(['s1', 's2', 's1', 's2', 's1']);
      expect(r.mapProperty('selectedHost')).to.eql(['h1', 'h1', 'h2', 'h2', 'h3']);
    });

    describe('some saved components exist', function() {

      beforeEach(function () {
        c.set('content.controllerName', 'addServiceController');
        c.get('multipleComponents').push('c4');
        c.set('content.masterComponentHosts', [
          {hostName: 'h3', component: 'c4'}
        ]);
        c.get('content.recommendations.blueprint.host_groups')[2].components.push({name: 'c4'});
      });

      it('data contains save components', function () {
        var r = c.createComponentInstallationObjects();
        expect(r.mapProperty('component_name')).to.eql(['c1', 'c2', 'c1', 'c2', 'c1', 'c4']);
        expect(r.mapProperty('serviceId')).to.eql(['s1', 's2', 's1', 's2', 's1', 's2']);
        expect(r.mapProperty('selectedHost')).to.eql(['h1', 'h1', 'h2', 'h2', 'h3', 'h3']);
      });

    });

  });

  describe('#getCurrentBlueprint', function () {

    beforeEach(function() {
      sinon.stub(c, 'getCurrentSlaveBlueprint', function() {
        return {
          blueprint_cluster_binding: {
            host_groups: []
          },
          blueprint: {
            host_groups: []
          }
        };
      });
    });

    afterEach(function() {
      c.getCurrentSlaveBlueprint.restore();
    });

    it('should map masterHostMapping', function () {

      c.reopen({masterHostMapping: [
        {host_name: 'h1', hostInfo:{}, masterServices: [
          {serviceId: 's1', component_name: 'c1'},
          {serviceId: 's2', component_name: 'c2'}
        ]},
        {host_name: 'h2', hostInfo:{}, masterServices: [
          {serviceId: 's1', component_name: 'c1'},
          {serviceId: 's3', component_name: 'c3'}
        ]}
      ]});

      var r = c.getCurrentBlueprint();
      expect(r).to.eql({"blueprint": {"host_groups": [
          {"name": "host-group-1", "components": [
            {"name": "c1"},
            {"name": "c2"}
          ]},
          {"name": "host-group-2", "components": [
            {"name": "c1"},
            {"name": "c3"}
          ]}
        ]}, "blueprint_cluster_binding": {"host_groups": [
          {"name": "host-group-1", "hosts": [
            {"fqdn": "h1"}
          ]},
          {"name": "host-group-2", "hosts": [
            {"fqdn": "h2"}
          ]}
        ]}}
      );
    });

  });

  describe('#updateValidationsSuccessCallback', function() {

    beforeEach(function() {
      sinon.stub(App.HostComponent, 'find', function() {
        return [];
      });
    });

    afterEach(function() {
      App.HostComponent.find.restore();
    });

    describe('should map messages to generalErrorMessages, generalWarningMessages', function() {

      var data = [
          {
            type: 'host-component',
            'component-name': 'c1',
            host: 'h1',
            level: 'ERROR',
            message: 'm1'
          },
          {
            type: 'host-component',
            'component-name': 'c2',
            host: 'h2',
            level: 'WARN',
            message: 'm2'
          },
          {
            type: 'host-component',
            'component-name': 'c3',
            host: 'h3',
            level: 'ERROR',
            message: 'm3'
          },
          {
            type: 'host-component',
            'component-name': 'c4',
            host: 'h4',
            level: 'WARN',
            message: 'm4'
          }
        ],
        servicesMasters = [
          Em.Object.create({selectedHost: 'h1', component_name: 'c1'}),
          Em.Object.create({selectedHost: 'h2', component_name: 'c2'})
        ];

      beforeEach(function () {
        c.set('servicesMasters', servicesMasters);
        c.updateValidationsSuccessCallback({resources: [{items: data}]});
      });

      it('submitDisabled is false', function () {
        expect(c.get('submitDisabled')).to.equal(false);
      });

      it('errorMessage for c1 is `m1`', function () {
        expect(c.get('servicesMasters').findProperty('component_name', 'c1').get('errorMessage')).to.equal('m1');
      });

      it('errorMessage for c2 is `m2`', function () {
        expect(c.get('servicesMasters').findProperty('component_name', 'c2').get('warnMessage')).to.equal('m2');
      });

      it('no general errors', function () {
        expect(c.get('generalErrorMessages')).to.be.empty;
      });

      it('no general warnings', function () {
        expect(c.get('generalWarningMessages')).to.be.empty;
      });

    });

  });

});

});

require.register("test/controllers/wizard/step6_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var validationUtils = require('utils/validator');
require('utils/helper');
require('controllers/wizard/step6_controller');
var controller,
  services = [
    Em.Object.create({
      serviceName: 'YARN',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'HBASE',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'HDFS',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'STORM',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'FLUME',
      isSelected: true
    })
  ];

function getController() {
  var c = App.WizardStep6Controller.create({
    content: Em.Object.create({
      hosts: {},
      masterComponentHosts: {},
      services: services,
      controllerName: ''
    })
  });

  var h = {}, m = [];
  Em.A(['host0', 'host1', 'host2', 'host3']).forEach(function (hostName) {
    var obj = Em.Object.create({
      name: hostName,
      hostName: hostName,
      bootStatus: 'REGISTERED'
    });
    h[hostName] = obj;
    m.push(obj);
  });

  c.set('content.hosts', h);
  c.set('content.masterComponentHosts', m);
  c.set('isMasters', false);
  return c;
}

describe('App.WizardStep6Controller', function () {

  beforeEach(function () {
    controller = getController();
  });

  App.TestAliases.testAsComputedEqual(getController(), 'isAddHostWizard', 'content.controllerName', 'addHostController');

  describe('#installedServiceNames', function () {
    it(' should filter content.services by isInstalled property', function () {
      var _services = Em.A([]);
      _services.pushObjects(Em.A([{isInstalled: true, serviceName: "service1"},
                           {isInstalled: false, serviceName: "service2"},
                           {isInstalled: true, serviceName: "service3"},
                           {isInstalled: false, serviceName: "service4"},
                           {isInstalled: true, serviceName: "service5"}]));
      controller.set('content.services', _services);
      expect(controller.get('installedServiceNames')).to.eql(["service1", "service3", "service5"]);
    });
  });

  describe('#showValidationIssuesAcceptBox', function () {
    it('should return true if success callback', function () {
      var deffer = jQuery.Deferred();
      function callback() {
        deffer.resolve(true);
      }
      controller.showValidationIssuesAcceptBox(callback);
      jQuery.when(deffer.promise()).then(function(data) {
        expect(data).to.equal(true);    
      }); 
    });
  });

  describe('#selectAllNodes', function () {

    var hostsObj = Em.A([Em.Object.create({
      hasMaster: false,
      isInstalled: false,
      checkboxes: Em.A([
        Em.Object.create({
          title: 'l1',
          component: 'name',
          isInstalled: false,
          checked: false
        })
      ])
    })]);
    var obj = Em.Object.create({
      context: {
        name: "name"
      }
    });
    var clientComponents = Em.A([{component_name: "name1"}]);

    it('should make checkbox checked', function () {
      controller.set('hosts', hostsObj);
      controller.set('content.clients', clientComponents);
      controller.selectAllNodes(obj);
      expect(controller.get('hosts')).to.eql(Em.A([Em.Object.create({
        hasMaster: false,
        isInstalled: false,
        checkboxes: Em.A([
          Em.Object.create({
            title: 'l1',
            component: 'name',
            isInstalled: false,
            checked: true
          })
        ])
      })]));
    });
  });

  describe('#deselectAllNodes', function () {

    var hostsObj = Em.A([Em.Object.create({
      hasMaster: false,
      isInstalled: false,
      checkboxes: Em.A([
        Em.Object.create({
          title: 'l1',
          component: 'name',
          isInstalled: false,
          checked: true
        })
      ])
    })]);
    var obj = Em.Object.create({
      context: {
        name: "name"
      }
    });
    var clientComponents = Em.A([{component_name: "name1"}]);

    it('should uncheck checkbox', function () {
      controller.set('hosts', hostsObj);
      controller.set('content.clients', clientComponents);
      controller.deselectAllNodes(obj);
      expect(controller.get('hosts')).to.eql(Em.A([Em.Object.create({
        hasMaster: false,
        isInstalled: false,
        checkboxes: Em.A([
          Em.Object.create({
            title: 'l1',
            component: 'name',
            isInstalled: false,
            checked: false
          })
        ])
      })]));
    });
  });

  describe('#renderSlaves()', function () {
    var hostsObj = [{}];

    beforeEach(function() {
      sinon.stub(controller, 'selectRecommendedComponents');
      sinon.stub(controller, 'setInstalledComponents');
      sinon.stub(controller, 'restoreComponentsSelection');
      sinon.stub(controller, 'selectClientHost');
      sinon.stub(controller, 'enableCheckboxesForDependentComponents');
    });

    afterEach(function() {
      controller.selectRecommendedComponents.restore();
      controller.setInstalledComponents.restore();
      controller.restoreComponentsSelection.restore();
      controller.selectClientHost.restore();
      controller.enableCheckboxesForDependentComponents.restore();
    });

    describe("slaveComponents is null", function() {

      beforeEach(function() {
        controller.set('content.slaveComponentHosts', null);
        controller.set('content.controllerName', null);
      });

      it("selectRecommendedComponents should be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.selectRecommendedComponents.calledWith(hostsObj)).to.be.true;
      });
      it("setInstalledComponents should be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.setInstalledComponents.calledWith(hostsObj)).to.be.true;
      });
      it("restoreComponentsSelection should not be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.restoreComponentsSelection.called).to.be.false;
      });
      it("selectClientHost should be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.selectClientHost.calledWith(hostsObj)).to.be.true;
      });
      it("enableCheckboxesForDependentComponents should not be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.enableCheckboxesForDependentComponents.calledOnce).to.be.false;
      });
      it("enableCheckboxesForDependentComponents should be called", function() {
        controller.set('content.controllerName', 'addServiceController');
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.enableCheckboxesForDependentComponents.calledOnce).to.be.true;
      });
    });

    describe("slaveComponents is defined", function() {

      var slaveComponentHosts = [{}];

      beforeEach(function() {
        controller.set('content.slaveComponentHosts', slaveComponentHosts);
      });

      it("selectRecommendedComponents should not be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.selectRecommendedComponents.called).to.be.false;
      });
      it("setInstalledComponents should not be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.setInstalledComponents.called).to.be.false;
      });
      it("restoreComponentsSelection should be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.restoreComponentsSelection.calledWith(hostsObj, slaveComponentHosts)).to.be.true;
      });
      it("selectClientHost should be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.selectClientHost.calledWith(hostsObj)).to.be.true;
      });
    });
  });

  describe("#setInstalledComponents()", function() {
    var hostsObj = [{
      hostName: 'host1',
      checkboxes: [
        {
          component: 'C1',
          isInstalled: false,
          checked: false
        },
        {
          component: 'C2',
          isInstalled: false,
          checked: false
        }
      ]
    }];

    it("installedHosts is null", function() {
      controller.set('content.installedHosts', null);
      expect(controller.setInstalledComponents(hostsObj)).to.be.false;
    });

    it("installedHosts is defined", function() {
      controller.set('content.installedHosts', {
        'host1': {
          hostComponents: [
            {
              HostRoles: {
                component_name: 'C1'
              }
            }
          ]
        }
      });
      controller.setInstalledComponents(hostsObj);
      expect(hostsObj[0].checkboxes[0].isInstalled).to.be.true;
      expect(hostsObj[0].checkboxes[1].isInstalled).to.be.false;
      expect(hostsObj[0].checkboxes[0].checked).to.be.true;
      expect(hostsObj[0].checkboxes[1].checked).to.be.false;
    });
  });

  describe("#restoreComponentsSelection()", function() {
    var getHostsObj = function() {
      return [{
        hostName: 'host1',
        checkboxes: [
          {
            component: 'C1',
            title: 'c1',
            isInstalled: false,
            checked: false
          },
          {
            component: 'C2',
            title: 'c1',
            isInstalled: true,
            checked: false
          },
          {
            component: 'C3',
            title: 'c3',
            isInstalled: false,
            checked: false
          }
        ]
      }];
    };

    var slaveComponents = [
      {
        componentName: 'C1',
        hosts: [{hostName: 'host1', isInstalled: true}]
      }
    ];

    beforeEach(function() {
      controller.set('headers', [
        Em.Object.create({
          name: 'C1',
          label: 'c1'
        }),
        Em.Object.create({
          name: 'C2',
          label: 'c2'
        }),
        Em.Object.create({
          name: 'C3',
          label: 'c3'
        })
      ]);
    });

    it("C1 components should be checked and installed", function() {
      var hostsObj = getHostsObj();
      controller.restoreComponentsSelection(hostsObj, slaveComponents);
      expect(hostsObj[0].checkboxes[0].isInstalled).to.be.true;
      expect(hostsObj[0].checkboxes[0].checked).to.be.true;
    });
    it("C2 components should not be checked and should be installed", function() {
      var hostsObj = getHostsObj();
      controller.restoreComponentsSelection(hostsObj, slaveComponents);
      expect(hostsObj[0].checkboxes[1].isInstalled).to.be.true;
      expect(hostsObj[0].checkboxes[1].checked).to.be.false;
    });
    it("C3 components should not be checked and should not be installed", function() {
      var hostsObj = getHostsObj();
      controller.restoreComponentsSelection(hostsObj, slaveComponents);
      expect(hostsObj[0].checkboxes[2].isInstalled).to.be.false;
      expect(hostsObj[0].checkboxes[2].checked).to.be.false;
    });
  });

  describe("#selectRecommendedComponents()", function() {

    var hostsObj = [{
      hostName: 'host1',
      checkboxes: [
        {
          component: 'C1',
          checked: false,
          isDisabled: false
        },
        {
          component: 'C2',
          checked: false,
          isDisabled: true
        },
        {
          component: 'C3',
          checked: false,
          isDisabled: false
        },
        {
          component: 'CLIENT',
          checked: false,
          isDisabled: false
        }
      ]
    }];

    var recommendations = {
      blueprint: {
        host_groups: [
          {
            name: 'g1',
            components: [
              {name: 'C1'},
              {name: 'C2'},
              {name: 'C_CLIENT'}
            ]
          }
        ]
      },
      blueprint_cluster_binding: {
        host_groups: [
          {
            name: 'g1',
            hosts: [{fqdn: 'host1'}]
          }
        ]
      }
    };

    beforeEach(function() {
      sinon.stub(App, 'get').returns(['C_CLIENT']);
    });

    afterEach(function() {
      App.get.restore();
    });

    it("C1 should be checked", function() {
      controller.set('content.recommendations', recommendations);
      controller.selectRecommendedComponents(hostsObj);
      expect(hostsObj[0].checkboxes[0].checked).to.be.true;
    });

    it("C2 should not be checked, as it is disabled", function() {
      controller.set('content.recommendations', recommendations);
      controller.selectRecommendedComponents(hostsObj);
      expect(hostsObj[0].checkboxes[1].checked).to.be.false;
    });

    it("C3 should not be checked", function() {
      controller.set('content.recommendations', recommendations);
      controller.selectRecommendedComponents(hostsObj);
      expect(hostsObj[0].checkboxes[2].checked).to.be.false;
    });

    it("CLIENT should be checked", function() {
      controller.set('content.recommendations', recommendations);
      controller.selectRecommendedComponents(hostsObj);
      expect(hostsObj[0].checkboxes[3].checked).to.be.true;
    });
  });

  App.TestAliases.testAsComputedOr(getController(), 'anyGeneralErrors', ['errorMessage', 'generalErrorMessages.length']);

  describe('#render', function () {
    it('true if loaded', function () {
      var hosts = {
          h1: {bootStatus: 'REGISTERED', name: 'h1'},
          h2: {bootStatus: 'REGISTERED', name: 'h2'},
          h3: {bootStatus: 'REGISTERED', name: 'h3'}
      };
      var headers = Em.A([
        Em.Object.create({name: "c1", label: 'l1', isDisabled: true}),
        Em.Object.create({name: "c2", label: 'l2', isDisabled: false})
      ]);
      var masterComponentHosts = Em.A([
        {hostName: 'h1', component: 'c1'}
      ]);
      var recommendations = {
        blueprint: {
          host_groups: [
            {
              components: [
                {
                  name: 'c6'
                }
              ],
              name: 'host-group-1'
            },
            {
              components: [
                {
                  name: 'c8'
                }
              ],
              name: 'host-group-2'
            }
          ]
        },
        blueprint_cluster_binding: {
          host_groups: [
            {
              hosts: [
                {
                  fqdn: 'h0'
                }
              ],
              name: 'host-group-1'
            },
            {
              hosts: [
                {
                  fqdn: 'h1'
                }
              ],
              name: 'host-group-2'
            }]
        }
      };
      controller.set('content.hosts', hosts);
      controller.set('content.masterComponentHosts', masterComponentHosts);
      controller.set('content.recommendations', recommendations);
      controller.set('headers', headers);
      controller.render();
      expect(controller.get('isLoaded')).to.equal(true);
    });
  });

  describe('#anyGeneralWarnings', function () {
    it('true if generalWarningMessages is non empty array and warningMessage is undefined', function () {
      controller.set('generalWarningMessages', ["warning1", "warning2"]);
      expect(controller.get('anyGeneralWarnings')).to.equal(true);
    });
    it('false if generalWarningMessages is empty array', function () {
      controller.set('generalWarningMessages', []);
      expect(controller.get('anyGeneralWarnings')).to.equal(false);
    });
    it('undefined if generalWarningMessages is undefined', function () {
      controller.set('generalWarningMessages', false);
      expect(controller.get('anyGeneralWarnings')).to.equal(false);
    });
  });

  App.TestAliases.testAsComputedOr(getController(), 'anyGeneralIssues', ['anyGeneralErrors', 'anyGeneralWarnings']);

  App.TestAliases.testAsComputedOr(getController(), 'anyErrors', ['anyGeneralErrors', 'anyHostErrors']);

  App.TestAliases.testAsComputedOr(getController(), 'anyWarnings', ['anyGeneralWarnings', 'anyHostWarnings']);

  describe('#anyWarnings', function () {
    it('true if generalWarningMessages is non empty', function () {
      controller.set('generalWarningMessages', ["error 404", "error"]);
      expect(controller.get('anyWarnings')).to.equal(true);
    });
    it('false if generalWarningMessages is empty', function () {
      controller.set('generalWarningMessages', []);
      expect(controller.get('anyWarnings')).to.equal(false);
    });
  });

  App.TestAliases.testAsComputedEqual(getController(), 'isInstallerWizard', 'content.controllerName', 'installerController');

  App.TestAliases.testAsComputedEqual(getController(), 'isAddServiceWizard', 'content.controllerName', 'addServiceController');

  describe('#selectClientHost', function () {
    it('true if isClientsSet false', function () {
      var hostsObj = Em.A([Em.Object.create({
        hasMaster: false,
        checkboxes: Em.A([
          Em.Object.create({
            component: 'c1',
            isInstalled: false,
            checked: true
          })
        ])
      })]);
      controller.set('isClientsSet', false);
      controller.selectClientHost(hostsObj);
      expect(controller.get('isClientsSet')).to.equal(true);
    });
  });

  describe('#updateValidationsSuccessCallback', function () {

    var hosts = Em.A([Em.Object.create({
      warnMessages: "warn",
      errorMessages: "error",
      anyMessage: true,
      checkboxes: Em.A([Em.Object.create({
        hasWarnMessage: true,
        hasErrorMessage: true
      })])
    })]);

    var validationData = Em.Object.create({
      resources: Em.A([
        Em.Object.create({
          items: Em.A([
            Em.Object.create({
              "component-name": 'HDFS_CLIENT',
              host: "1",
              isMaster: true
            })
          ])
        })
      ])
    });

    beforeEach(function () {
      sinon.stub(validationUtils, 'filterNotInstalledComponents', function () {
        return Em.A([Em.Object.create({
              componentName: 'c0',
              isSlave: true,
              type: 'host-component',
              level: 'ERROR'
            }),
            Em.Object.create({
              componentName: 'c1',
              isSlave: true,
              type: 'host-component',
              level: 'WARN',
              isShownOnInstallerSlaveClientPage: true
          })]);
      });
      sinon.stub(App.StackServiceComponent, 'find', function () {
          return [
            Em.Object.create({
              componentName: 'c0',
              isSlave: true
            }),
            Em.Object.create({
              componentName: 'c1',
              isSlave: true,
              isShownOnInstallerSlaveClientPage: true
            }),
            Em.Object.create({
              componentName: 'c2',
              isSlave: true,
              isShownOnInstallerSlaveClientPage: false
            }),
            Em.Object.create({
              componentName: 'c3',
              isClient: true
            }),
            Em.Object.create({
              componentName: 'c4',
              isClient: true,
              isRequiredOnAllHosts: false
            }),
            Em.Object.create({
              componentName: 'c5',
              isClient: true,
              isRequiredOnAllHosts: true
            }),
            Em.Object.create({
              componentName: 'c6',
              isMaster: true,
              isShownOnInstallerAssignMasterPage: true
            }),
            Em.Object.create({
              componentName: 'c7',
              isMaster: true,
              isShownOnInstallerAssignMasterPage: false
            }),
            Em.Object.create({
              componentName: 'HDFS_CLIENT',
              isMaster: true,
              isShownOnAddServiceAssignMasterPage: true
            }),
            Em.Object.create({
              componentName: 'c9',
              isMaster: true,
              isShownOnAddServiceAssignMasterPage: false
            })
          ];
        });
      controller.set('hosts', hosts);
      controller.updateValidationsSuccessCallback(validationData);
    });

    afterEach(function () {
      App.StackServiceComponent.find.restore();
      validationUtils.filterNotInstalledComponents.restore();
    });

    it('no generalErrorMessages', function () {
      expect(controller.get('generalErrorMessages').length).to.equal(0);
    });

    it('no generalWarningMessages', function () {
      expect(controller.get('generalWarningMessages').length).to.equal(0);
    });

    it('hosts info is valid', function () {
      var cHosts = JSON.parse(JSON.stringify(controller.get('hosts')));
      var expected = [{
        warnMessages: [null],
        errorMessages: [null],
        anyMessage: true,
        checkboxes: [{
          hasWarnMessage: true,
          hasErrorMessage: true
        }]
      }];
      expect(cHosts).to.eql(expected);
    });
  });

  describe('#clearError', function () {

    var headers = Em.A([
      Em.Object.create({name: "c1", label: 't1'}),
      Em.Object.create({name: "c2", label: 't2'})]);

    beforeEach(function () {
      controller.set('errorMessage', 'error');
      controller.set('headers', headers);
    });

    it('both checkboxes are checked', function () {
      var hosts = Em.A([
        Em.Object.create({
          checkboxes: Em.A([
            Em.Object.create({
              component: 'c1',
              isInstalled: false,
              checked: true
            }),
            Em.Object.create({
              component: 'c2',
              isInstalled: false,
              checked: true
            })])
        })
      ]);

      controller.set('hosts', hosts);
      controller.clearError();
      expect(controller.get('errorMessage')).to.equal('');
    });

    it('true if is one of checkboxes checked false', function () {
      var hosts = Em.A([
        Em.Object.create({
          checkboxes: Em.A([
            Em.Object.create({
              title: "t1",
              component: 'c1',
              isInstalled: false,
              checked: false
            }),
            Em.Object.create({
              title: "t2",
              component: 'c2',
              isInstalled: false,
              checked: true
            })])
        })
      ]);

      controller.set('hosts', hosts);
      controller.set('isAddHostWizard', true);
      controller.clearError();
      expect(controller.get('errorMessage')).to.equal('error');
    });
  });

  describe('#clearStep', function () {
    beforeEach(function () {
      sinon.stub(controller, 'clearError', Em.K);
    });
    afterEach(function () {
      controller.clearError.restore();
    });
    it('should call clearError', function () {
      controller.clearStep();
      expect(controller.clearError.calledOnce).to.equal(true);
    });
    it('should clear hosts', function () {
      controller.set('hosts', [
        {},
        {}
      ]);
      controller.clearStep();
      expect(controller.get('hosts')).to.eql([]);
    });
    it('should clear headers', function () {
      controller.set('headers', [
        {},
        {}
      ]);
      controller.clearStep();
      expect(controller.get('headers')).to.eql([]);
    });
    it('should set isLoaded to false', function () {
      controller.set('isLoaded', true);
      controller.clearStep();
      expect(controller.get('isLoaded')).to.equal(false);
    });
  });

  describe('#checkCallback', function () {
    beforeEach(function () {
      sinon.stub(controller, 'clearError', Em.K);
    });
    afterEach(function () {
      controller.clearError.restore();
    });
    it('should call clearError', function () {
      controller.checkCallback('');
      expect(controller.clearError.calledOnce).to.equal(true);
    });
    Em.A([
        {
          m: 'all checked, isInstalled false',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: true,
            noChecked: false
          }
        },
        {
          m: 'all checked, isInstalled true',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: true,
            noChecked: true
          }
        },
        {
          m: 'no one checked',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: false
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: false,
            noChecked: true
          }
        },
        {
          m: 'some checked',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: true
                }),
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: false
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: false,
            noChecked: false
          }
        },
        {
          m: 'some checked, some isInstalled true',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                }),
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: true,
            noChecked: true
          }
        },
        {
          m: 'some checked, some isInstalled true (2)',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: false
                }),
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: false,
            noChecked: true
          }
        }
      ]).forEach(function (test) {
        describe(test.m, function () {

          beforeEach(function () {
            controller.clearStep();
            controller.set('headers', test.headers);
            controller.set('hosts', test.hosts);
            controller.checkCallback(test.component);
            this.header = controller.get('headers').findProperty('name', test.component);
          });

          it('allChecked is ' + test.e.allChecked, function () {
            expect(this.header.get('allChecked')).to.equal(test.e.allChecked);
          });

          it('noChecked is ' + test.e.noChecked, function () {
            expect(this.header.get('noChecked')).to.equal(test.e.noChecked);
          });
        });
      });
  });

  describe('#getHostNames', function () {
    var tests = Em.A([
      {
        hosts: {
          h1: {bootStatus: 'REGISTERED', name: 'h1'},
          h2: {bootStatus: 'REGISTERED', name: 'h2'},
          h3: {bootStatus: 'REGISTERED', name: 'h3'}
        },
        m: 'All REGISTERED',
        e: ['h1', 'h2', 'h3']
      },
      {
        hosts: {
          h1: {bootStatus: 'REGISTERED', name: 'h1'},
          h2: {bootStatus: 'FAILED', name: 'h2'},
          h3: {bootStatus: 'REGISTERED', name: 'h3'}
        },
        m: 'Some REGISTERED',
        e: ['h1', 'h3']
      },
      {
        hosts: {
          h1: {bootStatus: 'FAILED', name: 'h1'},
          h2: {bootStatus: 'FAILED', name: 'h2'},
          h3: {bootStatus: 'FAILED', name: 'h3'}
        },
        m: 'No one REGISTERED',
        e: []
      },
      {
        hosts: {},
        m: 'Empty hosts',
        e: []
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.hosts', test.hosts);
        var r = controller.getHostNames();
        expect(r).to.eql(test.e);
      });
    });
  });

  describe('#getMasterComponentsForHost', function () {
    var tests = Em.A([
      {
        masterComponentHosts: Em.A([
          {hostName: 'h1', component: 'c1'}
        ]),
        hostName: 'h1',
        m: 'host exists',
        e: ['c1']
      },
      {
        masterComponentHosts: Em.A([
          {hostName: 'h1', component: 'c1'}
        ]),
        hostName: 'h2',
        m: 'host donesn\'t exists',
        e: []
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.masterComponentHosts', test.masterComponentHosts);
        var r = controller.getMasterComponentsForHost(test.hostName);
        expect(r).to.eql(test.e);
      });
    });
  });

  describe('#selectMasterComponents', function () {
    var tests = Em.A([
      {
        masterComponentHosts: Em.A([
          {
            hostName: 'h1',
            component: 'c1'
          }
        ]),
        hostsObj: [
          Em.Object.create({
            hostName: 'h1',
            checkboxes: [
              Em.Object.create({
                component: 'c1',
                checked: false
              })
            ]
          })
        ],
        e: true,
        m: 'host and component exist'
      },
      {
        masterComponentHosts: Em.A([
          {
            hostName: 'h1',
            component: 'c2'
          }
        ]),
        hostsObj: [
          Em.Object.create({
            hostName: 'h1',
            checkboxes: [
              Em.Object.create({
                component: 'c1',
                checked: false
              })
            ]
          })
        ],
        e: false,
        m: 'host exists'
      },
      {
        masterComponentHosts: Em.A([
          {
            hostName: 'h2',
            component: 'c2'
          }
        ]),
        hostsObj: [
          Em.Object.create({
            hostName: 'h1',
            checkboxes: [
              Em.Object.create({
                component: 'c1',
                checked: false
              })
            ]
          })
        ],
        e: false,
        m: 'host and component don\'t exist'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.masterComponentHosts', test.masterComponentHosts);
        var r = controller.selectMasterComponents(test.hostsObj);
        expect(r.findProperty('hostName', 'h1').get('checkboxes').findProperty('component', 'c1').get('checked')).to.equal(test.e);
      });
    });
  });

  describe('#getCurrentMastersBlueprint', function () {
    var tests = Em.A([
      {
        masterComponentHosts: Em.A([
          {hostName: 'h1', component: 'c1'}
        ]),
        hosts: {'h1': {}},
        m: 'one host and one component',
        e:{
          blueprint: {
            host_groups: [
              {
                name: 'host-group-1',
                components: [
                  { name: 'c1' }
                ]
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                name: 'host-group-1',
                hosts: [
                  { fqdn: 'h1' }
                ]
              }
            ]
          }
        }
      },
      {
        masterComponentHosts: Em.A([
          {hostName: 'h1', component: 'c1'},
          {hostName: 'h2', component: 'c2'},
          {hostName: 'h2', component: 'c3'}
        ]),
        hosts: {'h1': {}, 'h2': {}, 'h3': {}},
        m: 'multiple hosts and multiple components',
        e: {
          blueprint: {
            host_groups: [
              {
                name: 'host-group-1',
                components: [
                  { name: 'c1' }
                ]
              },
              {
                name: 'host-group-2',
                components: [
                  { name: 'c2' },
                  { name: 'c3' }
                ]
              },
              {
                name: 'host-group-3',
                components: []
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                name: 'host-group-1',
                hosts: [
                  { fqdn: 'h1' }
                ]
              },
              {
                name: 'host-group-2',
                hosts: [
                  { fqdn: 'h2' }
                ]
              },
              {
                name: 'host-group-3',
                hosts: [
                  { fqdn: 'h3' }
                ]
              }
            ]
          }
        }
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.masterComponentHosts', test.masterComponentHosts);
        controller.set('content.hosts', test.hosts);
        var r = controller.getCurrentMastersBlueprint();
        expect(r).to.eql(test.e);
      });
    });
  });

  describe('#getCurrentBlueprint', function () {
    var tests = Em.A([
      {
        clientComponents: Em.A([{component_name: "name1"}]),
        hosts: Em.A([
          Em.Object.create({
            checkboxes: Em.A([
              Em.Object.create({
                component: 'c1',
                checked: true
              }),
              Em.Object.create({
                component: 'CLIENT',
                checked: true
              })
            ])
          })
        ]),
        m: 'one host and one component',
        e:{
          blueprint: {
            host_groups: [
              {
                name: 'host-group-1',
                components: [
                  { name: 'c1' },
                  { name: 'name1' }
                ]
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                name: 'host-group-1',
                hosts: [
                  {}
                ]
              }
            ]
          }
        }
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.clients', test.clientComponents);
        controller.set('hosts', test.hosts);
        var r = controller.getCurrentBlueprint();
        expect(JSON.parse(JSON.stringify(r))).to.eql(JSON.parse(JSON.stringify(test.e)));
      });
    });
  });

  describe('#callServerSideValidation', function () {

    var cases = [
        {
          controllerName: 'installerController',
          hosts: [
            {
              hostName: 'h0'
            },
            {
              hostName: 'h1'
            }
          ],
          expected: [
            ['c0', 'c6'],
            ['c1', 'c3', 'c8']
          ]
        },
        {
          controllerName: 'addServiceController',
          hosts: [
            {
              hostName: 'h0'
            },
            {
              hostName: 'h1'
            }
          ],
          expected: [
            ['c0', 'c6'],
            ['c1', 'c3', 'c8']
          ]
        },
        {
          controllerName: 'addHostController',
          hosts: [
            {
              hostName: 'h0'
            }
          ],
          expected: [
            ['c0', 'c2', 'c5', 'c6'],
            ['c1', 'c2', 'c3', 'c5', 'c8']
          ]
        }
      ],
      expectedHostGroups = [
        {
          name: 'host-group-1',
          fqdn: 'h0'
        },
        {
          name: 'host-group-2',
          fqdn: 'h1'
        }
      ];

    beforeEach(function () {
      controller.get('content').setProperties({
        recommendations: {
          blueprint: {
            host_groups: [
              {
                components: [
                  {
                    name: 'c6'
                  }
                ],
                name: 'host-group-1'
              },
              {
                components: [
                  {
                    name: 'c8'
                  }
                ],
                name: 'host-group-2'
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                hosts: [
                  {
                    fqdn: 'h0'
                  }
                ],
                name: 'host-group-1'
              },
              {
                hosts: [
                  {
                    fqdn: 'h1'
                  }
                ],
                name: 'host-group-2'
              }]
          }
        },
        clients: [
          {
            component_name: 'c3'
          }
        ]
      });
      sinon.stub(App.StackService, 'find', function () {
        return [
          Em.Object.create({
            serviceName: 's0',
            isSelected: true
          }),
          Em.Object.create({
            serviceName: 's1',
            isInstalled: true,
            isSelected: true
          })
        ];
      });
      sinon.stub(App.StackServiceComponent, 'find', function () {
        return [
          Em.Object.create({
            componentName: 'c0',
            isSlave: true
          }),
          Em.Object.create({
            componentName: 'c1',
            isSlave: true,
            isShownOnInstallerSlaveClientPage: true
          }),
          Em.Object.create({
            componentName: 'c2',
            isSlave: true,
            isShownOnInstallerSlaveClientPage: false
          }),
          Em.Object.create({
            componentName: 'c3',
            isClient: true
          }),
          Em.Object.create({
            componentName: 'c4',
            isClient: true,
            isRequiredOnAllHosts: false
          }),
          Em.Object.create({
            componentName: 'c5',
            isClient: true,
            isRequiredOnAllHosts: true
          }),
          Em.Object.create({
            componentName: 'c6',
            isMaster: true,
            isShownOnInstallerAssignMasterPage: true
          }),
          Em.Object.create({
            componentName: 'c7',
            isMaster: true,
            isShownOnInstallerAssignMasterPage: false
          }),
          Em.Object.create({
            componentName: 'c8',
            isMaster: true,
            isShownOnAddServiceAssignMasterPage: true
          }),
          Em.Object.create({
            componentName: 'c9',
            isMaster: true,
            isShownOnAddServiceAssignMasterPage: false
          })
        ];
      });
      sinon.stub(controller, 'getCurrentBlueprint', function () {
        return {
          blueprint: {
            host_groups: [
              {
                components: [
                  {
                    name: 'c0'
                  }
                ],
                name: 'host-group-1'
              },
              {
                components: [
                  {
                    name: 'c1'
                  },
                  {
                    name: 'c3'
                  }
                ],
                name: 'host-group-2'
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                hosts: [
                  {
                    fqdn: 'h0'
                  }
                ],
                name: 'host-group-1'
              },
              {
                hosts: [
                  {
                    fqdn: 'h1'
                  }
                ],
                name: 'host-group-2'
              }]
          }
        };
      });
      sinon.stub(controller, 'getCurrentMastersBlueprint', function () {
        return {
          blueprint: {
            host_groups: [
              {
                components: [
                  {
                    name: 'c6'
                  }
                ],
                name: 'host-group-1'
              },
              {
                components: [
                  {
                    name: 'c8'
                  }
                ],
                name: 'host-group-2'
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                hosts: [
                  {
                    fqdn: 'h0'
                  }
                ],
                name: 'host-group-1'
              },
              {
                hosts: [
                  {
                    fqdn: 'h1'
                  }
                ],
                name: 'host-group-2'
              }]
          }
        };
      });
      sinon.stub(App, 'get').withArgs('components.clients').returns(['c3', 'c4']);
      sinon.stub(controller, 'getCurrentMasterSlaveBlueprint', function () {
        return {
          blueprint: {
            host_groups: [
              {
                components: [
                  {
                    name: 'c6'
                  }
                ],
                name: 'host-group-1'
              },
              {
                components: [
                  {
                    name: 'c8'
                  }
                ],
                name: 'host-group-2'
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                hosts: [
                  {
                    fqdn: 'h0'
                  }
                ],
                name: 'host-group-1'
              },
              {
                hosts: [
                  {
                    fqdn: 'h1'
                  }
                ],
                name: 'host-group-2'
              }]
          }
        };
      });
      sinon.stub(App.Host, 'find', function () {
        return [
          {
            hostName: 'h1'
          }
        ];
      });
    });

    afterEach(function () {
      App.StackService.find.restore();
      App.StackServiceComponent.find.restore();
      controller.getCurrentBlueprint.restore();
      controller.getCurrentMastersBlueprint.restore();
      App.get.restore();
      controller.getCurrentMasterSlaveBlueprint.restore();
      App.Host.find.restore();
    });

    cases.forEach(function (item) {
      describe(item.controllerName, function () {

        beforeEach(function () {
          controller.set('hosts', item.hosts);
          controller.set('content.controllerName', item.controllerName);
          controller.callServerSideValidation();
        });

        it('blueprint.host_groups count is correct', function () {
          expect(controller.get('content.recommendationsHostGroups.blueprint.host_groups.length')).to.equal(expectedHostGroups.length);
        });

        it('blueprint_cluster_binding.host_groups count is correct', function () {
          expect(controller.get('content.recommendationsHostGroups.blueprint_cluster_binding.host_groups.length')).to.equal(expectedHostGroups.length);
        });

        item.expected.forEach(function (e, index) {
          it('components are valid for group# ' + (index + 1), function () {
            expect(controller.get('content.recommendationsHostGroups.blueprint.host_groups')[index].components.mapProperty('name').sort()).to.be.eql(e);
          });
        });

        expectedHostGroups.forEach(function (group) {
          it(group.name, function () {
            var bpGroup = controller.get('content.recommendationsHostGroups.blueprint_cluster_binding.host_groups').findProperty('name', group.name);
            expect(bpGroup.hosts).to.have.length(1);
            expect(bpGroup.hosts[0].fqdn).to.equal(group.fqdn);
          });
        });

      });
    });

  });

  describe('#isAllCheckboxesEmpty', function () {

    Em.A([
      {
        m: 'all checkboxes are not empty',
        hosts: [
          {checkboxes: [{checked: true}, {checked: true}]},
          {checkboxes: [{checked: true}, {checked: true}]}
        ],
        e: false
      },
      {
        m: 'some checkboxes are empty',
        hosts: [
          {checkboxes: [{checked: true}, {checked: false}]},
          {checkboxes: [{checked: true}, {checked: false}]}
        ],
        e: false
      },
      {
        m: 'all checkboxes are empty',
        hosts: [
          {checkboxes: [{checked: false}, {checked: false}]},
          {checkboxes: [{checked: false}, {checked: false}]}
        ],
        e: true
      }
    ]).forEach(function (test) {

      it(test.m, function () {
        controller.set('hosts', test.hosts);
        expect(controller.isAllCheckboxesEmpty()).to.be.equal(test.e);
      });

    });

  });

  describe('#loadStep', function () {

    beforeEach(function () {
      sinon.stub(controller, 'render', Em.K);
      sinon.stub(controller, 'callValidation', Em.K);
      sinon.stub(App.StackService, 'find').returns([
        Em.Object.create({
          isSelected: true,
          serviceName: 's1',
          serviceComponents: [
            Em.Object.create({isShownOnInstallerSlaveClientPage: true, componentName: 's1c1', isRequired: true}),
            Em.Object.create({isShownOnInstallerSlaveClientPage: true, componentName: 's1c2', isRequired: true})
          ]
        }),
        Em.Object.create({
          isSelected: true,
          serviceName: 's2',
          serviceComponents: [
            Em.Object.create({isShownOnInstallerSlaveClientPage: true, componentName: 's2c3', isRequired: false}),
            Em.Object.create({isShownOnInstallerSlaveClientPage: true, componentName: 's2c4', isRequired: false})
          ]
        }),
        Em.Object.create({
          isInstalled: true,
          serviceName: 's3',
          serviceComponents: [
            Em.Object.create({isShownOnInstallerSlaveClientPage: true, componentName: 's3c1', isRequired: true}),
            Em.Object.create({isShownOnInstallerSlaveClientPage: true, componentName: 's3c2', isRequired: true})
          ]
        }),
        Em.Object.create({
          isInstalled: true,
          serviceName: 's4',
          serviceComponents: [
            Em.Object.create({isShownOnInstallerSlaveClientPage: true, componentName: 's4c3', isRequired: false}),
            Em.Object.create({isShownOnInstallerSlaveClientPage: true, componentName: 's4c4', isRequired: false})
          ]
        })
      ]);
    });

    afterEach(function () {
      controller.render.restore();
      controller.callValidation.restore();
      App.StackService.find.restore();
    });

    describe('isInstallerWizard', function () {

      beforeEach(function () {
        controller.set('content', {
          clients: [{}],
          controllerName: 'installerController'
        });
        controller.loadStep();
      });

      it('component names are valid', function () {
        expect(controller.get('headers').mapProperty('name')).to.be.eql(['s1c1', 's1c2', 's2c3', 's2c4', 'CLIENT']);
      });

      it('component labels are valid', function () {
        expect(controller.get('headers').mapProperty('label')).to.be.eql(['S1c1', 'S1c2', 'S2c3', 'S2c4', 'Client']);
      });

      it('everyone allChecked is false', function () {
        expect(controller.get('headers').everyProperty('allChecked', false)).to.be.true;
      });

      it('component required-flags are valid', function () {
        expect(controller.get('headers').mapProperty('isRequired')).to.be.eql([true, true, false, false, undefined]);
      });

      it('everyone noChecked is false', function () {
        expect(controller.get('headers').everyProperty('noChecked', true)).to.be.true;
      });

      it('everyone isDisabled is false', function () {
        expect(controller.get('headers').everyProperty('isDisabled', false)).to.be.true;
      });

      it('component allId-fields are valid', function () {
        expect(controller.get('headers').mapProperty('allId')).to.be.eql(['all-s1c1', 'all-s1c2', 'all-s2c3', 'all-s2c4', 'all-CLIENT']);
      });

      it('component noneId-fields are valid', function () {
        expect(controller.get('headers').mapProperty('noneId')).to.be.eql(['none-s1c1', 'none-s1c2', 'none-s2c3', 'none-s2c4', 'none-CLIENT']);
      });

    });

    describe('isAddHostWizard', function () {

      beforeEach(function () {
        controller.set('content', {
          clients: [{}],
          controllerName: 'addHostController'
        });
        controller.loadStep();
      });

      it('component names are valid', function () {
        expect(controller.get('headers').mapProperty('name')).to.be.eql(['s3c1', 's3c2', 's4c3', 's4c4', 'CLIENT']);
      });

      it('component labels are valid', function () {
        expect(controller.get('headers').mapProperty('label')).to.be.eql(['S3c1', 'S3c2', 'S4c3', 'S4c4', 'Client']);
      });

      it('everyone allChecked is false', function () {
        expect(controller.get('headers').everyProperty('allChecked', false)).to.be.true;
      });

      it('component required-flags are valid', function () {
        expect(controller.get('headers').mapProperty('isRequired')).to.be.eql([true, true, false, false, undefined]);
      });

      it('everyone noChecked is false', function () {
        expect(controller.get('headers').everyProperty('noChecked', true)).to.be.true;
      });

      it('everyone isDisabled is false', function () {
        expect(controller.get('headers').everyProperty('isDisabled', false)).to.be.true;
      });

      it('component allId-fields are valid', function () {
        expect(controller.get('headers').mapProperty('allId')).to.be.eql(['all-s3c1', 'all-s3c2', 'all-s4c3', 'all-s4c4', 'all-CLIENT']);
      });

      it('component noneId-fields are valid', function () {
        expect(controller.get('headers').mapProperty('noneId')).to.be.eql(['none-s3c1', 'none-s3c2', 'none-s4c3', 'none-s4c4', 'none-CLIENT']);
      });

    });

    describe('isAddServiceWizard', function () {

      beforeEach(function () {
        controller.set('content', {
          clients: [{}],
          controllerName: 'addServiceController'
        });
        controller.loadStep();
      });

      it('component names are valid', function () {
        expect(controller.get('headers').mapProperty('name')).to.be.eql(['s3c1', 's3c2', 's4c3', 's4c4', 's1c1', 's1c2', 's2c3', 's2c4', 'CLIENT']);
      });

      it('component labels are valid', function () {
        expect(controller.get('headers').mapProperty('label')).to.be.eql(['S3c1', 'S3c2', 'S4c3', 'S4c4', 'S1c1', 'S1c2', 'S2c3', 'S2c4', 'Client']);
      });

      it('everyone allChecked is false', function () {
        expect(controller.get('headers').everyProperty('allChecked', false)).to.be.true;
      });

      it('component required-flags are valid', function () {
        expect(controller.get('headers').mapProperty('isRequired')).to.be.eql([true, true, false, false, true, true, false, false, undefined]);
      });

      it('everyone noChecked is false', function () {
        expect(controller.get('headers').everyProperty('noChecked', true)).to.be.true;
      });

      it('installed services are disabled', function () {
        expect(controller.get('headers').mapProperty('isDisabled', false)).to.be.eql([true, true, true, true, false, false, false, false, false]);
      });

      it('component allId-fields are valid', function () {
        expect(controller.get('headers').mapProperty('allId')).to.be.eql(['all-s3c1', 'all-s3c2', 'all-s4c3', 'all-s4c4', 'all-s1c1', 'all-s1c2', 'all-s2c3', 'all-s2c4', 'all-CLIENT']);
      });

      it('component noneId-fields are valid', function () {
        expect(controller.get('headers').mapProperty('noneId')).to.be.eql(['none-s3c1', 'none-s3c2', 'none-s4c3', 'none-s4c4', 'none-s1c1', 'none-s1c2', 'none-s2c3', 'none-s2c4', 'none-CLIENT']);
      });

    });

  });
   
  describe('#anyHostErrors', function () {

    var tests = [
    {
       it: "anyHostErrors returns true if errorMessages are defined",
       host: Em.A([Em.Object.create({
          errorMessages: "Error Message"
       })]),
       result: true
     },
     {
       it: "anyHostErrors returns false if errorMessages are not defined",
       host: Em.A([Em.Object.create({
       })]),
       result: false
     }
    ];

    tests.forEach(function(test) {
      it(test.it, function() {
        controller.set('hosts', test.host);
        expect(controller.get('anyHostErrors')).to.equal(test.result);
      })
    });   
  });


   
  describe('#anyHostWarnings', function () {

    var tests = [
    {
       it: "anyHostWarnings returns true if warnMessages are defined",
       host: Em.A([Em.Object.create({
          warnMessages: "Warning Message"
       })]),
       result: true
     },
     {
       it: "anyHostWarnings returns false if warnMessages are not defined",
       host: Em.A([Em.Object.create({
       })]),
       result: false
     }
    ];

    tests.forEach(function(test) {
      it(test.it, function() {
        controller.set('hosts', test.host);
        expect(controller.get('anyHostWarnings')).to.equal(test.result);
      })
    });   
  });

  describe('#enableCheckboxesForDependentComponents', function () {

    beforeEach(function () {
      sinon.stub(App.StackService, 'find').returns([
        Em.Object.create({
          serviceName: 's1',
          isInstalled: false,
          isSelected: true,
          serviceComponents: [
            Em.Object.create({
              componentName: 'c1',
              isSlave: true,
              dependencies: [
                {
                  serviceName: 's2',
                  componentName: 'c2'
                }
              ]
            })
          ]
        }),
        Em.Object.create({
          serviceName: 's2',
          isInstalled: true,
          isSelected: false,
          serviceComponents: [
            Em.Object.create({
              componentName: 'c2',
              isSlave: true,
              dependencies: []
            })
          ]
        })
      ]);
      sinon.stub(App.StackServiceComponent, 'find').returns([
          Em.Object.create({
            componentName: 'c2',
            maxToInstall: 2
          })
      ]);
    });

    afterEach(function () {
      App.StackService.find.restore();
      App.StackServiceComponent.find.restore();
    });

    it('it should enable appropriate checkboxes', function() {
      var hostObj = [
        {
          checkboxes: [
            {
              component: 'c1',
              isInstalled: false,
              isDisabled: false
            },
            {
              component: 'c2',
              isInstalled: false,
              isDisabled: true
            }
          ]
        },
        {
          checkboxes: [
            {
              component: 'c1',
              isInstalled: false,
              isDisabled: false
            },
            {
              component: 'c2',
              isInstalled: false,
              isDisabled: true
            }
          ]
        }
      ];
      expect(controller.enableCheckboxesForDependentComponents(hostObj)).to.be.true;
      expect(hostObj[1].checkboxes[1].isDisabled).to.be.false;
    })
  });

});

});

require.register("test/controllers/wizard/step7/assign_master_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var stringUtils = require('utils/string_utils');
var numberUtils = require('utils/number_utils');
require('models/stack_service_component');

describe('App.AssignMasterOnStep7Controller', function () {
  var view;

  beforeEach(function () {
    view = App.AssignMasterOnStep7Controller.create();
  });

  describe("#content", function () {

    it("content is correct", function () {
      view.set('configWidgetContext.controller', Em.Object.create({
        content: {'name': 'name'}
      }));
      view.propertyDidChange('content');
      expect(view.get('content')).to.be.eql({'name': 'name'});
    });

    it("content is null", function () {
      view.set('configWidgetContext.controller', Em.Object.create({
        content: null
      }));
      view.propertyDidChange('content');
      expect(view.get('content')).to.be.empty;
    });
  });

  describe("#execute()", function () {
    var context = Em.Object.create({
      controller: {
        content: Em.Object.create({
          controllerName: ""
        })
      }
    });

    beforeEach(function() {
      this.mock = sinon.stub(view, 'getAllMissingDependentServices');
      sinon.stub(view, 'showInstallServicesPopup');
      sinon.stub(view, 'showAssignComponentPopup');
      sinon.stub(view, 'removeMasterComponent');
      view.reopen({
        content: Em.Object.create()
      });
    });

    afterEach(function() {
      this.mock.restore();
      view.showInstallServicesPopup.restore();
      view.showAssignComponentPopup.restore();
      view.removeMasterComponent.restore();
    });

    it("ADD action, controllerName is empty", function() {
      this.mock.returns([{}]);
      view.execute(context, 'ADD', {componentName: 'C1'});
      expect(view.showInstallServicesPopup.calledOnce).to.be.true;
    });

    it("ADD action, controllerName is set", function() {
      context = Em.Object.create({
        controller: {
          content: Em.Object.create({
            controllerName: "ctrl1"
          })
        }
      });
      this.mock.returns([{}]);
      view.execute(context, 'ADD', {componentName: 'C1'});
      expect(view.showAssignComponentPopup.calledOnce).to.be.true;
    });

    it("ADD action, no dependent services", function() {
      this.mock.returns([]);
      view.execute(context, 'ADD', {componentName: 'C1'});
      expect(view.showAssignComponentPopup.calledOnce).to.be.true;
    });

    it("DELETE action", function() {
      this.mock.returns([{}]);
      view.execute(context, 'DELETE', {componentName: 'C1'});
      expect(view.removeMasterComponent.calledOnce).to.be.true;
    });
  });

  describe("#showAssignComponentPopup()", function () {

    beforeEach(function() {
      sinon.stub(view, 'loadMasterComponentHosts');
      sinon.stub(App.ModalPopup, 'show');
    });

    afterEach(function() {
      view.loadMasterComponentHosts.restore();
      App.ModalPopup.show.restore();
    });

    it("loadMasterComponentHosts should be called", function() {
      view.reopen({
        content: {
          controllerName: null
        }
      });
      view.showAssignComponentPopup();
      expect(view.loadMasterComponentHosts.calledOnce).to.be.true;
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });

    it("loadMasterComponentHosts should not be called", function() {
      view.reopen({
        content: {
          controllerName: 'ctrl1'
        }
      });
      view.showAssignComponentPopup();
      expect(view.loadMasterComponentHosts.called).to.be.false;
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe("#showInstallServicesPopup()", function () {
    var mock = Em.Object.create({
      config: Em.Object.create({
        initialValue: 'init',
        value: '',
        displayName: 'c1'
      }),
      setValue: Em.K,
      toggleProperty: Em.K,
      sendRequestRorDependentConfigs: Em.K
    });

    beforeEach(function() {
      sinon.stub(stringUtils, 'getFormattedStringFromArray');
      sinon.stub(mock, 'setValue');
      sinon.stub(mock, 'toggleProperty');
      sinon.stub(mock, 'sendRequestRorDependentConfigs');
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function() {
      stringUtils.getFormattedStringFromArray.restore();
      mock.setValue.restore();
      mock.toggleProperty.restore();
      mock.sendRequestRorDependentConfigs.restore();
      App.ModalPopup.show.restore();
    });

    it("test", function() {
      view.set('configWidgetContext', mock);
      var popup = view.showInstallServicesPopup();
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(mock.get('config.value')).to.be.equal('init');
      expect(mock.setValue.calledWith('init')).to.be.true;
    });
  });

  describe("#removeMasterComponent()", function () {
    var mock = {
      setDBProperty: Em.K
    };

    beforeEach(function() {
      sinon.stub(App.router, 'get').returns(mock);
      sinon.stub(mock, 'setDBProperty');
    });

    afterEach(function() {
      App.router.get.restore();
      mock.setDBProperty.restore();
    });

    it("should set masterComponentHosts", function() {
      view.reopen({
        content: Em.Object.create({
          controllerName: 'ctrl1',
          masterComponentHosts: [
            {component: 'C1'},
            {component: 'C2'}
          ],
          componentsFromConfigs: ["C1","C2"],
          recommendationsHostGroups: {
            blueprint: {host_groups: [{name: 'host-group-1', components: [{name: 'C1'}, {name: 'C2'}]}]},
            blueprint_cluster_binding: {host_groups: [{name: 'host-group-1', hosts: [{fqdn: 'localhost'}]}]}
          }
        }),
        configWidgetContext: {
          config: Em.Object.create()
        }
      });
      view.set('mastersToCreate', ['C2']);
      view.removeMasterComponent();
      expect(view.get('content.masterComponentHosts')).to.be.eql([{component: 'C1'}]);
      expect(view.get('content.recommendationsHostGroups').blueprint).to.be.eql({host_groups: [{name: 'host-group-1', components: [{name: 'C1'}]}]});
    });
  });

  describe("#renderHostInfo()", function () {

    beforeEach(function() {
      sinon.stub(App.Host, 'find').returns([
        Em.Object.create({
          hostName: 'host1',
          cpu: 1,
          memory: 1,
          diskInfo: {}
        })
      ]);
      sinon.stub(view, 'sortHosts');
      sinon.stub(numberUtils, 'bytesToSize').returns(1);
    });

    afterEach(function() {
      App.Host.find.restore();
      view.sortHosts.restore();
      numberUtils.bytesToSize.restore();
    });

    it("should set hosts", function() {
      view.reopen({
        content: Em.Object.create({
          controllerName: null
        })
      });
      view.renderHostInfo();
      expect(view.get('hosts')).to.be.eql([Em.Object.create({
        host_name: 'host1',
        cpu: 1,
        memory: 1,
        disk_info: {},
        host_info: Em.I18n.t('installer.step5.hostInfo').fmt('host1', 1, 1)
      })]);
      expect(view.sortHosts.calledWith([Em.Object.create({
        host_name: 'host1',
        cpu: 1,
        memory: 1,
        disk_info: {},
        host_info: Em.I18n.t('installer.step5.hostInfo').fmt('host1', 1, 1)
      })])).to.be.true;
    });
  });

  describe("#loadMasterComponentHosts()", function () {

    beforeEach(function() {
      sinon.stub(App.HostComponent, 'find').returns([
        Em.Object.create({
          componentName: 'C1'
        }),
        Em.Object.create({
          componentName: 'C2'
        })
      ]);
      sinon.stub(App, 'get').returns(['C2']);
    });

    afterEach(function() {
      App.get.restore();
      App.HostComponent.find.restore();
    });

    it("should set master components", function() {
      view.loadMasterComponentHosts();
      expect(view.get('masterComponentHosts').mapProperty('component')).to.be.eql(['C2']);
    });
  });

  describe("#getAllMissingDependentServices()", function () {

    beforeEach(function() {
      sinon.stub(App.StackServiceComponent, 'find').returns(Em.Object.create({
        stackService: Em.Object.create({
          requiredServices: ['S1', 'S2']
        })
      }));
      sinon.stub(App.Service, 'find').returns([
        {serviceName: 'S1'}
      ]);
      sinon.stub(App.StackService, 'find', function(input) {
        return Em.Object.create({displayName: input});
      });
    });

    afterEach(function() {
      App.StackServiceComponent.find.restore();
      App.Service.find.restore();
      App.StackService.find.restore();
    });

    it("test", function() {
      view.set('configActionComponent', Em.Object.create({
        componentName: 'C1'
      }));
      expect(view.getAllMissingDependentServices()).to.be.eql(['S2']);
    });
  });

  describe("#submit()", function () {
    var popup = {
      hide: Em.K
      },
      mock = {
        saveMasterComponentHosts: Em.K,
        loadMasterComponentHosts: Em.K,
        setDBProperty: Em.K
      },
      config = Em.Object.create({
        filename: 'file1',
        name: 'conf1'
      });

    beforeEach(function() {
      sinon.stub(popup, 'hide');
      sinon.stub(App.router, 'get').returns(mock);
      sinon.stub(mock, 'saveMasterComponentHosts');
      sinon.stub(mock, 'loadMasterComponentHosts');
      sinon.stub(mock, 'setDBProperty');
      sinon.stub(App.config, 'getConfigTagFromFileName', function (value) {
        return value;
      });
      view.reopen({
        content: Em.Object.create({
          controllerName: 'ctrl1',
          componentsFromConfigs: []
        }),
        selectedServicesMasters: [
          {
            component_name: 'C1',
            selectedHost: 'host1'
          }
        ],
        popup: popup,
        configActionComponent: {
          componentName: 'C1'
        },
        configWidgetContext: Em.Object.create({
          config: Em.Object.create({
            fileName: 'file1',
            name: 'conf1',
            serviceName: 'S1',
            savedValue: 'val1',
            toggleProperty: Em.K
          }),
          controller: Em.Object.create({
            selectedService: {
              serviceName: 'S1'
            },
            wizardController: {
              name: 'ctrl'
            },
            stepConfigs: [
              Em.Object.create({
                serviceName: 'S1',
                configs: [
                  config
                ]
              }),
              Em.Object.create({
                serviceName: 'MISC',
                configs: [
                  config
                ]
              })
            ]
          })
        })
      });
      view.submit();
    });

    afterEach(function() {
      App.router.get.restore();
      popup.hide.restore();
      mock.saveMasterComponentHosts.restore();
      mock.loadMasterComponentHosts.restore();
      mock.setDBProperty.restore();
      App.config.getConfigTagFromFileName.restore();
    });

    it("saveMasterComponentHosts should be called", function() {
      expect(mock.saveMasterComponentHosts.calledOnce).to.be.true;
    });

    it("loadMasterComponentHosts                           should be called", function() {
      expect(mock.loadMasterComponentHosts.calledOnce).to.be.true;
    });

    it("configActionComponent should be set", function() {
      expect(view.get('configWidgetContext.config.configActionComponent')).to.be.eql({
        componentName: 'C1',
        hostName: 'host1'
      });
    });
  });
});
});

require.register("test/controllers/wizard/step7/pre_install_checks_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var preInstallChecksController;

describe('App.PreInstallChecksController', function () {

  beforeEach(function () {
    preInstallChecksController = App.PreInstallChecksController.create();
  });

  describe('#loadStep', function () {

    beforeEach(function () {
      preInstallChecksController.set('preInstallChecksWhereRun', true);
    });

    it('should set `preInstallChecksWhereRun` to false', function () {
      preInstallChecksController.loadStep();
      expect(preInstallChecksController.get('preInstallChecksWhereRun')).to.be.false;
    });

  });

  describe('#runPreInstallChecks', function () {

    it('should set `preInstallChecksWhereRun` to true', function () {
      preInstallChecksController.runPreInstallChecks();
      expect(preInstallChecksController.get('preInstallChecksWhereRun')).to.be.true;
    });

  });

  describe('#notRunChecksWarnPopup', function () {

    it('should throw error', function () {
      expect(function () {
        preInstallChecksController.notRunChecksWarnPopup()
      }).to.throw('`afterChecksCallback` should be a function');
    });

    describe('popup', function () {

      var popup;

      beforeEach(function () {
        popup = preInstallChecksController.notRunChecksWarnPopup(Em.K);
        sinon.spy(preInstallChecksController, 'runPreInstallChecks');
      });

      afterEach(function () {
        preInstallChecksController.runPreInstallChecks.restore();
      });

      it('#onPrimary', function (done) {
        preInstallChecksController.notRunChecksWarnPopup(done).onPrimary();
      });

      it('#onSecondary', function () {
        popup.onSecondary();
        expect(preInstallChecksController.runPreInstallChecks.calledOnce).to.be.true;
      });

    });

  });

});
});

require.register("test/controllers/wizard/step7_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mixins/common/localStorage');
require('controllers/wizard/step7_controller');
var testHelpers = require('test/helpers');

var installerStep7Controller,
  issuesFilterCases = [
    {
      transitionInProgress: false,
      hasStepConfigIssues: true,
      issuesFilterSelected: true,
      issuesFilterText: Em.I18n.t('installer.step7.showingPropertiesWithIssues'),
      issuesFilterLinkText: Em.I18n.t('installer.step7.showAllProperties'),
      title: 'issues filter on, has property issues, submit not clicked'
    },
    {
      transitionInProgress: true,
      hasStepConfigIssues: true,
      issuesFilterSelected: true,
      issuesFilterText: '',
      issuesFilterLinkText: '',
      title: 'issues filter on, has property issues, submit clicked'
    },
    {
      transitionInProgress: false,
      hasStepConfigIssues: false,
      issuesFilterSelected: true,
      issuesFilterText: Em.I18n.t('installer.step7.showingPropertiesWithIssues'),
      issuesFilterLinkText: Em.I18n.t('installer.step7.showAllProperties'),
      title: 'issues filter on, no property issues, submit not clicked'
    },
    {
      transitionInProgress: false,
      hasStepConfigIssues: true,
      issuesFilterSelected: false,
      issuesFilterText: '',
      issuesFilterLinkText: Em.I18n.t('installer.step7.showPropertiesWithIssues'),
      title: 'issues filter off, has property issues, submit not clicked'
    },
    {
      transitionInProgress: false,
      hasStepConfigIssues: true,
      issuesFilterSelected: false,
      issuesFilterText: '',
      issuesFilterLinkText: Em.I18n.t('installer.step7.showPropertiesWithIssues'),
      title: 'issues filter off, has property issues, submit not clicked'
    },
    {
      transitionInProgress: false,
      hasStepConfigIssues: true,
      issuesFilterSelected: false,
      issuesFilterText: '',
      issuesFilterLinkText: Em.I18n.t('installer.step7.showPropertiesWithIssues'),
      title: 'issues filter off, has property issues, submit not clicked'
    }
  ],
  issuesFilterTestSetup = function (controller, testCase) {
    controller.set('submitButtonClicked', testCase.submitButtonClicked);
    controller.reopen({
      isSubmitDisabled: testCase.isSubmitDisabled,
      transitionInProgress: testCase.transitionInProgress,
      issuesFilterSelected: testCase.issuesFilterSelected,
      hasStepConfigIssues: testCase.hasStepConfigIssues
    });
  };

function getController() {
  return App.WizardStep7Controller.create({
    content: Em.Object.create({
      services: [],
      advancedServiceConfig: [],
      serviceConfigProperties: []
    })
  });
}

describe('App.InstallerStep7Controller', function () {

  beforeEach(function () {
    sinon.stub(App.config, 'setPreDefinedServiceConfigs', Em.K);
    installerStep7Controller = getController();
    App.set('router.nextBtnClickInProgress', false);
  });

  afterEach(function() {
    App.set('router.nextBtnClickInProgress', false);
    App.config.setPreDefinedServiceConfigs.restore();
    installerStep7Controller.destroy();
  });

  App.TestAliases.testAsComputedAlias(getController(), 'masterComponentHosts', 'content.masterComponentHosts', 'array');

  App.TestAliases.testAsComputedAlias(getController(), 'slaveComponentHosts', 'content.slaveGroupProperties', 'array');

  App.TestAliases.testAsComputedAnd(getController(), 'isConfigsLoaded', ['wizardController.stackConfigsLoaded', 'isAppliedConfigLoaded']);

  describe('#installedServiceNames', function () {

    var tests = Em.A([
      {
        content: Em.Object.create({
          controllerName: 'installerController',
          services: Em.A([
            Em.Object.create({
              isInstalled: true,
              serviceName: 'SQOOP'
            }),
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HDFS'
            })
          ])
        }),
        e: ['SQOOP', 'HDFS'],
        m: 'installerController with SQOOP'
      },
      {
        content: Em.Object.create({
          controllerName: 'installerController',
          services: Em.A([
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HIVE'
            }),
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HDFS'
            })
          ])
        }),
        e: ['HIVE', 'HDFS'],
        m: 'installerController without SQOOP'
      },
      {
        content: Em.Object.create({
          controllerName: 'addServiceController',
          services: Em.A([
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HIVE'
            }),
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HDFS'
            })
          ])
        }),
        e: ['HIVE', 'HDFS'],
        m: 'addServiceController without SQOOP'
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        installerStep7Controller.set('content', test.content);
        expect(installerStep7Controller.get('installedServiceNames')).to.include.members(test.e);
        expect(test.e).to.include.members(installerStep7Controller.get('installedServiceNames'));
      });
    });

  });

  describe('#isSubmitDisabled', function () {
    it('should be true if miscModalVisible', function () {
      installerStep7Controller.reopen({miscModalVisible: true});
      expect(installerStep7Controller.get('isSubmitDisabled')).to.equal(true);
    });
    it('should be true if some of stepConfigs has errors', function () {
      installerStep7Controller.reopen({
        miscModalVisible: false,
        stepConfigs: [
          {
            showConfig: true,
            errorCount: 1
          }
        ]
      });
      expect(installerStep7Controller.get('isSubmitDisabled')).to.equal(true);
    });
    it('should be false if all of stepConfigs don\'t have errors and miscModalVisible is false', function () {
      installerStep7Controller.reopen({
        miscModalVisible: false,
        stepConfigs: [
          {
            showConfig: true,
            errorCount: 0
          }
        ]
      });
      expect(installerStep7Controller.get('isSubmitDisabled')).to.equal(false);
    });
  });

  describe('#selectedServiceNames', function () {
    it('should use content.services as source of data', function () {
      installerStep7Controller.set('content', {
        services: [
          {isSelected: true, isInstalled: false, serviceName: 's1'},
          {isSelected: false, isInstalled: false, serviceName: 's2'},
          {isSelected: true, isInstalled: true, serviceName: 's3'},
          {isSelected: false, isInstalled: false, serviceName: 's4'},
          {isSelected: true, isInstalled: false, serviceName: 's5'},
          {isSelected: false, isInstalled: false, serviceName: 's6'},
          {isSelected: true, isInstalled: true, serviceName: 's7'},
          {isSelected: false, isInstalled: false, serviceName: 's8'}
        ]
      });
      var expected = ['s1', 's5'];
      expect(installerStep7Controller.get('selectedServiceNames')).to.eql(expected);
    });
  });

  describe('#allSelectedServiceNames', function () {
    it('should use content.services as source of data', function () {
      installerStep7Controller.set('content', {
        services: [
          Em.Object.create({isSelected: true, isInstalled: false, serviceName: 's1'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's2'}),
          Em.Object.create({isSelected: true, isInstalled: true, serviceName: 's3'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's4'}),
          Em.Object.create({isSelected: true, isInstalled: false, serviceName: 's5'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's6'}),
          Em.Object.create({isSelected: true, isInstalled: true, serviceName: 's7'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's8'})
        ]
      });
      var expected = ['s1', 's3', 's5', 's7'];
      expect(installerStep7Controller.get('allSelectedServiceNames')).to.eql(expected);
    });
  });

  describe('#checkDatabaseConnectionTest', function () {

    beforeEach(function () {
      installerStep7Controller.set('content', {
        services: Em.A([
          Em.Object.create({isSelected: true, isInstalled: false, serviceName: 'OOZIE', ignored: []}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 'HIVE', ignored: []}),
          Em.Object.create({isSelected: true, isInstalled: true, serviceName: 's3', ignored: []}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's4', ignored: []}),
          Em.Object.create({isSelected: true, isInstalled: false, serviceName: 's5', ignored: []}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's6', ignored: []}),
          Em.Object.create({isSelected: true, isInstalled: true, serviceName: 's7', ignored: []}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's8', ignored: []})
        ])
      });
      var obj = Em.Object.create({name:'oozie_database',value:"aa"});
      installerStep7Controller.set('stepConfigs',Em.A([Em.Object.create({serviceName: 'OOZIE', configs: Em.A([obj]) })]));
      this.deffer = installerStep7Controller.checkDatabaseConnectionTest();
    });

    it('should return promise in process', function () {
      expect(this.deffer.isResolved()).to.equal(false);
      this.deffer.resolve(true);
      this.deffer.done(function(data) {
        expect(data).to.equal(true);
      });
    });
  });

  describe.skip('#submit', function () {

    beforeEach(function () {
      sinon.stub(App, 'get').withArgs('supports.preInstallChecks').returns(false);
    });

    afterEach(function () {
      App.get.restore();
    });

    it('should return false if submit disabled', function () {
      installerStep7Controller.set('isSubmitDisabled',true);
      expect(installerStep7Controller.submit()).to.be.false;
    });
    it('sumbit button should be unclicked if no configs', function () {
      installerStep7Controller.set('isSubmitDisabled',false);
      installerStep7Controller.submit();
      expect(installerStep7Controller.get('submitButtonClicked')).to.be.false;
    });
    it('if Next button is clicked multiple times before the next step renders, it must not be processed',function(){
      installerStep7Controller.submit();
      expect(App.router.send.calledWith('next')).to.equal(true);

      App.router.send.reset();
      installerStep7Controller.submit();
      expect(App.router.send.calledWith('next')).to.equal(false);
    });
  });

  describe('#getConfigTagsSuccess', function () {
    beforeEach(function(){
      sinon.stub(App.StackService, 'find', function () {
        return [
          Em.Object.create({
            serviceName: 's0',
            isInstalled: true,
            configTypes: {
              site3: true,
              site1: true
            }
          }),
          Em.Object.create({
            serviceName: 's1',
            isInstalled: true,
            configTypes: {
              site1: true,
              site2: true
            }
          })
        ];
      });
    });
    afterEach(function(){
      App.StackService.find.restore();
    });

    it('should return serviceConfigTags', function () {
      var desiredConfigs = {
        site1: {
          tag: "tag1"
        },
        site2: {
          tag: "tag2"
        },
        site3: {
          tag: "tag3"
        }
      };
      var data = {
        Clusters: {
          desired_configs: desiredConfigs
        }
      };
      installerStep7Controller.getConfigTagsSuccess(data);
      expect(installerStep7Controller.get('serviceConfigTags')).to.eql([
        {
          "siteName": "site1",
          "tagName": "tag1",
          "newTagName": null
        },
        {
          "siteName": "site2",
          "tagName": "tag2",
          "newTagName": null
        },
        {
          "siteName": "site3",
          "tagName": "tag3",
          "newTagName": null
        }
      ]);
      expect(installerStep7Controller.get('isAppliedConfigLoaded')).to.equal(true);
    });
  });

  describe('#clearStep', function () {

    beforeEach(function () {
      sinon.stub(installerStep7Controller, 'abortRequests');
    });

    afterEach(function () {
      installerStep7Controller.abortRequests.restore();
    });

    it('should clear stepConfigs', function () {
      installerStep7Controller.set('stepConfigs', [
        {},
        {}
      ]);
      installerStep7Controller.clearStep();
      expect(installerStep7Controller.get('stepConfigs.length')).to.equal(0);
    });
    it('should clear filter', function () {
      installerStep7Controller.set('filter', 'filter');
      installerStep7Controller.clearStep();
      expect(installerStep7Controller.get('filter')).to.equal('');
    });
    it('should set for each filterColumns "selected" false', function () {
      installerStep7Controller.set('filterColumns', [
        {selected: true},
        {selected: false},
        {selected: true}
      ]);
      installerStep7Controller.clearStep();
      expect(installerStep7Controller.get('filterColumns').everyProperty('selected', false)).to.equal(true);
    });
    it('should call abortRequests', function () {
      installerStep7Controller.clearStep();
      expect(installerStep7Controller.abortRequests.calledOnce).to.be.true;
    });
  });

  describe('#getConfigTags', function () {
    it('should do ajax-request', function () {
      installerStep7Controller.getConfigTags();
      var args = testHelpers.findAjaxRequest('name', 'config.tags');
      expect(args).exists;
    });
  });

  describe('#setGroupsToDelete', function () {
    beforeEach(function () {
      installerStep7Controller.set('wizardController', Em.Object.create(App.LocalStorage, {name: 'tdk'}));
    });
    it('should add new groups to groupsToDelete', function () {
      var groupsToDelete = [
          {id: '1'},
          {id: '2'}
        ],
        groups = [
          Em.Object.create({id: '3', isTemporary: false}),
          Em.Object.create({id: '4', isTemporary: true}),
          Em.Object.create({id: '5', isTemporary: false})
        ],
        expected = [
          {id: "1"},
          {id: "2"},
          {id: "3"},
          {id: "5"}
        ];
      installerStep7Controller.set('groupsToDelete', groupsToDelete);
      installerStep7Controller.setGroupsToDelete(groups);
      expect(installerStep7Controller.get('groupsToDelete')).to.eql(expected);
      expect(installerStep7Controller.get('wizardController').getDBProperty('groupsToDelete')).to.eql(expected);
    });
  });

  describe('#checkMySQLHost', function () {
    it('should send query', function () {
      installerStep7Controller.checkMySQLHost();
      var args = testHelpers.findAjaxRequest('name', 'ambari.service');
      expect(args).exists;
    });
  });

  describe('#selectConfigGroup', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({content: {services: []}});
      sinon.stub(installerStep7Controller, 'switchConfigGroupConfigs', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.switchConfigGroupConfigs.restore();
    });
    it('should set selectedConfigGroup', function () {
      var group = {':': []};
      installerStep7Controller.selectConfigGroup({context: group});
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(group);
    });
  });

  describe('#selectedServiceObserver', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({content: {services: []}});
      sinon.stub(installerStep7Controller, 'switchConfigGroupConfigs', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.switchConfigGroupConfigs.restore();
    });
    it('shouldn\'t do nothing if App.supports.hostOverridesInstaller is false', function () {
      App.set('supports.hostOverridesInstaller', false);
      var configGroups = [
          {},
          {}
        ],
        selectedConfigGroup = {};
      installerStep7Controller.reopen({configGroups: configGroups, selectedConfigGroup: selectedConfigGroup});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups')).to.eql(configGroups);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(selectedConfigGroup);
    });
    it('shouldn\'t do nothing if selectedService is null', function () {
      App.set('supports.hostOverridesInstaller', true);
      var configGroups = [
          {},
          {}
        ],
        selectedConfigGroup = {};
      installerStep7Controller.reopen({selectedService: null, configGroups: configGroups, selectedConfigGroup: selectedConfigGroup});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups')).to.eql(configGroups);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(selectedConfigGroup);
    });
    it('shouldn\'t do nothing if selectedService.serviceName is MISC', function () {
      App.set('supports.hostOverridesInstaller', true);
      var configGroups = [
          {},
          {}
        ],
        selectedConfigGroup = {};
      installerStep7Controller.reopen({selectedService: {serviceName: 'MISC'}, configGroups: configGroups, selectedConfigGroup: selectedConfigGroup});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups')).to.eql(configGroups);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(selectedConfigGroup);
    });
    it('should update configGroups and selectedConfigGroup', function () {
      App.set('supports.hostOverridesInstaller', true);
      var defaultGroup = {isDefault: true, n: 'n2'},
        configGroups = [
          {isDefault: false, n: 'n1'},
          defaultGroup,
          {n: 'n3'}
        ];
      installerStep7Controller.reopen({selectedService: {serviceName: 's1', configGroups: configGroups}});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups').mapProperty('n')).to.eql(['n2', 'n1', 'n3']);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(defaultGroup);
    });
  });

  describe('#loadConfigGroups', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({
        wizardController: Em.Object.create({
          allHosts: [
            {hostName: 'h1'},
            {hostName: 'h2'},
            {hostName: 'h3'}
          ]
        })
      });
    });
    afterEach(function () {
      App.ServiceConfigGroup.find().clear();
    });
    it('shouldn\'t do nothing if only MISC available', function () {
      var configGroups = [
        {}
      ];
      installerStep7Controller.reopen({
        stepConfigs: [Em.Object.create({serviceName: 'MISC', configGroups: configGroups})]
      });
      installerStep7Controller.loadConfigGroups([]);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups')).to.eql(configGroups);
    });
  });

  describe('#_getDisplayedConfigGroups', function () {
    it('should return [] if no selected group', function () {
      installerStep7Controller.reopen({
        content: {services: []},
        selectedConfigGroup: null
      });
      expect(installerStep7Controller._getDisplayedConfigGroups()).to.eql([]);
    });
    it('should return default config group if another selected', function () {
      var defaultGroup = Em.Object.create({isDefault: false});
      installerStep7Controller.reopen({
        content: {services: []},
        selectedConfigGroup: defaultGroup
      });
      expect(installerStep7Controller._getDisplayedConfigGroups()).to.eql([defaultGroup]);
    });
    it('should return other groups if default selected', function () {
      var defaultGroup = Em.Object.create({isDefault: true}),
        cfgG = Em.Object.create({isDefault: true}),
        configGroups = Em.A([
          Em.Object.create({isDefault: false}),
          Em.Object.create({isDefault: false}),
          cfgG,
          Em.Object.create({isDefault: false})
        ]);
      installerStep7Controller.reopen({
        content: {services: []},
        selectedConfigGroup: defaultGroup,
        selectedService: {configGroups: configGroups}
      });
      expect(installerStep7Controller._getDisplayedConfigGroups()).to.eql(configGroups.without(cfgG));
    });
  });

  describe('#_setEditableValue', function () {
    it('shouldn\'t update config if no selectedConfigGroup', function () {
      installerStep7Controller.reopen({
        selectedConfigGroup: null
      });
      var config = Em.Object.create({isEditable: null});
      var updatedConfig = installerStep7Controller._setEditableValue(config);
      expect(updatedConfig.get('isEditable')).to.be.null;
    });
    it('should set isEditable equal to selectedGroup.isDefault if service not installed', function () {
      var isDefault = true;
      installerStep7Controller.reopen({
        installedServiceNames: [],
        selectedService: {serviceName: 'abc'},
        selectedConfigGroup: Em.Object.create({isDefault: isDefault})
      });
      var config = Em.Object.create({isEditable: true});
      var updatedConfig = installerStep7Controller._setEditableValue(config);
      expect(updatedConfig.get('isEditable')).to.equal(isDefault);
      installerStep7Controller.toggleProperty('selectedConfigGroup.isDefault');
      updatedConfig = installerStep7Controller._setEditableValue(config);
      expect(updatedConfig.get('isEditable')).to.equal(!isDefault);
    });
    Em.A([
        {
          isEditable: false,
          isReconfigurable: false,
          isDefault: true,
          e: false
        },
        {
          isEditable: true,
          isReconfigurable: true,
          isDefault: true,
          e: true
        },
        {
          isEditable: false,
          isReconfigurable: true,
          isDefault: false,
          e: false
        },
        {
          isEditable: true,
          isReconfigurable: false,
          isDefault: false,
          e: false
        }
      ]).forEach(function (test) {
        it('service installed, isEditable = ' + test.isEditable.toString() + ', isReconfigurable = ' + test.isReconfigurable.toString(), function () {
          var config = Em.Object.create({
            isReconfigurable: test.isReconfigurable,
            isEditable: test.isEditable
          });
          installerStep7Controller.reopen({
            installedServiceNames: Em.A(['a']),
            selectedService: Em.Object.create({serviceName: 'a'}),
            selectedConfigGroup: Em.Object.create({isDefault: test.isDefault})
          });
          var updateConfig = installerStep7Controller._setEditableValue(config);
          expect(updateConfig.get('isEditable')).to.equal(test.e);
        });
      });
  });

  describe('#_setOverrides', function () {

    it('shouldn\'t update config if no selectedConfigGroup', function () {
      installerStep7Controller.reopen({
        selectedConfigGroup: null
      });
      var config = Em.Object.create({overrides: null});
      var updatedConfig = installerStep7Controller._setOverrides(config, []);
      expect(updatedConfig.get('overrides')).to.be.null;
    });

    describe('no overrideToAdd', function () {
      var isDefault;
      beforeEach(function () {
        isDefault = true;
        var id = 'n1',
          config = Em.Object.create({overrides: null, id: id, flag: 'flag'}),
          overrides = Em.A([
            Em.Object.create({id: id, value: 'v1'}),
            Em.Object.create({id: id, value: 'v2'}),
            Em.Object.create({id: 'n2', value: 'v3'})
          ]);
        installerStep7Controller.reopen({
          overrideToAdd: null,
          selectedConfigGroup: Em.Object.create({
            isDefault: isDefault
          })
        });
        this.updatedConfig = installerStep7Controller._setOverrides(config, overrides);
      });

      it('2 overrides', function () {
        expect(this.updatedConfig.get('overrides.length')).to.equal(2);
      });
      it('each isEditable is ' + !isDefault, function () {
        expect(this.updatedConfig.get('overrides').everyProperty('isEditable', !isDefault)).to.equal(true);
      });
      it('each parentSCP.flag is `flag`', function () {
        expect(this.updatedConfig.get('overrides').everyProperty('parentSCP.flag', 'flag')).to.equal(true);
      });
    });

    describe('overrideToAdd exists', function () {
      var isDefault = true;
      beforeEach(function () {
        var id = 'n1',
            config = Em.Object.create({overrides: null, id: id, flag: 'flag'}),
            overrides = Em.A([
              Em.Object.create({id: id, value: 'v1'}),
              Em.Object.create({id: id, value: 'v2'}),
              Em.Object.create({id: 'n2', value: 'v3'})
            ]);
        installerStep7Controller.reopen({
          overrideToAdd: Em.Object.create({id: id}),
          selectedService: {configGroups: [Em.Object.create({id: 'n', properties: []})]},
          selectedConfigGroup: Em.Object.create({
            isDefault: isDefault,
            id: 'n'
          })
        });
        this.updatedConfig = installerStep7Controller._setOverrides(config, overrides);
      });

      it('3 overrides', function () {
        expect(this.updatedConfig.get('overrides.length')).to.equal(3);
      });
      it('each isEditable is ' + !isDefault, function () {
        expect(this.updatedConfig.get('overrides').everyProperty('isEditable', !isDefault)).to.equal(true);
      });
      it('each parentSCP.flag is `flag`', function () {
        expect(this.updatedConfig.get('overrides').everyProperty('parentSCP.flag', 'flag')).to.equal(true);
      });
    });
  });

  describe('#switchConfigGroupConfigs', function () {

    it('if selectedConfigGroup is null, serviceConfigs shouldn\'t be changed', function () {
      installerStep7Controller.reopen({
        selectedConfigGroup: null,
        content: {services: []},
        serviceConfigs: {configs: [
          {overrides: []},
          {overrides: []}
        ]}
      });
      installerStep7Controller.switchConfigGroupConfigs();
      expect(installerStep7Controller.get('serviceConfigs.configs').everyProperty('overrides.length', 0)).to.equal(true);
    });

    describe('should set configs for serviceConfigs', function () {

      var configGroups = [
        Em.Object.create({
          properties: [
            {id: 'g1', value: 'v1'},
            {id: 'g2', value: 'v2'}
          ]
        })
      ];

      beforeEach(function () {
        sinon.stub(installerStep7Controller, '_getDisplayedConfigGroups', function () {
          return configGroups;
        });
        sinon.stub(installerStep7Controller, '_setEditableValue', function (config) {
          config.set('isEditable', true);
          return config;
        });
        installerStep7Controller.reopen({
          selectedConfigGroup: Em.Object.create({isDefault: true, name: 'g1'}),
          content: {services: []},
          selectedService: {configs: Em.A([Em.Object.create({id: 'g1', overrides: [], properties: []}), Em.Object.create({id: 'g2', overrides: []})])},
          serviceConfigs: {configs: [Em.Object.create({id: 'g1'})]}
        });
        installerStep7Controller.switchConfigGroupConfigs();
        this.configs = installerStep7Controller.get('selectedService.configs');
      });

      afterEach(function () {
        installerStep7Controller._getDisplayedConfigGroups.restore();
        installerStep7Controller._setEditableValue.restore();
      });

      it('g1 has 1 override', function () {
        expect(this.configs.findProperty('id', 'g1').get('overrides').length).to.equal(1);
      });

      it('g2 has 1 override', function () {
        expect(this.configs.findProperty('id', 'g2').get('overrides').length).to.equal(1);
      });

      it('all configs are editable', function () {
        expect(this.configs.everyProperty('isEditable', true)).to.equal(true);
      });

    });

  });

  describe('#selectProperService', function () {
    Em.A([
        {
          name: 'addServiceController',
          stepConfigs: [
            {selected: false, name: 'n1'},
            {selected: true, name: 'n2'},
            {selected: true, name: 'n3'}
          ],
          e: 'n2'
        },
        {
          name: 'installerController',
          stepConfigs: [
            {showConfig: false, name: 'n1'},
            {showConfig: false, name: 'n2'},
            {showConfig: true, name: 'n3'}
          ],
          e: 'n3'
        }
      ]).forEach(function (test) {
        describe(test.name, function () {

          beforeEach(function () {
            sinon.stub(installerStep7Controller, 'selectedServiceObserver', Em.K);
            installerStep7Controller.reopen({
              wizardController: Em.Object.create({
                name: test.name
              }),
              stepConfigs: test.stepConfigs
            });
            installerStep7Controller.selectProperService();
          });

          afterEach(function () {
            installerStep7Controller.selectedServiceObserver.restore();
          });

          it('selected service name is valid', function () {
            expect(installerStep7Controller.get('selectedService.name')).to.equal(test.e);
          });
        });
      });
  });

  describe.skip('#setStepConfigs', function () {
    var serviceConfigs;
    beforeEach(function () {
      installerStep7Controller.reopen({
        content: {services: []},
        wizardController: Em.Object.create({
          getDBProperty: function (key) {
            return this.get(key);
          }
        })
      });
      sinon.stub(installerStep7Controller, 'renderConfigs', function () {
        return serviceConfigs;
      });
      this.stub = sinon.stub(App, 'get');
    });

    afterEach(function () {
      installerStep7Controller.renderConfigs.restore();
      App.get.restore();
    });

    it('if wizard isn\'t addService, should set output of installerStep7Controller.renderConfigs', function () {
      serviceConfigs = Em.A([
        {serviceName:'HDFS', configs: []},
        {}
      ]);
      installerStep7Controller.set('wizardController.name', 'installerController');
      installerStep7Controller.setStepConfigs([], []);
      expect(installerStep7Controller.get('stepConfigs')).to.eql(serviceConfigs);
    });

    it('addServiceWizard used', function () {
      serviceConfigs = Em.A([Em.Object.create({serviceName: 'HDFS', configs: []}), Em.Object.create({serviceName: 's2'})]);
      installerStep7Controller.set('wizardController.name', 'addServiceController');
      installerStep7Controller.reopen({selectedServiceNames: ['s2']});
      installerStep7Controller.setStepConfigs([], []);
      expect(installerStep7Controller.get('stepConfigs').everyProperty('showConfig', true)).to.equal(true);
      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 's2').get('selected')).to.equal(true);
    });

    it('addServiceWizard used, HA enabled', function () {
      this.stub.withArgs('isHaEnabled').returns(true);
      serviceConfigs = Em.A([
        Em.Object.create({
          serviceName: 'HDFS',
          configs: [
            Em.Object.create({category: 'SECONDARY_NAMENODE'}),
            Em.Object.create({category: 'SECONDARY_NAMENODE'}),
            Em.Object.create({category: 'NameNode'}),
            Em.Object.create({category: 'NameNode'}),
            Em.Object.create({category: 'SECONDARY_NAMENODE'})
          ]
        }),
        Em.Object.create({serviceName: 's2'})]
      );
      installerStep7Controller.set('wizardController.name', 'addServiceController');
      installerStep7Controller.reopen({selectedServiceNames: ['HDFS', 's2']});
      installerStep7Controller.setStepConfigs([], []);
      expect(installerStep7Controller.get('stepConfigs').everyProperty('showConfig', true)).to.equal(true);
      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 'HDFS').get('selected')).to.equal(true);
      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 'HDFS').get('configs').length).to.equal(5);
    });

    it('not windows stack', function () {

      this.stub.withArgs('isHadoopWindowsStack').returns(false);
      this.stub.withArgs('isHaEnabled').returns(false);

      serviceConfigs = Em.A([
        Em.Object.create({
          serviceName: 'HDFS',
          configs: [
            {category: 'NameNode'},
            {category: 'NameNode'}
          ]
        }),
        Em.Object.create({serviceName: 's2'})]
      );
      installerStep7Controller.reopen({selectedServiceNames: ['HDFS', 's2']});
      installerStep7Controller.setStepConfigs([], []);
      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 'HDFS').get('configs').length).to.equal(2);
    });

    it('windows stack', function () {

      this.stub.withArgs('isHadoopWindowsStack').returns(true);
      this.stub.withArgs('isHaEnabled').returns(false);

      serviceConfigs = Em.A([
        Em.Object.create({
          serviceName: 'HDFS',
          configs: [
            {category: 'NameNode'},
            {category: 'NameNode'}
          ]
        }),
        Em.Object.create({serviceName: 's2'})]
      );

      installerStep7Controller.reopen({selectedServiceNames: ['HDFS', 's2']});
      installerStep7Controller.set('installedServiceNames',['HDFS', 's2', 's3']);
      installerStep7Controller.setStepConfigs([], []);

      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 'HDFS').get('configs').length).to.equal(2);

    });

  });

  describe('#loadStep', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({
        content: {services: []},
        wizardController: Em.Object.create({
          getDBProperty: function (k) {
            return this.get(k);
          },
          stackConfigsLoaded: true
        })
      });
      sinon.stub(installerStep7Controller, 'clearStep', Em.K);
      sinon.stub(installerStep7Controller, 'getConfigTags', Em.K);
      sinon.stub(installerStep7Controller, 'setInstalledServiceConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'checkHostOverrideInstaller', Em.K);
      sinon.stub(installerStep7Controller, 'selectProperService', Em.K);
      sinon.stub(installerStep7Controller, 'applyServicesConfigs', Em.K);
      sinon.stub(App.router, 'send', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.clearStep.restore();
      installerStep7Controller.getConfigTags.restore();
      installerStep7Controller.setInstalledServiceConfigs.restore();
      installerStep7Controller.checkHostOverrideInstaller.restore();
      installerStep7Controller.selectProperService.restore();
      installerStep7Controller.applyServicesConfigs.restore();
      App.router.send.restore();
    });
    it('should call clearStep', function () {
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.clearStep.calledOnce).to.equal(true);
    });
    it('shouldn\'t do nothing if isAdvancedConfigLoaded is false', function () {
      installerStep7Controller.set('wizardController.stackConfigsLoaded', false);
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.clearStep.called).to.equal(false);
    });
    it('should call setInstalledServiceConfigs for addServiceController', function () {
      installerStep7Controller.set('wizardController.name', 'addServiceController');
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.setInstalledServiceConfigs.calledOnce).to.equal(true);
    });
  });

  describe('#applyServicesConfigs', function() {
    beforeEach(function() {
      installerStep7Controller.reopen({
        allSelectedServiceNames: []
      });
      sinon.stub(installerStep7Controller, 'loadConfigRecommendations', function(c, callback) {
        return callback();
      });
      sinon.stub(installerStep7Controller, 'checkHostOverrideInstaller', Em.K);
      sinon.stub(installerStep7Controller, 'selectProperService', Em.K);
      sinon.stub(App.router, 'send', Em.K);
      sinon.stub(App.StackService, 'find', function () {
        return {
          findProperty: function () {
            return Em.Object.create({
              isInstalled: true,
              isSelected: false
            });
          },
          filter: function () {
            return [];
          }
        }
      });
      installerStep7Controller.applyServicesConfigs([{name: 'configs'}]);
    });

    afterEach(function () {
      installerStep7Controller.loadConfigRecommendations.restore();
      installerStep7Controller.checkHostOverrideInstaller.restore();
      installerStep7Controller.selectProperService.restore();
      App.router.send.restore();
      App.StackService.find.restore();
    });

    it('loadConfigRecommendations is called once' , function () {
     expect(installerStep7Controller.loadConfigRecommendations.calledOnce).to.equal(true);
    });
    it('isRecommendedLoaded is true' , function () {
     expect(installerStep7Controller.get('isRecommendedLoaded')).to.equal(true);
    });
    it('checkHostOverrideInstalleris called once' , function () {
     expect(installerStep7Controller.checkHostOverrideInstaller.calledOnce).to.equal(true);
    });
    it('selectProperServiceis called once' , function () {
     expect(installerStep7Controller.selectProperService.calledOnce).to.equal(true);
    });

  });

  describe('#removeHawqStandbyHostAddressConfig', function() {
    installerStep7Controller = App.WizardStep7Controller.create({
      content: Em.Object.create({}),
    });
    var testHawqSiteConfigs = [
      {
        name: 'hawq_standby_address_host',
        value: 'h2'
      },
      {
        name: 'hawq_master_address_host',
        value: 'h1'
      }
    ];
    var oldHawqSiteLength = testHawqSiteConfigs.length;

    it('hawq_standby_address_host should be removed on single node cluster', function() {
      var hawqSiteConfigs = testHawqSiteConfigs.slice();
      installerStep7Controller.set('content.hosts', {'hostname': 'h1'});
      var updatedHawqSiteConfigs = installerStep7Controller.updateHawqConfigs(hawqSiteConfigs);
      expect(updatedHawqSiteConfigs.length).to.be.equal(oldHawqSiteLength-1);
      expect(updatedHawqSiteConfigs.findProperty('name', 'hawq_standby_address_host')).to.not.exist;
      expect(updatedHawqSiteConfigs.findProperty('name', 'hawq_master_address_host').value).to.be.equal('h1');
    });

    it('hawq_standby_address_host should not be removed on multi node clusters', function() {
      var hawqSiteConfigs = testHawqSiteConfigs.slice();
      installerStep7Controller.set('content.hosts', Em.A([{'hostname': 'h1'}, {'hostname': 'h2'}]));
      var updatedHawqSiteConfigs = installerStep7Controller.updateHawqConfigs(hawqSiteConfigs);
      expect(updatedHawqSiteConfigs.length).to.be.equal(oldHawqSiteLength);
      expect(updatedHawqSiteConfigs.findProperty('name', 'hawq_standby_address_host').value).to.be.equal('h2');
      expect(updatedHawqSiteConfigs.findProperty('name', 'hawq_master_address_host').value).to.be.equal('h1');
    });

  });

  describe('#_updateIsEditableFlagForConfig', function () {
    Em.A([
        {
          isAdmin: false,
          isReconfigurable: false,
          isHostsConfigsPage: true,
          defaultGroupSelected: false,
          m: 'false for non-admin users',
          e: false
        },
        {
          isAdmin: true,
          isReconfigurable: false,
          isHostsConfigsPage: true,
          defaultGroupSelected: false,
          m: 'false if defaultGroupSelected is false and isHostsConfigsPage is true',
          e: false
        },
        {
          isAdmin: true,
          isReconfigurable: false,
          isHostsConfigsPage: true,
          defaultGroupSelected: true,
          m: 'false if defaultGroupSelected is true and isHostsConfigsPage is true',
          e: false
        },
        {
          isAdmin: true,
          isReconfigurable: false,
          isHostsConfigsPage: false,
          defaultGroupSelected: false,
          m: 'false if defaultGroupSelected is false and isHostsConfigsPage is false',
          e: false
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          installerStep7Controller.reopen({isHostsConfigsPage: test.isHostsConfigsPage});
          var serviceConfigProperty = Em.Object.create({
            isReconfigurable: test.isReconfigurable,
            isEditable: true
          });
          installerStep7Controller._updateIsEditableFlagForConfig(serviceConfigProperty, test.defaultGroupSelected);
          expect(serviceConfigProperty.get('isEditable')).to.equal(test.e);
        });
      });
  });

  describe('#setInstalledServiceConfigs', function () {

    var controller = App.WizardStep7Controller.create({
        installedServiceNames: ['HBASE', 'AMBARI_METRICS']
      }),
      configs = [
        {
          name: 'hbase.client.scanner.caching',
          value: '1000',
          serviceName: 'HBASE',
          filename: 'hbase-site.xml'
        },
        {
          name: 'hbase.client.scanner.caching',
          value: '2000',
          serviceName: 'AMBARI_METRICS',
          filename: 'ams-hbase-site.xml'
        }
      ],
      configsByTags = [
        {
          type: 'hbase-site',
          tag: 'version2',
          properties: {
            'hbase.client.scanner.caching': '1500'
          }
        },
        {
          type: 'ams-hbase-site',
          tag: 'version2',
          properties: {
            'hbase.client.scanner.caching': '2500'
          }
        },
        {
          type: 'site-without-properties',
          tag: 'version1'
        }
      ],
      installedServiceNames = ['HBASE', 'AMBARI_METRICS'];

    describe('should handle properties with the same name', function () {
      var properties;
      beforeEach(function () {
        controller.setInstalledServiceConfigs(configs, configsByTags, installedServiceNames);
        properties = configs.filterProperty('name', 'hbase.client.scanner.caching');
      });
      it('there are 2 properties', function () {
        expect(properties).to.have.length(2);
      });
      it('hbase-site/ value is valid', function () {
        expect(properties.findProperty('filename', 'hbase-site.xml').value).to.equal('1500');
      });
      it('hbase-site/ savedValue is valid', function () {
        expect(properties.findProperty('filename', 'hbase-site.xml').savedValue).to.equal('1500');
      });
      it('ams-hbase-site/ value is valid', function () {
        expect(properties.findProperty('filename', 'ams-hbase-site.xml').value).to.equal('2500');
      });
      it('ams-hbase-site/ savedValue is valid', function () {
        expect(properties.findProperty('filename', 'ams-hbase-site.xml').savedValue).to.equal('2500');
      });
    });

  });

  describe('#getAmbariDatabaseSuccess', function () {

    var controller = App.WizardStep7Controller.create({
        stepConfigs: [
          {
            serviceName: 'HIVE',
            configs: [
              {
                name: 'javax.jdo.option.ConnectionURL',
                value: 'jdbc:mysql://h0/db_name?createDatabaseIfNotExist=true',
                filename: 'hive-site.xml'
              }
            ]
          }
        ]
      }),
      cases = [
        {
          data: {
            hostComponents: []
          },
          mySQLServerConflict: false,
          title: 'no Ambari Server host components'
        },
        {
          data: {
            hostComponents: [
              {
                RootServiceHostComponents: {
                  host_name: 'h0',
                  properties: {
                    'server.jdbc.database': 'postgres'
                  }
                }
              }
            ]
          },
          mySQLServerConflict: false,
          title: 'Ambari MySQL Server and Hive Server are on the same host but different database types'
        },
        {
          data: {
            hostComponents: [
              {
                RootServiceHostComponents: {
                  host_name: 'h0',
                  properties: {
                    'server.jdbc.database': 'mysql'
                  }
                }
              }
            ]
          },
          mySQLServerConflict: true,
          title: 'Ambari MySQL Server and Hive Server are on the same host'
        },
        {
          data: {
            hostComponents: [
              {
                RootServiceHostComponents: {
                  host_name: 'h1',
                  properties: {
                    'server.jdbc.database': 'mysql'
                  }
                }
              }
            ]
          },
          mySQLServerConflict: false,
          title: 'Ambari MySQL Server and Hive Server are on different hosts'
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.getAmbariDatabaseSuccess(item.data);
        expect(controller.get('mySQLServerConflict')).to.equal(item.mySQLServerConflict);
      });
    });

  });

  describe('#showDatabaseConnectionWarningPopup', function () {

    var cases = [
        {
          method: 'onSecondary',
          submitButtonClicked: false,
          isRejected: true,
          title: 'Cancel button clicked'
        },
        {
          method: 'onPrimary',
          submitButtonClicked: true,
          isResolved: true,
          title: 'Proceed Anyway button clicked'
        }
      ],
      dfd,
      testObject,
      serviceNames = ['HIVE', 'OOZIE'],
      bodyMessage = 'HIVE, OOZIE';

    beforeEach(function () {
      installerStep7Controller.set('submitButtonClicked', true);
      dfd = $.Deferred(function (d) {
        d.done(function () {
          testObject.isResolved = true;
        });
        d.fail(function () {
          testObject.isRejected = true;
        })
      });
      testObject = {};
    });

    cases.forEach(function (item) {
      describe(item.title, function () {
        var popup;
        beforeEach(function () {
          popup = installerStep7Controller.showDatabaseConnectionWarningPopup(serviceNames, dfd);
        });

        it('popup body is valid', function () {
          expect(popup.get('body')).to.equal(Em.I18n.t('installer.step7.popup.database.connection.body').format(bodyMessage));
        });

        it('after ' + item.method + ' execution', function () {
          popup[item.method]();
          expect(testObject.isResolved).to.equal(item.isResolved);
          expect(testObject.isRejected).to.equal(item.isRejected);
          expect(installerStep7Controller.get('submitButtonClicked')).to.equal(item.submitButtonClicked);
        });
      });
    });

  });

  describe('#issuesFilterText', function () {

    issuesFilterCases.forEach(function (item) {
      it(item.title, function () {
        issuesFilterTestSetup(installerStep7Controller, item);
        expect(installerStep7Controller.get('issuesFilterText')).to.equal(item.issuesFilterText);
      })
    });

  });

  describe.skip('#loadServiceTagsSuccess', function () {
    it('should create ClusterSiteToTagMap', function () {
      var params = Em.Object.create({
        serviceName: "OOZIE",
        serviceConfigsDef: Em.Object.create({
          configTypes: Em.Object.create({
            site3: true,
            site2: true,
            site1: true
          })
        })
      });
      var wizardController = Em.Object.create({
          allHosts: [
            {hostName: 'h1'},
            {hostName: 'h2'},
            {hostName: 'h3'}
          ]
      });
      installerStep7Controller.set('wizardController', wizardController);
      installerStep7Controller.set('stepConfigs', Em.A([Em.Object.create({serviceName: 'OOZIE', configs: Em.A([]) })]));
      var desiredConfigs = {
        site1: {
          tag: "tag1"
        },
        site2: {
          tag: "tag2"
        },
        site3: {
          tag: "tag3"
        }
      };
      var data = {
        config_groups: Em.A([Em.Object.create({
          ConfigGroup: Em.Object.create({
            tag: 'OOZIE',
            hosts: Em.A([Em.Object.create({host_name: 'h1'})]),
            id: 1,
            group_name: "",
            description: "",
            desired_configs: Em.A([Em.Object.create({
              type: '1',
              tag: 'h1'
            })])
          })
        })]),
        Clusters: {
          desired_configs: desiredConfigs
        }
      };
      installerStep7Controller.loadServiceTagsSuccess(data, {}, params);
      var result = installerStep7Controller.get("loadedClusterSiteToTagMap");
      expect(JSON.parse(JSON.stringify(result))).to.eql(JSON.parse(JSON.stringify({"site1":"tag1","site2":"tag2","site3":"tag3"})));
    })
  });

  describe('#issuesFilterLinkText', function () {

    issuesFilterCases.forEach(function (item) {
      it(item.title, function () {
        issuesFilterTestSetup(installerStep7Controller, item);
        expect(installerStep7Controller.get('issuesFilterLinkText')).to.equal(item.issuesFilterLinkText);
      });
    });

  });

  describe('#toggleIssuesFilter', function () {
    it('should toggle issues filter', function () {
      var issuesFilter = installerStep7Controller.get('filterColumns').findProperty('attributeName', 'hasIssues');
      issuesFilter.set('selected', false);
      installerStep7Controller.toggleIssuesFilter();
      expect(issuesFilter.get('selected')).to.be.true;
      installerStep7Controller.toggleIssuesFilter();
      expect(issuesFilter.get('selected')).to.be.false;
    });
    it('selected service should be changed', function () {
      installerStep7Controller.setProperties({
        selectedService: {
          serviceName: 'service1',
          errorCount: 0,
          configGroups: [],
          showConfig: true
        },
        stepConfigs: [
          Em.Object.create({
            serviceName: 'service2',
            errorCount: 1,
            configGroups: [],
            showConfig: true
          }),
          Em.Object.create({
            serviceName: 'service3',
            errorCount: 2,
            configGroups: [],
            showConfig: true
          })
        ]
      });
      installerStep7Controller.toggleIssuesFilter();
      expect(installerStep7Controller.get('selectedService.serviceName')).to.eql('service2');
    });
  });

  describe('#addKerberosDescriptorConfigs', function() {

    beforeEach(function() {
      sinon.stub(App.config, 'kerberosIdentitiesDescription');
    });

    afterEach(function() {
      App.config.kerberosIdentitiesDescription.restore();
    });

    var configs = [
      { name: 'prop1', displayName: 'Prop1', description: 'd1' },
      { name: 'prop2', displayName: 'Prop2', description: 'd1' },
      { name: 'prop3', displayName: 'Prop3', description: 'd1' }
    ];
    var descriptor = [
      Em.Object.create({ name: 'prop4', filename: 'file-1'}),
      Em.Object.create({ name: 'prop1', filename: 'file-1'})
    ];
    var propertiesAttrTests = [
      {
        attr: 'isUserProperty', val: false,
        m: 'descriptor properties should not be marked as custom'
      },
      {
        attr: 'category', val: 'Advanced file-1',
        m: 'descriptor properties should be added to Advanced category'
      },
      {
        attr: 'isOverridable', val: false,
        m: 'descriptor properties should not be overriden'
      }
    ];

    propertiesAttrTests.forEach(function(test) {
      it(test.m, function() {
        installerStep7Controller.addKerberosDescriptorConfigs(configs, descriptor);
        expect(configs.findProperty('name', 'prop1')[test.attr]).to.be.eql(test.val);
      });
    });
  });

  describe('#addHawqConfigsOnNnHa', function () {
    var configs = [
      {
        id: 'dfs.nameservices__hdfs-site',
        description: 'dfs.nameservices__hdfs-site',
        displayName: 'dfs.nameservices',
        displayType: 'string',
        name: 'dfs.nameservices',
        value: 'haservice',
        recommendedValue: 'haservice'
      },
      {
        id: 'dfs.ha.namenodes.haservice__hdfs-site',
        description: 'dfs.ha.namenodes.haservice__hdfs-site',
        displayName: 'dfs.ha.namenodes.haservice',
        displayType: 'string',
        name: 'dfs.ha.namenodes.haservice',
        value: 'nn1,nn2',
        recommendedValue: 'nn1,nn2'
      },
      {
        id: 'dfs.namenode.rpc-address.haservice.nn1__hdfs-site',
        description: 'dfs.namenode.rpc-address.haservice.nn1__hdfs-site',
        displayName: 'dfs.namenode.rpc-address.haservice.nn1',
        displayType: 'string',
        name: 'dfs.namenode.rpc-address.haservice.nn1',
        value: 'c6401.ambari.apache.org:8020',
        recommendedValue: 'c6401.ambari.apache.org:8020'
      },
      {
        id: 'dfs.namenode.rpc-address.haservice.nn2__hdfs-site',
        description: 'dfs.namenode.rpc-address.haservice.nn2__hdfs-site',
        displayName: 'dfs.namenode.rpc-address.haservice.nn2',
        displayType: 'string',
        name: 'dfs.namenode.rpc-address.haservice.nn2',
        value: 'c6402.ambari.apache.org:8020',
        recommendedValue: 'c6402.ambari.apache.org:8020'
      },
      {
        id: 'dfs.namenode.http-address.haservice.nn1__hdfs-site',
        description: 'dfs.namenode.http-address.haservice.nn1__hdfs-site',
        displayName: 'dfs.namenode.http-address.haservice.nn1',
        displayType: 'string',
        name: 'dfs.namenode.http-address.haservice.nn1',
        value: 'c6401.ambari.apache.org:50070',
        recommendedValue: 'c6401.ambari.apache.org:50070'
      },
      {
        id: 'dfs.namenode.http-address.haservice.nn2__hdfs-site',
        description: 'dfs.namenode.http-address.haservice.nn2__hdfs-site',
        displayName: 'dfs.namenode.http-address.haservice.nn2',
        displayType: 'string',
        name: 'dfs.namenode.http-address.haservice.nn2',
        value: 'c6402.ambari.apache.org:50070',
        recommendedValue: 'c6402.ambari.apache.org:50070'
      }
    ];
    var oldConfigs = configs.slice();

    it('should copy properties from hdfs-site to hdfs-client for HAWQ', function() {
      installerStep7Controller.addHawqConfigsOnNnHa(configs);
      // ensure 6 new configs were added
      expect(configs.length).to.be.equal(oldConfigs.length + 6);
    });

    describe('find the same property in hdfs-client for HAWQ and see if attribute value matches with the corresponding property\'s attribute value in hdfs-site', function () {
      oldConfigs.forEach(function(property) {
        var id = property.name + '__hdfs-client';
        it(id, function () {
          expect(configs.findProperty('id', id).description).to.be.equal(property.description);
          expect(configs.findProperty('id', id).displayName).to.be.equal(property.displayName);
          expect(configs.findProperty('id', id).value).to.be.equal(property.value);
          expect(configs.findProperty('id', id).recommendedValue).to.be.equal(property.recommendedValue);
        });
      });
    });
  });

  describe('#addHawqConfigsOnRMHa', function () {
    var configs = [
      {
        id: 'yarn.resourcemanager.hostname.rm1__yarn-site',
        name: 'yarn.resourcemanager.hostname.rm1',
        value: 'c6401.ambari.apache.org',
        recommendedValue: 'c6401.ambari.apache.org'
      },
      {
        id: 'yarn.resourcemanager.hostname.rm2__yarn-site',
        name: 'yarn.resourcemanager.hostname.rm2',
        value: 'c6402.ambari.apache.org',
        recommendedValue: 'c6402.ambari.apache.org'
      }
    ];

    beforeEach(function () {
      this.inputConfigsCount = configs.length;
      installerStep7Controller.addHawqConfigsOnRMHa(configs);
      this.yarnRmDetails = configs.findProperty('id', 'yarn.resourcemanager.ha__yarn-client');
      this.yarnRmSchedulerDetails = configs.findProperty('id', 'yarn.resourcemanager.scheduler.ha__yarn-client');
    });

    it('should update properties in yarn-client for HAWQ if yarn ha is enabled', function() {
      var noOfConfigsAdded = 2;
      expect(configs.length).to.be.equal(this.inputConfigsCount + noOfConfigsAdded);
    });

    it('yarn.resourcemanager.ha__yarn-client', function() {
      var expectedYarnRmHaValue = 'c6401.ambari.apache.org:8032,c6402.ambari.apache.org:8032';
      expect(this.yarnRmDetails.value).to.be.equal(expectedYarnRmHaValue);
      expect(this.yarnRmDetails.recommendedValue).to.be.equal(expectedYarnRmHaValue);
      expect(this.yarnRmDetails.displayName).to.be.equal('yarn.resourcemanager.ha');
      expect(this.yarnRmDetails.description).to.be.equal('Comma separated yarn resourcemanager host addresses with port');
    });

    it('yarn.resourcemanager.scheduler.ha__yarn-client', function() {
      var expectedYarnRmSchedulerValue = 'c6401.ambari.apache.org:8030,c6402.ambari.apache.org:8030';
      expect(this.yarnRmSchedulerDetails.value).to.be.equal(expectedYarnRmSchedulerValue);
      expect(this.yarnRmSchedulerDetails.recommendedValue).to.be.equal(expectedYarnRmSchedulerValue);
      expect(this.yarnRmSchedulerDetails.displayName).to.be.equal('yarn.resourcemanager.scheduler.ha');
      expect(this.yarnRmSchedulerDetails.description).to.be.equal('Comma separated yarn resourcemanager scheduler addresses with port');
    });
  });

  describe('#errorsCount', function () {

    it('should ignore configs with widgets (enhanced configs)', function () {

      installerStep7Controller.reopen({selectedService: Em.Object.create({
          configsWithErrors: Em.A([
            Em.Object.create({widget: {}}),
            Em.Object.create({widget: null})
          ])
        })
      });

      expect(installerStep7Controller.get('errorsCount')).to.equal(1);

    });

  });

  describe('#_reconfigureServicesOnNnHa', function () {

    var dfsNameservices = 'some_cluster';

    Em.A([
      {
        serviceName: 'HBASE',
        configToUpdate: 'hbase.rootdir',
        oldValue: 'hdfs://nameserv:8020/apps/hbase/data',
        expectedNewValue: 'hdfs://' + dfsNameservices + '/apps/hbase/data'
      },
      {
        serviceName: 'ACCUMULO',
        configToUpdate: 'instance.volumes',
        oldValue: 'hdfs://localhost:8020/apps/accumulo/data',
        expectedNewValue: 'hdfs://' + dfsNameservices + '/apps/accumulo/data'
      },
      {
        serviceName: 'HAWQ',
        configToUpdate: 'hawq_dfs_url',
        oldValue: 'localhost:8020/hawq_data',
        expectedNewValue: dfsNameservices + '/hawq_data'
      }
    ]).forEach(function (test) {

      var serviceConfigs = [App.ServiceConfig.create({
        serviceName: test.serviceName,
        configs: [
          Em.Object.create({
            name: test.configToUpdate,
            value: test.oldValue
          })
        ]
      }),
        App.ServiceConfig.create({
          serviceName: 'HDFS',
          configs: [
            Em.Object.create({
              name: 'dfs.nameservices',
              value: dfsNameservices
            })
          ]
        })];

      it(test.serviceName + ' ' + test.configToUpdate, function () {
        installerStep7Controller.reopen({
          selectedServiceNames: [test.serviceName, 'HDFS']
        });
        serviceConfigs = installerStep7Controller._reconfigureServicesOnNnHa(serviceConfigs);
        expect(serviceConfigs.findProperty('serviceName', test.serviceName).configs.findProperty('name', test.configToUpdate).get('value')).to.equal(test.expectedNewValue);
      });
    });

  });

  describe('#showOozieDerbyWarning', function() {
    var controller;

    beforeEach(function() {
      controller = App.WizardStep7Controller.create({});
      sinon.stub(App.ModalPopup, 'show', Em.K);
    });

    afterEach(function() {
      App.ModalPopup.show.restore();
    });

    Em.A([
      {
        selectedServiceNames: ['HDFS', 'OOZIE'],
        databaseType: Em.I18n.t('installer.step7.oozie.database.new'),
        e: true,
        m: 'Oozie selected with derby database, warning popup should be shown'
      },
      {
        selectedServiceNames: ['HDFS'],
        databaseType: Em.I18n.t('installer.step7.oozie.database.new'),
        e: false,
        m: 'Oozie not selected warning popup should be skipped'
      },
      {
        selectedServiceNames: ['HDFS', 'OOZIE'],
        databaseType: 'New Mysql Database',
        e: false,
        m: 'Oozie selected, mysql database used, warning popup should be sk'
      }
    ]).forEach(function(test) {
      describe(test.m, function() {

        beforeEach(function () {
          sinon.stub(App.config, 'findConfigProperty').returns(Em.Object.create({ value: test.databaseType}));
          controller.reopen({
            selectedServiceNames: test.selectedServiceNames
          });
          controller.showOozieDerbyWarningPopup(Em.K);
        });

        afterEach(function () {
          App.config.findConfigProperty.restore();
        });

        it('modal popup is shown needed number of times', function () {
          expect(App.ModalPopup.show.calledOnce).to.equal(test.e);
        });
      });
    });
  });

  describe('#addHostNamesToConfigs', function() {

    beforeEach(function () {
      sinon.stub(App.StackServiceComponent, 'find', function () {
        return Em.Object.create({
          id: 'NAMENODE',
          displayName: 'NameNode'
        });
      });
    });

    afterEach(function () {
      App.StackServiceComponent.find.restore();
    });

    it('should not create duplicate configs', function () {
      var serviceConfig = Em.Object.create({
        configs: [],
        serviceName: 'HDFS',
        configCategories: [
          {
            showHost: true,
            name: 'NAMENODE'
          }
        ]
      });
      var masterComponents = [
        {component: 'NAMENODE', hostName: 'h1'}
      ];
      var slaveComponents = [];
      installerStep7Controller.addHostNamesToConfigs(serviceConfig, masterComponents, slaveComponents);
      expect(serviceConfig.get('configs').filterProperty('name', 'namenode_host').length).to.equal(1);
      installerStep7Controller.addHostNamesToConfigs(serviceConfig, masterComponents, slaveComponents);
      expect(serviceConfig.get('configs').filterProperty('name', 'namenode_host').length).to.equal(1);
    });

  });

  describe('#resolveHiveMysqlDatabase', function () {

    beforeEach(function () {
      installerStep7Controller.get('content').setProperties({
        services: Em.A([
          Em.Object.create({serviceName: 'HIVE', isSelected: true, isInstalled: false})
        ])
      });
      installerStep7Controller.setProperties({
        stepConfigs: Em.A([
          Em.Object.create({serviceName: 'HIVE', configs: [{name: 'hive_database', value: 'New MySQL Database'}]})
        ]),
        mySQLServerConflict: true
      });
      sinon.stub(installerStep7Controller, 'moveNext', Em.K);
      sinon.stub(installerStep7Controller, 'checkMySQLHost', function () {
        return $.Deferred().resolve();
      });
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      installerStep7Controller.moveNext.restore();
      installerStep7Controller.checkMySQLHost.restore();

      App.ModalPopup.show.restore();
    });

    it('no HIVE service', function () {
      installerStep7Controller.set('content.services', Em.A([]));
      installerStep7Controller.resolveHiveMysqlDatabase();
      expect(installerStep7Controller.moveNext.calledOnce).to.be.true;
      expect(App.ModalPopup.show.called).to.be.false;
    });

    it('if mySQLServerConflict, popup is shown', function () {
      installerStep7Controller.resolveHiveMysqlDatabase();
      expect(installerStep7Controller.moveNext.called).to.be.false;
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });

  });

  describe('#mySQLWarningHandler', function () {

    beforeEach(function () {
      installerStep7Controller.set('mySQLServerConflict', true);
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(App.router, 'get').returns({gotoStep: Em.K});
      sinon.stub(App.router.get(), 'gotoStep', Em.K);
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
      App.router.get().gotoStep.restore();
      App.router.get.restore();
    });

    it('warning popup is shown', function () {
      installerStep7Controller.mySQLWarningHandler();
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });

    it('submitButtonClicked is set to false on primary click', function () {
      installerStep7Controller.mySQLWarningHandler().onPrimary();
      expect(installerStep7Controller.get('submitButtonClicked')).to.be.false;
    });

    it('second popup is shown on secondary click', function () {
      installerStep7Controller.mySQLWarningHandler().onSecondary();
      expect(App.ModalPopup.show.calledTwice).to.be.true;
    });

    it('submitButtonClicked is set to false on secondary click on the second popup', function () {
      installerStep7Controller.mySQLWarningHandler().onSecondary().onSecondary();
      expect(installerStep7Controller.get('submitButtonClicked')).to.be.false;
    });

    it('user is moved to step5 on primary click on the second popup (installerController)', function () {
      installerStep7Controller.set('content.controllerName', 'installerController');
      installerStep7Controller.mySQLWarningHandler().onSecondary().onPrimary();
      expect(App.router.get('installerController').gotoStep.calledWith(5, true)).to.be.true;
    });

    it('user is moved to step2 on primary click on the second popup (addSeviceController)', function () {
      installerStep7Controller.set('content.controllerName', 'addServiceController');
      installerStep7Controller.mySQLWarningHandler().onSecondary().onPrimary();
      expect(App.router.get('addSeviceController').gotoStep.calledWith(2, true)).to.be.true;
    });

  });

  describe('#supportsPreInstallChecks', function () {

    beforeEach(function () {
      this.stub = sinon.stub(App, 'get');
    });

    afterEach(function () {
      this.stub.restore();
    });

    Em.A([
      {preInstallChecks: true, controllerName: 'installerController', e: true},
      {preInstallChecks: true, controllerName: '', e: false},
      {preInstallChecks: false, controllerName: 'installerController', e: false},
      {preInstallChecks: false, controllerName: '', e: false}
    ]).forEach(function (test) {

      it(JSON.stringify(test), function () {
        this.stub.withArgs('supports.preInstallChecks').returns(test.preInstallChecks);
        installerStep7Controller.set('content', {controllerName: test.controllerName});
        installerStep7Controller.propertyDidChange('supportsPreInstallChecks');

        expect(installerStep7Controller.get('supportsPreInstallChecks')).to.be.equal(test.e);
      });

    });

  });

  describe('#getHash', function () {

    var stepConfigs = [
      {
        configs: [
          Em.Object.create({name: 's1c1', isFinal: true, value: 'v11'}),
          Em.Object.create({name: 's1c2', isFinal: false, value: 'v12', overrides: []}),
          Em.Object.create({name: 's1c3', isFinal: true, value: 'v13', overrides: [
            Em.Object.create({value: 'v131'})
          ]})
        ]
      },
      {
        configs: [
          Em.Object.create({name: 's2c1', isFinal: true, value: 'v21'}),
          Em.Object.create({name: 's2c2', isFinal: false, value: 'v22', overrides: []}),
          Em.Object.create({name: 's2c3', isFinal: true, value: 'v23', overrides: [
            Em.Object.create({value: 'v231'})
          ]})
        ]
      }
    ];

    beforeEach(function () {
      installerStep7Controller.set('stepConfigs', stepConfigs);
      this.hash = installerStep7Controller.getHash();
    });

    it('should map value, isFinal and overrides values', function () {
      var expected = JSON.stringify({
        s1c1: {
          value: 'v11',
          overrides: [],
          isFinal: true
        },
        s1c2: {
          value: 'v12',
          overrides: [],
          isFinal: false
        },
        s1c3: {
          value: 'v13',
          overrides: ['v131'],
          isFinal: true
        },
        s2c1: {
          value: 'v21',
          overrides: [],
          isFinal: true
        },
        s2c2: {
          value: 'v22',
          overrides: [],
          isFinal: false
        },
        s2c3: {
          value: 'v23',
          overrides: ['v231'],
          isFinal: true
        }
      });
      expect(this.hash).to.be.equal(expected);
    });

  });

  describe('#updateHostOverrides', function () {

    var configProperty;
    var storedConfigProperty;

    beforeEach(function () {
      configProperty = Em.Object.create({});
      storedConfigProperty = {
        overrides: [
          {value: 'v1'}
        ]
      };
      installerStep7Controller.updateHostOverrides(configProperty, storedConfigProperty);
    });

    it('override is valid', function () {
      var override = configProperty.get('overrides.0');
      expect(override.get('value')).to.be.equal('v1');
      expect(override.get('isOriginalSCP')).to.be.false;
      expect(override.get('parentSCP')).to.be.eql(configProperty);
    });

  });

  describe('#allowUpdateProperty', function () {

    it('true if it is installer', function () {
      installerStep7Controller.set('wizardController', {name: 'installerController'});
      expect(installerStep7Controller.allowUpdateProperty([], '', '')).to.be.true;
    });

    it('true if it is parentProperties are not empty', function () {
      installerStep7Controller.set('wizardController', {name: 'some'});
      expect(installerStep7Controller.allowUpdateProperty([{}], '', '')).to.be.true;
    });

    describe('#addServiceController', function () {

      beforeEach(function () {
        installerStep7Controller.set('wizardController', {name: 'addServiceController'});
        this.stub = sinon.stub(App.configsCollection, 'getConfigByName');
        sinon.stub(App.config, 'get').withArgs('serviceByConfigTypeMap').returns({
          't1': Em.Object.create({serviceName: 's1'}),
          't2': Em.Object.create({serviceName: 's2'})
        })
      });

      afterEach(function () {
        App.configsCollection.getConfigByName.restore();
        App.config.get.restore();
      });

      it('stackProperty does not exist', function () {
        this.stub.returns(null);
        expect(installerStep7Controller.allowUpdateProperty([], '', '')).to.be.true;
      });

      it('installedServices does not contain stackProperty.serviceName', function () {
        this.stub.returns({serviceName: 's1'});
        installerStep7Controller.set('installedServices', {});
        expect(installerStep7Controller.allowUpdateProperty([], '', '')).to.be.true;
      });

      it('stackProperty.propertyDependsOn is empty', function () {
        installerStep7Controller.reopen({installedServices: {s1: true}});
        this.stub.returns({serviceName: 's1', propertyDependsOn: []});

        expect(installerStep7Controller.allowUpdateProperty([], '', '')).to.be.false;
      });

      it('stackProperty.propertyDependsOn is not empty', function () {
        installerStep7Controller.reopen({installedServices: {s1: true}});
        this.stub.returns({serviceName: 's1', propertyDependsOn: [
          {type: 't1'},
          {type: 't2'}
        ]});

        expect(installerStep7Controller.allowUpdateProperty([], '', '')).to.be.true;
      });

      it('stackProperty.propertyDependsOn is not empty (2)', function () {
        installerStep7Controller.reopen({installedServices: {s1: true}});
        this.stub.returns({serviceName: 's1', propertyDependsOn: [
          {type: 't1'},
          {type: 't1'}
        ]});

        expect(installerStep7Controller.allowUpdateProperty([], '', '')).to.be.false;
      });

    });

    it('true if it is not installer or addService', function () {
      installerStep7Controller.set('wizardController', {name: 'some'});
      expect(installerStep7Controller.allowUpdateProperty([], '', '')).to.be.true;
    });

  });

  describe('#setButtonClickFinish', function () {

    beforeEach(function () {
      installerStep7Controller.set('submitButtonClicked', true);
      App.set('router.nextBtnClickInProgress', true);
      installerStep7Controller.setButtonClickFinish();
    });

    it('submitButtonClicked should be false', function () {
      expect(installerStep7Controller.get('submitButtonClicked')).to.be.false;
    });

    it('nextBtnClickInProgress should be false', function () {
      expect(App.get('router.nextBtnClickInProgress')).to.be.false;
    });

  });

});

});

require.register("test/controllers/wizard/step8_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/ajax/ajax_queue');
require('controllers/main/service/info/configs');
require('controllers/wizard/step8_controller');
var installerStep8Controller;
var testHelpers = require('test/helpers');

var configs = Em.A([
  Em.Object.create({filename: 'hdfs-site.xml', name: 'p1', value: 'v1'}),
  Em.Object.create({filename: 'hdfs-site.xml', name: 'p2', value: 'v2'}),
  Em.Object.create({filename: 'hue-site.xml', name: 'p1', value: 'v1'}),
  Em.Object.create({filename: 'hue-site.xml', name: 'p2', value: 'v2'}),
  Em.Object.create({filename: 'mapred-site.xml', name: 'p1', value: 'v1'}),
  Em.Object.create({filename: 'mapred-site.xml', name: 'p2', value: 'v2'}),
  Em.Object.create({filename: 'yarn-site.xml', name: 'p1', value: 'v1'}),
  Em.Object.create({filename: 'yarn-site.xml', name: 'p2', value: 'v2'}),
  Em.Object.create({filename: 'capacity-scheduler.xml', name: 'p1', value: 'v1'}),
  Em.Object.create({filename: 'capacity-scheduler.xml', name: 'p2', value: 'v2'}),
  Em.Object.create({filename: 'mapred-queue-acls.xml', name: 'p1', value: 'v1'}),
  Em.Object.create({filename: 'mapred-queue-acls.xml', name: 'p2', value: 'v2'}),
  Em.Object.create({filename: 'hbase-site.xml', name: 'p1', value: 'v1'}),
  Em.Object.create({filename: 'hbase-site.xml', name: 'p2', value: 'v2'}),
  Em.Object.create({filename: 'oozie-site.xml', name: 'p1', value: 'v1'}),
  Em.Object.create({filename: 'oozie-site.xml', name: 'p2', value: 'v2'}),
  Em.Object.create({filename: 'hive-site.xml', name: 'p1', value: 'v1'}),
  Em.Object.create({filename: 'hive-site.xml', name: 'p2', value: 'v2'}),
  Em.Object.create({filename: 'pig-properties.xml', name: 'p1', value: 'v1'}),
  Em.Object.create({filename: 'webhcat-site.xml', name: 'p1', value: 'v1'}),
  Em.Object.create({filename: 'webhcat-site.xml', name: 'p2', value: 'v2'}),
  Em.Object.create({filename: 'tez-site.xml', name: 'p1', value: 'v1'}),
  Em.Object.create({filename: 'tez-site.xml', name: 'p2', value: 'v2'}),
  Em.Object.create({filename: 'falcon-startup.properties.xml', name: 'p1', value: 'v1'}),
  Em.Object.create({filename: 'falcon-startup.properties.xml', name: 'p2', value: 'v2'}),
  Em.Object.create({filename: 'falcon-runtime.properties.xml', name: 'p1', value: 'v1'}),
  Em.Object.create({filename: 'falcon-runtime.properties.xml', name: 'p2', value: 'v2'})
]);

function getController() {
  return App.WizardStep8Controller.create({
    configs: configs,
    content: {controllerName: ''}
  });
}

describe('App.WizardStep8Controller', function () {

  beforeEach(function () {
    installerStep8Controller = getController();
  });

  App.TestAliases.testAsComputedFilterBy(getController(), 'installedServices', 'content.services', 'isInstalled', true);

  App.TestAliases.testAsComputedEqual(getController(), 'isManualKerberos', 'App.router.mainAdminKerberosController.kdc_type', 'none');

  App.TestAliases.testAsComputedAlias(getController(), 'clusterName', 'content.cluster.name', 'string');

  describe('#createSelectedServicesData', function () {

    var tests = Em.A([
      {selectedServices: Em.A(['MAPREDUCE2']), e: 2},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN']), e: 5},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE']), e: 7},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE']), e: 9},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE']), e: 12},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE']), e: 13},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE']), e: 14},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE', 'PIG']), e: 15},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE', 'PIG', 'FALCON']), e: 17},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE', 'PIG', 'FALCON', 'STORM']), e: 18},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE', 'PIG', 'FALCON', 'STORM', 'TEZ']), e: 19},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE', 'PIG', 'FALCON', 'STORM', 'TEZ', 'ZOOKEEPER']), e: 21}
    ]);

    tests.forEach(function (test) {
      it(test.selectedServices.join(','), function () {
        var services = test.selectedServices.map(function (serviceName) {
          return Em.Object.create({isSelected: true, isInstalled: false, serviceName: serviceName});
        });
        installerStep8Controller = App.WizardStep8Controller.create({
          content: {controllerName: 'addServiceController', services: services},
          configs: configs
        });
        var serviceData = installerStep8Controller.createSelectedServicesData();
        expect(serviceData.mapProperty('ServiceInfo.service_name')).to.eql(test.selectedServices.toArray());
        installerStep8Controller.clearStep();
      });
    });

  });

  describe('#getRegisteredHosts', function () {

    var tests = Em.A([
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1'}),
          h2: Em.Object.create({bootStatus: 'OTHER', name: 'h2'})
        },
        e: ['h1'],
        m: 'Two hosts, one registered'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1'}),
          h2: Em.Object.create({bootStatus: 'OTHER', name: 'h2'})
        },
        e: [],
        m: 'Two hosts, zero registered'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1'}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2'})
        },
        e: ['h1', 'h2'],
        m: 'Two hosts, two registered'
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        installerStep8Controller.set('content', Em.Object.create({hosts: test.hosts}));
        var registeredHosts = installerStep8Controller.getRegisteredHosts();
        expect(registeredHosts.mapProperty('hostName').toArray()).to.eql(test.e);
      });
    });

  });

  describe('#createRegisterHostData', function () {

    var tests = Em.A([
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1', isInstalled: false}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h1', 'h2'],
        m: 'two registered, two isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1', isInstalled: false}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h2'],
        m: 'one registered, two isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1', isInstalled: true}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h2'],
        m: 'one registered, one isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1', isInstalled: true}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h2'],
        m: 'two registered, one isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1', isInstalled: false}),
          h2: Em.Object.create({bootStatus: 'OTHER', name: 'h2', isInstalled: false})
        },
        e: [],
        m: 'zero registered, two isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1', isInstalled: true}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: true})
        },
        e: [],
        m: 'two registered, zeto insInstalled false'
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        installerStep8Controller.set('content', Em.Object.create({hosts: test.hosts}));
        var registeredHostData = installerStep8Controller.createRegisterHostData();
        expect(registeredHostData.mapProperty('Hosts.host_name').toArray()).to.eql(test.e);
      });
    });

  });

  describe('#loadServices', function () {

    beforeEach(function () {
      var services = Em.A([
        Em.Object.create({
          serviceName: 's1',
          isSelected: true,
          displayNameOnSelectServicePage: 's01',
          isClientOnlyService: false,
          serviceComponents: Em.A([
            Em.Object.create({
              isClient: true
            })
          ]),
          isHiddenOnSelectServicePage: false
        }),
        Em.Object.create({
          serviceName: 's2',
          isSelected: true,
          displayNameOnSelectServicePage: 's02',
          serviceComponents: Em.A([
            Em.Object.create({
              isMaster: true
            })
          ]),
          isHiddenOnSelectServicePage: false
        }),
        Em.Object.create({
          serviceName: 's3',
          isSelected: true,
          displayNameOnSelectServicePage: 's03',
          serviceComponents: Em.A([
            Em.Object.create({
              isHAComponentOnly: true
            })
          ]),
          isHiddenOnSelectServicePage: false
        }),
        Em.Object.create({
          serviceName: 's4',
          isSelected: true,
          displayNameOnSelectServicePage: 's03',
          isClientOnlyService: true,
          serviceComponents: Em.A([
            Em.Object.create({
              isClient: true
            })
          ]),
          isHiddenOnSelectServicePage: false
        })
      ]);
      var selectedServices = services.filterProperty('isSelected');
      var slaveComponentHosts = Em.A([
        Em.Object.create({
          componentName: 'CLIENT',
          hostName: 'h1',
          hosts: Em.A([
            Em.Object.create({hostName: 'h1', isInstalled: true}),
            Em.Object.create({hostName: 'h2', isInstalled: false})
          ])
        })
      ]);
      var content = Em.Object.create({
        services: services,
        selectedServices: selectedServices,
        slaveComponentHosts: slaveComponentHosts,
        hosts: Em.A([
          Em.Object.create({hostName: 'h1', isInstalled: true}),
          Em.Object.create({hostName: 'h2', isInstalled: false})
        ]),
        masterComponentHosts: []
      });
      installerStep8Controller.set('content', content);
      installerStep8Controller.set('services', Em.A([]));
      installerStep8Controller.reopen({selectedServices: selectedServices});
      installerStep8Controller.loadServices();
    });

    it('should load services', function () {
      var expected = [
        {
          "service_name": "s1",
          "display_name": "s01",
          "service_components": []
        },
        {
          "service_name": "s2",
          "display_name": "s02",
          "service_components": []
        },
        {
          "service_name": "s3",
          "display_name": "s03",
          "service_components": []
        },
        {
          "service_name": "s4",
          "display_name": "s03",
          "service_components": [
            {
              "component_name": "CLIENT",
              "display_name": "Clients",
              "component_value": "2 hosts"
            }
          ]
        }
      ];
      var result = JSON.parse(JSON.stringify(installerStep8Controller.get('services')));
      expect(result).to.be.eql(expected);
    });
  });

  describe('#removeClientsFromList', function () {

    beforeEach(function () {
      installerStep8Controller.set('content', Em.Object.create({
        hosts: Em.Object.create({
          h1: Em.Object.create({
            hostName: 'h1',
            isInstalled: true,
            hostComponents: Em.A([Em.Object.create({HostRoles: Em.Object.create({component_name: "h1"})})])
          }),
          h2: Em.Object.create({
            hostName: 'h2',
            isInstalled: true,
            hostComponents: Em.A([Em.Object.create({HostRoles: Em.Object.create({component_name: "h2"})})])
          })
        })
      }));
    });

    it('should remove h1', function () {
      var hostList = Em.A(['h1','h2']);
      installerStep8Controller.removeClientsFromList('h1', hostList);
      expect(JSON.parse(JSON.stringify(hostList))).to.eql(["h2"]);
    });
  });

  describe('#createSlaveAndClientsHostComponents', function () {

    beforeEach(function () {
      installerStep8Controller.set('content', Em.Object.create({
        masterComponentHosts: Em.A([
          Em.Object.create({
            componentName: 'CLIENT',
            component: 'HBASE_MASTER',
            hostName: 'h1'
          })
        ]),
        slaveComponentHosts: Em.A([
          Em.Object.create({
            componentName: 'CLIENT',
            hostName: 'h1',
            hosts: Em.A([
              Em.Object.create({hostName: 'h1', isInstalled: true}),
              Em.Object.create({hostName: 'h2', isInstalled: false})
            ])
          }),
          Em.Object.create({
            componentName: 'CLIENT1',
            hostName: 'h1',
            hosts: Em.A([
              Em.Object.create({hostName: 'h1', isInstalled: true}),
              Em.Object.create({hostName: 'h2', isInstalled: false})
            ])

          })
        ]),
        clients: Em.A([
          Em.Object.create({
            isInstalled: false
          })
        ]),
        services: Em.A([
          Em.Object.create({
            isInstalled: true,
            serviceName: "name",
            isClient: true
          })
        ]),
        hosts: Em.Object.create({
          h1: Em.Object.create({
            hostName: 'h1',
            isInstalled: true,
            hostComponents: Em.A([Em.Object.create({})])
          }),
          h2: Em.Object.create({
            hostName: 'h2',
            isInstalled: false,
            hostComponents: Em.A([Em.Object.create({})])
          })
        }),
        additionalClients: Em.A([{hostNames: "name", componentName: "client"}])
      }));
      installerStep8Controller.set('ajaxRequestsQueue', App.ajaxQueue.create());
      installerStep8Controller.get('ajaxRequestsQueue').clear();
    });

    it('should return non install object', function () {
      installerStep8Controller.createSlaveAndClientsHostComponents();
      expect(installerStep8Controller.get('content.clients')[0].isInstalled).to.be.false;
    });
  });

  describe('#createAdditionalClientComponents', function () {

    beforeEach(function () {
      installerStep8Controller.set('content', Em.Object.create({
        masterComponentHosts: Em.A([
          Em.Object.create({
            componentName: 'CLIENT',
            component: 'HBASE_MASTER',
            hostName: 'h1'
          })
        ]),
        slaveComponentHosts: Em.A([
          Em.Object.create({
            componentName: 'CLIENT',
            hostName: 'h1',
            hosts: Em.A([
              Em.Object.create({hostName: 'h1', isInstalled: true}),
              Em.Object.create({hostName: 'h2', isInstalled: false})
            ])
          })
        ]),
        clients: Em.A([
          Em.Object.create({
            isInstalled: false
          })
        ]),
        services: Em.A([
          Em.Object.create({
            isInstalled: true,
            serviceName: "name",
            isClient: true
          })
        ]),
        hosts: Em.Object.create({
          h1: Em.Object.create({
            hostName: 'h1',
            isInstalled: true,
            hostComponents: Em.A([Em.Object.create({})])
          }),
          h2: Em.Object.create({
            hostName: 'h2',
            isInstalled: false,
            hostComponents: Em.A([Em.Object.create({})])
          })
        }),
        additionalClients: Em.A([{hostNames: "name", componentName: "client"}])
      }));
      installerStep8Controller.set('ajaxRequestsQueue', App.ajaxQueue.create());
      installerStep8Controller.get('ajaxRequestsQueue').clear();
      installerStep8Controller.createAdditionalClientComponents();
    });

    it('should bes equal to content.cluster.name', function () {

      var result = [
        {
          "hostNames": "name",
          "componentName": "client"
        }
      ];
      var expected = installerStep8Controller.get('content.additionalClients');
      expect(JSON.parse(JSON.stringify(expected))).to.eql(result);
    });
  });

  describe('#assignComponentHosts', function () {
    it('should return host name', function () {
      var component = Em.Object.create({
        isMaster: true,
        componentName: 'HBASE_MASTER',
        hostName: 'h1'
      });
      installerStep8Controller.set('content', Em.Object.create({
        masterComponentHosts:Em.A([
          Em.Object.create({component: 'HBASE_MASTER', hostName: 'h1'})
      ])}));
      var res = installerStep8Controller.assignComponentHosts(component);
      expect(res).to.equal("h1");
    });
    it('should return number of hosts', function () {
      var component = Em.Object.create({
        componentName: 'HBASE_MASTER',
        isClient: false,
        hostName: 'h1'
      });
      installerStep8Controller.set('content', Em.Object.create({
        slaveComponentHosts:Em.A([
          Em.Object.create({
            componentName: 'HBASE_MASTER',
            hostName: 'h1',
            hosts: [
              {hostName: 'h1'},
              {hostName: 'h2'}
            ]
          })
      ])}));
      var res = installerStep8Controller.assignComponentHosts(component);
      expect(res).to.equal("2 hosts");
    });
  });

  describe('#loadClusterInfo', function () {
    beforeEach(function () {
      sinon.stub(App.Stack, 'find', function(){
        return Em.A([
          Em.Object.create({isSelected: false, hostName: 'h1'}),
          Em.Object.create({
            isSelected: true,
            hostName: 'h2',
            operatingSystems: Em.A([Em.Object.create({
              name:'windows',
              isSelected: true,
              repositories: Em.A([Em.Object.create({
                baseUrl: "url",
                osType: "2",
                repoId: "3"
              })])
            })])
          }),
          Em.Object.create({isSelected: false, hostName: 'h3'})
        ]);
      });
    });
    afterEach(function () {
      App.Stack.find.restore();
    });
    it('should return config with display_name', function () {
      installerStep8Controller.set('clusterInfo', Em.A([]));
      installerStep8Controller.loadClusterInfo();
      var res = [{
        "config_name":"cluster",
        "display_name":"Cluster Name"
      },{
        "config_name":"hosts",
        "display_name":"Total Hosts",
        "config_value":"0 (0 new)"
      }];
      var calcRes = JSON.parse(JSON.stringify(installerStep8Controller.get('clusterInfo')));
      expect(calcRes).to.eql(res);
    });
  });

  describe('#loadStep', function () {
    beforeEach(function () {
      sinon.stub(installerStep8Controller, 'clearStep', Em.K);
      sinon.stub(installerStep8Controller, 'formatProperties', Em.K);
      sinon.stub(installerStep8Controller, 'loadConfigs', Em.K);
      sinon.stub(installerStep8Controller, 'loadClusterInfo', Em.K);
      sinon.stub(installerStep8Controller, 'loadServices', Em.K);
      installerStep8Controller.set('content', {controllerName: 'installerController'});
    });
    afterEach(function () {
      installerStep8Controller.clearStep.restore();
      installerStep8Controller.formatProperties.restore();
      installerStep8Controller.loadConfigs.restore();
      installerStep8Controller.loadClusterInfo.restore();
      installerStep8Controller.loadServices.restore();
    });
    it('should call clearStep', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.clearStep.calledOnce).to.equal(true);
    });
    it('should call loadClusterInfo', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadClusterInfo.calledOnce).to.equal(true);
    });
    it('should call loadServices', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadServices.calledOnce).to.equal(true);
    });
    it('should call formatProperties if content.serviceConfigProperties is true', function () {
      installerStep8Controller.set('content.serviceConfigProperties', true);
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadServices.calledOnce).to.equal(true);
    });
    it('should call loadConfigs if content.serviceConfigProperties is true', function () {
      installerStep8Controller.set('content.serviceConfigProperties', true);
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadConfigs.calledOnce).to.equal(true);
    });
    it('should set isSubmitDisabled to false', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.get('isSubmitDisabled')).to.equal(false);
    });
    it('should set isBackBtnDisabled to false', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.get('isBackBtnDisabled')).to.equal(false);
    });
  });

  describe('#getRegisteredHosts', function() {
    Em.A([
        {
          hosts: {},
          m: 'no content.hosts',
          e: []
        },
        {
          hosts: {
            h1:{bootStatus: ''},
            h2:{bootStatus: ''}
          },
          m: 'no registered hosts',
          e: []
        },
        {
          hosts: {
            h1:{bootStatus: 'REGISTERED', hostName: '', name: 'n1'},
            h2:{bootStatus: 'REGISTERED', hostName: '', name: 'n2'}
          },
          m: 'registered hosts available',
          e: ['n1', 'n2']
        }
      ]).forEach(function(test) {
        it(test.m, function() {
          installerStep8Controller.set('content', {hosts: test.hosts});
          var hosts = installerStep8Controller.getRegisteredHosts();
          expect(hosts.mapProperty('hostName')).to.eql(test.e);
        });
      });
  });

  describe('#loadRepoInfo', function() {

    beforeEach(function () {
      var stubForGet = sinon.stub(App, 'get');
      stubForGet.withArgs('currentStackName').returns('HDP');
      stubForGet.withArgs('currentStackVersionNumber').returns('2.3');
      sinon.stub(App.StackVersion, 'find', function() {
        return [
          Em.Object.create({state: 'NOT_CURRENT', stack: 'HDP', version: '2.3', repositoryVersion: {repositoryVersion: '2.3.0.0-2208'}})
        ];
      });
    });

    afterEach(function () {
      App.get.restore();
      App.StackVersion.find.restore();
    });
    it('should use current StackVersion', function() {
      installerStep8Controller.loadRepoInfo();
      var args = testHelpers.findAjaxRequest('name', 'cluster.load_repo_version');
      expect(args[0].data).to.eql({stackName: 'HDP', repositoryVersion: '2.3.0.0-2208'});
    });
  });

  describe('#loadRepoInfoSuccessCallback', function () {
    beforeEach(function () {
      installerStep8Controller.set('clusterInfo', Em.Object.create({}));
    });

    it('should assert error if no data returned from server', function () {
      expect(function () {
        installerStep8Controller.loadRepoInfoSuccessCallback({items: []});
      }).to.throw(Error);
    });

    Em.A([
      {
        m: 'Normal JSON',
        e: {
          base_url: ['baseurl1', 'baseurl2'],
          os_type: ['redhat6', 'suse11'],
          repo_id: ['HDP-2.3', 'HDP-UTILS-1.1.0.20']
        },
        items: [
          {
            repository_versions: [
              {
                operating_systems: [
                  {
                    OperatingSystems: {
                      ambari_managed_repositories: true
                    },
                    repositories: [
                      {
                        Repositories: {
                          base_url: 'baseurl1',
                          os_type: 'redhat6',
                          repo_id: 'HDP-2.3'
                        }
                      }
                    ]
                  },
                  {
                    OperatingSystems: {
                      ambari_managed_repositories: true
                    },
                    repositories: [
                      {
                        Repositories: {
                          base_url: 'baseurl2',
                          os_type: 'suse11',
                          repo_id: 'HDP-UTILS-1.1.0.20'
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]).forEach(function (test) {

      it(test.m, function () {
        installerStep8Controller.loadRepoInfoSuccessCallback({items: test.items});
        expect(installerStep8Controller.get('clusterInfo.repoInfo').mapProperty('base_url')).to.eql(test.e.base_url);
        expect(installerStep8Controller.get('clusterInfo.repoInfo').mapProperty('os_type')).to.eql(test.e.os_type);
        expect(installerStep8Controller.get('clusterInfo.repoInfo').mapProperty('repo_id')).to.eql(test.e.repo_id);
      });

    });

    /*Em.A([
        {
          items: [
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat5',
                    base_url: 'url1'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            }
          ],
          m: 'only redhat5',
          e: {
            base_url: ['url1'],
            os_type: ['redhat5']
          }
        },
        {
          items: [
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat5',
                    base_url: 'url1'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            },
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat6',
                    base_url: 'url2'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            }
          ],
          m: 'redhat5, redhat6',
          e: {
            base_url: ['url1', 'url2'],
            os_type: ['redhat5', 'redhat6']
          }
        },
        {
          items: [
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat5',
                    base_url: 'url1'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            },
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat6',
                    base_url: 'url2'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            },
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'sles11',
                    base_url: 'url3'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            }
          ],
          m: 'redhat5, redhat6, sles11',
          e: {
            base_url: ['url1', 'url2', 'url3'],
            os_type: ['redhat5', 'redhat6', 'sles11']
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          installerStep8Controller.loadRepoInfoSuccessCallback({items: test.items});
          expect(installerStep8Controller.get('clusterInfo.repoInfo').mapProperty('base_url')).to.eql(test.e.base_url);
          expect(installerStep8Controller.get('clusterInfo.repoInfo').mapProperty('os_type')).to.eql(test.e.os_type);
        });
      });*/
  });

  describe('#loadRepoInfoErrorCallback', function() {
    it('should set [] to repoInfo', function() {
      installerStep8Controller.set('clusterInfo', Em.Object.create({repoInfo: [{}, {}]}));
      installerStep8Controller.loadRepoInfoErrorCallback({});
      expect(installerStep8Controller.get('clusterInfo.repoInfo.length')).to.be.equal(0);
    });
  });

  describe('#loadHbaseMasterValue', function () {
    Em.A([
        {
          masterComponentHosts: [{component: 'HBASE_MASTER', hostName: 'h1'}],
          component: Em.Object.create({component_name: 'HBASE_MASTER'}),
          m: 'one host',
          e: 'h1'
        },
        {
          masterComponentHosts: [{component: 'HBASE_MASTER', hostName: 'h1'}, {component: 'HBASE_MASTER', hostName: 'h2'}, {component: 'HBASE_MASTER', hostName: 'h3'}],
          component: Em.Object.create({component_name: 'HBASE_MASTER'}),
          m: 'many hosts',
          e: 'h1 ' + Em.I18n.t('installer.step8.other').format(2)
        }
      ]).forEach(function (test) {
        it(test.m, function() {
          installerStep8Controller.set('content', {masterComponentHosts: test.masterComponentHosts});
          installerStep8Controller.loadHbaseMasterValue(test.component);
          expect(test.component.component_value).to.equal(test.e);
        });
      });
  });

  describe('#loadZkServerValue', function() {
    Em.A([
        {
          masterComponentHosts: [{component: 'ZOOKEEPER_SERVER'}],
          component: Em.Object.create({component_name: 'ZOOKEEPER_SERVER'}),
          m: '1 host',
          e: '1 host'
        },
        {
          masterComponentHosts: [{component: 'ZOOKEEPER_SERVER'},{component: 'ZOOKEEPER_SERVER'},{component: 'ZOOKEEPER_SERVER'}],
          component: Em.Object.create({component_name: 'ZOOKEEPER_SERVER'}),
          m: 'many hosts',
          e: '3 hosts'
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          installerStep8Controller.set('content', {masterComponentHosts: test.masterComponentHosts});
          installerStep8Controller.loadZkServerValue(test.component);
          expect(test.component.component_value).to.equal(test.e);
        });
      });
  });

  describe('#loadDbValue', function() {

    beforeEach(function() {
      installerStep8Controller.set('wizardController', Em.Object.create({
        getDBProperty: Em.K
      }));
    });

    afterEach(function() {
    });

    var tests = [
    {
       it: "Hive test for Existing Oracle Database",
       serviceConfigProperties: [
         {name: 'hive_database', value: 'Existing Oracle Database'}
       ],
       serviceName: 'HIVE',
       result: 'Existing Oracle Database'
     },
     {
       it: "Oozie test for New Derby Database",
       serviceConfigProperties: [
         {name: 'oozie_database', value: 'New Derby Database'}
       ],
       serviceName: 'OOZIE',
       result: 'New Derby Database'
     }
    ];

    tests.forEach(function(test) {
      it(test.it, function() {
        installerStep8Controller.set('content.serviceConfigProperties', test.serviceConfigProperties);
        var dbComponent = installerStep8Controller.loadDbValue(test.serviceName);
        expect(dbComponent).to.equal(test.result);
      });
    });
  });

  describe('#submit', function() {
    beforeEach(function() {
      sinon.stub(installerStep8Controller, 'submitProceed', Em.K);
      sinon.stub(installerStep8Controller, 'showRestartWarnings').returns($.Deferred().resolve().promise());
      sinon.stub(App.get('router.mainAdminKerberosController'), 'getKDCSessionState', Em.K);
    });
    afterEach(function() {
      installerStep8Controller.submitProceed.restore();
      installerStep8Controller.showRestartWarnings.restore();
      App.set('isKerberosEnabled', false);
      App.get('router.mainAdminKerberosController').getKDCSessionState.restore();
    });
    it('AddServiceController Kerberos enabled', function () {
      installerStep8Controller.reopen({
        isSubmitDisabled: false,
        content: {controllerName: 'addServiceController'}
      });
      installerStep8Controller.submit();
      expect(App.get('router.mainAdminKerberosController').getKDCSessionState.called).to.equal(true);
    });
    it('shouldn\'t do nothing if isSubmitDisabled is true', function() {
      installerStep8Controller.reopen({isSubmitDisabled: true});
      installerStep8Controller.submit();
      expect(App.get('router.mainAdminKerberosController').getKDCSessionState.called).to.equal(false);
      expect(installerStep8Controller.submitProceed.called).to.equal(false);
    });
  });

  describe('#getExistingClusterNamesSuccessCallBack', function() {
    it('should set clusterNames received from server', function() {
      var data = {
          items:[
            {Clusters: {cluster_name: 'c1'}},
            {Clusters: {cluster_name: 'c2'}},
            {Clusters: {cluster_name: 'c3'}}
          ]
        },
        clasterNames = ['c1','c2','c3'];
      installerStep8Controller.getExistingClusterNamesSuccessCallBack(data);
      expect(installerStep8Controller.get('clusterNames')).to.eql(clasterNames);
    });
  });

  describe('#getExistingClusterNamesErrorCallback', function() {
    it('should set [] to clusterNames', function() {
      installerStep8Controller.set('clusterNames', ['c1', 'c2']);
      installerStep8Controller.getExistingClusterNamesErrorCallback();
      expect(installerStep8Controller.get('clusterNames')).to.eql([]);
    });
  });

  describe('#deleteClusters', function() {

    describe('should call App.ajax.send for each provided clusterName', function() {
      var clusterNames = ['h1', 'h2', 'h3'];
      var args;
      beforeEach(function () {
        installerStep8Controller.deleteClusters(clusterNames);
        args = testHelpers.filterAjaxRequests('name', 'common.delete.cluster');
      });

      it('args', function () {
        expect(args).to.have.property('length').equal(clusterNames.length);
      });

      clusterNames.forEach(function(n, i) {
        it(n, function () {
          expect(args[i][0].data).to.eql({name: n, isLast: i === clusterNames.length - 1});
        });
      });
    });

    it('should clear cluster delete error popup body views', function () {
      installerStep8Controller.deleteClusters([]);
      expect(installerStep8Controller.get('clusterDeleteErrorViews')).to.eql([]);
    });

  });

  describe('#ajaxQueueFinished', function() {

    beforeEach(function () {
      sinon.stub(App.router, 'send', Em.K);
    });

    afterEach(function () {
      App.router.send.restore();
    });

    it('should call App.router.next', function() {
      installerStep8Controller.ajaxQueueFinished();
      expect(App.router.send.calledWith('next')).to.equal(true);
    });
  });

  describe('#addRequestToAjaxQueue', function() {

    describe('testMode = false', function() {
      it('should add request', function() {
        var clusterName = 'c1';
        installerStep8Controller.reopen({clusterName: clusterName});
        installerStep8Controller.set('ajaxRequestsQueue', App.ajaxQueue.create());
        installerStep8Controller.get('ajaxRequestsQueue').clear();
        installerStep8Controller.addRequestToAjaxQueue({name:'name', data:{}});
        var request = installerStep8Controller.get('ajaxRequestsQueue.queue.firstObject');
        expect(request.error).to.equal('ajaxQueueRequestErrorCallback');
        expect(request.data.cluster).to.equal(clusterName);
      });
    });
  });

  describe('#ajaxQueueRequestErrorCallback', function() {
    var obj = Em.Object.create({
      registerErrPopup: Em.K,
      setStepsEnable: Em.K
    });
    beforeEach(function() {
      sinon.stub(App.router, 'get', function() {
        return obj;
      });
      sinon.spy(obj, 'registerErrPopup');
      sinon.spy(obj, 'setStepsEnable');
    });
    afterEach(function() {
      App.router.get.restore();
      obj.registerErrPopup.restore();
      obj.setStepsEnable.restore();
    });
    it('should set hasErrorOccurred true', function () {
      installerStep8Controller.set('hasErrorOccurred', false);
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(installerStep8Controller.get('hasErrorOccurred')).to.equal(true);
    });
    it('should set isSubmitDisabled false', function () {
      installerStep8Controller.set('isSubmitDisabled', true);
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(installerStep8Controller.get('isSubmitDisabled')).to.equal(false);
    });
    it('should set isBackBtnDisabled false', function () {
      installerStep8Controller.set('isBackBtnDisabled', true);
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(installerStep8Controller.get('isBackBtnDisabled')).to.equal(false);
    });
    it('should call setStepsEnable', function () {
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(obj.setStepsEnable.calledOnce).to.equal(true);
    });
    it('should call registerErrPopup', function () {
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(obj.registerErrPopup.calledOnce).to.equal(true);
    });
  });

  describe('#removeInstalledServicesConfigurationGroups', function() {
    beforeEach(function() {
      sinon.stub(installerStep8Controller, 'deleteConfigurationGroup', Em.K);
    });
    afterEach(function() {
      installerStep8Controller.deleteConfigurationGroup.restore();
    });
    it('should call App.config.deleteConfigGroup for each received group', function() {
      var groups = [{}, {}, {}];
      installerStep8Controller.removeInstalledServicesConfigurationGroups(groups);
      expect(installerStep8Controller.deleteConfigurationGroup.callCount).to.equal(groups.length);
    });
  });

  describe('#getExistingClusterNames', function() {

    it('should do ajax request', function() {
      installerStep8Controller.getExistingClusterNames();
      var args = testHelpers.findAjaxRequest('name', 'wizard.step8.existing_cluster_names');
      expect(args).exists;
    });
  });

  describe('Queued requests', function() {

    beforeEach(function() {
      installerStep8Controller.clearStep();
      sinon.spy(installerStep8Controller, 'addRequestToAjaxQueue');
    });

    afterEach(function() {
      installerStep8Controller.addRequestToAjaxQueue.restore();
    });

    describe('#createCluster', function() {
      before(function () {
        sinon.stub(App.Stack, 'find').returns([
          Em.Object.create({
            id: "HDP-2.3-2.3.4.0-1234",
            isSelected: false,
            repositoryVersion: "2.3.4.0-1234"
          }),
          Em.Object.create({
            id: "HDP-2.3-2.3.4.1-1234",
            isSelected: false,
            repositoryVersion: "2.3.4.1-1234"
          }),
          Em.Object.create({
            id: "HDP-2.3-2.3.4.4-1234",
            isSelected: true,
            repositoryVersion: "2.3.4.4-1234"
          })
        ]);
      });
      after(function () {
        App.Stack.find.restore();
      });

      it('App.currentStackVersion should be changed if localRepo selected', function() {
        App.set('currentStackVersion', 'HDP-2.3');
        installerStep8Controller.reopen({content: {controllerName: 'installerController', installOptions: {localRepo: true}}});
        var data = {
          data: JSON.stringify({ "Clusters": {"version": 'HDPLocal-2.3', "repository_version": "2.3.4.4-1234"}})
        };
        installerStep8Controller.createCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data).to.equal(data.data);
      });

      it('App.currentStackVersion shouldn\'t be changed if localRepo ins\'t selected', function() {
        App.set('currentStackVersion', 'HDP-2.3');
        installerStep8Controller.reopen({content: {controllerName: 'installerController', installOptions: {localRepo: false}}});
        var data = {
          data: JSON.stringify({ "Clusters": {"version": 'HDP-2.3', "repository_version": "2.3.4.4-1234"}})
        };
        installerStep8Controller.createCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data).to.eql(data.data);
      });
    });

    describe('#createSelectedServices', function() {

      var data;

      beforeEach(function () {
        sinon.stub(installerStep8Controller, 'createSelectedServicesData', function () {
          return data;
        });
      });

      afterEach(function () {
        installerStep8Controller.createSelectedServicesData.restore();
      });

      it('shouldn\'t do nothing if no data', function() {
        data = [];
        installerStep8Controller.createSelectedServices();
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
      });

      it('should call addRequestToAjaxQueue with computed data', function() {
        data = [
          {"ServiceInfo": { "service_name": 's1' }},
          {"ServiceInfo": { "service_name": 's2' }},
          {"ServiceInfo": { "service_name": 's3' }}
        ];
        installerStep8Controller.createSelectedServices();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data).to.equal(JSON.stringify(data));
      });

    });

    describe('#registerHostsToCluster', function() {
      var data;
      beforeEach(function () {
        sinon.stub(installerStep8Controller, 'createRegisterHostData', function () {
          return data;
        });
      });

      afterEach(function () {
        installerStep8Controller.createRegisterHostData.restore();
      });

      it('shouldn\'t do nothing if no data', function() {
        data = [];
        installerStep8Controller.registerHostsToCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
      });
      it('should call addRequestToAjaxQueue with computed data', function() {
        data = [
          {"Hosts": { "host_name": 'h1'}},
          {"Hosts": { "host_name": 'h3'}}
        ];
        installerStep8Controller.registerHostsToCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data).to.equal(JSON.stringify(data));
      });
    });

    describe('#registerHostsToComponent', function() {

      it('shouldn\'t do request if no hosts provided', function() {
        installerStep8Controller.registerHostsToComponent([]);
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
      });

      it('should do request if hostNames are provided', function() {
        var hostNames = ['h1', 'h2'],
          componentName = 'c1';
        installerStep8Controller.registerHostsToComponent(hostNames, componentName);
        var data = JSON.parse(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data);
        expect(data.RequestInfo.query).to.equal('Hosts/host_name=h1|Hosts/host_name=h2');
        expect(data.Body.host_components[0].HostRoles.component_name).to.equal('c1');
      });

    });

    describe('#applyConfigurationsToCluster', function() {
      it('should call addRequestToAjaxQueue', function() {
        var serviceConfigTags = [
            {
              type: 'hdfs',
              tag: 'tag1',
              properties: {
                'prop1': 'value1'
              }
            }
          ],
          data = '['+JSON.stringify({
            Clusters: {
              desired_config: [serviceConfigTags[0]]
            }
          })+']';
        installerStep8Controller.reopen({
          installedServices: [
              Em.Object.create({
                isSelected: true,
                isInstalled: false,
                configTypesRendered: {hdfs:'tag1'}
              })
            ], selectedServices: []
        });
        installerStep8Controller.applyConfigurationsToCluster(serviceConfigTags);
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data).to.equal(data);
      });
    });

    describe('#newServiceComponentErrorCallback', function() {

      it('should add request for new component', function() {
        var serviceName = 's1',
          componentName = 'c1';
        installerStep8Controller.newServiceComponentErrorCallback({}, {}, '', {}, {serviceName: serviceName, componentName: componentName});
        var data = JSON.parse(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data);
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.serviceName).to.equal(serviceName);
        expect(data.components[0].ServiceComponentInfo.component_name).to.equal(componentName);
      });

    });

    describe('#createAdditionalHostComponents', function() {

      beforeEach(function() {
        sinon.stub(installerStep8Controller, 'registerHostsToComponent', Em.K);
      });

      afterEach(function() {
        installerStep8Controller.registerHostsToComponent.restore();
      });

      describe('should add components with isRequiredOnAllHosts == true (1)', function() {

        beforeEach(function () {
          installerStep8Controller.reopen({
            getRegisteredHosts: function() {
              return [{hostName: 'h1'}, {hostName: 'h2'}];
            },
            content: {
              services: [
                Em.Object.create({
                  serviceName: 'GANGLIA', isSelected: true, isInstalled: false, serviceComponents: [
                    Em.Object.create({
                      componentName: 'GANGLIA_MONITOR',
                      isRequiredOnAllHosts: true
                    }),
                    Em.Object.create({
                      componentName: 'GANGLIA_SERVER',
                      isRequiredOnAllHosts: false
                    })
                  ]
                })
              ]
            }
          });
          installerStep8Controller.createAdditionalHostComponents();
        });

        it('registerHostsToComponent is called once', function () {
          expect(installerStep8Controller.registerHostsToComponent.calledOnce).to.equal(true);
        });
        it('hosts are ["h1", "h2"]', function () {
          expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(['h1', 'h2']);
        });
        it('component is GANGLIA_MONITOR', function () {
          expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal('GANGLIA_MONITOR');
        });

      });

      describe('should add components with isRequiredOnAllHosts == true (2)', function() {

        beforeEach(function () {
          installerStep8Controller.reopen({
            getRegisteredHosts: function() {
              return [{hostName: 'h1', isInstalled: true}, {hostName: 'h2', isInstalled: false}];
            },
            content: {
              services: [
                Em.Object.create({
                  serviceName: 'GANGLIA', isSelected: true, isInstalled: true, serviceComponents: [
                    Em.Object.create({
                      componentName: 'GANGLIA_MONITOR',
                      isRequiredOnAllHosts: true
                    }),
                    Em.Object.create({
                      componentName: 'GANGLIA_SERVER',
                      isRequiredOnAllHosts: false
                    })
                  ]
                })
              ]
            }
          });
          installerStep8Controller.createAdditionalHostComponents();
        });

        it('registerHostsToComponent is called once', function () {
          expect(installerStep8Controller.registerHostsToComponent.calledOnce).to.equal(true);
        });
        it('hosts are ["h2"]', function () {
          expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(['h2']);
        });
        it('component is GANGLIA_MONITOR', function () {
          expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal('GANGLIA_MONITOR');
        });

      });

      var newDatabases = [
        {
          name: 'New MySQL Database',
          component: 'MYSQL_SERVER',
          expectedHosts: ['h2']
        },
        {
          name: 'New PostgreSQL Database',
          component: 'POSTGRESQL_SERVER',
          expectedHosts: ['h2']
        }
      ];

      newDatabases.forEach(function (db) {
        describe('should add {0}'.format(db.component), function() {

          beforeEach(function () {
            installerStep8Controller.reopen({
              getRegisteredHosts: function() {
                return [{hostName: 'h1'}, {hostName: 'h2'}];
              },
              content: {
                masterComponentHosts: [
                  {component: 'HIVE_METASTORE', hostName: 'h1'},
                  {component: 'HIVE_SERVER', hostName: 'h2'}
                ],
                services: [
                  Em.Object.create({serviceName: 'HIVE', isSelected: true, isInstalled: false, serviceComponents: []})
                ],
                serviceConfigProperties: [
                  {name: 'hive_database', value: db.name}
                ]
              }
            });
            installerStep8Controller.createAdditionalHostComponents();
          });

          it('registerHostsToComponent is called once', function () {
            expect(installerStep8Controller.registerHostsToComponent.calledOnce).to.equal(true);
          });
          it('hosts are ' + db.expectedHosts, function () {
            expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(db.expectedHosts);
          });
          it('component is ' + db.component, function () {
            expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal(db.component);
          });
        });

      });

    });

  describe('#createAdditionalHostComponentsOnAllHosts', function () {

      beforeEach(function() {
        sinon.stub(installerStep8Controller, 'registerHostsToComponent', Em.K);
      });

      afterEach(function() {
        installerStep8Controller.registerHostsToComponent.restore();
      });

      describe('should add components with isRequiredOnAllHosts == true (1)', function() {

        beforeEach(function () {
          installerStep8Controller.reopen({
            getRegisteredHosts: function() {
              return [{hostName: 'h1'}, {hostName: 'h2'}];
            },
            content: {
              services: Em.A([
                Em.Object.create({
                  serviceName: 'ANYSERVICE', isSelected: true, isInstalled: false, serviceComponents: [
                    // set isRequiredOnAllHosts = true for slave and client
                    Em.Object.create({
                      componentName: 'ANYSERVICE_MASTER',
                      isMaster: true,
                      isRequiredOnAllHosts: false
                    }),
                    Em.Object.create({
                      componentName: 'ANYSERVICE_SLAVE',
                      isSlave: true,
                      isRequiredOnAllHosts: true
                    }),
                    Em.Object.create({
                      componentName: 'ANYSERVICE_SLAVE2',
                      isSlave: true,
                      isRequiredOnAllHosts: true
                    }),
                    Em.Object.create({
                      componentName: 'ANYSERVICE_CLIENT',
                      isClient: true,
                      isRequiredOnAllHosts: true
                    })
                  ]
                })
              ]),
              masterComponentHosts: Em.A([
                Em.Object.create({
                  componentName: 'ANYSERVICE_MASTER',
                  component: 'ANYSERVICE_MASTER',
                  hosts: Em.A([
                    Em.Object.create({hostName: 'h1', isInstalled: true})
                  ])
                })
              ]),
              slaveComponentHosts: Em.A([
                Em.Object.create({
                  componentName: 'ANYSERVICE_SLAVE',
                  hosts: Em.A([
                    Em.Object.create({hostName: 'h1', isInstalled: false}),
                    Em.Object.create({hostName: 'h2', isInstalled: false})
                  ])
                }),
                Em.Object.create({
                  componentName: 'ANYSERVICE_SLAVE2',
                  hosts: Em.A([
                    Em.Object.create({hostName: 'h1', isInstalled: false}),
                    Em.Object.create({hostName: 'h2', isInstalled: false})
                  ])
                }),
                Em.Object.create({
                  componentName: 'CLIENT',
                  hosts: Em.A([
                    Em.Object.create({hostName: 'h1', isInstalled: false}),
                    Em.Object.create({hostName: 'h2', isInstalled: false})
                  ])
                })
              ]),
              clients: Em.A([
                Em.Object.create({
                  component_name: 'ANYSERVICE_CLIENT',
                  isInstalled: false,
                  hosts: Em.A([
                    Em.Object.create({hostName: 'h1', isInstalled: false}),
                    Em.Object.create({hostName: 'h2', isInstalled: false})
                  ])
                })
              ])
            }
          });
          installerStep8Controller.set('ajaxRequestsQueue', App.ajaxQueue.create());
          installerStep8Controller.get('ajaxRequestsQueue').clear();
          installerStep8Controller.createAdditionalHostComponents();
        });

        // Any component with isRequiredOnAllHosts = true implies that
        // registerHostsToComponent would be done via
        // createAdditionalHostComponents() BUT NOT
        // createMasterHostComponents() or createSlaveAndClientsHostComponents()
        // or createAdditionalClientComponents()
        it('registerHostsToComponent 1st call', function () {
          expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(['h1', 'h2']);
          expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal('ANYSERVICE_SLAVE');
        });
        it('registerHostsToComponent 2nd call', function () {
          expect(installerStep8Controller.registerHostsToComponent.args[1][0]).to.eql(['h1', 'h2']);
          expect(installerStep8Controller.registerHostsToComponent.args[1][1]).to.equal('ANYSERVICE_SLAVE2');
        });
        it('registerHostsToComponent 3rd call', function () {
          expect(installerStep8Controller.registerHostsToComponent.args[2][0]).to.eql(['h1', 'h2']);
          expect(installerStep8Controller.registerHostsToComponent.args[2][1]).to.equal('ANYSERVICE_CLIENT');
        });
      });

      describe('should add components with isRequiredOnAllHosts == true (2)', function() {

        beforeEach(function () {
          installerStep8Controller.reopen({
            getRegisteredHosts: function() {
              return [{hostName: 'h1'}, {hostName: 'h2'}];
            },
            content: {
              services: Em.A([
                Em.Object.create({
                  serviceName: 'ANYSERVICE', isSelected: true, isInstalled: false, serviceComponents: [
                    // set isRequiredOnAllHosts = true for master
                    Em.Object.create({
                      componentName: 'ANYSERVICE_MASTER',
                      isMaster: true,
                      isRequiredOnAllHosts: true
                    }),
                    Em.Object.create({
                      componentName: 'ANYSERVICE_SLAVE',
                      isSlave: true,
                      isRequiredOnAllHosts: false
                    }),
                    Em.Object.create({
                      componentName: 'ANYSERVICE_SLAVE2',
                      isSlave: true,
                      isRequiredOnAllHosts: false
                    }),
                    Em.Object.create({
                      componentName: 'ANYSERVICE_CLIENT',
                      isClient: true,
                      isRequiredOnAllHosts: false
                    })
                  ]
                })
              ]),
              masterComponentHosts: Em.A([
                Em.Object.create({
                  componentName: 'ANYSERVICE_MASTER',
                  component: 'ANYSERVICE_MASTER',
                  hosts: Em.A([
                    Em.Object.create({hostName: 'h1', isInstalled: true})
                  ])
                })
              ]),
              slaveComponentHosts: Em.A([
                Em.Object.create({
                  componentName: 'ANYSERVICE_SLAVE',
                  hosts: Em.A([
                    Em.Object.create({hostName: 'h1', isInstalled: false}),
                    Em.Object.create({hostName: 'h2', isInstalled: false})
                  ])
                }),
                Em.Object.create({
                  componentName: 'ANYSERVICE_SLAVE2',
                  hosts: Em.A([
                    Em.Object.create({hostName: 'h1', isInstalled: false}),
                    Em.Object.create({hostName: 'h2', isInstalled: false})
                  ])
                }),
                Em.Object.create({
                  componentName: 'CLIENT',
                  hosts: Em.A([
                    Em.Object.create({hostName: 'h1', isInstalled: false}),
                    Em.Object.create({hostName: 'h2', isInstalled: false})
                  ])
                })
              ]),
              clients: Em.A([
                Em.Object.create({
                  component_name: 'ANYSERVICE_CLIENT',
                  isInstalled: false,
                  hosts: Em.A([
                    Em.Object.create({hostName: 'h1', isInstalled: false}),
                    Em.Object.create({hostName: 'h2', isInstalled: false})
                  ])
                })
              ])
            }
          });
          installerStep8Controller.set('ajaxRequestsQueue', App.ajaxQueue.create());
          installerStep8Controller.get('ajaxRequestsQueue').clear();
          installerStep8Controller.createMasterHostComponents();
          installerStep8Controller.createAdditionalHostComponents();
        });

        // master component with isRequiredOnAllHosts = true implies that
        // registerHostsToComponent would be done via
        // createAdditionalHostComponents() BUT NOT
        // createMasterHostComponents()
        it('registerHostsToComponent 1st call', function () {
          expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(['h1', 'h2']);
          expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal('ANYSERVICE_MASTER');
          expect(installerStep8Controller.registerHostsToComponent.callCount).to.equal(1);
        });
      });

      describe('should not add components with isRequiredOnAllHosts == false (3)', function() {

        beforeEach(function () {
          installerStep8Controller.reopen({
            getRegisteredHosts: function() {
              return [{hostName: 'h1'}, {hostName: 'h2'}];
            },
            content: {
              services: Em.A([
                Em.Object.create({
                  serviceName: 'ANYSERVICE', isSelected: true, isInstalled: false, serviceComponents: [
                    // set isRequiredOnAllHosts = false for all components
                    Em.Object.create({
                      componentName: 'ANYSERVICE_MASTER',
                      isMaster: true,
                      isRequiredOnAllHosts: false
                    }),
                    Em.Object.create({
                      componentName: 'ANYSERVICE_SLAVE',
                      isSlave: true,
                      isRequiredOnAllHosts: false
                    }),
                    Em.Object.create({
                      componentName: 'ANYSERVICE_SLAVE2',
                      isSlave: true,
                      isRequiredOnAllHosts: false
                    }),
                    Em.Object.create({
                      componentName: 'ANYSERVICE_CLIENT',
                      isClient: true,
                      isRequiredOnAllHosts: false
                    })
                  ]
                })
              ]),
              masterComponentHosts: Em.A([
                Em.Object.create({
                  componentName: 'ANYSERVICE_MASTER',
                  component: 'ANYSERVICE_MASTER',
                  hosts: Em.A([
                    Em.Object.create({hostName: 'h1', isInstalled: true})
                  ])
                })
              ]),
              slaveComponentHosts: Em.A([
                Em.Object.create({
                  componentName: 'ANYSERVICE_SLAVE',
                  hosts: Em.A([
                    Em.Object.create({hostName: 'h1', isInstalled: false}),
                    Em.Object.create({hostName: 'h2', isInstalled: false})
                  ])
                }),
                Em.Object.create({
                  componentName: 'ANYSERVICE_SLAVE2',
                  hosts: Em.A([
                    Em.Object.create({hostName: 'h1', isInstalled: false}),
                    Em.Object.create({hostName: 'h2', isInstalled: false})
                  ])
                }),
                Em.Object.create({
                  componentName: 'CLIENT',
                  hosts: Em.A([
                    Em.Object.create({hostName: 'h1', isInstalled: false}),
                    Em.Object.create({hostName: 'h2', isInstalled: false})
                  ])
                })
              ]),
              clients: Em.A([
                Em.Object.create({
                  component_name: 'ANYSERVICE_CLIENT',
                  isInstalled: false,
                  hosts: Em.A([
                    Em.Object.create({hostName: 'h1', isInstalled: false}),
                    Em.Object.create({hostName: 'h2', isInstalled: false})
                  ])
                })
              ])
            }
          });
          installerStep8Controller.set('ajaxRequestsQueue', App.ajaxQueue.create());
          installerStep8Controller.get('ajaxRequestsQueue').clear();
          installerStep8Controller.createAdditionalHostComponents();
        });

        it('registerHostsToComponent is not called', function () {
          // isRequiredOnAllHosts = false for all components, implies that
          // registerHostsToComponent would be done via
          // createMasterHostComponents() or createSlaveAndClientsHostComponents()
          // or createAdditionalClientComponents()
          // BUT NOT createAdditionalHostComponents()
          expect(installerStep8Controller.registerHostsToComponent.callCount).to.equal(0);
        });

      });

  });

    describe('#createNotification', function () {

      beforeEach(function () {
        installerStep8Controller.clearStep();
        installerStep8Controller.set('content', {controllerName: 'installerController'});
        installerStep8Controller.set('configs', [
          {name: 'create_notification', value: 'yes', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'ambari.dispatch.recipients', value: 'to@f.c', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'mail.smtp.host', value: 'h', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'mail.smtp.port', value: '25', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'mail.smtp.from', value: 'from@f.c', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'mail.smtp.starttls.enable', value: true, serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'mail.smtp.startssl.enable', value: false, serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'smtp_use_auth', value: 'true', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'ambari.dispatch.credential.username', value: 'usr', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'ambari.dispatch.credential.password', value: 'pwd', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'some_p', value: 'some_v', serviceName: 'MISC', filename: 'alert_notification'}
        ]);
        installerStep8Controller.get('ajaxRequestsQueue').clear();
      });

      it('should add request to queue', function () {
        installerStep8Controller.createNotification();
        expect(installerStep8Controller.get('ajaxRequestsQueue.queue.length')).to.equal(1);
        installerStep8Controller.get('ajaxRequestsQueue').runNextRequest();
        var args = testHelpers.findAjaxRequest('name', 'alerts.create_alert_notification');
        expect(args).exists;
      });

      describe('sent data should be valid', function () {
        var data;
        beforeEach(function () {
          installerStep8Controller.createNotification();
          data = installerStep8Controller.get('ajaxRequestsQueue.queue')[0].data.data.AlertTarget;
        });

        it('global is true', function () {
          expect(data.global).to.be.true;
        });
        it('notification_type is EMAIL', function () {
          expect(data.notification_type).to.equal('EMAIL');
        });
        it('alert_states are valid', function () {
          expect(data.alert_states).to.eql(['OK', 'WARNING', 'CRITICAL', 'UNKNOWN']);
        });
        it('ambari.dispatch.recipients is valid', function () {
          expect(data.properties['ambari.dispatch.recipients']).to.eql(['to@f.c']);
        });
        it('mail.smtp.host is valid', function () {
          expect(data.properties['mail.smtp.host']).to.equal('h');
        });
        it('mail.smtp.port is valid', function () {
          expect(data.properties['mail.smtp.port']).to.equal('25');
        });
        it('mail.smtp.from is valid', function () {
          expect(data.properties['mail.smtp.from']).to.equal('from@f.c');
        });
        it('mail.smtp.starttls.enable is true', function () {
          expect(data.properties['mail.smtp.starttls.enable']).to.equal(true);
        });
        it('mail.smtp.startssl.enable is false', function () {
          expect(data.properties['mail.smtp.startssl.enable']).to.equal(false);
        });
        it('ambari.dispatch.credential.username is valid', function () {
          expect(data.properties['ambari.dispatch.credential.username']).to.equal('usr');
        });
        it('ambari.dispatch.credential.password is valid', function () {
          expect(data.properties['ambari.dispatch.credential.password']).to.equal('pwd');
        });
        it('custom property is valid', function () {
          expect(data.properties.some_p).to.equal('some_v');
        });

      });

    });

  });

  App.TestAliases.testAsComputedEqualProperties(getController(), 'isAllClusterDeleteRequestsCompleted', 'clusterDeleteRequestsCompleted', 'clusterNames.length');

  describe('#deleteClusterSuccessCallback', function () {

    beforeEach(function () {
      sinon.stub(installerStep8Controller, 'showDeleteClustersErrorPopup', Em.K);
      sinon.stub(installerStep8Controller, 'getExistingVersions', Em.K);
      installerStep8Controller.setProperties({
        clusterDeleteRequestsCompleted: 0,
        clusterNames: ['c0', 'c1'],
        clusterDeleteErrorViews: []
      });
      installerStep8Controller.deleteClusterSuccessCallback();
    });

    afterEach(function () {
      installerStep8Controller.showDeleteClustersErrorPopup.restore();
      installerStep8Controller.getExistingVersions.restore();
    });

    describe('no failed requests', function () {
      it('before Delete Cluster request', function () {
        expect(installerStep8Controller.get('clusterDeleteRequestsCompleted')).to.equal(1);
        expect(installerStep8Controller.showDeleteClustersErrorPopup.called).to.be.false;
        expect(installerStep8Controller.getExistingVersions.called).to.be.false;
      });
      it('after Delete Cluster request', function () {
        installerStep8Controller.deleteClusterSuccessCallback();
        expect(installerStep8Controller.get('clusterDeleteRequestsCompleted')).to.equal(2);
        expect(installerStep8Controller.showDeleteClustersErrorPopup.called).to.be.false;
        expect(installerStep8Controller.getExistingVersions.calledOnce).to.be.true;
      });
    });

    it('one request failed', function () {
      installerStep8Controller.deleteClusterErrorCallback({}, null, null, {});
      expect(installerStep8Controller.get('clusterDeleteRequestsCompleted')).to.equal(2);
      expect(installerStep8Controller.showDeleteClustersErrorPopup.calledOnce).to.be.true;
      expect(installerStep8Controller.getExistingVersions.called).to.be.false;
    });

  });

  describe('#deleteClusterErrorCallback', function () {

    var request = {
        status: 500,
        responseText: '{"message":"Internal Server Error"}'
      },
      ajaxOptions = 'error',
      error = 'Internal Server Error',
      opt = {
        url: 'api/v1/clusters/c0',
        type: 'DELETE'
      };

    beforeEach(function () {
      installerStep8Controller.setProperties({
        clusterDeleteRequestsCompleted: 0,
        clusterNames: ['c0', 'c1'],
        clusterDeleteErrorViews: []
      });
      sinon.stub(installerStep8Controller, 'showDeleteClustersErrorPopup', Em.K);
      installerStep8Controller.deleteClusterErrorCallback(request, ajaxOptions, error, opt);
    });

    afterEach(function () {
      installerStep8Controller.showDeleteClustersErrorPopup.restore();
    });

    describe('should show error popup only if all requests are completed', function () {
      it('Before Delete Cluster request fail', function () {
        expect(installerStep8Controller.get('clusterDeleteRequestsCompleted')).to.equal(1);
        expect(installerStep8Controller.showDeleteClustersErrorPopup.called).to.be.false;
      });
      it('After Delete Cluster request is failed', function () {
        installerStep8Controller.deleteClusterErrorCallback(request, ajaxOptions, error, opt);
        expect(installerStep8Controller.get('clusterDeleteRequestsCompleted')).to.equal(2);
        expect(installerStep8Controller.showDeleteClustersErrorPopup.calledOnce).to.be.true;
      });
    });

    describe('should create error popup body view', function () {
      it('One failed request', function () {
        expect(installerStep8Controller.get('clusterDeleteErrorViews')).to.have.length(1);
      });
      it('failed request url is valid', function () {
        expect(installerStep8Controller.get('clusterDeleteErrorViews.firstObject.url')).to.equal('api/v1/clusters/c0');
      });
      it('failed request type is valid', function () {
        expect(installerStep8Controller.get('clusterDeleteErrorViews.firstObject.type')).to.equal('DELETE');
      });
      it('failed request status is valid', function () {
        expect(installerStep8Controller.get('clusterDeleteErrorViews.firstObject.status')).to.equal(500);
      });
      it('failed request message is valid', function () {
        expect(installerStep8Controller.get('clusterDeleteErrorViews.firstObject.message')).to.equal('Internal Server Error');
      });
    });

  });

  describe('#showDeleteClustersErrorPopup', function () {

    beforeEach(function () {
      installerStep8Controller.setProperties({
        isSubmitDisabled: true,
        isBackBtnDisabled: true
      });
      sinon.stub(App.ModalPopup, 'show', Em.K);
      installerStep8Controller.showDeleteClustersErrorPopup();
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('should show error popup and unlock navigation', function () {
      expect(installerStep8Controller.get('isSubmitDisabled')).to.be.false;
      expect(installerStep8Controller.get('isBackBtnDisabled')).to.be.false;
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });

  });

  describe('#_startDeploy', function () {

    var stubbedNames = ['createCluster', 'createSelectedServices', 'createConfigurations',
        'applyConfigurationsToCluster', 'createComponents', 'registerHostsToCluster', 'createConfigurationGroups',
        'createMasterHostComponents', 'createSlaveAndClientsHostComponents', 'createAdditionalClientComponents',
        'createAdditionalHostComponents'],
      cases = [
        {
          controllerName: 'installerController',
          notExecuted: ['createAdditionalClientComponents'],
          fileNamesToUpdate: [],
          title: 'Installer, no configs to update'
        },
        {
          controllerName: 'addHostController',
          notExecuted: ['createConfigurations', 'applyConfigurationsToCluster', 'createAdditionalClientComponents'],
          title: 'Add Host Wizard'
        },
        {
          controllerName: 'addServiceController',
          notExecuted: ['updateConfigurations'],
          fileNamesToUpdate: [],
          title: 'Add Service Wizard, no configs to update'
        },
        {
          controllerName: 'addServiceController',
          notExecuted: [],
          fileNamesToUpdate: [''],
          title: 'Add Service Wizard, some configs to be updated'
        }
      ];

    beforeEach(function () {
      sinon.stub(App, 'get').withArgs('isKerberosEnabled').returns(false);
      sinon.stub(App.Stack, 'find').returns([
        Em.Object.create({
          id: "HDP-2.3-2.3.4.4-1234",
          isSelected: true,
          repositoryVersion: "2.3.4.4-1234"
        })
      ]);
      stubbedNames.forEach(function (name) {
        sinon.stub(installerStep8Controller, name, Em.K);
      });
      installerStep8Controller.setProperties({
        serviceConfigTags: [],
        content: {
          controllerName: null
        }
      });
    });

    afterEach(function () {
      App.get.restore();
      App.Stack.find.restore();
      stubbedNames.forEach(function (name) {
        installerStep8Controller[name].restore();
      });
      installerStep8Controller.get.restore();
    });

    cases.forEach(function (item) {
      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(installerStep8Controller, 'get')
            .withArgs('ajaxRequestsQueue').returns({
              start: Em.K
            })
            .withArgs('ajaxRequestsQueue.queue.length').returns(1)
            .withArgs('wizardController').returns({
              getDBProperty: function () {
                return item.fileNamesToUpdate;
              }
            })
            .withArgs('content.controllerName').returns(item.controllerName);
          installerStep8Controller._startDeploy();
        });

        stubbedNames.forEach(function (name) {
          it(name, function () {
            expect(installerStep8Controller[name].called).to.equal(!item.notExecuted.contains(name));
          });
        });

      });
    });

  });

  describe('#getClientsMap', function () {

    var cases = [
      {
        flag: 'isMaster',
        result: {
          c8: ['c1', 'c2'],
          c9: ['c1', 'c2']
        },
        title: 'dependencies for masters'
      },
      {
        flag: 'isSlave',
        result: {
          c8: ['c5', 'c6'],
          c9: ['c5', 'c6']
        },
        title: 'dependencies for slaves'
      },
      {
        flag: 'isClient',
        result: {
          c8: ['c9', 'c10'],
          c9: ['c9', 'c10']
        },
        title: 'dependencies for clients'
      },
      {
        flag: null,
        result: {
          c8: ['c1', 'c2', 'c5', 'c6', 'c9', 'c10'],
          c9: ['c1', 'c2', 'c5', 'c6', 'c9', 'c10']
        },
        title: 'dependencies for all components'
      }
    ];

    before(function () {
      sinon.stub(App.StackServiceComponent, 'find').returns([
        Em.Object.create({
          componentName: 'c0',
          isMaster: true,
          dependencies: [
            {
              componentName: 'c1'
            },
            {
              componentName: 'c2'
            },
            {
              componentName: 'c4'
            },
            {
              componentName: 'c5'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c1',
          isMaster: true,
          dependencies: [
            {
              componentName: 'c4'
            },
            {
              componentName: 'c5'
            },
            {
              componentName: 'c8'
            },
            {
              componentName: 'c9'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c2',
          isMaster: true,
          dependencies: [
            {
              componentName: 'c1'
            },
            {
              componentName: 'c2'
            },
            {
              componentName: 'c8'
            },
            {
              componentName: 'c9'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c3',
          isMaster: true,
          dependencies: []
        }),
        Em.Object.create({
          componentName: 'c4',
          isSlave: true,
          dependencies: [
            {
              componentName: 'c1'
            },
            {
              componentName: 'c2'
            },
            {
              componentName: 'c4'
            },
            {
              componentName: 'c5'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c5',
          isSlave: true,
          dependencies: [
            {
              componentName: 'c4'
            },
            {
              componentName: 'c5'
            },
            {
              componentName: 'c8'
            },
            {
              componentName: 'c9'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c6',
          isSlave: true,
          dependencies: [
            {
              componentName: 'c1'
            },
            {
              componentName: 'c2'
            },
            {
              componentName: 'c8'
            },
            {
              componentName: 'c9'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c7',
          isSlave: true,
          dependencies: []
        }),
        Em.Object.create({
          componentName: 'c8',
          isClient: true,
          dependencies: [
            {
              componentName: 'c1'
            },
            {
              componentName: 'c2'
            },
            {
              componentName: 'c4'
            },
            {
              componentName: 'c5'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c9',
          isClient: true,
          dependencies: [
            {
              componentName: 'c4'
            },
            {
              componentName: 'c5'
            },
            {
              componentName: 'c8'
            },
            {
              componentName: 'c9'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c10',
          isClient: true,
          dependencies: [
            {
              componentName: 'c1'
            },
            {
              componentName: 'c2'
            },
            {
              componentName: 'c8'
            },
            {
              componentName: 'c9'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c11',
          isClient: true,
          dependencies: []
        })
      ]);
    });

    after(function () {
      App.StackServiceComponent.find.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(installerStep8Controller.getClientsMap(item.flag)).to.eql(item.result);
      });
    });

  });

  describe('#showLoadingIndicator', function() {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('if popup doesn\'t exist should create another', function() {
      installerStep8Controller.set('isSubmitDisabled', true);
      installerStep8Controller.showLoadingIndicator();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });

  });

  describe('#updateKerberosDescriptor', function () {

    var requestData = {artifactName: 'kerberos_descriptor',
      data: {
        artifact_data: 1234
      }
    };

    beforeEach(function () {
      sinon.stub(App.db, 'get').withArgs('KerberosWizard', 'kerberosDescriptorConfigs').returns(1234);
      sinon.stub(installerStep8Controller, 'addRequestToAjaxQueue', Em.K);
      sinon.stub(installerStep8Controller, 'get').withArgs('wizardController').returns(Em.Object.create({
        getDBProperty: function() { return true; }
      }));
    });

    afterEach(function () {
      App.db.get.restore();
      installerStep8Controller.addRequestToAjaxQueue.restore();
      installerStep8Controller.get.restore();
    });

    it('should send request instantly', function () {
      installerStep8Controller.updateKerberosDescriptor(true);
      var args = testHelpers.findAjaxRequest('name', 'admin.kerberos.cluster.artifact.update');
      expect(args[0]).exists;
      expect(args[0].data).to.be.eql(requestData);
      expect(installerStep8Controller.addRequestToAjaxQueue.called).to.be.false;
    });

    it('should add request to the queue', function () {
      installerStep8Controller.updateKerberosDescriptor(false);
      var args = testHelpers.findAjaxRequest('name', 'admin.kerberos.cluster.artifact.update');
      expect(args).not.exists;
      expect(installerStep8Controller.addRequestToAjaxQueue.calledOnce).to.be.true;
      expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data).to.be.eql(requestData);
    });

  });

});

});

require.register("test/controllers/wizard/step9_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/stack_service_component');
require('models/hosts');
require('controllers/wizard');
require('controllers/installer');
require('controllers/wizard/step9_controller');
require('utils/helper');
require('utils/ajax/ajax');
var testHelpers = require('test/helpers');

var modelSetup = require('test/init_model_test');
var c, obj;

function getController() {
  return App.WizardStep9Controller.create({
    content: {controllerName: '', cluster: {status: ''}},
    saveClusterStatus: Em.K,
    saveInstalledHosts: Em.K,
    togglePreviousSteps: Em.K,
    setFinishState: Em.K,
    changeParseHostInfo: Em.K,
    parseHostInfoPolling: Em.K,
    wizardController: Em.Object.create({
      requestsId: [],
      cluster: {oldRequestsId: []},
      getDBProperty: function(name) {
        return this.get(name);
      }
    })
  });
}

describe('App.InstallerStep9Controller', function () {

  beforeEach(function () {
    App.set('supports.skipComponentStartAfterInstall', false);
    modelSetup.setupStackServiceComponent();
    c = getController();
    obj = App.InstallerController.create();
    App.ajax.send.restore();
    sinon.stub(App.ajax, 'send', function() {
      return {
        then: function() { 
          return true;
        },
        retry: function() {
          return {
            then: Em.K,
            complete: Em.K
          };
        },
        complete: Em.K
      };
    });
  });

  afterEach(function () {
    modelSetup.cleanStackServiceComponent();
  });

  App.TestAliases.testAsComputedEqual(getController(), 'showRetry', 'content.cluster.status', 'INSTALL FAILED');

  describe('#isSubmitDisabled', function () {
    var tests = Em.A([
      {controllerName: 'addHostController', state: 'STARTED', e: false},
      {controllerName: 'addHostController', state: 'START_SKIPPED', e: false},
      {controllerName: 'addHostController', state: 'START FAILED', e: false},
      {controllerName: 'addHostController', state: 'INSTALL FAILED', e: false},
      {controllerName: 'addHostController', state: 'PENDING', e: true},
      {controllerName: 'addHostController', state: 'INSTALLED', e: true},
      {controllerName: 'addServiceController', state: 'STARTED', e: false},
      {controllerName: 'addServiceController', state: 'START_SKIPPED', e: false},
      {controllerName: 'addServiceController', state: 'START FAILED', e: false},
      {controllerName: 'addServiceController', state: 'INSTALL FAILED', e: false},
      {controllerName: 'addServiceController', state: 'PENDING', e: true},
      {controllerName: 'addServiceController', state: 'INSTALLED', e: true},
      {controllerName: 'installerController', state: 'STARTED', e: false},
      {controllerName: 'installerController', state: 'START_SKIPPED', e: false},
      {controllerName: 'installerController', state: 'START FAILED', e: false},
      {controllerName: 'installerController', state: 'INSTALL FAILED', e: true},
      {controllerName: 'installerController', state: 'INSTALLED', e: true},
      {controllerName: 'installerController', state: 'PENDING', e: true}
    ]);
    tests.forEach(function (test) {
      var controller = App.WizardStep9Controller.create({
        saveClusterStatus: Em.K,
        saveInstalledHosts: Em.K,
        content: {
          controllerName: test.controllerName,
          cluster: {
            status: test.state
          }
        }
      });
      it('controllerName is ' + test.controllerName + '; cluster status is ' + test.state + '; isSubmitDisabled should be ' + test.e, function () {
        expect(controller.get('isSubmitDisabled')).to.equal(test.e);
      });
    });

  });

  describe('#status', function () {
    var tests = Em.A([
      {
        hosts: [
          {status: 'failed'},
          {status: 'success'}
        ],
        isStepFailed: false,
        progress: '100',
        m: 'One host is failed',
        e: 'failed'
      },
      {
        hosts: [
          {status: 'warning'},
          {status: 'success'}
        ],
        m: 'One host is failed and step is not failed',
        isStepFailed: false,
        progress: '100',
        e: 'warning'
      },
      {
        hosts: [
          {status: 'warning'},
          {status: 'success'}
        ],
        m: 'One host is failed and step is failed',
        isStepFailed: true,
        progress: '100',
        e: 'failed'
      },
      {
        hosts: [
          {status: 'success'},
          {status: 'success'}
        ],
        m: 'All hosts are success and progress is 100',
        isStepFailed: false,
        progress: '100',
        e: 'success'
      },
      {
        hosts: [
          {status: 'success'},
          {status: 'success'}
        ],
        m: 'All hosts are success and progress is 50',
        isStepFailed: false,
        progress: '50',
        e: 'info'
      }
    ]);
    tests.forEach(function (test) {
      var controller = App.WizardStep9Controller.create({
        saveClusterStatus: Em.K,
        saveInstalledHosts: Em.K,
        hosts: test.hosts,
        isStepFailed: function () {
          return test.isStepFailed
        },
        progress: test.progress
      });
      controller.updateStatus();
      it(test.m, function () {
        expect(controller.get('status')).to.equal(test.e);
      });
    });
  });

  describe('#resetHostsForRetry', function () {
    var hosts = {'host1': Em.Object.create({status: 'failed', message: 'Failed'}), 'host2': Em.Object.create({status: 'success', message: 'Success'})};

    beforeEach(function () {
      c.reopen({content: {hosts: hosts}});
      c.resetHostsForRetry();
    });

    Object.keys(hosts).forEach(function (name) {
      if (hosts.hasOwnProperty(name)) {
        it(name + '.status', function () {
          expect(c.get('content.hosts')[name].get('status', 'pending')).to.equal('pending');
        });
        it(name + '.message', function () {
          expect(c.get('content.hosts')[name].get('message', 'Waiting')).to.equal('Waiting');
        });
      }
    });

  });

  describe('#setParseHostInfo', function () {
    var tasks = Em.A([
      Em.Object.create({
        Tasks: Em.Object.create({
          host_name: 'host1',
          status: 'PENDING'
        })
      }),
      Em.Object.create({
        Tasks: Em.Object.create({
          host_name: 'host1',
          status: 'PENDING'
        })
      })
    ]);
    var content = Em.Object.create({
      cluster: Em.Object.create({
        requestId: '11',
        status: 'PENDING'
      })
    });
    beforeEach(function(){
      c.set('content', content)
    });
    it('Should make parseHostInfo false"', function () {
      var polledData = Em.Object.create({
        tasks: tasks,
        Requests: Em.Object.create({
          id: '222'
        })
      });
      c.setParseHostInfo(polledData);
      expect(c.get('parseHostInfo')).to.be.false;
    });
    it('Should set polledData"', function () {
      var polledData = Em.Object.create({
        tasks: tasks,
        Requests: Em.Object.create({
          id: '11'
        })
      });
      c.setParseHostInfo(polledData);
      var expected = [
        {
          "Tasks": {
            "status": "PENDING",
            "host_name": "host1",
            "request_id": "11"
          }
        },
        {
          "Tasks": {
            "status": "PENDING",
            "host_name": "host1",
            "request_id": "11"
          }
        }
      ];
      var result = JSON.parse(JSON.stringify(c.get('polledData')));
      expect(result).to.eql(expected);
    });
    it('Should set progress for hosts"', function () {
      var polledData = Em.Object.create({
        tasks: tasks,
        Requests: Em.Object.create({
          id: '11'
        })
      });
      var hosts = Em.A([
        Em.Object.create({
          name: 'host1',
          logTasks: [
            {Tasks: {role: 'HDFS_CLIENT'}},
            {Tasks: {role: 'DATANODE'}}
          ],
          status: 'old_status',
          progress: '10',
          isNoTasksForInstall: true,
          e: {status: 'old_status', progress: '10'}
        }),
        Em.Object.create({
          name: 'host2',
          logTasks: [
            {Tasks: {role: 'HDFS_CLIENT'}}
          ],
          status: 'old_status',
          progress: '10',
          e: {status: 'success', progress: '100'}
        })
      ]);
      c.set('hosts', hosts);
      c.setParseHostInfo(polledData);
      var expected = [
        {
          "name": "host1",
          "logTasks": [
            {
              "Tasks": {
                "role": "HDFS_CLIENT",
                "status": "PENDING"
              }
            },
            {
              "Tasks": {
                "role": "DATANODE"
              }
            }
          ],
          "progress": "0",
          "isNoTasksForInstall": false,
          "e": {
            "status": "old_status",
            "progress": "10"
          },
          "status": "in_progress",
          "message": ""
        },
        {
          "name": "host2",
          "logTasks": [
            {
              "Tasks": {
                "role": "HDFS_CLIENT"
              }
            }
          ],
          "progress": "33",
          "e": {
            "status": "success",
            "progress": "100"
          },
          "status": "pending",
          "isNoTasksForInstall": true,
          "message": "Install complete (Waiting to start)"
        }
      ];

      var result = JSON.parse(JSON.stringify(c.get('hosts')));
      expect(result).to.eql(expected);
    });
  });

  var hostsForLoadAndRender = {
    'host1': {
      message: 'message1',
      status: 'unknown',
      progress: '1',
      logTasks: [
        {},
        {}
      ],
      bootStatus: 'REGISTERED'
    },
    'host2': {
      message: '',
      status: 'failed',
      progress: '1',
      logTasks: [
        {},
        {}
      ],
      bootStatus: ''
    },
    'host3': {
      message: '',
      status: 'waiting',
      progress: null,
      logTasks: [
        {},
        {}
      ],
      bootStatus: ''
    },
    'host4': {
      message: 'message4',
      status: null,
      progress: '10',
      logTasks: [
        {}
      ],
      bootStatus: 'REGISTERED'
    }
  };

  describe('#loadHosts', function () {

    beforeEach(function() {
      c.reopen({content: {hosts: hostsForLoadAndRender}});
      c.loadHosts();
    });

    it('Only REGISTERED hosts', function () {
      var loadedHosts = c.get('hosts');
      expect(loadedHosts.length).to.equal(2);
    });

    it('All hosts have progress 0', function () {
      var loadedHosts = c.get('hosts');
      expect(loadedHosts.everyProperty('progress', 0)).to.equal(true);
    });

    it('All host don\'t have logTasks', function () {
      var loadedHosts = c.get('hosts');
      expect(loadedHosts.everyProperty('logTasks.length', 0)).to.equal(true);
    });
  });

  describe('#isServicesStarted', function () {
    it('Should return false when server not started', function () {
      var polledData = Em.A([
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'PENDING'
          })
        }),
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'PENDING'
          })
        })
      ]);
      expect(c.isServicesStarted(polledData)).to.be.false;
    });
    it('Should return true when server started', function () {
      var polledData = Em.A([
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'NONE'
          })
        }),
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'NONE'
          })
        })
      ]);
      expect(c.isServicesStarted(polledData)).to.be.true;
    });
    it('Should return true when tasks completed', function () {
      var polledData = Em.A([
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'COMPLETED'
          })
        }),
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'COMPLETED'
          })
        })
      ]);
      expect(c.isServicesStarted(polledData)).to.be.true;
    });
  });

  describe('#setIsServicesInstalled', function () {

    Em.A([
      {
        m: 'Should return 100% completed',
        c: {
          status: 'failed',
          isPolling: true,
          hosts: Em.A([
            Em.Object.create({
              progress: 0
            })
          ])
        },
        polledData: Em.A([
          Em.Object.create({
            Tasks: Em.Object.create({
              status: 'NONE'
            })
          }),
          Em.Object.create({
            Tasks: Em.Object.create({
              status: 'NONE'
            })
          })
        ]),
        e: {
          progress: '100',
          isPolling: false
        }
      },
      {
        m: 'Should return 34% completed',
        c: {
          status: '',
          isPolling: true,
          hosts: Em.A([
            Em.Object.create({
              progress: 0
            })
          ]),
          content: Em.Object.create({
            controllerName: 'installerController'
          })
        },
        polledData: Em.A([
          Em.Object.create({
            Tasks: Em.Object.create({
              status: 'NONE'
            })
          }),
          Em.Object.create({
            Tasks: Em.Object.create({
              status: 'NONE'
            })
          })
        ]),
        e: {
          progress: '34',
          isPolling: true
        }
      }
    ]).forEach(function (test) {
      it(test.m, function () {
        c.setProperties(test.c);
        c.setIsServicesInstalled(test.polledData);
        expect(c.get('progress')).to.equal(test.e.progress);
        expect(c.get('isPolling')).to.be.equal(test.e.isPolling);
      });
    });

    describe('`skipComponentStartAfterInstall` is true', function () {

      var polledData = Em.A([
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'NONE'
          })
        }),
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'NONE'
          })
        })
      ]);

      var hosts = [
        Em.Object.create({status: '', message: '', progress: 0}),
        Em.Object.create({status: '', message: '', progress: 0}),
        Em.Object.create({status: '', message: '', progress: 0}),
        Em.Object.create({status: '', message: '', progress: 0})
      ];

      beforeEach(function () {
        sinon.stub(App, 'get').withArgs('supports.skipComponentStartAfterInstall').returns(true);
        sinon.stub(c, 'saveClusterStatus', Em.K);
        sinon.stub(c, 'saveInstalledHosts', Em.K);
        sinon.stub(c, 'changeParseHostInfo', Em.K);
        c.set('hosts', hosts);
        c.setIsServicesInstalled(polledData);
      });

      afterEach(function () {
        App.get.restore();
        c.saveClusterStatus.restore();
        c.saveInstalledHosts.restore();
        c.changeParseHostInfo.restore();
      });

      it('cluster status is valid', function () {
        var clusterStatus = c.saveClusterStatus.args[0][0];
        expect(clusterStatus.status).to.be.equal('START_SKIPPED');
        expect(clusterStatus.isCompleted).to.be.true;
      });

      it('each host status is `success`', function () {
        expect(c.get('hosts').everyProperty('status', 'success')).to.be.true;
      });

      it('each host progress is `100`', function () {
        expect(c.get('hosts').everyProperty('progress', '100')).to.be.true;
      });

      it('each host message is valid', function () {
        expect(c.get('hosts').everyProperty('message', Em.I18n.t('installer.step9.host.status.success'))).to.be.true;
      });

    });

  });

  describe('#launchStartServices', function () {
    beforeEach(function() {
      sinon.stub(App, 'get', function(k) {
        if (k === 'components.slaves') {
          return ["TASKTRACKER", "DATANODE", 
                  "JOURNALNODE", "ZKFC", 
                  "APP_TIMELINE_SERVER", 
                  "NODEMANAGER", 
                  "GANGLIA_MONITOR", 
                  "HBASE_REGIONSERVER", 
                  "SUPERVISOR", 
                  "FLUME_HANDLER"];
        }
        return true;
      });
    });
    afterEach(function() {
      App.get.restore();
    });
    var tests = [
      {
        expected: [],
        message: 'should return query',
        controllerName: 'addHostController',
        hosts: Em.A([
          Em.Object.create({
            name: 'h1'
          }),
          Em.Object.create({
            name: 'h2'
          })
        ])
      },
      {
        expected: [],
        message: 'should return server info',
        controllerName: 'addServiceController',
        services: Em.A([
          Em.Object.create({
            serviceName: 'OOZIE',
            isSelected: true,
            isInstalled: false
          }),
          Em.Object.create({
            serviceName: 'h2',
            isSelected: false,
            isInstalled: true
          })
        ])
      },
      {
        expected: [],
        message: 'should return default data',
        controllerName: 'addHostContro',
        hosts: Em.A([
          Em.Object.create({
            name: 'h1'
          }),
          Em.Object.create({
            name: 'h2'
          })
        ])
      }
    ];
    tests.forEach(function(test) {
      it(test.message, function () {
        var content = Em.Object.create({
          controllerName: test.controllerName,
          services: test.services
        });
        var wizardController = Em.Object.create({
          getDBProperty: function() {
            return test.hosts
          }
        });
        c.set('content', content);
        c.set('wizardController', wizardController);
        expect(c.launchStartServices(function(){})).to.be.true;
      });
    })
  });

  describe('#hostHasClientsOnly', function () {
    var tests = Em.A([
      {
        hosts: [
          Em.Object.create({
            hostName: 'host1',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}},
              {Tasks: {role: 'DATANODE'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'old_status', progress: '10'}
          }),
          Em.Object.create({
            hostName: 'host2',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'success', progress: '100'}
          })
        ],
        jsonError: false
      },
      {
        hosts: [
          Em.Object.create({
            hostName: 'host1',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}},
              {Tasks: {role: 'DATANODE'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'success', progress: '100'}
          }),
          Em.Object.create({
            hostName: 'host2',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'success', progress: '100'}
          })
        ],
        jsonError: true
      }
    ]);
    tests.forEach(function (test, index1) {
      test.hosts.forEach(function (host, index2) {
        it('#test ' + index1 + ' #host ' + index2, function () {
          c.reopen({hosts: test.hosts});
          c.hostHasClientsOnly(test.jsonError);
          expect(c.get('hosts').findProperty('hostName', host.hostName).get('status')).to.equal(host.e.status);
          expect(c.get('hosts').findProperty('hostName', host.hostName).get('progress')).to.equal(host.e.progress);
        });
      });
    });
  });

  describe('#onSuccessPerHost', function () {
    var tests = Em.A([
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'pending'}),
        actions: [],
        e: {status: 'success'},
        m: 'No tasks for host'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'success'},
        m: 'All Tasks COMPLETED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'FAILED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        m: 'All Tasks COMPLETED and cluster status FAILED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        m: 'Not all Tasks COMPLETED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'FAILED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        m: 'Not all Tasks COMPLETED and cluster status FAILED'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({content: {cluster: {status: test.cluster.status}}});
        c.onSuccessPerHost(test.actions, test.host);
        expect(test.host.status).to.equal(test.e.status);
      });
    });
  });

  describe('#onErrorPerHost', function () {
    var tests = Em.A([
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'pending'}),
        actions: [],
        e: {status: 'pending'},
        isMasterFailed: false,
        m: 'No tasks for host'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'warning'},
        isMasterFailed: false,
        m: 'One Task FAILED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'ABORTED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'warning'},
        isMasterFailed: false,
        m: 'One Task ABORTED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'TIMEDOUT'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'warning'},
        isMasterFailed: false,
        m: 'One Task TIMEDOUT and cluster status INSTALLED'
      },
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'failed'},
        isMasterFailed: true,
        m: 'One Task FAILED and cluster status PENDING isMasterFailed true'
      },
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        isMasterFailed: false,
        m: 'One Task FAILED and cluster status PENDING isMasterFailed false'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({content: {cluster: {status: test.cluster.status}}, isMasterFailed: function () {
          return test.isMasterFailed;
        }});
        c.onErrorPerHost(test.actions, test.host);
        expect(test.host.status).to.equal(test.e.status);
      });
    });
  });

  describe('#isMasterFailed', function () {

    beforeEach(function() {
      sinon.stub(App, 'get', function(k) {
        if (k === 'components.slaves') {
          return ["TASKTRACKER", "DATANODE", "JOURNALNODE", "ZKFC", "APP_TIMELINE_SERVER", "NODEMANAGER", "GANGLIA_MONITOR", "HBASE_REGIONSERVER", "SUPERVISOR", "FLUME_HANDLER"];
        }
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      App.get.restore();
    });

    var tests = Em.A([
      {
        actions: [
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'DATANODE'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'TASKTRACKER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'HBASE_REGIONSERVER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'GANGLIA_MONITOR'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'SUPERVISOR'}}
        ],
        e: false,
        m: 'No one Master is failed'
      },
      {
        actions: [
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'NAMENODE'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'TASKTRACKER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'HBASE_REGIONSERVER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'GANGLIA_MONITOR'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'SUPERVISOR'}}
        ],
        e: true,
        m: 'One Master is failed'
      },
      {
        actions: [
          {Tasks: {command: 'PENDING', status: 'FAILED', role: 'NAMENODE'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'TASKTRACKER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'HBASE_REGIONSERVER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'GANGLIA_MONITOR'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'SUPERVISOR'}}
        ],
        e: false,
        m: 'one Master is failed but command is not install'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        expect(c.isMasterFailed(test.actions)).to.equal(test.e);
      });
    });
  });

  describe('#onInProgressPerHost', function () {
    var tests = Em.A([
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: true},
        m: 'All Tasks COMPLETED'
      },
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'IN_PROGRESS'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: false},
        m: 'One Task IN_PROGRESS'
      },
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'QUEUED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: false},
        m: 'One Task QUEUED'
      },
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'PENDING'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: false},
        m: 'One Task PENDING'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.onInProgressPerHost(test.actions, test.host);
        if (test.e.b) {
          expect(test.host.message).to.be.equal(test.e.message);
        }
        else {
          expect(test.host.message).to.be.not.equal(test.e.message);
        }
      });
    });
  });

  describe('#progressPerHost', function () {
    var tests = Em.A([
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({progress: 0}),
        actions: {
          'COMPLETED': 2,
          'QUEUED': 2,
          'IN_PROGRESS': 1
        },
        e: {progress: 17},
        s: false,
        m: 'All types of status available. cluster status PENDING'
      },
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({progress: 0}),
        actions: {},
        e: {progress: 33},
        s: false,
        m: 'No tasks available. cluster status PENDING'
      },
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({progress: 0}),
        actions: {},
        e: {progress: 100},
        s: true,
        m: 'No tasks available. cluster status PENDING. skipComponentStartAfterInstall is true.'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: {},
        e: {progress: 100},
        m: 'No tasks available. cluster status INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: {
          'COMPLETED': 2,
          'QUEUED': 2,
          'IN_PROGRESS': 1
        },
        e: {progress: 66},
        s: false,
        m: 'All types of status available. cluster status INSTALLED'
      },
      {
        cluster: {status: 'FAILED'},
        host: Em.Object.create({progress: 0}),
        actions: {},
        e: {progress: 100},
        s: false,
        m: 'Cluster status is not PENDING or INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: {
          'COMPLETED': 150,
          'QUEUED': 0,
          'IN_PROGRESS': 1
        },
        e: {progress: 99},
        s: false,
        m: '150 tasks on host'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: {
          'COMPLETED': 498,
          'QUEUED': 1,
          'IN_PROGRESS': 1
        },
        e: {progress: 99},
        s: false,
        m: '500 tasks on host'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: {
          'COMPLETED': 150,
          'QUEUED': 0,
          'IN_PROGRESS': 0
        },
        e: {progress: 100},
        s: false,
        m: '100 tasks, 100 completed'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: {
          'COMPLETED': 1,
          'QUEUED': 0,
          'IN_PROGRESS': 0
        },
        e: {progress: 100},
        s: false,
        m: '1 task, 1 completed'
      }
    ]);
    tests.forEach(function (test) {
      describe(test.m, function () {

        beforeEach(function () {
          var actions = [];
          for (var prop in test.actions) {
            if (test.actions.hasOwnProperty(prop) && test.actions[prop]) {
              for (var i = 0; i < test.actions[prop]; i++) {
                actions.push({Tasks: {status: prop}});
              }
            }
          }
          c.reopen({content: {cluster: {status: test.cluster.status}}});
          App.set('supports.skipComponentStartAfterInstall', test.s);
          this.progress = c.progressPerHost(actions, test.host);
        });

        it('progress is ' + test.e.progress, function () {
          expect(this.progress).to.equal(test.e.progress);
        });

        it('host progress is ' + test.e.progress.toString(), function () {
          expect(test.host.progress).to.equal(test.e.progress.toString());
        });
      });
    });
  });

  describe('#clearStep', function () {

    beforeEach(function () {
      c.reopen({hosts: [{},{},{}]});
      c.clearStep();
    });

    it('hosts are empty', function () {
      expect(c.get('hosts.length')).to.equal(0);
    });
    it('status is `info`', function () {
      expect(c.get('status')).to.equal('info');
    });
    it('progress is 0', function () {
      expect(c.get('progress')).to.equal('0');
    });
    it('numPolls is 1', function () {
      expect(c.get('numPolls')).to.equal(1);
    });
  });

  describe('#replacePolledData', function () {
    it('replacing polled data', function () {
      c.reopen({polledData: [{},{},{}]});
      var newPolledData = [{}];
      c.replacePolledData(newPolledData);
      expect(c.get('polledData.length')).to.equal(newPolledData.length);
    });
  });

  describe('#isSuccess', function () {
    var tests = Em.A([
      {
        polledData: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: true,
        m: 'All tasks are COMPLETED'
      },
      {
        polledData: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'FAILED'}}
        ],
        e: false,
        m: 'Not all tasks are COMPLETED'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        expect(c.isSuccess(test.polledData)).to.equal(test.e);
      });
    });
  });

  describe('#isStepFailed', function () {

    beforeEach(function() {
      sinon.stub(App, 'get', function(k) {
        if (k === 'components.slaves') {
          return ["TASKTRACKER", "DATANODE", "JOURNALNODE", "ZKFC", "APP_TIMELINE_SERVER", "NODEMANAGER", "GANGLIA_MONITOR", "HBASE_REGIONSERVER", "SUPERVISOR", "FLUME_HANDLER"];
        }
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      App.get.restore();
    });

    var tests = Em.A([
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'PENDING'}}
        ],
        e: true,
        m: 'GANGLIA_MONITOR 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'PENDING'}}
        ],
        e: false,
        m: 'GANGLIA_MONITOR 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'PENDING'}}
        ],
        e: true,
        m: 'HBASE_REGIONSERVER 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'PENDING'}}
        ],
        e: false,
        m: 'HBASE_REGIONSERVER 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'PENDING'}}
        ],
        e: true,
        m: 'TASKTRACKER 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'PENDING'}}
        ],
        e: false,
        m: 'TASKTRACKER 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: true,
        m: 'DATANODE 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: false,
        m: 'DATANODE 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'NAMENODE', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: true,
        m: 'NAMENODE failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'NAMENODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: false,
        m: 'Nothing failed failed'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({polledData: test.polledData});
        expect(c.isStepFailed()).to.equal(test.e);
      });
    });
  });

  describe('#setLogTasksStatePerHost', function () {
    var tests = Em.A([
      {
        tasksPerHost: [
          {Tasks: {id: 1, status: 'COMPLETED'}},
          {Tasks: {id: 2, status: 'COMPLETED'}}
        ],
        tasks: [],
        e: {m: 'COMPLETED', l: 2},
        m: 'host didn\'t have tasks and got 2 new'
      },
      {
        tasksPerHost: [
          {Tasks: {id: 1, status: 'COMPLETED'}},
          {Tasks: {id: 2, status: 'COMPLETED'}}
        ],
        tasks: [
          {Tasks: {id: 1, status: 'IN_PROGRESS'}},
          {Tasks: {id: 2, status: 'IN_PROGRESS'}}
        ],
        e: {m: 'COMPLETED', l: 2},
        m: 'host had 2 tasks and got both updated'
      },
      {
        tasksPerHost: [],
        tasks: [
          {Tasks: {id: 1, status: 'IN_PROGRESS'}},
          {Tasks: {id: 2, status: 'IN_PROGRESS'}}
        ],
        e: {m: 'IN_PROGRESS', l: 2},
        m: 'host had 2 tasks and didn\'t get updates'
      },
      {
        tasksPerHost: [
          {Tasks: {id: 1, status: 'COMPLETED'}},
          {Tasks: {id: 2, status: 'COMPLETED'}},
          {Tasks: {id: 3, status: 'COMPLETED'}}
        ],
        tasks: [
          {Tasks: {id: 1, status: 'IN_PROGRESS'}},
          {Tasks: {id: 2, status: 'IN_PROGRESS'}}
        ],
        e: {m: 'COMPLETED', l: 3},
        m: 'host had 2 tasks and got both updated and 1 new'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({hosts: [Em.Object.create({logTasks: test.tasks})]});
        c.setLogTasksStatePerHost(test.tasksPerHost, c.get('hosts')[0]);
        var host = c.get('hosts')[0];
        expect(host.get('logTasks').everyProperty('Tasks.status', test.e.m)).to.equal(true);
        expect(host.get('logTasks.length')).to.equal(test.e.l);
      });
    });
  });

 // On completion of Start all services error callback function,
  // Cluster Status should be INSTALL FAILED
  // All progress bar on the screen should be finished (100%) with blue color.
  // Retry button should be enabled, next button should be disabled

  describe('#launchStartServicesErrorCallback', function () {

    it('Main progress bar on the screen should be finished (100%) with red color', function () {
      var hosts = Em.A([Em.Object.create({name: 'host1', progress: '33', status: 'info'}), Em.Object.create({name: 'host2', progress: '33', status: 'info'})]);
      c.reopen({hosts: hosts, content: {controllerName: 'installerController', cluster: {status: 'PENDING', name: 'c1'}}});
      c.launchStartServicesErrorCallback({status: 500, statusTesxt: 'Server Error'}, {}, '', {});
      expect(c.get('progress')).to.equal('100');
      expect(c.get('status')).to.equal('failed');
    });

    it('All Host progress bars on the screen should be finished (100%) with blue color', function () {
      var hosts = Em.A([Em.Object.create({name: 'host1', progress: '33', status: 'info'}), Em.Object.create({name: 'host2', progress: '33', status: 'info'})]);
      c.reopen({hosts: hosts, content: {controllerName: 'installerController', cluster: {status: 'PENDING', name: 'c1'}}});
      c.launchStartServicesErrorCallback({status: 500, statusTesxt: 'Server Error'}, {}, '', {});
      expect(c.get('hosts').everyProperty('progress', '100')).to.be.true;
      expect(c.get('hosts').everyProperty('status', 'info')).to.be.true;
    });

    it('Next button should be disabled', function () {
      var hosts = Em.A([Em.Object.create({name: 'host1', progress: '33', status: 'info'}), Em.Object.create({name: 'host2', progress: '33', status: 'info'})]);
      c.reopen({hosts: hosts, content: {controllerName: 'installerController', cluster: {status: 'PENDING', name: 'c1'}}});
      c.launchStartServicesErrorCallback({status: 500, statusTesxt: 'Server Error'}, {}, '', {});
      expect(c.get('isSubmitDisabled')).to.equal(true);
    });

  });

  describe('#submit', function () {

    beforeEach(function () {
      sinon.stub(App.router, 'send', Em.K);
    });

    afterEach(function () {
      App.router.send.restore();
    });

    it('should call App.router.send', function () {
      c.submit();
      expect(App.router.send.calledWith('next')).to.equal(true);
    });
  });

  describe('#back', function () {
    beforeEach(function () {
      sinon.stub(App.router, 'send', Em.K);
    });
    afterEach(function () {
      App.router.send.restore();
    });
    it('should call App.router.send', function () {
      c.reopen({isSubmitDisabled: false});
      c.back();
      expect(App.router.send.calledWith('back')).to.equal(true);
    });
    it('shouldn\'t call App.router.send', function () {
      c.reopen({isSubmitDisabled: true});
      c.back();
      expect(App.router.send.called).to.equal(false);
    });
  });

  describe('#loadStep', function () {
    beforeEach(function () {
      sinon.stub(c, 'clearStep', Em.K);
      sinon.stub(c, 'loadHosts', Em.K);
    });
    afterEach(function () {
      c.clearStep.restore();
      c.loadHosts.restore();
    });
    it('should call clearStep', function () {
      c.loadStep();
      expect(c.clearStep.calledOnce).to.equal(true);
    });
    it('should call loadHosts', function () {
      c.loadStep();
      expect(c.loadHosts.calledOnce).to.equal(true);
    });
  });

  describe('#startPolling', function () {
    beforeEach(function () {
      sinon.stub(c, 'reloadErrorCallback', Em.K);
      sinon.stub(c, 'doPolling', Em.K);
    });
    afterEach(function () {
      c.reloadErrorCallback.restore();
      c.doPolling.restore();
    });
    it('should set isSubmitDisabled to true', function () {
      c.set('isSubmitDisabled', false);
      c.startPolling();
      expect(c.get('isSubmitDisabled')).to.equal(true);
    });
    it('should call doPolling', function () {
      c.startPolling();
      expect(c.doPolling.calledOnce).to.equal(true);
    });
  });

  describe('#loadLogData', function () {

    beforeEach(function () {
      obj.reopen({
        cluster: {oldRequestsId: [1,2,3]},
        getDBProperty: function (name) {
          return this.get(name);
        }
      });
      c.reopen({wizardController: obj});
      sinon.stub(c, 'getLogsByRequest', Em.K);
    });

    afterEach(function () {
      c.getLogsByRequest.restore();
    });

    it('should call getLogsByRequest 1 time with 3', function () {
      c.loadLogData(true);
      expect(c.getLogsByRequest.calledWith(true, 3)).to.equal(true);
    });

  });

  describe('#loadCurrentTaskLog', function () {
    beforeEach(function () {
      sinon.stub(c, 'loadLogData', Em.K);
      c.set('wizardController', Em.Object.create({
        getDBProperty: Em.K
      }));
      sinon.stub(c, 'togglePreviousSteps', Em.K);
    });
    afterEach(function () {
      c.loadLogData.restore();
      c.togglePreviousSteps.restore();
    });

    it('shouldn\'t call App.ajax.send if no currentOpenTaskId', function () {
      c.set('currentOpenTaskId', null);
      c.loadCurrentTaskLog();
      var args = testHelpers.findAjaxRequest('name', 'background_operations.get_by_task');
      expect(args).not.exists;
    });

    it('should call App.ajax.send with provided data', function () {
      c.set('currentOpenTaskId', 1);
      c.set('currentOpenTaskRequestId', 2);
      c.set('content', {cluster: {name: 3}});
      c.loadCurrentTaskLog();
      var args = testHelpers.findAjaxRequest('name', 'background_operations.get_by_task');
      expect(args[0]).exists;
      expect(args[0].data).to.be.eql({taskId: 1, requestId: 2, clusterName: 3});
    });
  });

  describe('#loadCurrentTaskLogSuccessCallback', function () {

    beforeEach(function() {
      sinon.stub(c, 'getLogsByRequest', Em.K);
      sinon.stub(c, 'loadLogData', Em.K);
    });

    afterEach(function() {
      c.getLogsByRequest.restore();
      c.loadLogData.restore();
    });

    it('should increment logTasksChangesCounter', function () {
      c.set('logTasksChangesCounter', 0);
      c.loadCurrentTaskLogSuccessCallback();
      expect(c.get('logTasksChangesCounter')).to.equal(1);
    });
    it('should update stdout, stderr', function () {
      c.set('currentOpenTaskId', 1);
      c.reopen({
        hosts: [
          Em.Object.create({
            name: 'h1',
            logTasks: [
              {Tasks: {id: 1, stdout: '', stderr: ''}}
            ]
          })
        ]
      });
      var data = {Tasks: {host_name: 'h1', id: 1, stderr: 'stderr', stdout: 'stdout'}};
      c.loadCurrentTaskLogSuccessCallback(data);
      var t = c.get('hosts')[0].logTasks[0].Tasks;
      expect(t.stdout).to.equal('stdout');
      expect(t.stderr).to.equal('stderr');
    });
    it('shouldn\'t update stdout, stderr', function () {
      c.set('currentOpenTaskId', 1);
      c.reopen({
        hosts: [
          Em.Object.create({
            name: 'h1',
            logTasks: [
              {Tasks: {id: 2, stdout: '', stderr: ''}}
            ]
          })
        ]
      });
      var data = {Tasks: {host_name: 'h1', id: 1, stderr: 'stderr', stdout: 'stdout'}};
      c.loadCurrentTaskLogSuccessCallback(data);
      var t = c.get('hosts')[0].logTasks[0].Tasks;
      expect(t.stdout).to.equal('');
      expect(t.stderr).to.equal('');
    });
    it('shouldn\'t update stdout, stderr (2)', function () {
      c.set('currentOpenTaskId', 1);
      c.reopen({
        hosts: [
          Em.Object.create({
            name: 'h2',
            logTasks: [
              {Tasks: {id: 1, stdout: '', stderr: ''}}
            ]
          })
        ]
      });
      var data = {Tasks: {host_name: 'h1', id: 1, stderr: 'stderr', stdout: 'stdout'}};
      c.loadCurrentTaskLogSuccessCallback(data);
      var t = c.get('hosts')[0].logTasks[0].Tasks;
      expect(t.stdout).to.equal('');
      expect(t.stderr).to.equal('');
    });
  });

  describe('#loadCurrentTaskLogErrorCallback', function () {
    it('should set currentOpenTaskId to 0', function () {
      c.set('currentOpenTaskId', 123);
      c.loadCurrentTaskLogErrorCallback();
      expect(c.get('currentOpenTaskId')).to.equal(0);
    });
  });

  describe('#doPolling', function () {

    beforeEach(function () {
      sinon.stub(c, 'getLogsByRequest', Em.K);
      sinon.stub(c, 'togglePreviousSteps', Em.K);
    });

    afterEach(function () {
      c.getLogsByRequest.restore();
      c.togglePreviousSteps.restore();
    });

    it('should call getLogsByRequest', function () {
      c.set('content', {cluster: {requestId: 1}});
      c.doPolling();
      expect(c.getLogsByRequest.calledWith(true, 1)).to.equal(true);
    });

  });

  describe('#isAllComponentsInstalledErrorCallback', function () {
    beforeEach(function () {
      sinon.stub(c, 'saveClusterStatus', Em.K);
      sinon.stub(c, 'togglePreviousSteps', Em.K);
    });
    afterEach(function () {
      c.saveClusterStatus.restore();
      c.togglePreviousSteps.restore();
    });
    it('should call saveClusterStatus', function () {
      c.isAllComponentsInstalledErrorCallback({});
      expect(c.saveClusterStatus.calledOnce).to.equal(true);
    });
  });

  describe('#navigateStep', function () {

    beforeEach(function () {
      sinon.stub(c, 'togglePreviousSteps', Em.K);
      sinon.stub(c, 'loadStep', Em.K);
      sinon.stub(c, 'loadLogData', Em.K);
      sinon.stub(c, 'startPolling', Em.K);
    });

    afterEach(function () {
      c.togglePreviousSteps.restore();
      c.loadStep.restore();
      c.loadLogData.restore();
      c.startPolling.restore();
    });

    it('isCompleted = true, requestId = 1', function () {
      c.reopen({content: {cluster: {isCompleted: true, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(false)).to.equal(true);
      expect(c.get('progress')).to.equal('100');
    });
    it('isCompleted = false, requestId = 1, status = INSTALL FAILED', function () {
      c.reopen({content: {cluster: {status: 'INSTALL FAILED', isCompleted: false, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(false)).to.equal(true);
    });
    it('isCompleted = false, requestId = 1, status = START FAILED', function () {
      c.reopen({content: {cluster: {status: 'START FAILED', isCompleted: false, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(false)).to.equal(true);
    });
    it('isCompleted = false, requestId = 1, status = OTHER', function () {
      c.reopen({content: {cluster: {status: 'STARTED', isCompleted: false, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(true)).to.equal(true);
    });
  });

  describe('#launchStartServicesSuccessCallback', function () {
    beforeEach(function () {
      sinon.stub(App.clusterStatus, 'setClusterStatus', function() {
        return $.ajax();
      });
      sinon.stub(c, 'saveClusterStatus', Em.K);
      sinon.stub(c, 'doPolling', Em.K);
      sinon.stub(c, 'hostHasClientsOnly', Em.K);
    });
    afterEach(function () {
      c.saveClusterStatus.restore();
      c.doPolling.restore();
      c.hostHasClientsOnly.restore();
      App.clusterStatus.setClusterStatus.restore();
    });
    it('should call doPolling if some data were received', function () {
      c.launchStartServicesSuccessCallback({Requests: {id: 2}});
      expect(c.doPolling.calledOnce).to.equal(true);
    });
    Em.A([
        {
          m: 'Launch start service after install services completed',
          jsonData: {Requests: {id: 2}},
          e: {
            hostHasClientsOnly: false,
            clusterStatus: {
              status: 'INSTALLED',
              requestId: 2,
              isStartError: false,
              isCompleted: false
            }
          }
        },
        {
          jsonData: null,
          e: {
            hostHasClientsOnly: true,
            clusterStatus: {
              status: 'STARTED',
              isStartError: false,
              isCompleted: true
            },
            status: 'success',
            progress: '100'
          }
        }
      ]).forEach(function (test) {
        describe(test.m, function () {

          beforeEach(function () {
            c.launchStartServicesSuccessCallback(test.jsonData);
          });

          it('hostHasClientsOnly is called with valid arguments', function () {
            expect(c.hostHasClientsOnly.calledWith(test.e.hostHasClientsOnly)).to.equal(true);
          });

          it('saveClusterStatus is called with valid arguments', function () {
            expect(c.saveClusterStatus.calledWith(test.e.clusterStatus)).to.equal(true);
          });


          if (test.e.status) {
            it('status is valid', function () {
              expect(c.get('status')).to.equal(test.e.status);
            });
          }
          if (test.e.progress) {
            it('progress is valid', function () {
              expect(c.get('progress')).to.equal(test.e.progress);
            });
          }
        });
      });
  });

  describe('#isAllComponentsInstalledSuccessCallback', function () {

    var hosts = [
      Em.Object.create({name: 'h1', status: '', message: '', progress: ''}),
      Em.Object.create({name: 'h2', status: '', message: '', progress: ''})
    ];

    var jsonData = {
      items: [
        {
          Hosts: {
            host_state: 'HEARTBEAT_LOST',
            host_name: 'h1'
          },
          host_components: [
            {
              HostRoles: {
                component_name: 'c1'
              }
            },
            {
              HostRoles: {
                component_name: 'c2'
              }
            }
          ]
        },
        {
          Hosts: {
            host_state: 'HEARTBEAT_LOST',
            host_name: 'h2'
          },
          host_components: [
            {
              HostRoles: {
                component_name: 'c3'
              }
            },
            {
              HostRoles: {
                component_name: 'c4'
              }
            }
          ]
        }
      ]
    };

    beforeEach(function () {
      sinon.stub(c, 'changeParseHostInfo', Em.K);
      sinon.stub(c, 'launchStartServices', Em.K);
      sinon.stub(c, 'saveClusterStatus', Em.K);
      c.set('hosts', hosts);
      c.set('content', Em.Object.create({
        slaveComponentHosts: [
          {hosts: [{isInstalled: true, hostName: 'h1'}]},
          {hosts: [{isInstalled: false, hostName: 'h2'}]}
        ],
        masterComponentHosts: []
      }));
      c.isAllComponentsInstalledSuccessCallback(jsonData);
      this.clusterStatus = c.saveClusterStatus.args[0][0];
    });

    afterEach(function () {
      c.changeParseHostInfo.restore();
      c.launchStartServices.restore();
      c.saveClusterStatus.restore();
    });

    it('cluster status / status', function () {
      expect(this.clusterStatus.status).to.be.equal('INSTALL FAILED');
    });

    it('cluster status / isStartError', function () {
      expect(this.clusterStatus.isStartError).to.be.true;
    });

    it('cluster status / isCompleted', function () {
      expect(this.clusterStatus.isCompleted).to.be.false;
    });

    it('each host progress is 100', function () {
      expect(c.get('hosts').everyProperty('progress', '100')).to.be.true;
    });

    it('each host status is `heartbeat_lost`', function () {
      expect(c.get('hosts').everyProperty('status', 'heartbeat_lost')).to.be.true;
    });

    it('overall progress is 100', function () {
      expect(c.get('progress')).to.be.equal('100');
    });

  });

  describe('#loadDoServiceChecksFlagSuccessCallback', function () {

    var data = {
      RootServiceComponents: {
        properties: {
          'skip.service.checks': 'true'
        }
      }
    };

    it('skipServiceChecks should be true', function () {
      c.loadDoServiceChecksFlagSuccessCallback(data);
      expect(c.get('skipServiceChecks')).to.be.true;
    });

    it('skipServiceChecks should be false', function () {
      data.RootServiceComponents.properties['skip.service.checks'] = 'false';
      c.loadDoServiceChecksFlagSuccessCallback(data);
      expect(c.get('skipServiceChecks')).to.be.false;
    });

  });

  describe('#isNextButtonDisabled', function () {

    var cases = [
      {
        nextBtnClickInProgress: true,
        isSubmitDisabled: true,
        isNextButtonDisabled: true,
        description: 'button clicked, submit disabled',
        title: 'next button disabled'
      },
      {
        nextBtnClickInProgress: true,
        isSubmitDisabled: false,
        isNextButtonDisabled: true,
        description: 'button clicked, submit not disabled',
        title: 'next button disabled'
      },
      {
        nextBtnClickInProgress: false,
        isSubmitDisabled: true,
        isNextButtonDisabled: true,
        description: 'no button clicked, submit disabled',
        title: 'next button disabled'
      },
      {
        nextBtnClickInProgress: false,
        isSubmitDisabled: false,
        isNextButtonDisabled: false,
        description: 'no button clicked, submit not disabled',
        title: 'next button enabled'
      }
    ];

    cases.forEach(function (item) {

      describe(item.description, function () {

        beforeEach(function () {
          c.reopen({
            isSubmitDisabled: item.isSubmitDisabled
          });
          sinon.stub(App, 'get').withArgs('router.nextBtnClickInProgress').returns(item.nextBtnClickInProgress);
          c.propertyDidChange('isSubmitDisabled');
          c.propertyDidChange('App.router.nextBtnClickInProgress');
        });

        afterEach(function () {
          App.get.restore();
        });

        it(item.title, function () {
          expect(c.get('isNextButtonDisabled')).to.equal(item.isNextButtonDisabled);
        });

      });

    });

  });

});

});

require.register("test/controllers/wizard_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/cluster');
require('controllers/wizard');

var c;

function getSteps(start, count) {
  var steps = [];
  for (var j = start; j <= count; j++) {
    steps.push(Em.Object.create({step: j, value: false}));
  }
  return steps;
}

describe('App.WizardController', function () {

  var wizardController = App.WizardController.create({});

  var totalSteps = 11;
  var ruller = d3.range(0, totalSteps);
  var i;
  beforeEach(function () {
    c = App.WizardController.create({});
  });

  describe('#setLowerStepsDisable', function () {
    var steps = getSteps(1, 10);
    wizardController.set('isStepDisabled', steps);
    steps.forEach(function (step) {
      var index = step.get('step');
      it('Steps: 10 | Disabled: ' + (index - 1), function () {
        wizardController.setLowerStepsDisable(index);
        expect(wizardController.get('isStepDisabled').filterProperty('value', true).length).to.be.equal(index - 1);
      });
    });
  });

  // isStep0 ... isStep10 tests
  App.WizardController1 = App.WizardController.extend({currentStep:''});
  var tests = [];
  for (i = 0; i < totalSteps; i++) {
    var n = ruller.slice(0);
    n.splice(i, 1);
    tests.push({i: i, n: n});
  }
  tests.forEach(function (test) {
    describe('isStep' + test.i, function () {
      var w = App.WizardController1.create();
      w.set('currentStep', test.i);

      it('Current Step is {0}, so isStep{1} is TRUE'.format(test.i, test.i), function () {
        expect(w.get('isStep' + test.i)).to.equal(true);
      });

      test.n.forEach(function (indx) {
        it('Current Step is {0}, so isStep{1} is FALSE'.format(test.i, indx), function () {
          expect(w.get('isStep' + indx)).to.equal(false);
        });
      });
    });
  });
  // isStep0 ... isStep10 tests end

  describe('#gotoStep', function() {
    var w = App.WizardController1.create();
    var steps = getSteps(0, totalSteps - 1);
    steps.forEach(function(step, index) {
      step.set('value', true);
      w.set('isStepDisabled', steps);
      it('step {0} is disabled, so gotoStep({1}) is not possible'.format(index, index), function() {
        expect(w.gotoStep(index)).to.equal(false);
      });
    });
  });

  describe('#launchBootstrapSuccessCallback', function() {
    var params = {popup: {finishLoading: function(){}}};
    beforeEach(function () {
      sinon.spy(params.popup, "finishLoading");
    });

    afterEach(function () {
      params.popup.finishLoading.restore();
    });

    it('Save bootstrapRequestId', function() {
      var data = {requestId: 123, status: 'SUCCESS', log: 'ok'};
      wizardController.launchBootstrapSuccessCallback(data, {}, params);
      expect(params.popup.finishLoading.calledWith(123, null, 'SUCCESS', 'ok')).to.be.true;
    });
  });

  describe('#getInstallOptions', function () {

    var cases = [
        {
          isHadoopWindowsStack: true,
          expected: {
            useSsh: false
          }
        },
        {
          isHadoopWindowsStack: false,
          expected: {
            useSsh: true
          }
        }
      ],
      title = 'should return {0}';

    beforeEach(function () {
      sinon.stub(wizardController, 'get')
        .withArgs('installOptionsTemplate').returns({useSsh: true})
        .withArgs('installWindowsOptionsTemplate').returns({useSsh: false});
      this.stub = sinon.stub(App, 'get');
    });

    afterEach(function () {
      App.get.restore();
      wizardController.get.restore();
    });

    cases.forEach(function (item) {
      it(title.format(item.expected), function () {
        this.stub.withArgs('isHadoopWindowsStack').returns(item.isHadoopWindowsStack);
        expect(wizardController.getInstallOptions()).to.eql(item.expected);
      });
    });

  });

  describe('#clearInstallOptions', function () {

    wizardController.setProperties({
      content: {},
      name: 'wizardController'
    });

    beforeEach(function () {
      sinon.stub(App, 'get').withArgs('isHadoopWindowsStack').returns(false);
    });

    afterEach(function () {
      App.get.restore();
    });

    describe('should clear install options', function () {

      beforeEach(function () {
        wizardController.clearInstallOptions();
      });
      it('content.installOptions', function () {
        expect(wizardController.get('content.installOptions')).to.eql(wizardController.get('installOptionsTemplate'));
      });
      it('content.hosts', function () {
        expect(wizardController.get('content.hosts')).to.eql({});
      });
      it('installOptions', function () {
        expect(wizardController.getDBProperty('installOptions')).to.eql(wizardController.get('installOptionsTemplate'));
      });
      it('hosts', function () {
        expect(wizardController.getDBProperty('hosts')).to.eql({});
      });
    });
  });

  describe('#loadServiceConfigGroups', function () {
     beforeEach(function () {
      sinon.stub(wizardController, 'getDBProperties', function() {
        return {
          serviceConfigGroups: [
            {
              hosts: ['h1']
            }
          ],
          hosts: Em.Object.create({
            h1: Em.Object.create({
              id: 'h1'
            })
          })
        };
      });
    });
    afterEach(function () {
      wizardController.getDBProperties.restore();
    });
    it('should load service confgig group', function () {
      wizardController.loadServiceConfigGroups();
      expect(wizardController.get('content.configGroups')).to.eql([
        {
          "hosts": [
            "h1"
          ]
        }
      ]);
    });
  });

  describe('#saveTasksStatuses', function () {
    it('should set status', function () {
      wizardController.saveTasksStatuses('st');
      expect(wizardController.get('content.tasksStatuses')).to.equal('st');
    });
  });

  describe('#saveSlaveComponentHosts', function () {
    beforeEach(function(){
      sinon.stub(wizardController,'getDBProperty').returns(Em.A({
        'h1': {
          id: 1
        }
      }));
    });
    afterEach(function(){
      wizardController.getDBProperty.restore();
    });
    it('should save slave components', function () {
      var stepController = Em.Object.create({
        hosts: Em.A([
          Em.Object.create({
            hostName: 'h1',
            checkboxes: Em.A([
              Em.Object.create({title: 'hl1', checked: true})
            ])
          })
        ]),
        headers: Em.A([
          Em.Object.create({name: 'header1', label: 'hl1'})
        ])
      });
      wizardController.saveSlaveComponentHosts(stepController);
      var res = JSON.parse(JSON.stringify(wizardController.get('content.slaveComponentHosts')));
      expect(res).to.eql([
        {
          "componentName": "header1",
          "displayName": "hl1",
          "hosts": [
            {
              "group": "Default",
              "host_id": 1
            }
          ]
        }
      ]);
    });
  });

  describe('#showLaunchBootstrapPopup', function () {
    afterEach(function(){
      App.ModalPopup.show.restore();
    });

    describe('errors', function () {

      beforeEach(function () {
        sinon.stub(App.ModalPopup,'show', function (data) {
          data.finishLoading.call(c);
        });
      });

      it('should set error', function () {
        c.showLaunchBootstrapPopup(Em.K);
        expect(c.get('isError')).to.be.true;
      });
    });

    describe('#finishLoading', function () {
      var stepController = App.get('router.wizardStep3Controller'),
        cases = [
          {
            requestId: null,
            serverError: 'error',
            wizardControllerProperties: {
              isError: true,
              showFooter: true,
              showCloseButton: true,
              serverError: 'error'
            },
            stepControllerProperties: {
              isRegistrationInProgress: false,
              isBootstrapFailed: true
            },
            bootStatus: 'FAILED',
            callbackCallCount: 0,
            hideCallCount: 0,
            title: 'no request id'
          },
          {
            requestId: 0,
            status: 'ERROR',
            log: 'log',
            wizardControllerProperties: {
              isError: true,
              showFooter: true,
              showCloseButton: true,
              serverError: 'log'
            },
            stepControllerProperties: {
              isRegistrationInProgress: false,
              isBootstrapFailed: true
            },
            bootStatus: 'FAILED',
            callbackCallCount: 0,
            hideCallCount: 0,
            title: 'ERROR status'
          },
          {
            requestId: 1,
            log: 'log',
            wizardControllerProperties: {
              isError: false,
              showFooter: false,
              showCloseButton: false,
              serverError: null
            },
            stepControllerProperties: {
              isRegistrationInProgress: true,
              isBootstrapFailed: false
            },
            bootStatus: 'PENDING',
            callbackCallCount: 1,
            hideCallCount: 1,
            title: 'request accepted'
          }
        ];
      beforeEach(function () {
        c.setProperties({
          isError: false,
          showFooter: false,
          showCloseButton: false,
          serverError: null,
          hide: Em.K,
          callback: Em.K
        });
        stepController.setProperties({
          isRegistrationInProgress: true,
          isBootstrapFailed: false,
          hosts: [
            {
              bootStatus: 'PENDING'
            },
            {
              bootStatus: 'PENDING'
            }
          ]
        });
        sinon.spy(c, 'hide');
        sinon.spy(c, 'callback');
      });
      afterEach(function () {
        c.hide.restore();
        c.callback.restore();
      });
      cases.forEach(function (item) {
        describe(item.title, function () {
          var wizardControllerProperties = Em.keys(item.wizardControllerProperties),
            stepControllerProperties = Em.keys(item.stepControllerProperties);

          beforeEach(function () {
            sinon.stub(App.ModalPopup,'show', function (data) {
              data.finishLoading.call(c, item.requestId, item.serverError, item.status, item.log);
            });
            c.showLaunchBootstrapPopup(c.callback);
          });

          it('wizardControllerProperties are valid', function () {
            expect(c.getProperties.apply(c, wizardControllerProperties)).to.eql(item.wizardControllerProperties);
          });

          it('stepControllerProperties are valid', function () {
            expect(stepController.getProperties.apply(stepController, stepControllerProperties)).to.eql(item.stepControllerProperties);
          });

          it('bootStatus is valid', function () {
            expect(stepController.get('hosts').mapProperty('bootStatus').uniq()).to.eql([item.bootStatus]);
          });

          it('callback is called needed number of times', function () {
            expect(c.callback.callCount).to.equal(item.callbackCallCount);
          });

          it('hide is called needed number of times', function () {
            expect(c.hide.callCount).to.equal(item.hideCallCount);
          });
        });
      });
    });
  });

  describe('#gotoStep0', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 0 step', function () {
      wizardController.gotoStep0(Em.K);
      expect(res).to.be.equal(0);
    });
  });

  describe('#gotoStep1', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 1 step', function () {
      wizardController.gotoStep1(Em.K);
      expect(res).to.be.equal(1);
    });
  });

  describe('#gotoStep2', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 2 step', function () {
      wizardController.gotoStep2(Em.K);
      expect(res).to.be.equal(2);
    });
  });

  describe('#gotoSte3', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 3 step', function () {
      wizardController.gotoStep3(Em.K);
      expect(res).to.be.equal(3);
    });
  });

  describe('#gotoStep4', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 4 step', function () {
      wizardController.gotoStep4(Em.K);
      expect(res).to.be.equal(4);
    });
  });

  describe('#gotoStep5', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 5 step', function () {
      wizardController.gotoStep5(Em.K);
      expect(res).to.be.equal(5);
    });
  });

  describe('#gotoStep6', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 6 step', function () {
      wizardController.gotoStep6(Em.K);
      expect(res).to.be.equal(6);
    });
  });

  describe('#gotoStep7', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 7 step', function () {
      wizardController.gotoStep7(Em.K);
      expect(res).to.be.equal(7);
    });
  });

  describe('#gotoStep8', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 8 step', function () {
      wizardController.gotoStep8(Em.K);
      expect(res).to.be.equal(8);
    });
  });

  describe('#gotoStep9', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 9 step', function () {
      wizardController.gotoStep9(Em.K);
      expect(res).to.be.equal(9);
    });
  });

  describe('#gotoStep10', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 10 step', function () {
      wizardController.gotoStep10(Em.K);
      expect(res).to.be.equal(10);
    });
  });

  describe('#gotoStep', function () {
    beforeEach(function(){
      sinon.stub(App.ModalPopup,'show', Em.K);
      sinon.stub(App.clusterStatus,'setClusterStatus', Em.K);  
      sinon.stub(App.router,'send', Em.K);  
    });
    afterEach(function(){
      App.ModalPopup.show.restore();
      App.clusterStatus.setClusterStatus.restore();
      App.router.send.restore();
    });
    it('should go to step', function () {
      wizardController.set('isStepDisabled', Em.A([
        Em.Object.create({
          step: '8',
          value: false
        })
      ]));
      wizardController.hide = Em.K;
      wizardController.set('content.controllerName','installerController');
      wizardController.set('currentStep','9');

      expect(wizardController.gotoStep('8')).to.be.true;
    });
  });

  describe('#launchBootstrap', function () {
    beforeEach(function(){
      sinon.stub(wizardController,'showLaunchBootstrapPopup').returns({
        name: 'popup'
      });
    });
    afterEach(function(){
      wizardController.showLaunchBootstrapPopup.restore();
    });
    it('should return popup', function () {
      expect(wizardController.launchBootstrap()).to.be.eql({
        name: 'popup'
      });
    });
  });

  describe('#save', function () {
    var res;
    beforeEach(function () {
      sinon.stub(wizardController,'setDBProperty', function(data){
        res = data;
      });
      sinon.stub(wizardController,'toJSInstance').returns('val');
    });

    afterEach(function () {
      wizardController.setDBProperty.restore();
      wizardController.toJSInstance.restore();
    });

    it('should save data', function () {
      wizardController.save('name');
      expect(res).to.be.equal('name');
    });
  });

  describe('#installServicesSuccessCallback', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'saveClusterStatus', function(data){
        res = JSON.parse(JSON.stringify(data));
      });
      sinon.stub(App,'dateTime').returns('22');
    });
    afterEach(function(){
      wizardController.saveClusterStatus.restore();
      App.dateTime.restore();
    });
    it('should call callbeck with data', function () {
      var jsonData = {
        Requests: {
          id: 1
        }
      };
      wizardController.installServicesSuccessCallback(jsonData);
      expect(res).to.be.eql({
        "status": "PENDING",
        "requestId": 1,
        "isInstallError": false,
        "isCompleted": false,
        "installStartTime": "22"
      });
    });
  });

  describe('#installServices', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'saveClusterStatus', function(data){
        res = JSON.parse(JSON.stringify(data));
      });
    });
    afterEach(function(){
      wizardController.saveClusterStatus.restore();
    });
    it('should call callbeck with data', function () {
      wizardController.set('content', Em.Object.create({
        cluster: {
          oldRequestsId: '1'
        }
      }));
      wizardController.installServices(true);
      expect(res).to.be.eql({
        "status": "PENDING"
      });
    });
  });

  describe('#saveInstalledHosts', function () {
    beforeEach(function(){
      sinon.stub(wizardController,'getDBProperty').returns({
        'h1': {
          id: 1,
          status: '',
          name: 'h1'
        }
      });
    });
    afterEach(function(){
      wizardController.getDBProperty.restore();
    });
    it('should save installed hosts', function () {
      var stepController = Em.Object.create({
        hosts: Em.A([
          Em.Object.create({
            hostName: 'h1',
            name: 'h1',
            status: 'st',
            message: 'ms',
            checkboxes: Em.A([
              Em.Object.create({title: 'hl1', checked: true})
            ])
          })
        ])
      });
      wizardController.saveInstalledHosts(stepController);
      var res = JSON.parse(JSON.stringify(wizardController.get('content.hosts')));
      expect(res).to.eql({
        "h1": {
          "id": 1,
          "status": "st",
          "name": "h1",
          "message": "ms"
        }
      });
    });
  });

  describe('#saveConfirmedHosts', function () {
    beforeEach(function(){
      sinon.stub(wizardController,'getDBProperty').returns({
        'h1': {
          id: 1,
          status: '',
          name: 'h1'
        }
      });
    });
    afterEach(function(){
      wizardController.getDBProperty.restore();
    });
    it('should save confirmed hosts', function () {
      var stepController = Em.Object.create({
        confirmedHosts: Em.A([
          {
            name: 'h2',
            cpu: '1',
            isInstalled: true
          }
        ])
      });
      wizardController.set('content.hosts', {
        'h1': {
          isInstalled: false,
          bootStatus: 'REGISTERED'
        },
        'h2': {
          isInstalled: true,
          bootStatus: 'REGISTERED'
        }
      });
      wizardController.saveConfirmedHosts(stepController);
      var res = JSON.parse(JSON.stringify(wizardController.get('content.hosts')));
      expect(res).to.eql({
        "h2": {
          "isInstalled": true,
          "bootStatus": "REGISTERED"
        }
      });
    });
  });

  describe('#loadTasksStatuses', function () {
    beforeEach(function () {
      sinon.stub(wizardController, 'getDBProperty').returns('st');
    });
    afterEach(function () {
      wizardController.getDBProperty.restore();
    });
    it('should load status', function () {
      wizardController.loadTasksStatuses();
      expect(wizardController.get('content.tasksStatuses')).to.equal('st');
    });
  });

  describe('#saveTasksRequestIds', function () {
    it('should save id', function () {
      wizardController.saveTasksRequestIds('st');
      expect(wizardController.get('content.tasksRequestIds')).to.equal('st');
    });
  });

  describe('#loadTasksRequestIds', function () {
    beforeEach(function () {
      sinon.stub(wizardController, 'getDBProperty').returns('st');
    });
    afterEach(function () {
      wizardController.getDBProperty.restore();
    });
    it('should load status', function () {
      wizardController.loadTasksRequestIds();
      expect(wizardController.get('content.tasksRequestIds')).to.equal('st');
    });
  });

  describe('#saveRequestIds', function () {
    it('should save id', function () {
      wizardController.saveRequestIds('st');
      expect(wizardController.get('content.requestIds')).to.equal('st');
    });
  });

  describe('#load', function () {
    it('should clear install options', function () {
      var name = 'Name';
      wizardController.set('get'+name.capitalize(), function() {return 'res';});
      wizardController.load(name, true);
      expect(wizardController.get('content.' + name)).to.equal('res');
    });
  });

  describe('#usersLoading', function () {
    beforeEach(function(){
      sinon.stub(App.MainAdminServiceAccountsController,'create').returns({
        loadUsers: function() {},
        get: function(type) {
          if (type === 'dataIsLoaded') {
            return true;
          }
          return Em.Object.create({
            hdfsUser: {
              name: 'user'
            }
          });
        }
      });
    });
    afterEach(function(){
      App.MainAdminServiceAccountsController.create.restore();
    });
    it('should load users', function () {
      wizardController.set('content.hdfsUser', true);
      wizardController.usersLoading().then(function(data){
        expect(data).to.be.undefined;
      });
    });
  });

  describe('#loadConfirmedHosts', function () {
    beforeEach(function(){
      sinon.stub(App.db, 'getHosts').returns(Em.A([
        Em.Object.create({
          name: 'h1'
        })
      ]));
    });
    afterEach(function(){
      App.db.getHosts.restore();
    });
    it('should load hosts from db', function () {
      wizardController.loadConfirmedHosts();
      var res = JSON.parse(JSON.stringify(wizardController.get('content.hosts')));
      expect(res).to.eql([
        {
          "name": "h1"
        }
      ]);
    });
  });

  describe('#loadServicesFromServer', function () {//TODO
    var res;
    beforeEach(function(){
      sinon.stub(App.StackService, 'find').returns(Em.A([
        Em.Object.create({
          isSelected: false,
          isInstalled: false,
          serviceName: 's1'
        })
      ]));
      sinon.stub(App.Service, 'find').returns(Em.A([
        Em.Object.create({
          isSelected: false,
          isInstalled: false,
          serviceName: 's1'
        })
      ]));
      sinon.stub(wizardController, 'setDBProperty', function(data) {
        res = data;
      });
    });
    
    afterEach(function () {
      App.StackService.find.restore();
      App.Service.find.restore();
      wizardController.setDBProperty.restore();
    });
    it('should load services from server', function () {
      wizardController.loadServicesFromServer();
      expect(res).to.be.equal('services');
    });
  });

  describe('#loadRequestIds', function () {
    beforeEach(function () {
      sinon.stub(wizardController, 'getDBProperty').returns('st');
    });
    afterEach(function () {
      wizardController.getDBProperty.restore();
    });
    it('should load status', function () {
      wizardController.loadRequestIds();
      expect(wizardController.get('content.requestIds')).to.equal('st');
    });
  });

  describe('#loadServiceComponentsSuccessCallback', function () {
    beforeEach(function () {
      sinon.stub(wizardController, 'getDBProperties', function() {
        return {
          selectedServiceNames: ['a','b'],
          installedServiceNames: ['c','d']
        };
      });
      sinon.stub(App.stackServiceMapper, 'mapStackServices', Em.K); 
    });
    afterEach(function () {
      wizardController.getDBProperties.restore();
      App.stackServiceMapper.mapStackServices.restore();
    });
    it('should load json data', function () {
      var jsonData = {
        items: [
          {
            StackServices: {
              isSelected: false,
              service_name: 'a'
            }
          },
          {
            StackServices: {
              isSelected: false,
              service_name: 'none'
            }
          }
        ]
      };
      wizardController.loadServiceComponentsSuccessCallback(jsonData);
      var exp = {
        "items": [
          {
            "StackServices": {
              "isSelected": false,
              "service_name": "a",
              "is_selected": true,
              "is_installed": false
            }
          },
          {
            "StackServices": {
              "isSelected": false,
              "service_name": "none",
              "is_selected": false,
              "is_installed": false
            }
          }
        ]
      };

      expect(jsonData).to.eql(exp);
    });
  });

  describe('#setInfoForStep9', function () {

    var res;

    beforeEach(function () {
      sinon.stub(wizardController, 'getDBProperty').returns(Em.Object.create({
        status: {},
        message: {},
        logTasks: {},
        tasks: {},
        progress: {}
      }));
      sinon.stub(wizardController, 'setDBProperty', function(title,data) {
        res = data;
      });
    });

    afterEach(function () {
      wizardController.getDBProperty.restore();
      wizardController.setDBProperty.restore();
    });

    it('should return info for step 9', function () {
      wizardController.setInfoForStep9();
      var exp = {
        "status": {
          "status": "pending",
          "message": "Waiting",
          "logTasks": [],
          "tasks": [],
          "progress": "0"
        },
        "message": {
          "status": "pending",
          "message": "Waiting",
          "logTasks": [],
          "tasks": [],
          "progress": "0"
        },
        "logTasks": {
          "status": "pending",
          "message": "Waiting",
          "logTasks": [],
          "tasks": [],
          "progress": "0"
        },
        "tasks": {
          "status": "pending",
          "message": "Waiting",
          "logTasks": [],
          "tasks": [],
          "progress": "0"
        },
        "progress": {
          "status": "pending",
          "message": "Waiting",
          "logTasks": [],
          "tasks": [],
          "progress": "0"
        }
      };

      res = JSON.parse(JSON.stringify(res));

      expect(res).to.eql(exp);
    });
  });

  describe('#saveServiceConfigProperties', function () {

    beforeEach(function () {
      c.set('content', {});
      sinon.stub(c, 'setDBProperty', Em.K);
      sinon.stub(c, 'setDBProperties', Em.K);
      sinon.stub(c, 'getDBProperty').withArgs('fileNamesToUpdate').returns([]);
      sinon.stub(c, 'setPersistentProperty', Em.K);
      sinon.stub(App.config, 'shouldSupportFinal').returns(true);
    });

    afterEach(function () {
      c.setDBProperty.restore();
      c.setDBProperties.restore();
      c.getDBProperty.restore();
      c.setPersistentProperty.restore();
      App.config.shouldSupportFinal.restore();
    });

    var kerberosStepController = Em.Object.create({
      installedServiceNames: ['KERBEROS'],
      stepConfigs: [
        Em.Object.create({
          serviceName: 'KERBEROS',
          configs: [
            Em.Object.create({
              id: 'id',
              name: 'admin_password',
              value: 'value',
              defaultValue: 'defaultValue',
              description: 'description',
              serviceName: 'serviceName',
              domain: 'domain',
              isVisible: true,
              isNotDefaultValue: true,
              isFinal: true,
              defaultIsFinal: true,
              supportsFinal: true,
              filename: 'krb5-conf.xml',
              displayType: 'string',
              isRequiredByAgent: true,
              hasInitialValue: true,
              isRequired: true,
              group: {name: 'group'},
              showLabel: true,
              category: 'some_category'
            }),

            Em.Object.create({
              id: 'id',
              name: 'admin_principal',
              value: 'value',
              defaultValue: 'defaultValue',
              description: 'description',
              serviceName: 'serviceName',
              domain: 'domain',
              isVisible: true,
              isNotDefaultValue: true,
              isFinal: true,
              defaultIsFinal: true,
              supportsFinal: true,
              filename: 'krb5-conf.xml',
              displayType: 'string',
              isRequiredByAgent: true,
              hasInitialValue: true,
              isRequired: true,
              group: {name: 'group'},
              showLabel: true,
              category: 'some_category'
            })
          ]
        })
      ]
    });

    var stepController = Em.Object.create({
      installedServiceNames: ['HDFS'],
      stepConfigs: [
      Em.Object.create({
        serviceName: 'HDFS',
        configs: [
          Em.Object.create({
            id: 'id',
            name: 'name',
            value: 'value',
            defaultValue: 'defaultValue',
            description: 'description',
            serviceName: 'serviceName',
            domain: 'domain',
            isVisible: true,
            isNotDefaultValue: true,
            isFinal: true,
            defaultIsFinal: true,
            supportsFinal: true,
            filename: 'hdfs-site',
            displayType: 'string',
            isRequiredByAgent: true,
            hasInitialValue: true,
            isRequired: true,
            isUserProperty: true,
            showLabel: true,
            category: 'some_category'
          }),
          Em.Object.create({
            id: 'id',
            name: 'name2',
            value: 'value',
            defaultValue: 'defaultValue',
            description: 'description',
            serviceName: 'serviceName',
            domain: 'domain',
            isVisible: true,
            isNotDefaultValue: true,
            isFinal: true,
            defaultIsFinal: true,
            supportsFinal: true,
            filename: 'hdfs-site',
            displayType: 'string',
            isRequiredByAgent: true,
            hasInitialValue: true,
            isRequired: false,
            isUserProperty: false,
            showLabel: true,
            category: 'some_category'
          })
        ]
      }),
      Em.Object.create({
        serviceName: 'YARN',
        configs: [
          Em.Object.create({
            id: 'id',
            name: 'name',
            value: 'value',
            defaultValue: 'defaultValue',
            description: 'description',
            serviceName: 'serviceName',
            domain: 'domain',
            isVisible: true,
            isFinal: true,
            defaultIsFinal: true,
            supportsFinal: true,
            filename: 'filename',
            displayType: 'string',
            isRequiredByAgent: true,
            hasInitialValue: true,
            isRequired: true,
            isUserProperty: false,
            group: {name: 'group'},
            showLabel: true,
            category: 'some_category'
          })
        ]
      })
    ]});

    it('should save configs from default config group to content.serviceConfigProperties', function () {
      c.saveServiceConfigProperties(stepController);
      var saved = c.get('content.serviceConfigProperties');
      expect(saved.length).to.equal(2);
      expect(saved[0].category).to.equal('some_category');
    });

    it('should not save admin_principal or admin_password to the localStorage', function () {
      c.saveServiceConfigProperties(kerberosStepController);
      var saved = c.get('content.serviceConfigProperties');
      expect(saved.everyProperty('value', '')).to.be.true;
    });

    it('should save `isUserProperty` and `isRequired` attributes correctly', function() {
      c.saveServiceConfigProperties(stepController);
      var saved = c.get('content.serviceConfigProperties'),
          nameProp = saved.filterProperty('filename', 'hdfs-site.xml').findProperty('name', 'name'),
          name2Prop = saved.filterProperty('filename', 'hdfs-site.xml').findProperty('name', 'name2');
      assert.isTrue(Em.get(nameProp, 'isRequired'), 'hdfs-site.xml:name isRequired validation');
      assert.isTrue(Em.get(nameProp, 'isUserProperty'), 'hdfs-site.xml:name isUserProperty validation');
      assert.isFalse(Em.get(name2Prop, 'isRequired'), 'hdfs-site.xml:name2 isRequired validation');
      assert.isFalse(Em.get(name2Prop, 'isUserProperty'), 'hdfs-site.xml:name2 isUserProperty validation');
    });
  });

  describe('#enableStep', function () {

    beforeEach(function () {
      c.set('isStepDisabled', [
        Em.Object.create({step: 1, value: true}),
        Em.Object.create({step: 2, value: true}),
        Em.Object.create({step: 3, value: true}),
        Em.Object.create({step: 4, value: true}),
        Em.Object.create({step: 5, value: true}),
        Em.Object.create({step: 6, value: true}),
        Em.Object.create({step: 7, value: true})
      ]);
    });

    it('should update 1st value in isStepDisabled', function () {
      c.enableStep(1);
      expect(c.get('isStepDisabled')[0].get('value')).to.be.false;
    });

    it('should update 6th value in isStepDisabled', function () {
      c.enableStep(7);
      expect(c.get('isStepDisabled')[6].get('value')).to.be.false;
    });

  });

  describe('#allHosts', function () {

    it('should return all hosts', function () {
      var hosts = {
        'h1': {hostComponents: ['c1', 'c2'], disk_info: [{size: 2, available: 1}]},
        'h2': {hostComponents: ['c3', 'c4'], disk_info: [{size: 2, available: 1}]}
      };

      var content = Em.Object.create({
        hosts: hosts
      });

      c.set('content', content);

      var exp = [
        {
          "id": "h1",
          "hostName": "h1",
          "publicHostName": "h1",
          "diskInfo": [
            {
              "size": 2,
              "available": 1
            }
          ],
          "diskTotal": 0.0000019073486328125,
          "diskFree": 9.5367431640625e-7,
          "disksMounted": 1,
          "osType": 0,
          "osArch": 0,
          "ip": 0,
          "hostComponents": [
            {
              "componentName": "c1",
              "displayName": "C1"
            },
            {
              "componentName": "c2",
              "displayName": "C2"
            }
          ]
        },
        {
          "id": "h2",
          "hostName": "h2",
          "publicHostName": "h2",
          "diskInfo": [
            {
              "size": 2,
              "available": 1
            }
          ],
          "diskTotal": 0.0000019073486328125,
          "diskFree": 9.5367431640625e-7,
          "disksMounted": 1,
          "osType": 0,
          "osArch": 0,
          "ip": 0,
          "hostComponents": [
            {
              "componentName": "c3",
              "displayName": "C3"
            },
            {
              "componentName": "c4",
              "displayName": "C4"
            }
          ]
        }
      ];

      var res = JSON.parse(JSON.stringify(c.get('allHosts')));

      expect(res).to.be.eql(exp);
    });
  });

  describe('#getSlaveComponentHosts', function () {
    beforeEach(function () {
      sinon.stub(App.Service, 'find').returns(Em.A([
        Em.Object.create({
          serviceName: 's1'
        })
      ]));
      sinon.stub(App.StackService, 'find').returns(Em.A([
        Em.Object.create({
          serviceName: 's2',
          isSelected: true
        })
      ]));
      sinon.stub(App.StackServiceComponent, 'find').returns(Em.A([
        Em.Object.create({componentName: 'DATANODE', serviceName: 's1', isSlave: true}),
        Em.Object.create({componentName: 'c2', serviceName: 's2', isSlave: true})
      ]));
      sinon.stub(App.HostComponent, 'find').returns(Em.A([
        Em.Object.create({
          componentName: 'DATANODE',
          hostName: 'h1'
        })
      ]));
    });

    afterEach(function () {
      App.Service.find.restore();
      App.HostComponent.find.restore();
      App.StackService.find.restore();
      App.StackServiceComponent.find.restore();
    });

    it('should return slave components', function () {
      var res = JSON.parse(JSON.stringify(c.getSlaveComponentHosts()));
      var exp = [
        {
          "componentName": "DATANODE",
          "displayName": "DataNode",
          "hosts": [
            {
              "group": "Default",
              "hostName": "h1",
              "isInstalled": true
            }
          ],
          "isInstalled": true
        },
        {
          "componentName": "CLIENT",
          "displayName": "Client",
          "hosts": [],
          "isInstalled": true
        },
        {
          "componentName": "c2",
          "displayName": "C2",
          "hosts": [
            {
              "group": "Default",
              "hostName": "h1",
              "isInstalled": false
            }
          ],
          "isInstalled": false
        }
      ];

      expect(res).to.be.eql(exp);
    });

  });

  describe('#setSkipSlavesStep', function () {

    var step = 6,
      cases = [
        {
          services: [
            {
              hasSlave: true,
              hasNonMastersWithCustomAssignment: true
            }
          ],
          skipSlavesStep: false,
          title: 'service with customizable slave selected'
        },
        {
          services: [
            {
              hasClient: true,
              hasNonMastersWithCustomAssignment: true
            }
          ],
          skipSlavesStep: false,
          title: 'service with customizable client selected'
        },
        {
          services: [
            {
              hasSlave: true,
              hasNonMastersWithCustomAssignment: false
            },
            {
              hasClient: true,
              hasNonMastersWithCustomAssignment: false
            }
          ],
          skipSlavesStep: true,
          title: 'no service with customizable slaves or clients selected'
        },
        {
          services: [
            {
              hasSlave: false,
              hasClient: false
            }
          ],
          skipSlavesStep: true,
          title: 'no service with slaves or clients selected'
        }
      ];

    beforeEach(function () {
      c.reopen({
        isStepDisabled: [
          Em.Object.create({
            step: 6
          })
        ],
        content: {}
      });
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        c.setSkipSlavesStep(item.services, step);
        expect(Boolean(c.get('isStepDisabled').findProperty('step', step).get('value'))).to.equal(item.skipSlavesStep);
      });
    });

  });

  describe('#toJSInstance', function () {

    var testCases = [
      {
        o: {'test': 'test'},
        e: {'test': 'test'}
      },
      {
        o: {'test': Em.Object.create()},
        e: {'test': {}}
      },
      {
        o: {'test': Em.Object.create({'test': {}})},
        e: {'test': {'test': {}}}
      },
      {
        o: [],
        e: []
      },
      {
        o: Em.A([[]]),
        e: [[]]
      },
      {
        o: 11,
        e: 11
      },
      {
        o: '11',
        e: '11'
      },
      {
        o: null,
        e: null
      }
    ];

    testCases.forEach(function (testCase, index) {
      it('should convert objects and arrays to pure JS objects and arrays (' + (index + 1) + ')', function () {
        expect(c.toJSInstance(testCase.o)).to.eql(testCase.e);
      });
    });
  });

  describe('#loadConfigThemes', function() {
    beforeEach(function () {
      sinon.stub(wizardController, 'loadConfigThemeForServices').returns({
        always: Em.clb
      });
      sinon.stub(App.themesMapper, 'generateAdvancedTabs').returns(true);
      sinon.stub(App.config, 'loadConfigsFromStack').returns({
        done: Em.clb
      });
      sinon.stub(App.StackService, 'find').returns(Em.A([
        Em.Object.create({
          isSelected: true,
          serviceName: 's1'
        })
      ]));
      this.stub = sinon.stub(App, 'get');
    });
    afterEach(function () {
      App.get.restore();
      App.StackService.find.restore();
      App.config.loadConfigsFromStack.restore();
      App.themesMapper.generateAdvancedTabs.restore();
      wizardController.loadConfigThemeForServices.restore();
    });
    it('Should load config themes', function(done) {
      this.stub.returns(true);
      wizardController.loadConfigThemes().then(function() {
        done();
      });
    });
    it('Should load config themes (2)', function(done) {
      this.stub.returns(false);
      wizardController.loadConfigThemes().then(function() {
        done();
      });
    });
  });

  describe('#dataLoading', function () {
    var clusterController = Em.Object.create({
      isLoaded: false
    });
    beforeEach(function(){
      sinon.stub(App.router,'get').returns(clusterController);
      sinon.stub(wizardController, 'connectOutlet', Em.K);
      clusterController.set('isLoaded', false);
    });
    afterEach(function(){
      App.router.get.restore();
      wizardController.connectOutlet.restore();
    });
    it('should load data', function () {
      clusterController.set('isLoaded', true);
      wizardController.dataLoading().then(function(data){
        expect(data).to.be.undefined;
      });
    });
    it('should load data after 25ms', function () {
      clusterController.set('isLoaded', false);
      setTimeout(function(){
        clusterController.set('isLoaded', true);
      },25);
      wizardController.dataLoading().then(function(data){
        expect(data).to.be.undefined;
      });
    });
  });

  describe('#saveMasterComponentHosts', function () {

    var stepController = Em.Object.create({
        selectedServicesMasters: [
          Em.Object.create({
            display_name: 'd0',
            component_name: 'c0',
            selectedHost: 'h0',
            serviceId: 's0',
            isInstalled: true
          }),
          Em.Object.create({
            display_name: 'd1',
            component_name: 'c1',
            selectedHost: 'h1',
            serviceId: 's1',
            isInstalled: false
          })
        ]
      }),
      masterComponentHosts = [
        {
          display_name: 'd0',
          component: 'c0',
          hostName: 'h0',
          serviceId: 's0',
          isInstalled: true
        },
        {
          display_name: 'd1',
          component: 'c1',
          hostName: 'h1',
          serviceId: 's1',
          isInstalled: false
        }
      ];

    beforeEach(function () {
      sinon.stub(wizardController, 'setDBProperty', Em.K);
    });

    afterEach(function () {
      wizardController.setDBProperty.restore();
    });

    it('should save master component hosts', function () {
      wizardController.saveMasterComponentHosts(stepController);
      expect(wizardController.setDBProperty.calledOnce).to.be.true;
      expect(wizardController.setDBProperty.calledWith('masterComponentHosts', masterComponentHosts)).to.be.true;
      expect(wizardController.get('content.masterComponentHosts')).to.eql(masterComponentHosts);
    });

  });

  describe('#clearMasterComponentHosts', function () {

    beforeEach(function () {
      sinon.stub(wizardController, 'setDBProperty', Em.K);
    });

    afterEach(function () {
      wizardController.setDBProperty.restore();
    });

    it('should clear master component hosts', function () {
      wizardController.set('content.masterComponentHosts', {});
      wizardController.clearMasterComponentHosts();
      expect(wizardController.setDBProperty.calledOnce).to.be.true;
      expect(wizardController.setDBProperty.calledWith('masterComponentHosts', null)).to.be.true;
      expect(wizardController.get('content.masterComponentHosts')).to.be.null;
    });

  });

  describe('#loadRecommendations', function () {

    beforeEach(function () {
      sinon.stub(c, 'getDBProperty').returns({});
    });

    afterEach(function () {
      c.getDBProperty.restore();
    });

    it('should set recommendations', function () {
      c.set('content', {});
      c.loadRecommendations();
      expect(c.get('content.recommendations')).to.eql({});
    });

  });

  describe("#resetOnClose()", function () {
    var ctrl = Em.Object.create({
      finish: Em.K,
      popup: {
        hide: Em.K
      }
    });

    var mock = Em.Object.create({
      resetUser: Em.K
    });

    beforeEach(function () {
      sinon.stub(ctrl, 'finish');
      sinon.stub(ctrl.popup, 'hide');
      sinon.stub(App.router, 'get').returns(mock);
      sinon.stub(App.clusterStatus, 'setClusterStatus', function (arg1, arg2) {
        arg2.alwaysCallback();
      });
      sinon.stub(Em.run, 'next');
      sinon.stub(mock, 'resetUser');
      sinon.stub(App.router, 'transitionTo');

      c.resetOnClose(ctrl, 'path');
    });

    afterEach(function () {
      ctrl.finish.restore();
      ctrl.popup.hide.restore();
      App.router.get.restore();
      App.clusterStatus.setClusterStatus.restore();
      Em.run.next.restore();
      mock.resetUser.restore();
      App.router.transitionTo.restore();
    });

    it("resetUser should be called", function () {
      expect(mock.resetUser.calledOnce).to.be.true;
    });

    it("finish should be called", function () {
      expect(ctrl.finish.calledOnce).to.be.true;
    });

    it("isWorking should be true", function () {
      expect(mock.get('isWorking')).to.be.true;
    });

    it("App.clusterStatus.setClusterStatus should be called", function () {
      expect(App.clusterStatus.setClusterStatus.calledOnce).to.be.true;
    });

    it("popup should be hidden", function () {
      expect(ctrl.get('popup').hide.calledOnce).to.be.true;
    });

    it("App.router.transitionTo should be called", function () {
      expect(App.router.transitionTo.calledOnce).to.be.true;
    });

    it("Em.run.next should be called", function () {
      expect(Em.run.next.calledOnce).to.be.true;
    });
  });

});

});

require.register("test/data/HDP2.2/site_properties_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('utils/helper');
require('data/HDP2/gluster_fs_properties');
var siteProperties = require('data/HDP2.2/site_properties').configProperties;

describe('hdp2SiteProperties', function () {
  /**
   * @stackProperties: All the properties that are derived from stack definition
   */
  var stackProperties = siteProperties.filter(function(item){
    return !(item.isRequiredByAgent === false || item.category === 'Ambari Principals')
  });

  stackProperties.forEach(function(siteProperty){
    /**
     * Following config attributes are stack driven and should be defined in the stack metainfo instead of ambari-web site-properties file
     * isVisible
     * isOverridable
     * value
     * recommendedValue
     * isReconfigurable
     * isRequired
     * displayName
     * description
     * showLabel
     * unit
     */
    describe('Check attributes of "{0}/{1}". Stack driven attributes should be undefined '.format(siteProperty.filename, siteProperty.name), function () {
      ['isVisible', 'value', 'recommendedValue', 'description', 'isReconfigurable', 'isRequired', 'displayName', 'showLabel', 'unit'].forEach(function (p) {
        it(p, function () {
          expect(siteProperty[p]).to.not.exist;
        });
      });
    });

    /**
     * displayTypes <code>supportTextConnection<code> and <code>radio button<code>
     * can be used as exception. Other displayTypes values should be used in stack definition
     */
    it('Check attributes of "{0}/{1}". Display type value {2} should be described in stack '.format(siteProperty.filename, siteProperty.name, siteProperty.displayType), function () {
      expect(siteProperty.displayType).to.match(/undefined|supportTextConnection|radio button/);
    });

    /**
     * Following config attributes uniquely represent a config property
     * name
     * filename
     */
    describe('Check primary attributes of "{0}/{1}". Attributes that uniquely represent a property should be defined '.format(siteProperty.filename, siteProperty.name), function () {
      it('name', function () {
        expect(siteProperty.name).to.not.equal(undefined);
      });
      it('filename', function () {
        expect(siteProperty.filename).to.not.equal(undefined);
      });
    });
  });

});
});

require.register("test/data/HDP2.3/site_properties_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('utils/helper');
require('data/HDP2/gluster_fs_properties');
var siteProperties = require('data/HDP2.3/site_properties').configProperties;

describe('hdp2SiteProperties', function () {
  /**
   * @stackProperties: All the properties that are derived from stack definition
   */
  var stackProperties = siteProperties.filter(function(item){
    return !(item.isRequiredByAgent === false || item.category === 'Ambari Principals')
  });

  stackProperties.forEach(function(siteProperty){
    /**
     * Following config attributes are stack driven and should be defined in the stack metainfo instead of ambari-web site-properties file
     * isVisible
     * isOverridable
     * value
     * recommendedValue
     * isReconfigurable
     * isRequired
     * displayName
     * description
     * showLabel
     * unit
     */
    describe('Check attributes of "{0}/{1}". Stack driven attributes should be undefined '.format(siteProperty.filename, siteProperty.name), function () {
      ['isVisible', 'value', 'recommendedValue', 'description', 'isReconfigurable', 'isRequired', 'displayName', 'showLabel', 'unit'].forEach(function (p) {
        it(p, function () {
          expect(siteProperty[p]).to.not.exist;
        });
      });
    });


    /**
     * displayTypes <code>supportTextConnection<code> and <code>radio button<code>
     * can be used as exception. Other displayTypes values should be used in stack definition
     */
    it('Check attributes of "{0}/{1}". Display type value {2} should be described in stack '.format(siteProperty.filename, siteProperty.name, siteProperty.displayType), function () {
      expect(siteProperty.displayType).to.match(/undefined|supportTextConnection|radio button/);
    });

    /**
     * Following config attributes uniquely represent a config property
     * name
     * filename
     */
    describe('Check primary attributes of "{0}/{1}". Attributes that uniquely represent a property should be defined '.format(siteProperty.filename, siteProperty.name), function () {
      it('name', function () {
        expect(siteProperty.name).to.not.equal(undefined);
      });
      it('filename', function () {
        expect(siteProperty.filename).to.not.equal(undefined);
      });
    });
  });

});

});

require.register("test/data/HDP2/secure_mapping_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('utils/helper');
var mappedHdp2Properties = require('data/HDP2/secure_mapping');

describe('hdp2SiteMapping', function () {

  // All mapped properties should have value of string type
  mappedHdp2Properties.forEach(function(mappedProperty){
    it('Value of "{0}" should be string'.format(mappedProperty.name), function () {
      expect(mappedProperty.value).to.be.a('string');
    });
  });
  mappedHdp2Properties.forEach(function(mappedProperty){
    it('Value of "{0}" should have serviceName and filename attribute'.format(mappedProperty.name), function () {
      expect(mappedProperty).to.have.property('serviceName');
      expect(mappedProperty).to.have.property('filename');
    });
  });
});
});

require.register("test/data/HDP2/site_properties_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('utils/helper');
require('data/HDP2/gluster_fs_properties');
var siteProperties = require('data/HDP2/site_properties').configProperties;

describe('hdp2SiteProperties', function () {
  /**
   * @stackProperties: All the properties that are derived from stack definition
   */
  var stackProperties = siteProperties.filter(function(item){
    return !(item.isRequiredByAgent === false || item.category === 'Ambari Principals')
  });

  stackProperties.forEach(function(siteProperty){
    /**
     * Following config attributes are stack driven and should be defined in the stack metainfo instead of ambari-web site-properties file
     * isVisible
     * isOverridable
     * value
     * recommendedValue
     * isReconfigurable
     * isRequired
     * displayName
     * description
     * showLabel
     * unit
     */
    describe('Check attributes of "{0}/{1}". Stack driven attributes should be undefined '.format(siteProperty.filename, siteProperty.name), function () {
      ['isVisible', 'value', 'recommendedValue', 'description', 'isReconfigurable', 'isRequired', 'displayName', 'showLabel', 'unit'].forEach(function (p) {
        it(p, function () {
          expect(siteProperty[p]).to.not.exist;
        });
      });
    });

    /**
     * displayTypes <code>supportTextConnection<code> and <code>radio button<code>
     * can be used as exception. Other displayTypes values should be used in stack definition
     */
    it('Check attributes of "{0}/{1}". Display type value {2} should be described in stack '.format(siteProperty.filename, siteProperty.name, siteProperty.displayType), function () {
      expect(siteProperty.displayType).to.match(/undefined|supportTextConnection|radio button/);
    });

    /**
     * Following config attributes uniquely represent a config property
     * name
     * filename
     */
    describe('Check primary attributes of "{0}/{1}". Attributes that uniquely represent a property should be defined '.format(siteProperty.filename, siteProperty.name), function () {
      it('name', function () {
        expect(siteProperty.name).to.not.equal(undefined);
      });
      it('filename', function () {
        expect(siteProperty.filename).to.not.equal(undefined);
      });
    });
  });

});
});

require.register("test/helpers", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

module.exports = {

  /**
   * Examples:
   * <code>
   *   var actual = [{a:1, b: [1, 2], c: 3}],
   *    expected = [{a: 1, b: [1, 2]}];
   *  nestedExpect(expected, actual); // valid
   * </code>
   *
   * <code>
   *   var actual = [{a:1, b: [1, 2]}],
   *    expected = [{a: 1, b: [1, 2], c: 3}];
   *  nestedExpect(expected, actual); // invalid valid (actual[0] doesn't contains key 'c)
   * </code>
   * @param {object[]} expected
   * @param {object[]} actual
   * @method nestedExpect
   */
  nestedExpect: function (expected, actual) {
    expected.forEach(function (group, i) {
      Em.keys(group).forEach(function (key) {
        if (Em.isArray(actual[i][key])) {
          expect(group[key]).to.eql(actual[i][key].toArray());
        }
        else {
          expect(group[key]).to.equal(actual[i][key]);
        }
      });
    });
  },

  /**
   * Get arguments for one <code>App.ajax.send</code> call according to the criteria
   * Example:
   * <pre>
   *  sinon.stub(App.ajax, 'send', Em.K);
   *  App.ajax.send({
   *    name: 'n1',
   *    sender: {},
   *    data: {
   *      f1: 'v1',
   *      f2: 'v2'
   *    }
   *  });
   *  App.ajax.send({
   *    name: 'n2',
   *    sender: {}
   *  });
   *  var args = findAjaxRequest('name', 'n1');
   *  console.log(args); // [{name: 'n1', sender: {}, data: {f1: 'v1', f2: 'v2'}}]
   *  App.ajax.send.restore();
   * </pre>
   *
   * @param {string} property field to find
   * @param {*} value value to find
   * @returns {array|null}
   */
  findAjaxRequest: function(property, value) {
    if (!Em.isArray(App.ajax.send.args)) {
      return null;
    }
    return App.ajax.send.args.find(function (request) {
      return Em.get(request[0], property) === value;
    });
  },

  /**
   * Get arguments for several <code>App.ajax.send</code> calls according to the criteria
   * Example:
   * <pre>
   *  sinon.stub(App.ajax, 'send', Em.K);
   *  App.ajax.send({
   *    name: 'n1',
   *    sender: {},
   *    data: {
   *      f1: 'v1',
   *      f2: 'v2'
   *    }
   *  });
   *  App.ajax.send({
   *    name: 'n2',
   *    sender: {}
   *  });
   *  App.ajax.send({
   *    name: 'n2',
   *    sender: {},
   *    data: {
   *      d1: 1234
   *    }
   *  });
   *  var args = filterAjaxRequests('name', 'n2');
   *  console.log(args); // [[{name: 'n1', sender: {}}], [{name: 'n2', sender: {}, data: {d1: 1234}}]]
   *  App.ajax.send.restore();
   * </pre>
   *
   * @param {string} property field to filter
   * @param {*} value value to filter
   * @returns {array}
   */
  filterAjaxRequests: function (property, value) {
    if (!Em.isArray(App.ajax.send.args)) {
      return [];
    }
    return App.ajax.send.args.filter(function (request) {
      return Em.get(request[0], property) === value;
    });
  }

};
});

require.register("test/init_computed_aliases", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 *
 *
 * @class App.TestAliases
 */
App.TestAliases = {
  helpers: {

    /**
     * Get needed value (basing on <code>key</code>) from <code>self</code> or <code>App</code>
     *
     * @param {Ember.Object} self
     * @param {string} key
     * @returns {*}
     */
    smartGet: function (self, key) {
      var isApp = key.startsWith('App.');
      var name = isApp ? key.replace('App.', '') : key;
      return isApp ? App.get(name) : self.get(name);
    },

    /**
     * Stub <code>get</code> for <code>App</code> or <code>self</code>
     *
     * @returns {App.TestAliases}
     */
    smartStubGet: function () {
      var args = [].slice.call(arguments);
      if (args.length === 3) {
        return this._stubOneKey.apply(this, args);
      }
      return this._stubManyKeys.apply(this, args)
    },

    /**
     * Trigger recalculation of the needed property in the <code>self</code>
     * or in the <code>App</code> (depends on <code>propertyName</code>)
     *
     * @param {Ember.Object} self
     * @param {string} propertyName
     * @returns {App.TestAliases}
     */
    propertyDidChange: function (self, propertyName) {
      var isApp = propertyName.startsWith('App.');
      var name = isApp ? propertyName.replace('App.', '') : propertyName;
      var context = isApp ? App : self;
      Em.propertyDidChange(context, name);
      return this;
    },

    /**
     * Try to restore (@see sinon.restore) <code>get</code> for <code>App</code> and <code>context</code>
     *
     * @param {Ember.Object} context
     * @returns {App.TestAliases}
     */
    smartRestoreGet: function(context) {
      Em.tryInvoke(context.get, 'restore');
      Em.tryInvoke(App.get, 'restore');
      return this;
    },

    /**
     * Stub <code>get</code>-method for <code>App</code> or <code>self</code> (depends on <code>dependentKey</code>)
     * to return <code>value</code> if <code>dependentKey</code> is get
     *
     * @param {Ember.Object} self
     * @param {string} dependentKey
     * @param {*} value
     * @returns {App.TestAliases}
     * @private
     */
    _stubOneKey: function (self,dependentKey, value) {
      var isApp = dependentKey.startsWith('App.');
      var name = isApp ? dependentKey.replace('App.', '') : dependentKey;
      var context = isApp ? App : self;
      sinon.stub(context, 'get', function (k) {
        return k === name ? value : Em.get(context, k);
      });
      return this;
    },

    /**
     * Stub <code>get</code>-method for <code>App</code> or <code>self</code> (depends on </code>hash</code>-keys)
     * If some key is starts with 'App.' it will be used in the App-stub,
     * otherwise it will be used in thw self-stub
     *
     * @param {Ember.Object} self
     * @param {object} hash
     * @returns {App.TestAliases}
     * @private
     */
    _stubManyKeys: function (self, hash) {
      var hashForApp = {}; // used in the App-stub
      var hashForSelf = {}; // used in the self-stub
      Object.keys(hash).forEach(function(key) {
        var isApp = key.startsWith('App.');
        var name = isApp ? key.replace('App.', '') : key;
        if(isApp) {
          hashForApp[name] = hash[key];
        }
        else {
          hashForSelf[name] = hash[key];
        }
      });
      sinon.stub(App, 'get', function (k) {
        if (hashForApp.hasOwnProperty(k)) {
          return hashForApp[k];
        }
        return Em.get(App, k);
      });
      sinon.stub(self, 'get', function (k) {
        if (hashForSelf.hasOwnProperty(k)) {
          return hashForSelf[k];
        }
        return Em.get(self, k);
      });
      return this;
    },

    /**
     * Generates array of all possible boolean combinations
     * Example:
     * <code>
     *   var keys = ['a', 'b'];
     *   var result = getBinaryCombos(keys);
     *   console.log(result); // [{a: true, b: true}, {a: true, b: false}, {a: false, b: true}, {a: false, b: false}]
     * </code>
     *
     * @param {string[]} dependentKeys
     * @returns {Array}
     */
    getBinaryCombos: function (dependentKeys) {
      var n = dependentKeys.length;
      var result = [];
      var allCombos = Math.pow(2, n);
      for (var y = 0; y < allCombos; y++) {
        var combo = {};
        for (var x = 0; x < n; x++) {
          combo[dependentKeys[x]] = !!(y >> x & 1);
        }
        result.push(combo);
      }
      return result;
    }

  }
};

require('test/aliases/computed/equal');
require('test/aliases/computed/notEqual');
require('test/aliases/computed/equalProperties');
require('test/aliases/computed/notEqualProperties');
require('test/aliases/computed/ifThenElse');
require('test/aliases/computed/sumProperties');
require('test/aliases/computed/countBasedMessage');
require('test/aliases/computed/firstNotBlank');
require('test/aliases/computed/percents');
require('test/aliases/computed/existsIn');
require('test/aliases/computed/notExistsIn');
require('test/aliases/computed/alias');
require('test/aliases/computed/gte');
require('test/aliases/computed/gt');
require('test/aliases/computed/gteProperties');
require('test/aliases/computed/gtProperties');
require('test/aliases/computed/lte');
require('test/aliases/computed/lt');
require('test/aliases/computed/lteProperties');
require('test/aliases/computed/ltProperties');
require('test/aliases/computed/someBy');
require('test/aliases/computed/someByKey');
require('test/aliases/computed/everyBy');
require('test/aliases/computed/everyByKey');
require('test/aliases/computed/mapBy');
require('test/aliases/computed/filterBy');
require('test/aliases/computed/filterByKey');
require('test/aliases/computed/findBy');
require('test/aliases/computed/findByKey');
require('test/aliases/computed/sumBy');
require('test/aliases/computed/and');
require('test/aliases/computed/or');
require('test/aliases/computed/formatUnavailable');
require('test/aliases/computed/getByKey');
require('test/aliases/computed/truncate');
});

require.register("test/init_model_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/stack_service_component');
require('mappers/server_data_mapper');
require('mappers/stack_service_mapper');

module.exports = {
  setupStackServiceComponent: function() {
    /**
     * initialization of App.StackServiceComponent and App.StackService models
     * @type {*}
     */
    App.stackServiceMapper.map(require('test/service_components'));
  },
  cleanStackServiceComponent: function() {
    App.StackServiceComponent.find().set('content',[]);
    App.StackService.find().set('content',[]);
  },
  setupStackVersion: function(context, version) {
    context.prevStackVersion = App.get('currentStackVersion');
    App.set('currentStackVersion', version);
  },
  restoreStackVersion: function(context) {
    App.set('currentStackVersion', context.prevStackVersion);
  },
  configs: require('test/mock_data_setup/configs_mock_data'),
  /**
   * Delete record from DS.Store and set its stateManager to proper state
   * @param {DS.Model} record
   * @method deleteRecord
   */
  deleteRecord: function (record) {
    record.deleteRecord();
    record.get('stateManager').transitionTo('loading');
  }
};
});

require.register("test/init_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//
/**
 * Function.prototype.bind is not available in PhantomJS
 * Polyfill used instead: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
 */
if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
      fToBind = this,
      fNOP = function() {},
      fBound = function() {
        return fToBind.apply(this instanceof fNOP
            ? this
            : oThis,
          aArgs.concat(Array.prototype.slice.call(arguments)));
      };

    if (this.prototype) {
      // native functions don't have a prototype
      fNOP.prototype = this.prototype;
    }
    fBound.prototype = new fNOP();

    return fBound;
  };
}

Number.isFinite = Number.isFinite || function(value) {
  return typeof value === 'number' && isFinite(value);
};
});

require.register("test/login_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('controllers/login_controller');

describe('App.LoginController', function () {
  describe('#validateCredentials()', function () {});
});

});

require.register("test/mappers/alert_definition_summary_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');

require('mappers/alert_definition_summary_mapper');

describe('App.alertDefinitionSummaryMapper', function () {

  describe('#map', function () {

    var testModels = [
        App.AlertDefinition.createRecord({id: 1, enabled: true, type: 'PORT'}),
        App.AlertDefinition.createRecord({id: 2, enabled: true, type: 'METRICS'}),
        App.AlertDefinition.createRecord({id: 3, enabled: true, type: 'WEB'}),
        App.AlertDefinition.createRecord({id: 4, enabled: true, type: 'AGGREGATE'}),
        App.AlertDefinition.createRecord({id: 5, enabled: true, type: 'SCRIPT'}),
        App.AlertDefinition.createRecord({id: 6, enabled: false, type: 'SCRIPT', summary: {OK: 1}})
      ],
      dataToMap = {
        alerts_summary_grouped: [
          {
            definition_id: 1,
            summary: {
              OK: {
                count: 1,
                original_timestamp: 1,
                maintenance_count: 0,
                latest_text: "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"
              },
              WARNING: {
                count: 1,
                original_timestamp: 2,
                maintenance_count: 0,
                latest_text: "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"
              },
              CRITICAL: {count: 0, original_timestamp: 0, maintenance_count: 1},
              UNKNOWN: {count: 0, original_timestamp: 0, maintenance_count: 0}
            }
          },
          {
            definition_id: 2,
            summary: {
              OK: {
                count: 1,
                original_timestamp: 1,
                maintenance_count: 0,
                latest_text: "HTTP 200 response in 0.000 seconds"
              },
              WARNING: {
                count: 5,
                original_timestamp: 2,
                maintenance_count: 0,
                latest_text: "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"
              },
              CRITICAL: {count: 1, original_timestamp: 1, maintenance_count: 0},
              UNKNOWN: {count: 1, original_timestamp: 3, maintenance_count: 0}
            }
          },
          {
            definition_id: 3,
            summary: {
              OK: {
                count: 1,
                original_timestamp: 1,
                maintenance_count: 0,
                latest_text: "HTTP 200 response in 0.000 seconds"
              },
              WARNING: {count: 2, original_timestamp: 2, maintenance_count: 2},
              CRITICAL: {
                count: 3,
                original_timestamp: 4,
                maintenance_count: 0,
                latest_text: "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"
              },
              UNKNOWN: {count: 4, original_timestamp: 3, maintenance_count: 0}
            }
          },
          {
            definition_id: 4,
            summary: {
              OK: {
                count: 4,
                original_timestamp: 1,
                maintenance_count: 0,
                latest_text: "HTTP 200 response in 0.000 seconds"
              },
              WARNING: {count: 3, original_timestamp: 2, maintenance_count: 0},
              CRITICAL: {count: 2, original_timestamp: 1, maintenance_count: 0},
              UNKNOWN: {
                count: 1,
                original_timestamp: 2,
                maintenance_count: 0,
                latest_text: "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"
              }
            }
          },
          {
            definition_id: 5,
            summary: {
              OK: {
                count: 1,
                original_timestamp: 1,
                maintenance_count: 0,
                latest_text: "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"
              },
              WARNING: {count: 1, original_timestamp: 2, maintenance_count: 0},
              CRITICAL: {count: 1, original_timestamp: 3, maintenance_count: 0},
              UNKNOWN: {count: 1, original_timestamp: 4, maintenance_count: 0}
            }
          }
        ]
      };

    beforeEach(function () {
      sinon.stub(App.AlertDefinition, 'find').returns(testModels);
      App.alertDefinitionSummaryMapper.map(dataToMap);
    });

    afterEach(function () {
      App.AlertDefinition.find.restore();
    });

    it('should map summary info for 1st alert', function () {
      expect(App.AlertDefinition.find().findProperty('id', 1).get('lastTriggered')).to.equal(2);
      expect(App.AlertDefinition.find().findProperty('id', 1).get('summary')).to.eql({
        OK: {
          count: 1,
          maintenanceCount: 0,
          latestText: "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"
        },
        WARNING: {
          count: 1,
          maintenanceCount: 0,
          latestText: "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"
        },
        CRITICAL: {count: 0, maintenanceCount: 1},
        UNKNOWN: {count: 0, maintenanceCount: 0}
      });
    });

    it('should map summary info for 2nd alert', function () {
      expect(App.AlertDefinition.find().findProperty('id', 2).get('lastTriggered')).to.equal(3);
      expect(App.AlertDefinition.find().findProperty('id', 2).get('summary')).to.eql({
        OK: {
          count: 1,
          maintenanceCount: 0,
          latestText: "HTTP 200 response in 0.000 seconds"
        },
        WARNING: {
          count: 5,
          maintenanceCount: 0,
          latestText: "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"
        },
        CRITICAL: {count: 1, maintenanceCount: 0},
        UNKNOWN: {count: 1, maintenanceCount: 0}
      });
    });

    it('should map summary info for 3rd alert', function () {
      expect(App.AlertDefinition.find().findProperty('id', 3).get('lastTriggered')).to.equal(4);
      expect(App.AlertDefinition.find().findProperty('id', 3).get('summary')).to.eql({
        OK: {
          count: 1,
          maintenanceCount: 0,
          latestText: "HTTP 200 response in 0.000 seconds"
        },
        WARNING: {count: 2, maintenanceCount: 2},
        CRITICAL: {
          count: 3,
          maintenanceCount: 0,
          latestText: "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"
        },
        UNKNOWN: {count: 4, maintenanceCount: 0}
      });
    });

    it('should map summary info for 4th alert', function () {
      expect(App.AlertDefinition.find().findProperty('id', 4).get('lastTriggered')).to.equal(2);
      expect(App.AlertDefinition.find().findProperty('id', 4).get('summary')).to.eql({
        OK: {
          count: 4,
          maintenanceCount: 0,
          latestText: "HTTP 200 response in 0.000 seconds"
        },
        WARNING: {count: 3, maintenanceCount: 0},
        CRITICAL: {count: 2, maintenanceCount: 0},
        UNKNOWN: {
          count: 1,
          maintenanceCount: 0,
          latestText: "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"
        }
      });
    });

    it('should map summary info for 5th alert', function () {
      expect(App.AlertDefinition.find().findProperty('id', 5).get('lastTriggered')).to.equal(4);
      expect(App.AlertDefinition.find().findProperty('id', 5).get('summary')).to.eql({
        OK: {
          count: 1,
          maintenanceCount: 0,
          latestText: "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"
        },
        WARNING: {count: 1, maintenanceCount: 0},
        CRITICAL: {count: 1, maintenanceCount: 0},
        UNKNOWN: {count: 1, maintenanceCount: 0}
      });
    });

    it('should clear summary for disabled definitions', function () {
      expect(App.AlertDefinition.find().findProperty('id', 6).get('summary')).to.eql({});
    });

  });

});
});

require.register("test/mappers/alert_definitions_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');

require('mappers/alert_definitions_mapper');
var testHelpers = require('test/helpers');

describe('App.alertDefinitionsMapper', function () {
  /*eslint-disable mocha-cleanup/asserts-limit */
  describe('#map', function () {

    var json = {
      items: [
        {
          "AlertDefinition" : {
            "component_name" : "RESOURCEMANAGER",
            "enabled" : true,
            "id" : 1,
            "ignore_host" : false,
            "interval" : 5,
            "label" : "ResourceManager RPC Latency",
            "name" : "yarn_resourcemanager_rpc_latency",
            "description" : "some description",
            "scope" : "ANY",
            "service_name" : "YARN",
            "source" : {
              "jmx" : {
                "property_list" : [
                  "Hadoop:service=ResourceManager,name=RpcActivityForPort*/RpcQueueTimeAvgTime",
                  "Hadoop:service=ResourceManager,name=RpcActivityForPort*/RpcProcessingTimeAvgTime"
                ],
                "value" : "{0}"
              },
              "reporting" : {
                "ok" : {
                  "text" : "Average Queue Time:[{0}], Average Processing Time:[{1}]"
                },
                "warning" : {
                  "text" : "Average Queue Time:[{0}], Average Processing Time:[{1}]",
                  "value" : 3000.0
                },
                "critical" : {
                  "text" : "Average Queue Time:[{0}], Average Processing Time:[{1}]",
                  "value" : 5000.0
                }
              },
              "type" : "METRIC",
              "uri" : {
                "http" : "{{yarn-site/yarn.resourcemanager.webapp.address}}",
                "https" : "{{yarn-site/yarn.resourcemanager.webapp.https.address}}",
                "https_property" : "{{yarn-site/yarn.http.policy}}",
                "https_property_value" : "HTTPS_ONLY",
                "default_port" : 0.0
              }
            }
          }
        },
        {
          "AlertDefinition" : {
            "component_name" : "RESOURCEMANAGER",
            "enabled" : true,
            "id" : 2,
            "ignore_host" : false,
            "interval" : 1,
            "label" : "ResourceManager Web UI",
            "name" : "yarn_resourcemanager_webui",
            "description" : "",
            "scope" : "ANY",
            "service_name" : "YARN",
            "source" : {
              "reporting" : {
                "ok" : {
                  "text" : "HTTP {0} response in {2:.4f} seconds"
                },
                "warning" : {
                  "text" : "HTTP {0} response in {2:.4f} seconds"
                },
                "critical" : {
                  "text" : "Connection failed to {1}"
                }
              },
              "type" : "WEB",
              "uri" : {
                "http" : "{{yarn-site/yarn.resourcemanager.webapp.address}}",
                "https" : "{{yarn-site/yarn.resourcemanager.webapp.https.address}}",
                "https_property" : "{{yarn-site/yarn.http.policy}}",
                "https_property_value" : "HTTPS_ONLY",
                "connection_timeout" : 5.0,
                "default_port" : 0.0
              }
            }
          }
        },
        {
          "AlertDefinition" : {
            "component_name" : null,
            "enabled" : true,
            "id" : 3,
            "ignore_host" : false,
            "interval" : 1,
            "label" : "Percent NodeManagers Available",
            "name" : "yarn_nodemanager_webui_percent",
            "description" : null,
            "scope" : "SERVICE",
            "service_name" : "YARN",
            "source" : {
              "alert_name" : "yarn_nodemanager_webui",
              "reporting" : {
                "ok" : {
                  "text" : "affected: [{1}], total: [{0}]"
                },
                "warning" : {
                  "text" : "affected: [{1}], total: [{0}]",
                  "value" : 0.1
                },
                "critical" : {
                  "text" : "affected: [{1}], total: [{0}]",
                  "value" : 0.3
                }
              },
              "type" : "AGGREGATE"
            }
          }
        },
        {
          "AlertDefinition" : {
            "component_name" : "NODEMANAGER",
            "enabled" : true,
            "id" : 4,
            "ignore_host" : false,
            "interval" : 1,
            "label" : "NodeManager Health",
            "name" : "yarn_nodemanager_health",
            "description" : "some description",
            "scope" : "HOST",
            "service_name" : "YARN",
            "source" : {
              "parameters" : [
                {
                  "name" : "connection.timeout",
                  "display_name" : "Connection Timeout",
                  "units" : "seconds",
                  "value" : 5.0,
                  "description" : "The maximum time before this alert is considered to be CRITICAL",
                  "type" : "NUMERIC",
                  "threshold" : "CRITICAL"
                }
              ],
              "path" : "HDP/2.0.6/services/YARN/package/files/alert_nodemanager_health.py",
              "type" : "SCRIPT"
            }
          }
        },
        {
          "AlertDefinition" : {
            "component_name" : "ZOOKEEPER_SERVER",
            "enabled" : true,
            "id" : 5,
            "ignore_host" : false,
            "interval" : 1,
            "label" : "ZooKeeper Server Process",
            "name" : "zookeeper_server_process",
            "description" : "some description",
            "scope" : "ANY",
            "service_name" : "ZOOKEEPER",
            "source" : {
              "default_port" : 2181.0,
              "reporting" : {
                "ok" : {
                  "text" : "TCP OK - {0:.4f} response on port {1}"
                },
                "critical" : {
                  "text" : "Connection failed: {0} to {1}:{2}"
                }
              },
              "type" : "PORT",
              "uri" : "{{zookeeper-env/clientPort}}"
            }
          }
        },
        {
          "AlertDefinition" : {
            "component_name" : "NAMENODE",
            "description" : "This service-level alert is triggered if the NN heap usage deviation has grown beyond the specified threshold within a given time interval.",
            "enabled" : true,
            "help_url" : "http://test.test",
            "id" : 6,
            "ignore_host" : false,
            "interval" : 1,
            "label" : "NameNode Heap Usage (Hourly)",
            "name" : "namenode_free_heap_size_deviation_percentage",
            "repeat_tolerance" : 1,
            "repeat_tolerance_enabled" : true,
            "scope" : "SERVICE",
            "service_name" : "HDFS",
            "source" : {
              "ams" : {
                "metric_list" : [
                  "jvm.JvmMetrics.MemHeapUsedM",
                  "jvm.JvmMetrics.MemHeapMaxM"
                ],
                "value" : "{1} - {0}",
                "interval" : 60.0,
                "compute" : "sample_standard_deviation_percentage",
                "app_id" : "NAMENODE",
                "minimum_value" : 1.0
              },
              "reporting" : {
                "ok" : {
                  "text" : "The sample standard deviation percentage is {0}%"
                },
                "warning" : {
                  "text" : "The sample standard deviation percentage is {0}%",
                  "value" : 20.0
                },
                "critical" : {
                  "text" : "The sample standard deviation percentage is {0}%",
                  "value" : 50.0
                },
                "units" : "%"
              },
              "type" : "AMS",
              "uri" : {
                "http" : "{{ams-site/timeline.metrics.service.webapp.address}}",
                "https" : "{{ams-site/timeline.metrics.service.webapp.address}}",
                "https_property" : "{{ams-site/timeline.metrics.service.http.policy}}",
                "https_property_value" : "HTTPS_ONLY",
                "default_port" : 0.0,
                "connection_timeout" : 5.0
              }
            }
          }
        }
      ]
    };

    beforeEach(function () {

      App.alertDefinitionsMapper.setProperties({
        'model': {},
        'parameterModel': {},
        'reportModel': {},
        'metricsSourceModel': {},
        'metricsUriModel': {},
        'metricsAmsModel': {}
      });

      sinon.stub(App.alertDefinitionsMapper, 'deleteRecord', Em.K);

      sinon.stub(App.store, 'commit', Em.K);
      sinon.stub(App.store, 'loadMany', function (type, content) {
        type.content = content;
      });

      sinon.stub(App.router, 'get', function() {return false;});
      App.cache.previousAlertGroupsMap = {};

      sinon.stub(App.alertDefinitionsMapper, 'setMetricsSourcePropertyLists', Em.K);
      sinon.stub(App.alertDefinitionsMapper, 'setAlertDefinitionsRawSourceData', Em.K);

    });

    afterEach(function () {

      App.store.commit.restore();
      App.store.loadMany.restore();

      App.alertDefinitionsMapper.setProperties({
        'model': App.AlertDefinition,

        'reportModel': App.AlertReportDefinition,
        'metricsSourceModel': App.AlertMetricsSourceDefinition,
        'metricsUriModel': App.AlertMetricsUriDefinition,
        'metricsAmsModel': App.AlertMetricsAmsDefinition
      });

      App.alertDefinitionsMapper.deleteRecord.restore();

      App.router.get.restore();
      App.cache.previousAlertGroupsMap = {};

      App.alertDefinitionsMapper.setMetricsSourcePropertyLists.restore();
      App.alertDefinitionsMapper.setAlertDefinitionsRawSourceData.restore();

    });

    describe('should parse METRIC alertDefinitions', function () {

      var data = {items: [json.items[0]]},
        expected = [{
          id: 1,
          "name": "yarn_resourcemanager_rpc_latency",
          "label": "ResourceManager RPC Latency",
          "description" : "some description",
          "service_id": "YARN",
          "component_name": "RESOURCEMANAGER",
          "enabled": true,
          "scope": "ANY",
          "interval": 5,
          "type": "METRIC",
          "jmx_id": "1jmx",
          "uri_id": "1uri"
        }],
        expectedMetricsSource = [{
          "id":"1jmx",
          "value":"{0}",
          "property_list":[
            "Hadoop:service=ResourceManager,name=RpcActivityForPort*/RpcQueueTimeAvgTime",
            "Hadoop:service=ResourceManager,name=RpcActivityForPort*/RpcProcessingTimeAvgTime"
          ]
        }],
        expectedMetricsUri = [{
          "id":"1uri",
          "http":"{{yarn-site/yarn.resourcemanager.webapp.address}}",
          "https":"{{yarn-site/yarn.resourcemanager.webapp.https.address}}",
          "https_property":"{{yarn-site/yarn.http.policy}}",
          "https_property_value":"HTTPS_ONLY"
        }];


      beforeEach(function () {

        App.alertDefinitionsMapper.map(data);

      });

      it('parsing metrics model', function() {
        testHelpers.nestedExpect(expected, App.alertDefinitionsMapper.get('model.content'));
      });

      it('parse metrics source', function() {
        testHelpers.nestedExpect(expectedMetricsSource, App.alertDefinitionsMapper.get('metricsSourceModel.content'));
      });

      it('parse metrics uri', function() {
        testHelpers.nestedExpect(expectedMetricsUri, App.alertDefinitionsMapper.get('metricsUriModel.content'));
      });

    });

    describe('should parse WEB alertDefinitions', function () {

      var data = {items: [json.items[1]]},
        expected = [
          {
            "id": 2,
            "name": "yarn_resourcemanager_webui",
            "label": "ResourceManager Web UI",
            "description" : "",
            "service_id": "YARN",
            "component_name": "RESOURCEMANAGER",
            "enabled": true,
            "scope": "ANY",
            "interval": 1,
            "type": "WEB",
            "uri_id": "2uri"
          }
        ],
        expectedMetricsUri = [{
          "id":"2uri",
          "http":"{{yarn-site/yarn.resourcemanager.webapp.address}}",
          "https":"{{yarn-site/yarn.resourcemanager.webapp.https.address}}",
          "https_property":"{{yarn-site/yarn.http.policy}}",
          "https_property_value":"HTTPS_ONLY",
          "connection_timeout" : 5.0
        }];

      beforeEach(function () {

        App.alertDefinitionsMapper.map(data);

      });

      it('parsing web model', function() {
        testHelpers.nestedExpect(expected, App.alertDefinitionsMapper.get('model.content'));
      });


      it('parse metrics uri', function() {
        testHelpers.nestedExpect(expectedMetricsUri, App.alertDefinitionsMapper.get('metricsUriModel.content'));
      });

    });

    it('should parse AGGREGATE alertDefinitions', function () {

      var data = {items: [json.items[2]]},
        expected = [
          {
            "id":3,
            "name":"yarn_nodemanager_webui_percent",
            "label":"Percent NodeManagers Available",
            "description" : "",
            "service_id":"YARN",
            "component_name":null,
            "enabled":true,
            "scope":"SERVICE",
            "interval":1,
            "type":"AGGREGATE",
            "alert_name":"yarn_nodemanager_webui"
          }
        ];
      App.alertDefinitionsMapper.map(data);

      testHelpers.nestedExpect(expected, App.alertDefinitionsMapper.get('model.content'));

    });

    describe('should parse SCRIPT alertDefinitions', function () {

      var data = {items: [json.items[3]]},
        expected = [
          {
            "id":4,
            "name":"yarn_nodemanager_health",
            "label":"NodeManager Health",
            "description" : "some description",
            "service_id":"YARN",
            "component_name":"NODEMANAGER",
            "enabled":true,
            "scope":"HOST",
            "interval":1,
            "type":"SCRIPT",
            "location":"HDP/2.0.6/services/YARN/package/files/alert_nodemanager_health.py"
          }
        ];

      var expectedParameters = [{
        "id": "4connection.timeout",
        "name": "connection.timeout",
        "display_name": "Connection Timeout",
        "units": "seconds",
        "value": 5,
        "description": "The maximum time before this alert is considered to be CRITICAL",
        "type": "NUMERIC",
        "threshold": "CRITICAL"
      }];

      beforeEach(function () {
        App.alertDefinitionsMapper.map(data);
      });

      it('should map definition', function () {
        testHelpers.nestedExpect(expected, App.alertDefinitionsMapper.get('model.content'));
      });

      it('should map parameters', function () {
        testHelpers.nestedExpect(expectedParameters, App.alertDefinitionsMapper.get('parameterModel.content'));
      });

    });

    it('should parse PORT alertDefinitions', function () {

      var data = {items: [json.items[4]]},
        expected = [
          {
            "id":5,
            "name":"zookeeper_server_process",
            "label":"ZooKeeper Server Process",
            "description" : "some description",
            "service_id":"ZOOKEEPER",
            "component_name":"ZOOKEEPER_SERVER",
            "enabled":true,
            "scope":"ANY",
            "interval":1,
            "type":"PORT",
            "default_port":2181,
            "port_uri":"{{zookeeper-env/clientPort}}"
          }
        ];
      App.alertDefinitionsMapper.map(data);

      testHelpers.nestedExpect(expected, App.alertDefinitionsMapper.get('model.content'));

    });

    describe('should parse AMS alertDefinitions', function () {

      var data = {items: [json.items[5]]};
      var expected = [
        {
          "id" : 6,
          "interval" : 1,
          "label" : "NameNode Heap Usage (Hourly)",
          "name" : "namenode_free_heap_size_deviation_percentage",
          "repeat_tolerance" : 1,
          "repeat_tolerance_enabled" : true,
          "scope" : "SERVICE",
          "service_name" : "HDFS",
          "component_name" : "NAMENODE",
          "help_url" : "http://test.test"
        }
      ];

      var expectedMetricsUri = [{
        "id":"6uri",
        "http" : "{{ams-site/timeline.metrics.service.webapp.address}}",
        "https" : "{{ams-site/timeline.metrics.service.webapp.address}}",
        "https_property" : "{{ams-site/timeline.metrics.service.http.policy}}",
        "https_property_value" : "HTTPS_ONLY",
        "connection_timeout" : 5.0
      }];

      var expectedAms = [{
        "id": "6ams",
        "value": "{1} - {0}",
        "minimal_value": 1,
        "interval": 60
      }];

      beforeEach(function () {
        App.alertDefinitionsMapper.map(data);
      });

      it('should map definition', function () {
        testHelpers.nestedExpect(expected, App.alertDefinitionsMapper.get('model.content'));
      });

      it('parse metrics uri', function() {
        testHelpers.nestedExpect(expectedMetricsUri, App.alertDefinitionsMapper.get('metricsUriModel.content'));
      });

      it('parse ams parameters', function () {
        testHelpers.nestedExpect(expectedAms, App.alertDefinitionsMapper.get('metricsAmsModel.content'));
      });

    });

    /*eslint-disable mocha-cleanup/complexity-it */
    it('should set groups from App.cache.previousAlertGroupsMap', function () {

      App.cache.previousAlertGroupsMap = {
        1: [5,1],
        2: [4,3],
        3: [3,2],
        4: [2,5],
        5: [1,4]
      };

      App.alertDefinitionsMapper.map(json);

      expect(App.alertDefinitionsMapper.get('model.content')[0].groups).to.eql([5, 1]);
      expect(App.alertDefinitionsMapper.get('model.content')[1].groups).to.eql([4, 3]);
      expect(App.alertDefinitionsMapper.get('model.content')[2].groups).to.eql([3, 2]);
      expect(App.alertDefinitionsMapper.get('model.content')[3].groups).to.eql([2, 5]);
      expect(App.alertDefinitionsMapper.get('model.content')[4].groups).to.eql([1, 4]);


    });
    /*eslint-enable mocha-cleanup/complexity-it */

    describe('should delete not existing definitions', function () {

      var definitions = [
        Em.Object.create({id: 100500, type: 'PORT'})
      ];

      beforeEach(function () {

        sinon.stub(App.AlertDefinition, 'find', function () {
          return definitions;
        });

      });

      afterEach(function() {
        App.AlertDefinition.find.restore();
      });

      it('should delete PORT alert definition with id 100500', function () {

        App.alertDefinitionsMapper.map(json);
        expect(App.alertDefinitionsMapper.deleteRecord.calledOnce).to.be.true;
        expect(App.alertDefinitionsMapper.deleteRecord.args[0][0].id).to.equal(100500);
      });

    });

  });
  /*eslint-enable mocha-cleanup/asserts-limit */

});
});

require.register("test/mappers/alert_groups_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');

require('mappers/alert_groups_mapper');
var testHelpers = require('test/helpers');

describe('App.alertGroupsMapper', function () {

  describe('#map', function () {

    var json = {
      items: [
        {
          "AlertGroup" : {
            "default" : true,
            "definitions" : [
              {
                "id" : 8,
                "source_type" : "PORT"
              },
              {
                "id" : 9,
                "source_type" : "AGGREGATE"
              }
            ],
            "id" : 3,
            "name" : "ZOOKEEPER",
            "targets": [{id: 1}, {id: 2}]
          }
        },
        {
          "AlertGroup" : {
            "default" : true,
            "definitions" : [
              {
                "id" : 1,
                "source_type" : "METRIC"
              },
              {
                "id" : 2,
                "source_type" : "WEB"
              },
              {
                "id" : 3,
                "source_type" : "WEB"
              },
              {
                "id" : 4,
                "source_type" : "AGGREGATE"
              },
              {
                "id" : 5,
                "source_type" : "METRIC"
              },
              {
                "id" : 6,
                "source_type" : "SCRIPT"
              },
              {
                "id" : 7,
                "source_type" : "WEB"
              }
            ],
            "id" : 2,
            "name" : "YARN",
            "targets": [{id: 2}, {id: 3}]
          }
        }
      ]
    };

    beforeEach(function () {

      sinon.stub(App.store, 'fastCommit', Em.K);
      sinon.stub(App.store, 'loadMany', function (type, content) {
        type.content = content;
      });

      App.alertGroupsMapper.set('model', {});
      App.cache.previousAlertGroupsMap = {};

    });

    afterEach(function () {

      App.store.fastCommit.restore();
      App.store.loadMany.restore();
      App.alertGroupsMapper.set('model', App.AlertGroup);
      App.cache.previousAlertGroupsMap = {};

    });

    /*eslint-disable mocha-cleanup/asserts-limit */
    it('should parse alert groups', function() {

      var expected = [
        {
          id: 3,
          name: 'ZOOKEEPER',
          default: true,
          definitions: [8,9],
          targets: [1, 2]
        },
        {
          id: 2,
          name: 'YARN',
          default: true,
          definitions: [1, 2, 3, 4, 5, 6, 7],
          targets: [2, 3]
        }
      ];

      App.alertGroupsMapper.map(json);
      var mapped = App.alertGroupsMapper.get('model.content');
      testHelpers.nestedExpect(expected, mapped);
    });
    /*eslint-enable mocha-cleanup/asserts-limit */

    it('should set App.cache.previousAlertGroupsMap', function () {

      var expected = {
        8: [3],
        9: [3],
        1: [2],
        2: [2],
        3: [2],
        4: [2],
        5: [2],
        6: [2],
        7: [2]
      };

      App.alertGroupsMapper.map(json);

      expect(App.cache.previousAlertGroupsMap).to.eql(expected);

    });

    describe('should delete not existing groups', function () {

      var groups = [
        {id: 1},
        {id: 2},
        {id: 3},
        {id: 4}
      ];

      beforeEach(function () {

        sinon.stub(App.AlertGroup, 'find', function() {
          if (arguments.length) {
            return groups.findProperty('id', arguments[0]);
          }
          return groups;
        });

        sinon.stub(App.alertGroupsMapper, 'deleteRecord', Em.K);

      });

      afterEach(function () {
        App.AlertGroup.find.restore();
        App.alertGroupsMapper.deleteRecord.restore();
      });

      it('should call deleteRecord with not existing groups', function () {

        App.alertGroupsMapper.map(json);
        expect(App.alertGroupsMapper.deleteRecord.calledTwice).to.be.true;
        // first call
        expect(App.alertGroupsMapper.deleteRecord.args[0][0].id).to.equal(1);
        // second call
        expect(App.alertGroupsMapper.deleteRecord.args[1][0].id).to.equal(4);

      });

    });

  });

});
});

require.register("test/mappers/alert_instances_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');

require('mappers/alert_instances_mapper');

describe('App.alertInstanceMapper', function () {

  var json = {
      "items": [
        {
          "Alert": {
            "component_name": "AMBARI_AGENT",
            "host_name": "c6401.ambari.apache.org",
            "id": 2,
            "instance": null,
            "label": "Host Disk Usage",
            "latest_timestamp": 1415224354954,
            "maintenance_state": "OFF",
            "name": "ambari_agent_disk_usage",
            "original_timestamp": 1414695835400,
            "scope": "HOST",
            "service_name": "AMBARI",
            "state": "OK",
            "text": "Capacity Used: [1.26%, 6.6 GB], Capacity Total: [525.3 GB]"
          }
        },
        {
          "Alert": {
            "component_name": null,
            "host_name": null,
            "id": 3,
            "instance": null,
            "label": "Percent DataNodes Available",
            "latest_timestamp": 1415224362617,
            "maintenance_state": "OFF",
            "name": "datanode_process_percent",
            "original_timestamp": 1414695787466,
            "scope": "SERVICE",
            "service_name": "HDFS",
            "state": "CRITICAL",
            "text": "affected: [1], total: [1]"
          }
        }
      ]
    };

  it('load new records', function () {
    App.alertInstanceMapper.map(json);

    expect(App.AlertInstance.find().content.length).to.equal(2);
  });

  it('delete inexistent record', function () {
    App.alertInstanceMapper.map({
      items: [
        json.items[0]
      ]
    });

    expect(App.AlertInstance.find().content.length).to.equal(1);
  });

  it('model should be empty', function () {
    App.alertInstanceMapper.map({items: []});

    expect(App.AlertInstance.find().content).to.be.empty;
  });
});

});

require.register("test/mappers/configs/config_groups_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mappers/configs/config_groups_mapper');

/**
 * not using this mapper
 */
describe.skip('App.configGroupsMapper', function () {

  var allHosts = App.get('allHostNames');
  var defaultAllHosts = ['host1', 'host2', 'host3'];
  beforeEach(function () {
    App.set('allHostNames', defaultAllHosts);
  });
  afterEach(function(){
    App.set('allHostNames', allHosts);
  });

  describe("#map", function() {

    var json = {
      "items" : [
        {
          "ConfigGroup" : {
            "cluster_name" : "1",
            "description" : "1",
            "desired_configs" : [
              {
                "tag" : "version1426088081862",
                "type" : "hadoop-env"
              }
            ],
            "group_name" : "1",
            "hosts" : [
              {
                "host_name" : "host1"
              }
            ],
            "id" : 2,
            "tag" : "Service1"
          }
        },
        {
          "ConfigGroup" : {
            "cluster_name" : "1",
            "description" : "hdfs2",
            "desired_configs" : [ ],
            "group_name" : "hdfs2",
            "hosts" : [
              {
                "host_name" : "host2"
              }
            ],
            "id" : 3,
            "tag" : "Service1"
          }
        },
        {
          "ConfigGroup" : {
            "cluster_name" : "1",
            "description" : "yarn1",
            "desired_configs" : [ ],
            "group_name" : "yarn1",
            "hosts" : [
              {
                "host_name" : "host1"
              },
              {
                "host_name" : "host2"
              }
            ],
            "id" : 4,
            "tag" : "Service2"
          }
        }
      ]
    };

    beforeEach(function () {
      App.resetDsStoreTypeMap(App.ServiceConfigGroup);
      App.resetDsStoreTypeMap(App.Service);
      sinon.stub(App.store, 'commit', Em.K);
    });
    afterEach(function(){
      App.store.commit.restore();
    });

    it('should not do anything as there is no serviceName', function() {
      App.configGroupsMapper.map(json);
      expect(App.ServiceConfigGroup.find().get('length')).to.equal(0);
    });

    it('should generate default groups for services', function() {
      App.Service.createRecord({'id': 'Service1'});
      App.configGroupsMapper.map(null, ["Service1"]);
      expect(App.ServiceConfigGroup.find().get('length')).to.equal(1);
      expect(App.ServiceConfigGroup.find('Service10').get('id')).to.equal('Service10');
      expect(App.ServiceConfigGroup.find('Service10').get('configGroupId')).to.equal(-1);
      expect(App.ServiceConfigGroup.find('Service10').get('name')).to.equal('Service1 Default');
      expect(App.ServiceConfigGroup.find('Service10').get('description')).to.equal('Default cluster level Service1 configuration');
      expect(App.ServiceConfigGroup.find('Service10').get('hostNames')).to.eql(defaultAllHosts);
      expect(App.ServiceConfigGroup.find('Service10').get('serviceName')).to.equal('Service1');
      expect(App.ServiceConfigGroup.find('Service10').get('service.id')).to.equal('Service1');
    });

    it('should generate groups form json and default config groups', function() {
      App.Service.createRecord({'id': 'Service1'});
      App.Service.createRecord({'id': 'Service2'});
      App.configGroupsMapper.map(json, ["Service1", "Service2"]);
      expect(App.ServiceConfigGroup.find().get('length')).to.equal(5);
      expect(App.ServiceConfigGroup.find().mapProperty('id')).to.eql(["Service12", "Service13", "Service24", "Service10", "Service20"]);
    });

    it('should generate groups form json and default config groups and check data', function() {
      App.Service.createRecord({'id': 'Service1'});
      App.Service.createRecord({'id': 'Service2'});
      App.configGroupsMapper.map(json, ["Service1", "Service2"]);

      expect(App.ServiceConfigGroup.find('Service12').get('id')).to.equal('Service12');
      expect(App.ServiceConfigGroup.find('Service12').get('configGroupId')).to.equal(2);
      expect(App.ServiceConfigGroup.find('Service12').get('name')).to.equal('1');
      expect(App.ServiceConfigGroup.find('Service12').get('description')).to.equal('1');
      expect(App.ServiceConfigGroup.find('Service12').get('hostNames')).to.eql(["host1"]);
      expect(App.ServiceConfigGroup.find('Service12').get('serviceName')).to.equal('Service1');
      expect(App.ServiceConfigGroup.find('Service12').get('service.id')).to.equal('Service1');
    });
  });

  describe("generateDefaultGroup", function() {
    var tests = [
      {
        service: 's1',
        hosts: ['h1'],
        res: {
          id: 's10',
          config_group_id: '-1',
          name: 's1 Default',
          service_name: 's1',
          description: 'Default cluster level s1 configuration',
          host_names: ['h1'],
          service_id: 's1'
        },
        m: 'with hosts'
      },
      {
        service: 's1',
        res: {
          id: 's10',
          config_group_id: '-1',
          name: 's1 Default',
          service_name: 's1',
          description: 'Default cluster level s1 configuration',
          host_names: defaultAllHosts,
          service_id: 's1'
        },
        m: 'without hosts'
      }
    ];


    tests.forEach(function(t) {
      it('generates default config group mock object ' + t.m, function() {
        expect(App.configGroupsMapper.generateDefaultGroup(t.service, t.hosts)).to.be.eql(t.res);
      });
    });

  });
});

});

require.register("test/mappers/configs/service_config_version_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mappers/configs/service_config_version_mapper');

describe.skip('App.serviceConfigVersionsMapper', function () {

  var allHosts = App.get('allHostNames');
  var defaultAllHosts = ['host1', 'host2', 'host3'];
  beforeEach(function () {
    App.set('allHostNames', defaultAllHosts);
  });
  afterEach(function(){
    App.set('allHostNames', allHosts);
  });

  describe("#map", function() {

    var json = { items: [
      {
        "cluster_name" : "1",
        "createtime" : 1425979244738,
        "group_id" : -1,
        "group_name" : "default",
        "hosts" : [ ],
        "is_current" : true,
        "service_config_version" : 1,
        "service_config_version_note" : "Initial configurations for SERVICE1",
        "service_name" : "SERVICE1",
        "user" : "admin"
      },
      {
        "cluster_name" : "1",
        "configurations" : [
          {
            "Config" : {
              "cluster_name" : "1"
            },
            "type" : "hadoop-env",
            "tag" : "version1426088081862",
            "version" : 2,
            "properties" : {
              "dtnode_heapsize" : "1026m"
            },
            "properties_attributes" : { }
          }
        ],
        "createtime" : 1426088137115,
        "group_id" : 2,
        "group_name" : "1",
        "hosts" : [
          "host1"
        ],
        "is_current" : false,
        "service_config_version" : 4,
        "service_config_version_note" : "",
        "service_name" : "SERVICE2",
        "user" : "admin"
      },
    ]};

    beforeEach(function () {
      App.resetDsStoreTypeMap(App.ServiceConfigVersion);
      sinon.stub(App.store, 'commit', Em.K);
    });
    afterEach(function(){
      App.store.commit.restore();
    });

    it('should not do anything as there is no json', function() {
      App.serviceConfigVersionsMapper.map(null);
      expect(App.ServiceConfigVersion.find().get('length')).to.equal(0);
    });

    describe('should load data to model', function() {

      beforeEach(function () {
        App.serviceConfigVersionsMapper.map(json);
      });

      it('two versions are mapped', function () {
        expect(App.ServiceConfigVersion.find().get('length')).to.equal(2);
      });

      it('services have correct ids', function () {
        expect(App.ServiceConfigVersion.find().mapProperty('id')).to.eql(['SERVICE1_1','SERVICE2_4']);
      });

      it('SERVICE1_1 createTime', function () {
        expect(App.ServiceConfigVersion.find('SERVICE1_1').get('createTime')).to.equal(1425979244738);
      });
      it('SERVICE1_1 groupId', function () {
        expect(App.ServiceConfigVersion.find('SERVICE1_1').get('groupId')).to.equal(-1);
      });
      it('SERVICE1_1 hosts', function () {
        expect(App.ServiceConfigVersion.find('SERVICE1_1').get('hosts')).to.eql(defaultAllHosts);
      });
      it('SERVICE1_1 isCurrent', function () {
        expect(App.ServiceConfigVersion.find('SERVICE1_1').get('isCurrent')).to.be.true;
      });
      it('SERVICE1_1 version', function () {
        expect(App.ServiceConfigVersion.find('SERVICE1_1').get('version')).to.equal(1);
      });
      it('SERVICE1_1 notes', function () {
        expect(App.ServiceConfigVersion.find('SERVICE1_1').get('notes')).to.equal("Initial configurations for SERVICE1");
      });
      it('SERVICE1_1 serviceName', function () {
        expect(App.ServiceConfigVersion.find('SERVICE1_1').get('serviceName')).to.equal("SERVICE1");
      });
      it('SERVICE1_1 author', function () {
        expect(App.ServiceConfigVersion.find('SERVICE1_1').get('author')).to.equal("admin");
      });

      it('SERVICE2_4 createTime', function () {
        expect(App.ServiceConfigVersion.find('SERVICE2_4').get('createTime')).to.equal(1426088137115);
      });
      it('SERVICE2_4 groupId', function () {
        expect(App.ServiceConfigVersion.find('SERVICE2_4').get('groupId')).to.equal(2);
      });
      it('SERVICE2_4 hosts', function () {
        expect(App.ServiceConfigVersion.find('SERVICE2_4').get('hosts')).to.eql(["host1"]);
      });
      it('SERVICE2_4 isCurrent', function () {
        expect(App.ServiceConfigVersion.find('SERVICE2_4').get('isCurrent')).to.be.false;
      });
      it('SERVICE2_4 version', function () {
        expect(App.ServiceConfigVersion.find('SERVICE2_4').get('version')).to.equal(4);
      });
      it('SERVICE2_4 notes', function () {
        expect(App.ServiceConfigVersion.find('SERVICE2_4').get('notes')).to.equal("");
      });
      it('SERVICE2_4 serviceName', function () {
        expect(App.ServiceConfigVersion.find('SERVICE2_4').get('serviceName')).to.equal("SERVICE2");
      });
      it('SERVICE2_4 author', function () {
        expect(App.ServiceConfigVersion.find('SERVICE2_4').get('author')).to.equal("admin");
      });
    });
  });

});


});

require.register("test/mappers/configs/stack_config_properties_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mappers/configs/stack_config_properties_mapper');

describe.skip('App.stackConfigPropertiesMapper', function () {

  describe("#map", function () {

    var json = {
      items: [
        {
          "StackServices": {
            "service_name": "HBASE",
            "stack_name": "HDP",
            "stack_version": "2.2",
            "config_types": {
              "site1": {
                "supports": {
                  "adding_forbidden": "false",
                  "do_not_extend": "false",
                  "final": "true"
                }
              }
            }
          },
          "configurations": [
            {
              "StackConfigurations": {
                "final": "false",
                "property_description": "desc1",
                "property_name": "p1",
                "property_display_name": "P1",
                "property_type": [],
                "property_value": "v1",
                "service_name": "s1",
                "stack_name": "HDP",
                "stack_version": "2.2",
                "type": "site1.xml",
                "property_depends_on": [
                  {
                    "name": "p5",
                    "type": "site5"
                  }
                ],
                "property_value_attributes": {
                  "type": "int",
                  "minimum": "512",
                  "maximum": "10240",
                  "unit": "MB"
                }
              },
              "dependencies": [
                {
                  "StackConfigurationDependency": {
                    "dependency_name": "p4",
                    "dependency_type": "site4"
                  }
                }
              ]
            }
          ]
        },
        {
          "StackServices": {
            "service_name": "HDFS",
            "stack_name": "HDP",
            "stack_version": "2.2",
            "config_types": {
              "site2": {
                "supports": {
                  "adding_forbidden": "false",
                  "do_not_extend": "false",
                  "final": "true"
                }
              },
              "site3": {
                "supports": {
                  "adding_forbidden": "false",
                  "do_not_extend": "false",
                  "final": "true"
                }
              }
            }
          },
          "configurations": [
            {
              "StackConfigurations": {
                "final": "false",
                "property_description": "desc3",
                "property_name": "p2",
                "property_display_name": "P2",
                "property_type": [],
                "property_value": "v2",
                "service_name": "s2",
                "stack_name": "HDP",
                "stack_version": "2.2",
                "type": "site2.xml"
              }
            },
            {
              "StackConfigurations": {
                "final": "false",
                "property_description": "desc3",
                "property_name": "p3",
                "property_display_name": "P3",
                "property_type": [],
                "property_value": "v3",
                "service_name": "s2",
                "stack_name": "HDP",
                "stack_version": "2.2",
                "type": "site3.xml"
              }
            },
            {
              "StackConfigurations": {
                "final": "false",
                "property_description": "desc4",
                "property_name": "p4",
                "property_display_name": "P4",
                "property_type": ["PASSWORD"],
                "property_value": "v4",
                "service_name": "s2",
                "stack_name": "HDP",
                "stack_version": "2.2",
                "type": "site3.xml"
              }
            },
            {
              "StackConfigurations": {
                "final": "false",
                "property_description": "desc5",
                "property_name": "p5",
                "property_display_name": "P5",
                "property_type": ["USER"],
                "property_value": "v4",
                "service_name": "s2",
                "stack_name": "HDP",
                "stack_version": "2.2",
                "type": "site3.xml"
              }
            }
          ]
        }
      ]
    };

    beforeEach(function () {
      App.resetDsStoreTypeMap(App.StackConfigProperty);
      sinon.stub(App.store, 'commit', Em.K);
      sinon.stub(App.StackService, 'find', function () {
        return Em.A()
      });
    });
    afterEach(function () {
      App.store.commit.restore();
      App.StackService.find.restore();
    });

    it('should not do anything as there is no json', function () {
      App.stackConfigPropertiesMapper.map(null);
      expect(App.StackConfigProperty.find().get('length')).to.equal(0);
    });

    describe('should load data to model', function () {

      beforeEach(function () {
        App.stackConfigPropertiesMapper.map(json);
      });

      it('5 properties are mapped', function () {
        expect(App.StackConfigProperty.find().get('length')).to.equal(5);
      });

      it('ids are valid', function () {
        expect(App.StackConfigProperty.find().mapProperty('id')).to.eql(['p1__site1', 'p2__site2', 'p3__site3', 'p4__site3', 'p5__site3']);
      });

      it('name is valid', function () {
        expect(App.StackConfigProperty.find('p1__site1').get('name')).to.be.equal('p1');
      });

      it('displayName is valid', function () {
        expect(App.StackConfigProperty.find('p1__site1').get('displayName')).to.be.equal('P1');
      });

      it('description is valid', function () {
        expect(App.StackConfigProperty.find('p1__site1').get('description')).to.be.equal('desc1');
      });

      it('recommendedValue is valid', function () {
        expect(App.StackConfigProperty.find('p1__site1').get('recommendedValue')).to.be.equal('v1');
      });

      it('recommendedIsFinal is valid', function () {
        expect(App.StackConfigProperty.find('p1__site1').get('recommendedIsFinal')).to.be.false;
      });

      it('serviceName is valid', function () {
        expect(App.StackConfigProperty.find('p1__site1').get('serviceName')).to.be.equal('s1');
      });

      it('stackName is valid', function () {
        expect(App.StackConfigProperty.find('p1__site1').get('stackName')).to.be.equal('HDP');
      });

      it('stackVersion is valid', function () {
        expect(App.StackConfigProperty.find('p1__site1').get('stackVersion')).to.be.equal('2.2');
      });

      it('type is valid', function () {
        expect(App.StackConfigProperty.find('p1__site1').get('type').toArray()).to.eql([]);
      });

      it('fileName is valid', function () {
        expect(App.StackConfigProperty.find('p1__site1').get('fileName')).to.be.equal('site1.xml');
      });

      it('propertyDependedBy is valid', function () {
        expect(App.StackConfigProperty.find('p1__site1').get('propertyDependedBy')).to.eql([
          {
            "type": "site4",
            "name": "p4"
          }
        ]);
      });

      it('propertyDependsOn is valid', function () {
        expect(App.StackConfigProperty.find('p1__site1').get('propertyDependsOn')).to.eql([
          {
            "type": "site5",
            "name": "p5"
          }
        ]);
      });

      it('valueAttributes is valid', function () {
        expect(App.StackConfigProperty.find('p1__site1').get('valueAttributes')).to.eql({
          "type": "int",
          "minimum": "512",
          "maximum": "10240",
          "unit": "MB"
        });
      });

      it('supportsFinal is valid', function () {
        expect(App.StackConfigProperty.find('p1__site1').get('supportsFinal')).to.be.true;
      });
    });

    it('should set "displayType" by "property_type" attribute', function () {
      App.stackConfigPropertiesMapper.map(json);
      var prop = App.StackConfigProperty.find().findProperty('name', 'p4');
      var prop2 = App.StackConfigProperty.find().findProperty('name', 'p5');
      expect(prop).to.be.ok;
      expect(prop.get('displayType')).to.be.equal('password');
      expect(prop2.get('displayType')).to.be.equal('user');
    });
  });

  describe('#_isRequired', function() {
    [
      {
        allow_empty: true,
        property_value: 'some',
        is_required: false,
        message: 'false for value "some" and "allow_empty" true'
      },
      {
        allow_empty: false,
        property_value: '',
        is_required: true,
        message: 'true for value "" and "allow_empty" false'
      },
      {
        allow_empty: false,
        property_value: null,
        is_required: false,
        message: 'false for value null" and "allow_empty" false'
      }
    ].forEach(function(c) {
        it(c.message, function() {
          expect(App.stackConfigPropertiesMapper._isRequired(c.allow_empty, c.property_value)).to.equal(c.is_required);
        })
      });
  });

});

});

require.register("test/mappers/configs/themes_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mappers/configs/themes_mapper');
require('models/configs/theme/tab');
require('models/configs/theme/section');
require('models/configs/theme/sub_section');

describe('App.themeMapper', function () {

  beforeEach(function () {
    App.resetDsStoreTypeMap(App.Tab);
    App.resetDsStoreTypeMap(App.Section);
    App.resetDsStoreTypeMap(App.SubSection);
    sinon.stub(App.store, 'commit', Em.K);
  });

  afterEach(function () {
    App.store.commit.restore();
  });

  describe("#map", function () {

    var json = {
      items: [
        {
          ThemeInfo: {
            service_name: "HDFS",
            theme_data: {
              "Theme": {
                "name": "default",
                "description": "Default theme for HDFS service",
                "configuration": {
                  "layouts": [
                    {
                      "name": "default",
                      "tabs": [
                        {
                          "name": "settings",
                          "display-name": "Settings",
                          "layout": {
                            "tab-columns": "2",
                            "tab-rows": "1",
                            "sections": [
                              {
                                "name": "Section-1",
                                "display-name": "Section One",
                                "row-index": "0",
                                "column-index": "0",
                                "row-span": "1",
                                "column-span": "1",
                                "section-columns": "2",
                                "section-rows": "3",
                                "subsections": [
                                  {
                                    "name": "subsection1",
                                    "display-name": "Storage",
                                    "border": "false",
                                    "row-index": "0",
                                    "column-index": "0",
                                    "column-span": "1",
                                    "row-span": "1"
                                  }
                                ]
                              },
                              {
                                "name": "Section-2",
                                "display-name": "Section Two",
                                "row-index": "0",
                                "column-index": "1"
                              }
                            ]
                          }
                        }
                      ]
                    }
                  ],
                  "widgets": [
                    {
                      "config": "c1/p1",
                      "widget": {
                        "type": "slider",
                        "units": [
                          {
                            "unit-name": "MB"
                          },
                          {
                            "unit-name": "GB"
                          }
                        ]
                      }
                    },
                    {
                      "config": "c1/p2",
                      "widget": {
                        "type": "slider",
                        "units": [
                          {
                            "unit-name": "percent"
                          }
                        ]
                      }
                    }
                  ],
                  "placement": {
                    "configuration-layout": "default",
                    "configs": [
                      {
                        "config": "c1/p1",
                        "subsection-name": "subsection1"
                      },
                      {
                        "config": "c1/p2",
                        "subsection-name": "subsection1"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      ]
    };

    describe('should map theme data', function () {

      beforeEach(function () {
        App.themesMapper.map(json, []);
      });

      it('1 Tab is mapped', function () {
        expect(App.Tab.find().get('length')).to.equal(1);
      });

      it('2 Sections are mapped', function () {
        expect(App.Section.find().get('length')).to.equal(2);
      });

      it('1 SubSection is mapped', function () {
        expect(App.SubSection.find().get('length')).to.equal(1);
      });

      it('HDFS_settings tab is mapped correctly', function () {
        //checking tab
        expect(App.Tab.find('HDFS_settings').toJSON()).to.eql({
          id: 'HDFS_settings',
          name: 'settings',
          display_name: 'Settings',
          columns: "2",
          rows: "1",
          is_advanced: false,
          service_name: 'HDFS',
          is_advanced_hidden: false,
          is_rendered: false,
          is_configs_prepared: false
        });
      });

      it('HDFS_settings section is mapped correctly', function () {
        //checking section
        expect(App.Tab.find('HDFS_settings').get('sections').objectAt(0).toJSON()).to.eql({
          "id": "Section-1",
          "name": "Section-1",
          "display_name": "Section One",
          "row_index": "0",
          "row_span": "1",
          "column_index": "0",
          "column_span": "1",
          "section_columns": "2",
          "section_rows": "3",
          "tab_id": "HDFS_settings"
        });
      });

      it('HDFS_settings section subsection is mapped correctly', function () {
        //checking subsection
        expect(App.Tab.find('HDFS_settings').get('sections').objectAt(0).get('subSections').objectAt(0).toJSON()).to.eql({
          "id": "subsection1",
          "name": "subsection1",
          "display_name": "Storage",
          "border": "false",
          "row_index": "0",
          "row_span": "1",
          "column_index": "0",
          "depends_on": [],
          "config_properties": [],
          "left_vertical_splitter": true,
          "column_span": "1",
          "section_id": "Section-1"
        });
      });
    });
  });

  describe('#generateAdvancedTabs', function () {
    it('generates advanced tabs', function () {
      App.themesMapper.generateAdvancedTabs(['HDFS']);
      expect(App.Tab.find('HDFS_advanced').toJSON()).to.eql({
        "id": "HDFS_advanced",
        "name": "advanced",
        "display_name": "Advanced",
        "columns": 1,
        "rows": 1,
        "is_advanced": true,
        "service_name": "HDFS",
        "is_advanced_hidden": false,
        is_rendered: false,
        is_configs_prepared: false
      });
    });
  });

  describe('#getConfigId', function () {
    it('gets configs id from json', function () {
      expect(App.themesMapper.getConfigId({config: "c1/p1"})).to.equal("p1__c1");
    });
    it('returns null as data is invalid', function () {
      expect(App.themesMapper.getConfigId({configs: "c1/p1"})).to.equal(null);
    });
  });
});

});

require.register("test/mappers/hosts_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/host');
require('models/host_component');
require('mappers/server_data_mapper');
require('mappers/hosts_mapper');

describe('App.hostsMapper', function () {
  var mapper = App.hostsMapper;

  describe("#setMetrics()", function() {
    var data = {
      items: [
        {
          Hosts: {
            host_name: 'host1'
          },
          metrics: {
            load: {
              load_one: 1
            }
          }
        }
      ]
    };
    beforeEach(function(){
      this.mock = sinon.stub(App.Host, 'find')
    });
    afterEach(function(){
      this.mock.restore();
    });
    it("Host not in the model", function() {
      var host = Em.Object.create({
        hostName: 'host2'
      });
      var mockedModel = [host];
      mockedModel.content = mockedModel;
      this.mock.returns(mockedModel);
      mapper.setMetrics(data);
      expect(host.get('loadOne')).to.be.undefined;
    });
    it("Host should have updated metrics", function() {
      var host = Em.Object.create({
        hostName: 'host1'
      });
      var mockedModel = [host];
      mockedModel.content = mockedModel;
      this.mock.returns(mockedModel);
      mapper.setMetrics(data);
      expect(host.get('loadOne')).to.equal(1);
    });
  });
});

});

require.register("test/mappers/repository_version_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('utils/helper');
require('mappers/repository_version_mapper');

describe('App.repoVersionMapper', function () {

  describe("#convertToRepoScheme()", function () {

    it("json is null", function() {
      expect(App.repoVersionMapper.convertToRepoScheme(null)).to.be.eql({items: []});
    });

    it("json is correct", function() {
      var json = {
        items: [{
          versions: [{
            repository_versions: [{
              id: 1
            }]
          }]
        }]
      };
      expect(App.repoVersionMapper.convertToRepoScheme(json)).to.be.eql({items: [{id: 1}]});
    });
  });

});

});

require.register("test/mappers/server_data_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var mapper;

require('mappers/server_data_mapper');

describe('App.QuickDataMapper', function () {

  var testJson = {
    a1: {
      b1: {
        c1: 'val1'
      },
      b2: 'val2',
      b3: [
        {
          c2: 'val4'
        },
        {
          c2: 'val5'
        },
        {
          c2: 'val1'
        }
      ]
    },
    a2: 'val3',
    item: {
      'key.dotted': 'val6'
    }
  };

  beforeEach(function () {
    mapper = App.QuickDataMapper.create();
  });

  describe('#getJsonProperty', function() {
    var tests = [
      {i:'a1.b1.c1',e:'val1'},
      {i:'a1.b2',e:'val2'},
      {i:'a2',e:'val3'},
      {i:'a1.b3[0].c2',e:'val4'},
      {i:'a1.b3[1].c2',e:'val5'}
    ];
    tests.forEach(function(test) {
      it(test.i, function() {
        expect(mapper.getJsonProperty(testJson, test.i)).to.equal(test.e);
      });
    });
  });

  describe('#parseIt', function() {
    var config = {
      $a2: 'a2',
      f1: 'a1.b1.c1',
      f2: 'a1.b3[0].c2',
      f3: 'a1.b3',
      f4_key: 'a1.b3',
      f4_type: 'array',
      f4: {
        item: 'c2'
      }
    };
    var result;

    beforeEach(function () {
      result = mapper.parseIt(testJson, config);
    });

    it('Property starts with $', function() {
      expect(result.a2).to.equal('a2');
    });
    it('Multi-components path', function() {
      expect(result.f1).to.equal('val1');
    });
    it('Path with array index', function() {
      expect(result.f2).to.equal('val4');
    });
    it('Path returns array', function() {
      expect(result.f3.length).to.equal(3);
    });
    it('Generate array of json fields', function() {
      expect(result.f4).to.eql(['val1','val4','val5']);
    });
  });

  describe('#binaryIndexOf', function () {

    var array1 = [1,2,3,4,5,6,7,8,9];
    var array2 = ['b','c','d','e','f','g'];

    array1.forEach(function(item, index) {
      it('numeric array. test ' + (index + 1), function () {
        expect(mapper.binaryIndexOf(array1, item)).to.equal(index);
      });
    });

    it('numeric array. element doesn\'t exists', function () {
      expect(mapper.binaryIndexOf(array1, 0)).to.be.below(0);
    });

    it('numeric array. element doesn\'t exists 2', function () {
      expect(mapper.binaryIndexOf(array1, 10)).to.be.below(0);
    });

    array2.forEach(function(item, index) {
      it('string array. test ' + (index + 1), function () {
        expect(mapper.binaryIndexOf(array2, item)).to.equal(index);
      });
    });

    it('string array. element doesn\'t exists', function () {
      expect(mapper.binaryIndexOf(array2, 'a')).to.be.below(0);
    });

    it('string array. element doesn\'t exists 2', function () {
      expect(mapper.binaryIndexOf(array2, 'q')).to.be.below(0);
    });

  });

});

});

require.register("test/mappers/service_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('utils/helper');
require('mappers/server_data_mapper');
require('mappers/service_metrics_mapper');

describe('App.serviceMetricsMapper', function () {

  describe('#hbaseMapper', function() {

    var tests = [
        {
          components: [
            {
              ServiceComponentInfo: {
                component_name: "HBASE_MASTER",
                RegionsInTransition : [ ]
              },
              host_components: [
                {
                  metrics:{
                    hbase: {
                      master: {
                        IsActiveMaster: 'true',
                        AverageLoad: 1.23456789
                      }
                    },
                    master: {
                      AssignmentManger: {
                        ritCount: 0
                      }
                    }
                  },
                  HostRoles: {
                    host_name: 'host1'
                  }
                }
              ]
            }
          ],
          e: '1.23'
        },
        {
          components: [
            {
              ServiceComponentInfo: {
                component_name: "HBASE_MASTER",
                RegionsInTransition : [ ]
              },
              host_components: [
                {
                  metrics:{
                    hbase: {
                      master: {
                        IsActiveMaster: 'true',
                        AverageLoad: 1.00
                      }
                    },
                    master: {
                      AssignmentManger: {
                        ritCount: 0
                      }
                    }
                  },
                  HostRoles: {
                    host_name: 'host1'
                  }
                }
              ]
            }
          ],
          e: '1.00'
        },
        {
          components: [
            {
              ServiceComponentInfo: {
                component_name: "HBASE_MASTER",
                RegionsInTransition : [ ]
              },
              host_components: [
                {
                  metrics:{
                    hbase: {
                      master: {
                        IsActiveMaster: 'true',
                        AverageLoad: 1
                      }
                    },
                    master: {
                      AssignmentManger: {
                        ritCount: 0
                      }
                    }
                  },
                  HostRoles: {
                    host_name: 'host1'
                  }
                }
              ]
            }
          ],
          e: '1.00'
        },
        {
          components: [
            {
              ServiceComponentInfo: {
                component_name: "HBASE_MASTER",
                RegionsInTransition : [ ]
              },
              host_components: [
                {
                  metrics:{
                    hbase: {
                      master: {
                        IsActiveMaster: 'true',
                        AverageLoad: 1.2
                      }
                    },
                    master: {
                      AssignmentManger: {
                        ritCount: 0
                      }
                    }
                  },
                  HostRoles: {
                    host_name: 'host1'
                  }
                }
              ]
            }
          ],
          e: '1.20'
        }
    ];
    tests.forEach(function(test) {
      it('Round Average Load (' + test.e + ')', function () {
        var result = App.serviceMetricsMapper.hbaseMapper(test);
        expect(result.average_load).to.equal(test.e);
      });
    });
  });

  describe('#stormMapper', function() {
    var tests = [
      {
        stackVersionNumber: '2.2',
        message: 'Storm mapper, stack version 2.2',
        expectedValues: {
          total_executors: 28,
          nimbus_uptime: "15m 1s",
          free_slots: 0,
          used_slots: 2,
          total_slots: 2,
          total_tasks: 28,
          topologies: 1
        },
        components: [
          {
            "ServiceComponentInfo" : {
              "component_name" : "STORM_UI_SERVER",
              "service_name" : "STORM"
            },
            "metrics" : {
              "api" : {
                "v1": {
                  "cluster": {
                    "summary": {
                      "executorsTotal": 28.0,
                      "nimbusUptime": "15m 1s",
                      "slotsFree": 0.0,
                      "slotsTotal": 2.0,
                      "slotsUsed": 2.0,
                      "supervisors": 1.0,
                      "tasksTotal": 28.0
                    }
                  },
                  "topology": {
                    "summary": [
                      {
                        "executorsTotal": 21.0,
                        "uptime": "5m 59s",
                        "schedulerInfo": null,
                        "name": "WordCountida8c06640_date2901141",
                        "workersTotal": 2.0,
                        "status": "ACTIVE",
                        "owner": "",
                        "tasksTotal": 21.0,
                        "id": "WordCountida8c06640_date2901141-2-1412195707"
                      }
                    ]
                  }
                }
              }
            }
          }
        ]
      },
      {
        stackVersionNumber: '2.1',
        message: 'Storm mapper, stack version 2.1',
        expectedValues: {
          total_executors: 2,
          nimbus_uptime: "3.96 hours",
          free_slots: 2,
          used_slots: 0,
          total_slots: 2,
          total_tasks: 21,
          topologies: 0
        },
        components: [
          {
            "ServiceComponentInfo" : {
              "component_name" : "STORM_REST_API",
              "service_name" : "STORM"
            },
            "metrics" : {
              "api" : {
                "cluster" : {
                  "summary" : {
                    "executors.total" : 2.0,
                    "nimbus.uptime" : 14250.0,
                    "slots.free" : 2.0,
                    "slots.total" : 2.0,
                    "slots.used" : 0.0,
                    "supervisors" : 1.0,
                    "tasks.total" : 21.0,
                    "topologies" : 0.0
                  }
                }
              }
            }
          }
        ]
      }
    ];

    beforeEach(function () {
      this.stub = sinon.stub(App, 'get');
    });

    afterEach(function () {
      App.get.restore();
    });

    tests.forEach(function(test) {
      it(test.message, function() {
        this.stub.withArgs('currentStackVersionNumber').returns(test.stackVersionNumber);
        var result = App.serviceMetricsMapper.stormMapper(test);
        expect(result).to.include(test.expectedValues);
      });
    });

  });
});

});

require.register("test/mappers/service_metrics_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */


var App = require('app');

describe('App.serviceMetricsMapper', function () {

  describe('#computeAdditionalRelations', function () {

    var tests = [
      {
        message: 'if both namenodes are standby then `display_name_advanced` for both should be `Standby NameNode`',
        haStateForNn1: 'standby',
        haStateForNn2: 'standby',
        expectedNameForNn1: 'Standby NameNode',
        expectedNameForNn2: 'Standby NameNode'
      },
      {
        message: 'if one namenode is active and another is standby then they should be shown as  `Active NameNode` and `Standby NameNode` respectively',
        haStateForNn1: 'active',
        haStateForNn2: 'standby',
        expectedNameForNn1: 'Active NameNode',
        expectedNameForNn2: 'Standby NameNode'
      },
      {
        message: 'if one namenode is active and another is unknown then they should be shown as  `Active NameNode` and `Standby NameNode` respectively',
        haStateForNn1: 'active',
        haStateForNn2: undefined,
        expectedNameForNn1: 'Active NameNode',
        expectedNameForNn2: 'Standby NameNode'
      },
      {
        message: 'if both namenodes state are unknown then `display_name_advanced` for both should be null (NN will be shown with display name as `NameNode`)',
        haStateForNn1: undefined,
        haStateForNn2: undefined,
        expectedNameForNn1: null,
        expectedNameForNn2: null
      }
    ];

    var services = [
      {
        ServiceInfo: {
          service_name: "HDFS"
        },
        components: [
          {
            ServiceComponentInfo: {
              component_name: "NAMENODE",
              service_name: "HDFS"
            },
            host_components: [
              {
                HostRoles: {
                  component_name: "NAMENODE",
                  host_name: "h1"
                },
                metrics: {
                  dfs: {
                    FSNamesystem: {
                      HAState: ""
                    }
                  }
                }
              },
              {
                HostRoles: {
                  component_name: "NAMENODE",
                  host_name: "h2"
                },
                metrics: {
                  dfs: {
                    FSNamesystem: {
                      HAState: ""
                    }
                  }
                }
              }
            ]
          }
        ]
      }
    ];

    var hostComponents = [
      {
        component_name: "NAMENODE",
        host_id: "h1",
        service_id: "HDFS"
      },
      {
        component_name: "NAMENODE",
        host_id: "h2",
        service_id: "HDFS"
      }
    ];

    tests.forEach(function (test) {
      it(test.message, function () {
        services[0].components[0].host_components[0].metrics.dfs.FSNamesystem.HAState = test.haStateForNn1;
        services[0].components[0].host_components[1].metrics.dfs.FSNamesystem.HAState = test.haStateForNn2;
        App.serviceMetricsMapper.computeAdditionalRelations(hostComponents, services);
        expect(hostComponents[0].display_name_advanced).to.equal(test.expectedNameForNn1);
        expect(hostComponents[1].display_name_advanced).to.equal(test.expectedNameForNn2);
      });
    });
  });

  describe('#yarnMapper', function () {

    it('should set ACTIVE RM first in any cases (if RM HA enabled)', function() {
      var item = {
          components: [
            {
              ServiceComponentInfo: {
                component_name: 'RESOURCEMANAGER'
              },
              host_components: [
                {
                  HostRoles: {
                    ha_state: null,
                    host_name : 'h1'
                  }
                },
                {
                  HostRoles: {
                    ha_state: 'ACTIVE',
                    host_name : 'h2'
                  },
                  metrics: {
                    yarn: {
                      Queue: {
                        root: {
                          default: {}
                        }
                      }
                    }
                  }
                }
              ]
            }
          ]
        },
        result = App.serviceMetricsMapper.yarnMapper(item);
      expect(result.queue).to.equal("{\"root\":{\"default\":{}}}");
    });
  });

  describe("#isHostComponentPresent()", function () {
    var testCases = [
      {
        title: 'component is empty',
        data: {
          component: {},
          name: 'C1'
        },
        result: false
      },
      {
        title: 'component name does not match',
        data: {
          component: {
            ServiceComponentInfo: {
              component_name: ''
            }
          },
          name: 'C1'
        },
        result: false
      },
      {
        title: 'host_components is undefined',
        data: {
          component: {
            ServiceComponentInfo: {
              component_name: 'C1'
            }
          },
          name: 'C1'
        },
        result: false
      },
      {
        title: 'host_components is empty',
        data: {
          component: {
            ServiceComponentInfo: {
              component_name: 'C1'
            },
            host_components: []
          },
          name: 'C1'
        },
        result: false
      },
      {
        title: 'host_components has component',
        data: {
          component: {
            ServiceComponentInfo: {
              component_name: 'C1'
            },
            host_components: [{}]
          },
          name: 'C1'
        },
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(App.serviceMetricsMapper.isHostComponentPresent(test.data.component, test.data.name)).to.equal(test.result);
      });
    });
  });
});

});

require.register("test/mappers/stack_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mappers/server_data_mapper');
require('mappers/stack_mapper');
require('models/stack');
require('models/operating_system');
require('models/repository');
require('models/stack_version/service_simple');

describe('App.stackMapper', function () {
	describe("#map", function() {
    var testData = {
      "items" : [
      {
        "VersionDefinition" : {
          "id" : "HDP-2.3",
          "show_available": true,
          "stack_name" : "HDP",
          "stack_version" : "2.3",
          "repository_version" : "2.3",
          "version_url" : "file:/Users/ncole/src/hwx/ambari/contrib/version-builder/version_234-3396.xml",
          "release" : {
            "build" : "3396",
            "compatible_with" : "2.3.[0-3].0",
            "notes" : "http://example.com",
            "version" : "2.3.4.0"
          },
          "stack_services" : [
            {
              "name" : "HDFS",
              "display_name" : "HDFS",
              "comment" : "Data warehouse system for ad-hoc queries & analysis of large datasets and table & storage management service",
              "versions" : [
                "2.7.1.2.3396"
              ]
            },
            {
              "name" : "YARN",
              "display_name" : "YARN",
              "comment" : "",
              "versions" : [
                "1.7.3.3396"
              ]
            },
            {
              "name" : "ZOOKEEPER",
              "display_name" : "ZooKeeper",
              "comment" : "",
              "versions" : [
                "1.7.3.3396"
              ]
            }
          ]
        },
        "operating_systems" : [
          {
            "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/debian7",
            "OperatingSystems" : {
              "os_type" : "debian7",
              "repository_version_id" : 1,
              "stack_name" : "HDP",
              "stack_version" : "2.3"
            },
            "repositories" : [
              {
                "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/debian7/repositories/HDP-2.3",
                "Repositories" : {
                  "base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/debian7/2.x/BUILDS/2.3.4.0-3396",
                  "default_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/debian7/2.x/BUILDS/2.3.4.0-3396",
                  "latest_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/debian7/2.x/BUILDS/2.3.4.0-3396",
                  "mirrors_list" : "",
                  "os_type" : "debian7",
                  "repo_id" : "HDP-2.3",
                  "repo_name" : "HDP",
                  "repository_version_id" : 1,
                  "stack_name" : "HDP",
                  "stack_version" : "2.3"
                }
              },
              {
                "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/debian7/repositories/HDP-UTILS-1.1.0.20",
                "Repositories" : {
                  "base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/debian7",
                  "default_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/debian7",
                  "latest_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/debian7",
                  "mirrors_list" : "",
                  "os_type" : "debian7",
                  "repo_id" : "HDP-UTILS-1.1.0.20",
                  "repo_name" : "HDP-UTILS",
                  "repository_version_id" : 1,
                  "stack_name" : "HDP",
                  "stack_version" : "2.3"
                }
              }
            ]
          },
          {
            "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/redhat6",
            "OperatingSystems" : {
              "os_type" : "redhat6",
              "repository_version_id" : 1,
              "stack_name" : "HDP",
              "stack_version" : "2.3"
            },
            "repositories" : [
              {
                "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/redhat6/repositories/HDP-2.3",
                "Repositories" : {
                  "base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/centos6/2.x/BUILDS/2.3.4.0-3396",
                  "default_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/centos6/2.x/BUILDS/2.3.4.0-3396",
                  "latest_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/centos6/2.x/BUILDS/2.3.4.0-3396",
                  "mirrors_list" : "",
                  "os_type" : "redhat6",
                  "repo_id" : "HDP-2.3",
                  "repo_name" : "HDP",
                  "repository_version_id" : 1,
                  "stack_name" : "HDP",
                  "stack_version" : "2.3"
                }
              },
              {
                "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/redhat6/repositories/HDP-UTILS-1.1.0.20",
                "Repositories" : {
                  "base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/centos6",
                  "default_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/centos6",
                  "latest_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/centos6",
                  "mirrors_list" : "",
                  "os_type" : "redhat6",
                  "repo_id" : "HDP-UTILS-1.1.0.20",
                  "repo_name" : "HDP-UTILS",
                  "repository_version_id" : 1,
                  "stack_name" : "HDP",
                  "stack_version" : "2.3"
                }
              }
            ]
          }
        ]
      },

      {
        "VersionDefinition" : {
          "id" : "HDP-2.3-2.3.4.0",
          "stack_name" : "HDP",
          "stack_version" : "2.3",
          "show_available": true,
          "repository_version" : "2.3.4.0",
          "version_url" : "file:/Users/ncole/src/hwx/ambari/contrib/version-builder/version_234-3397.xml",
          "release" : {
            "build" : "3397",
            "compatible_with" : "2.3.[0-3].0",
            "notes" : "http://example.com",
            "version" : "2.3.4.0"
          },
          "stack_services" : [
            {
              "name" : "HDFS",
              "display_name" : "HDFS",
              "comment" : "Data warehouse system for ad-hoc queries & analysis of large datasets and table & storage management service",
              "versions" : [
                "2.7.1.2-3397"
              ]
            },
            {
              "name" : "YARN",
              "display_name" : "YARN",
              "comment" : "",
              "versions" : [
                "1.7.3-3397"
              ]
            },
            {
              "name" : "HBase",
              "display_name" : "HBase",
              "comment" : "",
              "versions" : [
                "1.7.3-3397"
              ]
            },
            {
              "name" : "ZOOKEEPER",
              "display_name" : "ZooKeeper",
              "comment" : "",
              "versions" : [
                "1.7.3-3397"
              ]
            },
            {
              "name" : "Hive",
              "display_name" : "Hive",
              "comment" : "",
              "versions" : [
                "1.1.0-3397"
              ]
            }
          ]
        },
        "operating_systems" : [
          {
            "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/debian7",
            "OperatingSystems" : {
              "os_type" : "debian7",
              "repository_version_id" : 1,
              "stack_name" : "HDP",
              "stack_version" : "2.3"
            },
            "repositories" : [
              {
                "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/debian7/repositories/HDP-2.3",
                "Repositories" : {
                  "base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/debian7/2.x/BUILDS/2.3.4.0-3397",
                  "default_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/debian7/2.x/BUILDS/2.3.4.0-3397",
                  "latest_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/debian7/2.x/BUILDS/2.3.4.0-3397",
                  "mirrors_list" : "",
                  "os_type" : "debian7",
                  "repo_id" : "HDP-2.3",
                  "repo_name" : "HDP",
                  "repository_version_id" : 1,
                  "stack_name" : "HDP",
                  "stack_version" : "2.3"
                }
              },
              {
                "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/debian7/repositories/HDP-UTILS-1.1.0.20",
                "Repositories" : {
                  "base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/debian7",
                  "default_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/debian7",
                  "latest_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/debian7",
                  "mirrors_list" : "",
                  "os_type" : "debian7",
                  "repo_id" : "HDP-UTILS-1.1.0.20",
                  "repo_name" : "HDP-UTILS",
                  "repository_version_id" : 1,
                  "stack_name" : "HDP",
                  "stack_version" : "2.3"
                }
              }
            ]
          },
          {
            "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/redhat6",
            "OperatingSystems" : {
              "os_type" : "redhat6",
              "repository_version_id" : 1,
              "stack_name" : "HDP",
              "stack_version" : "2.3"
            },
            "repositories" : [
              {
                "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/redhat6/repositories/HDP-2.3",
                "Repositories" : {
                  "base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/centos6/2.x/BUILDS/2.3.4.0-3397",
                  "default_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/centos6/2.x/BUILDS/2.3.4.0-3397",
                  "latest_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/centos6/2.x/BUILDS/2.3.4.0-3397",
                  "mirrors_list" : "",
                  "os_type" : "redhat6",
                  "repo_id" : "HDP-2.3",
                  "repo_name" : "HDP",
                  "repository_version_id" : 1,
                  "stack_name" : "HDP",
                  "stack_version" : "2.3"
                }
              },
              {
                "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/redhat6/repositories/HDP-UTILS-1.1.0.20",
                "Repositories" : {
                  "base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/centos6",
                  "default_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/centos6",
                  "latest_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/centos6",
                  "mirrors_list" : "",
                  "os_type" : "redhat6",
                  "repo_id" : "HDP-UTILS-1.1.0.20",
                  "repo_name" : "HDP-UTILS",
                  "repository_version_id" : 1,
                  "stack_name" : "HDP",
                  "stack_version" : "2.3"
                }
              }
            ]
          }
        ]
      },

      {
        "VersionDefinition" : {
          "id" : "HDP-2.3-2.3.6.0",
          "stack_name" : "HDP",
          "stack_version" : "2.3",
          "show_available": true,
          "repository_version" : "2.3.6.0",
          "version_url" : "file:/Users/ncole/src/hwx/ambari/contrib/version-builder/version_234-3646.xml",
          "release" : {
            "build" : "3646",
            "compatible_with" : "2.3.[0-6].0",
            "notes" : "http://example.com",
            "version" : "2.3.6.0"
          },
          "stack_services" : [
            {
              "name" : "HDFS",
              "display_name" : "HDFS",
              "comment" : "Data warehouse system for ad-hoc queries & analysis of large datasets and table & storage management service",
              "versions" : [
                "2.7.1.2-3646"
              ]
            },
            {
              "name" : "YARN",
              "display_name" : "YARN",
              "comment" : "",
              "versions" : [
                "1.7.3-3646"
              ]
            },
            {
              "name" : "HBase",
              "display_name" : "HBase",
              "comment" : "",
              "versions" : [
                "1.7.3-3646"
              ]
            },
            {
              "name" : "ZOOKEEPER",
              "display_name" : "ZooKeeper",
              "comment" : "",
              "versions" : [
                "1.7.3-3646"
              ]
            },
            {
              "name" : "Hive",
              "display_name" : "Hive",
              "comment" : "",
              "versions" : [
                "1.1.0-3646"
              ]
            }
          ]
        },
        "operating_systems" : [
          {
            "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/debian7",
            "OperatingSystems" : {
              "os_type" : "debian7",
              "repository_version_id" : 1,
              "stack_name" : "HDP",
              "stack_version" : "2.3"
            },
            "repositories" : [
              {
                "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/debian7/repositories/HDP-2.3",
                "Repositories" : {
                  "base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/debian7/2.x/BUILDS/2.3.6.0-3646",
                  "default_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/debian7/2.x/BUILDS/2.3.6.0-3646",
                  "latest_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/debian7/2.x/BUILDS/2.3.6.0-3646",
                  "mirrors_list" : "",
                  "os_type" : "debian7",
                  "repo_id" : "HDP-2.3",
                  "repo_name" : "HDP",
                  "repository_version_id" : 1,
                  "stack_name" : "HDP",
                  "stack_version" : "2.3"
                }
              },
              {
                "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/debian7/repositories/HDP-UTILS-1.1.0.20",
                "Repositories" : {
                  "base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/debian7",
                  "default_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/debian7",
                  "latest_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/debian7",
                  "mirrors_list" : "",
                  "os_type" : "debian7",
                  "repo_id" : "HDP-UTILS-1.1.0.20",
                  "repo_name" : "HDP-UTILS",
                  "repository_version_id" : 1,
                  "stack_name" : "HDP",
                  "stack_version" : "2.3"
                }
              }
            ]
          },
          {
            "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/redhat6",
            "OperatingSystems" : {
              "os_type" : "redhat6",
              "repository_version_id" : 1,
              "stack_name" : "HDP",
              "stack_version" : "2.3"
            },
            "repositories" : [
              {
                "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/redhat6/repositories/HDP-2.3",
                "Repositories" : {
                  "base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/centos6/2.x/BUILDS/2.3.6.0-3646",
                  "default_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/centos6/2.x/BUILDS/2.3.6.0-3646",
                  "latest_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/centos6/2.x/BUILDS/2.3.6.0-3646",
                  "mirrors_list" : "",
                  "os_type" : "redhat6",
                  "repo_id" : "HDP-2.3",
                  "repo_name" : "HDP",
                  "repository_version_id" : 1,
                  "stack_name" : "HDP",
                  "stack_version" : "2.3"
                }
              },
              {
                "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/redhat6/repositories/HDP-UTILS-1.1.0.20",
                "Repositories" : {
                  "base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/centos6",
                  "default_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/centos6",
                  "latest_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/centos6",
                  "mirrors_list" : "",
                  "os_type" : "redhat6",
                  "repo_id" : "HDP-UTILS-1.1.0.20",
                  "repo_name" : "HDP-UTILS",
                  "repository_version_id" : 1,
                  "stack_name" : "HDP",
                  "stack_version" : "2.3"
                }
              }
            ]
          }
        ]
      },


      {
        "VersionDefinition" : {
          "id" : "HDP-2.4-2.4.0.0",
          "stack_name" : "HDP",
          "stack_version" : "2.4",
          "show_available": true,
          "repository_version" : "2.4.0.0",
          "version_url" : "file:/Users/ncole/src/hwx/ambari/contrib/version-builder/version_169.xml",
          "release" : {
            "build" : "169",
            "compatible_with" : "2.4.[0-3].0",
            "notes" : "http://example.com",
            "version" : "2.4.0.0"
          },
          "stack_services" : [
            {
              "name" : "HDFS",
              "display_name" : "HDFS",
              "comment" : "Data warehouse system for ad-hoc queries & analysis of large datasets and table & storage management service",
              "versions" : [
                "2.7.1.2-169"
              ]
            },
            {
              "name" : "YARN",
              "display_name" : "YARN",
              "comment" : "",
              "versions" : [
                "1.7.3-169"
              ]
            },
            {
              "name" : "HBase",
              "display_name" : "HBase",
              "comment" : "",
              "versions" : [
                "1.7.3-169"
              ]
            },
            {
              "name" : "ZOOKEEPER",
              "display_name" : "ZooKeeper",
              "comment" : "",
              "versions" : [
                "1.7.3-169"
              ]
            },
            {
              "name" : "Hive",
              "display_name" : "Hive",
              "comment" : "",
              "versions" : [
                "1.1.0-169"
              ]
            },
            {
              "name" : "MAPREDUCE2",
              "display_name" : "MapReduce2",
              "comment" : "service",
              "versions" : [
                "2.7.1.2-169"
              ]
            },
            {
              "name" : "Slider",
              "display_name" : "Slider",
              "comment" : "service",
              "versions" : [
                "2.7.1.2-169"
              ]
            },
            {
              "name" : "Pig",
              "display_name" : "Pig",
              "comment" : "service",
              "versions" : [
                "2.7.1.2-169"
              ]
            },
            {
              "name" : "Sqoop",
              "display_name" : "Sqoop",
              "comment" : "service",
              "versions" : [
                "2.7.1.2-169"
              ]
            }
          ]
        },
        "operating_systems" : [
          {
            "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/debian7",
            "OperatingSystems" : {
              "os_type" : "debian7",
              "repository_version_id" : 1,
              "stack_name" : "HDP",
              "stack_version" : "2.4"
            },
            "repositories" : [
              {
                "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/debian7/repositories/HDP-2.3",
                "Repositories" : {
                  "base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/debian7/2.x/BUILDS/2.4.0.0-169",
                  "default_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/debian7/2.x/BUILDS/2.4.0.0-169",
                  "latest_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP/debian7/2.x/BUILDS/2.4.0.0-169",
                  "mirrors_list" : "",
                  "os_type" : "debian7",
                  "repo_id" : "HDP-2.4",
                  "repo_name" : "HDP",
                  "repository_version_id" : 1,
                  "stack_name" : "HDP",
                  "stack_version" : "2.4"
                }
              },
              {
                "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/repository_versions/1/operating_systems/debian7/repositories/HDP-UTILS-1.1.0.20",
                "Repositories" : {
                  "base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/debian7",
                  "default_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/debian7",
                  "latest_base_url" : "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.20/repos/debian7",
                  "mirrors_list" : "",
                  "os_type" : "debian7",
                  "repo_id" : "HDP-UTILS-1.1.0.20",
                  "repo_name" : "HDP-UTILS",
                  "repository_version_id" : 1,
                  "stack_name" : "HDP",
                  "stack_version" : "2.4"
                }
              }
            ]
          }
        ]
      }
    ]
    };
    beforeEach(function () {
      App.resetDsStoreTypeMap(App.Repository);
      App.resetDsStoreTypeMap(App.OperatingSystem);
      App.resetDsStoreTypeMap(App.Stack);
      App.resetDsStoreTypeMap(App.ServiceSimple);
      sinon.stub(App.store, 'commit', Em.K);
      testData.items.sortProperty('VersionDefinition.stack_version').reverse().forEach(function (versionDefinition) {
        App.stackMapper.map(versionDefinition);
      });
    });
    afterEach(function(){
      App.store.commit.restore();
    });

    it ('should map all Stack data', function() {
      expect(App.Stack.find().get('length')).to.equal(4);
    });

    it ('all stacks are showAvailable', function() {
      expect(App.Stack.find().everyProperty('showAvailable')).to.equal(true);
    });

    it ('no one stack is selected', function() {
      expect(App.Stack.find().everyProperty('isSelected')).to.equal(false);
    });

    it ('7 OSes are mapped', function() {
      expect(App.OperatingSystem.find().get('length')).to.equal(7);
    });

    it ('OSes have valid ids', function() {
      expect(App.OperatingSystem.find().mapProperty('id')).to.eql(
        ['HDP-2.4-2.4.0.0-debian7', 'HDP-2.3-2.3.6.0-debian7', 'HDP-2.3-2.3.6.0-redhat6', 'HDP-2.3-2.3.4.0-debian7',
        'HDP-2.3-2.3.4.0-redhat6', 'HDP-2.3-debian7', 'HDP-2.3-redhat6']);
    });

    it ('14 repositories are mapped', function() {
      expect(App.Repository.find().get('length')).to.equal(14);
    });

    it ('Repositories ids are valid', function() {
      expect(App.Repository.find().mapProperty('id')).to.eql(
        ['HDP-2.4-2.4.0.0-debian7-HDP-2.4', 'HDP-2.4-2.4.0.0-debian7-HDP-UTILS-1.1.0.20',
          'HDP-2.3-2.3.6.0-debian7-HDP-2.3', 'HDP-2.3-2.3.6.0-debian7-HDP-UTILS-1.1.0.20',
          'HDP-2.3-2.3.6.0-redhat6-HDP-2.3','HDP-2.3-2.3.6.0-redhat6-HDP-UTILS-1.1.0.20',
          'HDP-2.3-2.3.4.0-debian7-HDP-2.3','HDP-2.3-2.3.4.0-debian7-HDP-UTILS-1.1.0.20',
          'HDP-2.3-2.3.4.0-redhat6-HDP-2.3', 'HDP-2.3-2.3.4.0-redhat6-HDP-UTILS-1.1.0.20',
          'HDP-2.3-debian7-HDP-2.3', 'HDP-2.3-debian7-HDP-UTILS-1.1.0.20',
          'HDP-2.3-redhat6-HDP-2.3', 'HDP-2.3-redhat6-HDP-UTILS-1.1.0.20'
        ]);
    });
  });
});

});

require.register("test/mappers/stack_service_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

/*eslint-disable */

var App = require('app');

require('mappers/stack_service_mapper');

describe('App.stackServiceMapper', function () {

  describe('#map', function () {

    var data = {
        "items": [
          {
            "StackServices" : {
              "comments" : "A high-throughput distributed messaging system",
              "custom_commands" : [ ],
              "display_name" : "Kafka",
              "required_services" : [
                "ZOOKEEPER"
              ],
              "service_check_supported" : true,
              "service_name" : "KAFKA",
              "service_version" : "0.8.1.2.2",
              "stack_name" : "HDP",
              "stack_version" : "2.2",
              "config_types" : {
                "kafka-broker" : {
                  "supports" : {
                    "adding_forbidden" : "false",
                    "do_not_extend" : "false",
                    "final" : "false"
                  }
                },
                "kafka-env" : {
                  "supports" : {
                    "adding_forbidden" : "false",
                    "do_not_extend" : "false",
                    "final" : "false"
                  }
                },
                "kafka-log4j" : {
                  "supports" : {
                    "adding_forbidden" : "false",
                    "do_not_extend" : "false",
                    "final" : "false"
                  }
                }
              }
            },
            "components" : [
              {
                "StackServiceComponents" : {
                  "cardinality" : "1+",
                  "component_category" : "MASTER",
                  "component_name" : "KAFKA_BROKER",
                  "custom_commands" : [ ],
                  "display_name" : "Kafka Broker",
                  "is_client" : false,
                  "is_master" : true,
                  "service_name" : "KAFKA",
                  "stack_name" : "HDP",
                  "stack_version" : "2.2"
                },
                "dependencies" : [
                  {
                    "Dependencies" : {
                      "component_name" : "ZOOKEEPER_SERVER",
                      "dependent_component_name" : "KAFKA_BROKER",
                      "dependent_service_name" : "KAFKA",
                      "scope" : "cluster",
                      "stack_name" : "HDP",
                      "stack_version" : "2.2"
                    }
                  }
                ]
              }
            ],
            "artifacts" : [
              {
                "Artifacts" : {
                  "artifact_name": "widget_descriptor"
                }
              }
            ]
          },
          {
            "StackServices" : {
              "service_name" : "ZOOKEEPER"
            },
            "components" : [ ],
            "artifacts" : [ ]
          },
          {
            "StackServices" : {
              "service_name" : "KERBEROS"
            },
            "components" : [ ],
            "artifacts" : [ ]
          },
          {
            "StackServices" : {
              "service_name" : "HDFS"
            },
            "components" : [
              {
                "StackServiceComponents" : {
                  "cardinality" : "1+",
                  "component_category" : "SLAVE",
                  "component_name" : "DATANODE",
                  "custom_commands" : [ ],
                  "decommission_allowed" : true,
                  "bulk_commands_display_name" : "DataNodes",
                  "bulk_commands_master_component_name" : "NAMENODE",
                  "has_bulk_commands_definition" : true,
                  "reassign_allowed" : true,
                  "cardinality" : "1+",
                  "display_name" : "DataNode",
                  "is_client" : false,
                  "is_master" : true,
                  "service_name" : "HDFS",
                  "stack_name" : "HDP"
                },
                "dependencies" : []
              }
            ],
            "artifacts" : [ ]
          },
          {
            "StackServices" : {
              "service_name" : "ACCUMULO"
            },
            "components" : [ ],
            "artifacts" : [ ]
          },
          {
            "StackServices" : {
              "service_name" : "HIVE"
            },
            "components" : [
              {
                "StackServiceComponents" : {
                  "component_name" : "MYSQL_SERVER",
                  "custom_commands" : [
                    "CLEAN"
                  ]
                },
                "dependencies" : [ ]
              }
            ],
            "artifacts" : [ ]
          }
        ]
      },
      sortedServiceNames = ["HDFS", "HIVE", "ZOOKEEPER", "ACCUMULO", "KAFKA", "KERBEROS"],
      serviceResult = {
        id: "KAFKA",
        serviceName: "KAFKA",
        displayName: "Kafka",
        configTypes: {
          "kafka-broker" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "kafka-env" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "kafka-log4j" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          }
        },
        comments: "A high-throughput distributed messaging system",
        serviceVersion: "0.8.1.2.2",
        stackName: "HDP",
        isInstalled: false,
        isInstallable: true,
        isServiceWithWidgets: false,
        serviceCheckSupported: true,
        requiredServices: ["ZOOKEEPER"]
      },
      componentResult = {
        id: "KAFKA_BROKER",
        componentName: "KAFKA_BROKER",
        displayName: "Kafka Broker",
        cardinality: "1+",
        customCommands: [],
        serviceName: "KAFKA",
        componentCategory: "MASTER",
        isMaster: true,
        isClient: false,
        stackName: "HDP",
        stackVersion: "2.2",
        dependencies: [
          {
            componentName: "ZOOKEEPER_SERVER",
            scope : "cluster"
          }
        ]
      };

    beforeEach(function () {
      App.stackServiceMapper.clearStackModels();
    });

    it('should sort and map data about services with their components', function () {
      App.stackServiceMapper.map(data);
      var services = App.StackService.find(),
        components = App.StackServiceComponent.find(),
        kafkaService = services.findProperty('serviceName', 'KAFKA');
      expect(services.mapProperty('serviceName')).to.eql(sortedServiceNames);
      expect(kafkaService.get('serviceComponents.length')).to.equal(1);
      Em.keys(serviceResult).forEach(function (key) {
        expect(kafkaService.get(key)).to.eql(serviceResult[key]);
      });
      Em.keys(componentResult).forEach(function (key) {
        expect(kafkaService.get('serviceComponents').toArray()[0].get(key)).to.eql(componentResult[key]);
      });
      Em.keys(componentResult).forEach(function (key) {
        expect(components.findProperty('componentName', 'KAFKA_BROKER').get(key)).to.eql(componentResult[key]);
      });
      expect(services.findProperty('serviceName', 'KERBEROS').get('isInstallable')).to.be.false;
      expect(services.findProperty('serviceName', 'KERBEROS').get('isSelected')).to.be.false;
      expect(components.findProperty('componentName', 'MYSQL_SERVER').get('customCommands')).to.be.empty;

      expect(components.findProperty('componentName', 'DATANODE').get('hasBulkCommandsDefinition')).to.be.true;
      expect(components.findProperty('componentName', 'DATANODE').get('bulkCommandsDisplayName')).to.eql("DataNodes");
      expect(components.findProperty('componentName', 'DATANODE').get('bulkCommandsMasterComponentName')).to.eql("NAMENODE");
      expect(components.findProperty('componentName', 'DATANODE').get('decommissionAllowed')).to.be.true;
      expect(components.findProperty('componentName', 'DATANODE').get('reassignAllowed')).to.be.true;
    });

  });

});

});

require.register("test/mappers/stack_upgrade_history_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

/*eslint-disable */

var App = require('app');

require('mappers/stack_upgrade_history_mapper');

describe('App.stackUpgradeHistoryMapper', function () {

  describe('#map', function () {

    var data = {
        "href" : "http://bdavm079.svl.ibm.com:8080/api/v1/clusters/bi/upgrades?fields=Upgrade",
        "items" : [
          {
            "href" : "http://bdavm079.svl.ibm.com:8080/api/v1/clusters/bi/upgrades/7",
            "Upgrade" : {
              "cluster_name" : "bi",
              "create_time" : 1463779169144,
              "direction" : "UPGRADE",
              "downgrade_allowed" : true,
              "end_time" : 1463779266087,
              "exclusive" : false,
              "from_version" : "2.3.6.0-3712",
              "pack" : "nonrolling-upgrade-2.4",
              "progress_percent" : 100.0,
              "request_context" : "Upgrading to 2.4.0.0-169",
              "request_id" : 7,
              "request_status" : "ABORTED",
              "skip_failures" : false,
              "skip_service_check_failures" : false,
              "start_time" : 1463779170159,
              "suspended" : false,
              "to_version" : "2.4.0.0-169",
              "type" : "INTERNAL_REQUEST",
              "upgrade_type" : "NON_ROLLING"
            }
          },
          {
            "href" : "http://bdavm079.svl.ibm.com:8080/api/v1/clusters/bi/upgrades/8",
            "Upgrade" : {
              "cluster_name" : "bi",
              "create_time" : 1463779266212,
              "direction" : "DOWNGRADE",
              "downgrade_allowed" : true,
              "end_time" : 1463779299440,
              "exclusive" : false,
              "from_version" : "2.3.6.0-3712",
              "pack" : "nonrolling-upgrade-2.4",
              "progress_percent" : 100.0,
              "request_context" : "Downgrading to 2.3.6.0-3712",
              "request_id" : 8,
              "request_status" : "COMPLETED",
              "skip_failures" : false,
              "skip_service_check_failures" : false,
              "start_time" : 1463779267220,
              "suspended" : false,
              "to_version" : "2.3.6.0-3712",
              "type" : "INTERNAL_REQUEST",
              "upgrade_type" : "NON_ROLLING"
            }
          },
          {
            "href" : "http://bdavm079.svl.ibm.com:8080/api/v1/clusters/bi/upgrades/9",
            "Upgrade" : {
              "cluster_name" : "bi",
              "create_time" : 1463780699654,
              "direction" : "UPGRADE",
              "downgrade_allowed" : true,
              "end_time" : 1463780757685,
              "exclusive" : false,
              "from_version" : "2.3.6.0-3712",
              "pack" : "nonrolling-upgrade-2.4",
              "progress_percent" : 100.0,
              "request_context" : "Upgrading to 2.4.0.0-169",
              "request_id" : 9,
              "request_status" : "ABORTED",
              "skip_failures" : false,
              "skip_service_check_failures" : false,
              "start_time" : 1463780700670,
              "suspended" : false,
              "to_version" : "2.4.0.0-169",
              "type" : "INTERNAL_REQUEST",
              "upgrade_type" : "NON_ROLLING"
            }
          },
          {
            "href" : "http://bdavm079.svl.ibm.com:8080/api/v1/clusters/bi/upgrades/10",
            "Upgrade" : {
              "cluster_name" : "bi",
              "create_time" : 1463780757799,
              "direction" : "DOWNGRADE",
              "downgrade_allowed" : true,
              "end_time" : 1463780794009,
              "exclusive" : false,
              "from_version" : "2.3.6.0-3712",
              "pack" : "nonrolling-upgrade-2.4",
              "progress_percent" : 100.0,
              "request_context" : "Downgrading to 2.3.6.0-3712",
              "request_id" : 10,
              "request_status" : "COMPLETED",
              "skip_failures" : false,
              "skip_service_check_failures" : false,
              "start_time" : 1463780758807,
              "suspended" : false,
              "to_version" : "2.3.6.0-3712",
              "type" : "INTERNAL_REQUEST",
              "upgrade_type" : "NON_ROLLING"
            }
          },
          {
            "href" : "http://bdavm079.svl.ibm.com:8080/api/v1/clusters/bi/upgrades/11",
            "Upgrade" : {
              "cluster_name" : "bi",
              "create_time" : 1463781287967,
              "direction" : "UPGRADE",
              "downgrade_allowed" : true,
              "end_time" : 1463781341452,
              "exclusive" : false,
              "from_version" : "2.3.6.0-3712",
              "pack" : "nonrolling-upgrade-2.4",
              "progress_percent" : 100.0,
              "request_context" : "Upgrading to 2.4.0.0-169",
              "request_id" : 11,
              "request_status" : "ABORTED",
              "skip_failures" : false,
              "skip_service_check_failures" : false,
              "start_time" : 1463781288984,
              "suspended" : false,
              "to_version" : "2.4.0.0-169",
              "type" : "INTERNAL_REQUEST",
              "upgrade_type" : "NON_ROLLING"
            }
          },
          {
            "href" : "http://bdavm079.svl.ibm.com:8080/api/v1/clusters/bi/upgrades/12",
            "Upgrade" : {
              "cluster_name" : "bi",
              "create_time" : 1463781341576,
              "direction" : "DOWNGRADE",
              "downgrade_allowed" : true,
              "end_time" : 1463781371778,
              "exclusive" : false,
              "from_version" : "2.3.6.0-3712",
              "pack" : "nonrolling-upgrade-2.4",
              "progress_percent" : 100.0,
              "request_context" : "Downgrading to 2.3.6.0-3712",
              "request_id" : 12,
              "request_status" : "COMPLETED",
              "skip_failures" : false,
              "skip_service_check_failures" : false,
              "start_time" : 1463781342585,
              "suspended" : false,
              "to_version" : "2.3.6.0-3712",
              "type" : "INTERNAL_REQUEST",
              "upgrade_type" : "NON_ROLLING"
            }
          },
          {
            "href" : "http://bdavm079.svl.ibm.com:8080/api/v1/clusters/bi/upgrades/13",
            "Upgrade" : {
              "cluster_name" : "bi",
              "create_time" : 1464120656181,
              "direction" : "UPGRADE",
              "downgrade_allowed" : true,
              "end_time" : 1464120881477,
              "exclusive" : false,
              "from_version" : "2.3.6.0-3712",
              "pack" : "upgrade-2.4",
              "progress_percent" : 100.0,
              "request_context" : "Upgrading to 2.4.0.0-169",
              "request_id" : 13,
              "request_status" : "ABORTED",
              "skip_failures" : false,
              "skip_service_check_failures" : false,
              "start_time" : 1464120657198,
              "suspended" : false,
              "to_version" : "2.4.0.0-169",
              "type" : "INTERNAL_REQUEST",
              "upgrade_type" : "ROLLING"
            }
          },
          {
            "href" : "http://bdavm079.svl.ibm.com:8080/api/v1/clusters/bi/upgrades/14",
            "Upgrade" : {
              "cluster_name" : "bi",
              "create_time" : 1464120881574,
              "direction" : "DOWNGRADE",
              "downgrade_allowed" : true,
              "end_time" : 1464120918774,
              "exclusive" : false,
              "from_version" : "2.3.6.0-3712",
              "pack" : "upgrade-2.4",
              "progress_percent" : 100.0,
              "request_context" : "Downgrading to 2.3.6.0-3712",
              "request_id" : 14,
              "request_status" : "COMPLETED",
              "skip_failures" : false,
              "skip_service_check_failures" : false,
              "start_time" : 1464120882580,
              "suspended" : false,
              "to_version" : "2.3.6.0-3712",
              "type" : "INTERNAL_REQUEST",
              "upgrade_type" : "ROLLING"
            }
          },
          {
            "href" : "http://bdavm079.svl.ibm.com:8080/api/v1/clusters/bi/upgrades/15",
            "Upgrade" : {
              "cluster_name" : "bi",
              "create_time" : 1464120943986,
              "direction" : "UPGRADE",
              "downgrade_allowed" : true,
              "end_time" : 1464121132856,
              "exclusive" : false,
              "from_version" : "2.3.6.0-3712",
              "pack" : "upgrade-2.4",
              "progress_percent" : 100.0,
              "request_context" : "Upgrading to 2.4.0.0-169",
              "request_id" : 15,
              "request_status" : "ABORTED",
              "skip_failures" : false,
              "skip_service_check_failures" : false,
              "start_time" : 1464120945002,
              "suspended" : false,
              "to_version" : "2.4.0.0-169",
              "type" : "INTERNAL_REQUEST",
              "upgrade_type" : "ROLLING"
            }
          },
          {
            "href" : "http://bdavm079.svl.ibm.com:8080/api/v1/clusters/bi/upgrades/16",
            "Upgrade" : {
              "cluster_name" : "bi",
              "create_time" : 1464121132981,
              "direction" : "DOWNGRADE",
              "downgrade_allowed" : true,
              "end_time" : 1464121167178,
              "exclusive" : false,
              "from_version" : "2.3.6.0-3712",
              "pack" : "upgrade-2.4",
              "progress_percent" : 100.0,
              "request_context" : "Downgrading to 2.3.6.0-3712",
              "request_id" : 16,
              "request_status" : "COMPLETED",
              "skip_failures" : false,
              "skip_service_check_failures" : false,
              "start_time" : 1464121133988,
              "suspended" : false,
              "to_version" : "2.3.6.0-3712",
              "type" : "INTERNAL_REQUEST",
              "upgrade_type" : "ROLLING"
            }
          },
          {
            "href" : "http://bdavm079.svl.ibm.com:8080/api/v1/clusters/bi/upgrades/17",
            "Upgrade" : {
              "cluster_name" : "bi",
              "create_time" : 1464121207511,
              "direction" : "UPGRADE",
              "downgrade_allowed" : true,
              "end_time" : 1464121301821,
              "exclusive" : false,
              "from_version" : "2.3.6.0-3712",
              "pack" : "nonrolling-upgrade-2.4",
              "progress_percent" : 100.0,
              "request_context" : "Upgrading to 2.4.0.0-169",
              "request_id" : 17,
              "request_status" : "ABORTED",
              "skip_failures" : false,
              "skip_service_check_failures" : false,
              "start_time" : 1464121208524,
              "suspended" : false,
              "to_version" : "2.4.0.0-169",
              "type" : "INTERNAL_REQUEST",
              "upgrade_type" : "NON_ROLLING"
            }
          },
          {
            "href" : "http://bdavm079.svl.ibm.com:8080/api/v1/clusters/bi/upgrades/18",
            "Upgrade" : {
              "cluster_name" : "bi",
              "create_time" : 1464121301933,
              "direction" : "DOWNGRADE",
              "downgrade_allowed" : true,
              "end_time" : 1464121336149,
              "exclusive" : false,
              "from_version" : "2.3.6.0-3712",
              "pack" : "nonrolling-upgrade-2.4",
              "progress_percent" : 100.0,
              "request_context" : "Downgrading to 2.3.6.0-3712",
              "request_id" : 18,
              "request_status" : "COMPLETED",
              "skip_failures" : false,
              "skip_service_check_failures" : false,
              "start_time" : 1464121302941,
              "suspended" : false,
              "to_version" : "2.3.6.0-3712",
              "type" : "INTERNAL_REQUEST",
              "upgrade_type" : "NON_ROLLING"
            }
          }
        ]
      };

    var upgradeParseResult = {
        'clusterName':'bi',
        'createTime':1464121301933,
        "direction" : "DOWNGRADE",
        "downgradeAllowed" : true,
        "endTime" : 1464121336149,
        "fromVersion" : "2.3.6.0-3712",
        "requestId" : 18,
        "requestStatus" : "COMPLETED",
        "skipFailures" : false,
        "skipServiceCheckFailures" : false,
        "startTime" : 1464121302941,
        "toVersion" : "2.3.6.0-3712",
        "upgradeType" : "NON_ROLLING"
    };

    beforeEach(function () {
      App.resetDsStoreTypeMap(App.StackUpgradeHistory);
      sinon.stub(App.store, 'commit', Em.K);
    });

    afterEach(function(){
      App.store.commit.restore();
    });

    it('Parse upgrade records returned by the Ambari server', function () {
      App.stackUpgradeHistoryMapper.map(data);
      var all_records = App.StackUpgradeHistory.find();
      var upgrades = all_records.toArray();
      expect(upgrades.length).to.eql(12);
      var total_downgrades = 0;
      var total_upgrades = 0;
      upgrades.forEach(function(upgrade){
        var direction = upgrade.get('direction')
        if ('DOWNGRADE' == direction){
          total_downgrades++;
        }
        if ('UPGRADE' == direction){
          total_upgrades++;
        }
      });
      expect(total_upgrades).to.eql(6);
      expect(total_downgrades).to.eql(6);

      var record = App.StackUpgradeHistory.find().findProperty('requestId', 18);
      Em.keys(upgradeParseResult).forEach(function (key) {
        expect(record.get(key)).to.eql(upgradeParseResult[key]);
      });
    });
  });
});
});

require.register("test/mappers/status_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

describe('App.statusMapper', function () {});

});

require.register("test/mappers/users_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mappers/server_data_mapper');
require('mappers/users_mapper');

describe('App.usersMapper', function () {

  describe('#isAdmin', function() {
    var tests = [
      {i:["AMBARI.ADMINISTRATOR"],e:true,m:'has admin role'},
      {i:["CLUSTER.USER", "AMBARI.ADMINISTRATOR"],e:true,m:'has admin role'},
      {i:["VIEW.USER"],e:false,m:'doesn\'t have admin role'},
      {i:["CLUSTER.ADMINISTRATOR"],e:true,m:'has admin role'}
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.usersMapper.isAdmin(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#isClusterUser', function() {
    var tests = [
      {i:["AMBARI.ADMINISTRATOR", "CLUSTER.USER"],e:false,m:'is cluster user'},
      {i:["CLUSTER.USER"],e:true,m:'has admin role'}
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.usersMapper.isClusterUser(test.i)).to.equal(test.e);
      });
    });
  });
});

});

require.register("test/mixins/common/configs/config_recommendation_parser_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var helpers = require('test/helpers');

describe('App.ConfigRecommendationParser', function() {
  var mixinObject = Em.Controller.extend(App.ConfigRecommendationParser, {});
  var instanceObject = mixinObject.create({});

  var recommendationObject = {
    'fileName1': {
      'properties': {
        'p1': 'v1'
      },
      'property_attributes': {
        'p2': {
          'delete': true
        },
        'p3': {
          'maximum': 100,
          'minimum': 1
        }
      }
    }
  };
  var configs = [
    Em.Object.create({
      name: 'p1',
      filename: 'fileName1'
    }),
    Em.Object.create({
      name: 'p2',
      filename: 'fileName1'
    }),
    Em.Object.create({
      name: 'p3',
      filename: 'fileName1'
    })
  ];

  beforeEach(function() {
    instanceObject.set('stepConfigs', []);
  });


  describe('#parseRecommendations', function() {

    describe('#recommendartion parsed', function() {
      beforeEach(function() {
        instanceObject.reopen({
          updateCallback: Em.K,
          removeCallback: Em.K,
          updateBoundariesCallback: Em.K
        });

        sinon.stub(App.configsCollection, 'getConfigByName', function(name, fileName) {
          return { name: name, filename: fileName };
        });
        sinon.stub(instanceObject, 'allowUpdateProperty').returns(true);

        sinon.spy(instanceObject, 'updateCallback');
        sinon.spy(instanceObject, 'removeCallback');
        sinon.spy(instanceObject, 'updateBoundariesCallback');

        instanceObject.parseRecommendations(recommendationObject, configs, null, null,
          instanceObject.updateCallback, instanceObject.removeCallback, instanceObject.updateBoundariesCallback);
      });

      afterEach(function() {
        App.configsCollection.getConfigByName.restore();

        instanceObject.allowUpdateProperty.restore();
        instanceObject.updateCallback.restore();
        instanceObject.removeCallback.restore();
        instanceObject.updateBoundariesCallback.restore();
      });

      it('updateCallback', function() {
        expect(instanceObject.updateCallback.calledWith(configs[0], 'v1', null, null)).to.be.true;
      });

      it('removeCallback', function() {
        expect(instanceObject.removeCallback.calledWith(configs[1], configs, null, null)).to.be.true;
      });

      it('updateBoundariesCallback maximum', function() {
        expect(instanceObject.updateBoundariesCallback.calledWith({ name: 'p3', filename: 'fileName1' },
          'maximum', 100, 'p3', 'fileName1', null)).to.be.true;
      });

      it('updateBoundariesCallback minimum', function() {
        expect(instanceObject.updateBoundariesCallback.calledWith({ name: 'p3', filename: 'fileName1' },
          'minimum', 1, 'p3', 'fileName1', null)).to.be.true;
      });
    });

    it('#recommendation parsing failed', function() {
      expect(instanceObject.parseRecommendations.bind(instanceObject, null)).to.throw(App.ObjectTypeError);
    });

    it('#recommendation parsing failed', function() {
      expect(instanceObject.parseRecommendations.bind(instanceObject, {}, null)).to.throw(App.ArrayTypeError);
    });

    it('#recommendation parsing failed', function() {
      expect(instanceObject.parseRecommendations.bind(instanceObject, {}, [Em.Object.create({name: 'cfg1'})])).to.throw(App.FunctionTypeError);
    });
  });

  describe('#addByRecommendations', function(){
    var _recommendationObject = {
      'file-name': {
        'properties': {
          'p1': 'v1'
        }
      }
    };
    var stepConfig = App.ServiceConfig.create({
      serviceName: 'serviceName1',
      configs: []
    });
    var cases = [
      {
        m: 'allowUpdateProperty true',
        allowUpdateProperty: true
      },
      {
        m: 'allowUpdateProperty false',
        allowUpdateProperty: false
      }
    ];
    cases.forEach(function (c) {
      describe('non error case', function() {
        beforeEach(function() {
          sinon.stub(App.config, 'getStepConfigForProperty').returns(stepConfig);
          sinon.stub(instanceObject, 'allowUpdateProperty').returns(c.allowUpdateProperty);
          sinon.stub(instanceObject, '_createNewProperty').returns(App.ServiceConfigProperty.create({
            'name': 'p1',
            'filename': 'file-name'
          }));
          instanceObject.addByRecommendations(_recommendationObject, []);
        });

        afterEach(function() {
          App.config.getStepConfigForProperty.restore();
          instanceObject.allowUpdateProperty.restore();
          instanceObject._createNewProperty.restore();
        });

        if (c.allowUpdateProperty) {
          it ('adds new property', function() {
            expect(instanceObject._createNewProperty.calledWith('p1', 'file-name', 'serviceName1', 'v1', [])).to.be.true;

            expect(stepConfig.get('configs.0.name')).to.equal('p1');
            expect(stepConfig.get('configs.0.filename')).to.equal('file-name');
          });

        } else {
          it('does  not add property error', function() {
            expect(instanceObject._createNewProperty.called).to.be.false;
          });
        }
      });
    });

    it('throws error', function() {
      expect(instanceObject.addByRecommendations.bind(instanceObject, null)).to.throw(App.ObjectTypeError);
    });
  });

  describe('#_updateConfigByRecommendation', function() {
    var cases = [
      {
        'allowUpdateProperty': true,
        'updateInitialOnRecommendations': true,
        'm': 'allowUpdateProperty and update init on recommendation',
        'result': {
          'recommendedValue': 'recommendedValue',
          'value': 'recommendedValue',
          'initialValue': 'recommendedValue',
          'errorMessage': '',
          'warnMessage': '',
          'isVisible': true
        }
      },
      {
        'allowUpdateProperty': true,
        'updateInitialOnRecommendations': false,
        'm': 'allowUpdateProperty and do not update init on recommendation',
        'result': {
          'recommendedValue': 'recommendedValue',
          'value': 'recommendedValue',
          'initialValue': null,
          'errorMessage': '',
          'warnMessage': '',
          'isVisible': true
        }
      },
      {
        'allowUpdateProperty': false,
        'updateInitialOnRecommendations': false,
        'm': 'do not allowUpdateProperty and do not update init on recommendation',
        'result': {
          'recommendedValue': 'recommendedValue',
          'value': null,
          'initialValue': null
        }
      }
    ];

    cases.forEach(function(c) {
      describe('update recommendation', function() {
        beforeEach(function() {
          sinon.spy(instanceObject, 'applyRecommendation');
          sinon.stub(instanceObject, 'allowUpdateProperty').returns(c.allowUpdateProperty);
          sinon.stub(instanceObject, 'updateInitialOnRecommendations').returns(c.updateInitialOnRecommendations);
        });
        afterEach(function() {
          instanceObject.allowUpdateProperty.restore();
          instanceObject.updateInitialOnRecommendations.restore();
          instanceObject.applyRecommendation.restore();
        });

        it(c.m, function() {
          expect(instanceObject._updateConfigByRecommendation({
            'recommendedValue': null,
            'value': null,
            'initialValue': null
          }, 'recommendedValue')).to.eql(c.result);
        });

        if(c.allowUpdateProperty) {
          it('runs applyRecommendation', function() {
            instanceObject._updateConfigByRecommendation({}, 'recommendedValue');
            expect(instanceObject.applyRecommendation.calledOnce).to.be.true;
          });
        }
      });
    });

    it('throws error for configs', function() {
      expect(instanceObject._updateConfigByRecommendation.bind(instanceObject, null)).to.throw(App.ObjectTypeError);
    });
  });

  describe('#_createNewProperty', function() {
    beforeEach(function() {
      sinon.spy(instanceObject, 'applyRecommendation');
      sinon.stub(instanceObject, '_getCoreProperties').returns({
        'value': 'recommendedValue',
        'recommendedValue': 'recommendedValue',
        'initialValue': 'initialValue',
        'savedValue': null
      });
      sinon.stub(App.config, 'getDefaultConfig', function(name, fileName, coreObject) {
        coreObject.name = name;
        coreObject.filename = fileName;
        return coreObject;
      });
    });
    afterEach(function() {
      instanceObject.applyRecommendation.restore();
      instanceObject._getCoreProperties.restore();
      App.config.getDefaultConfig.restore();
    });
    
    it('adds new config', function() {
      var res = {
        'value': 'recommendedValue',
        'recommendedValue': 'recommendedValue',
        'savedValue': null,
        'name': 'name',
        'filename': 'fileName',
        'errorMessage': ''
      };

      var test = instanceObject._createNewProperty('name', 'fileName', 'recommendedValue', null);
      helpers.nestedExpect([res], [test]);
      expect(instanceObject.applyRecommendation.calledOnce).to.be.true;
    });

    it('throws error for name/fileName/serviceName', function() {
      expect(instanceObject._createNewProperty.bind(instanceObject)).to.throw(App.NotNullTypeError);
      expect(instanceObject._createNewProperty.bind(instanceObject, 'name')).to.throw(App.NotNullTypeError);
    });
  });

  describe('#_removeConfigByRecommendation', function() {
    beforeEach(function() {
      sinon.spy(instanceObject, 'applyRecommendation');
    });
    afterEach(function() {
      instanceObject.applyRecommendation.restore();
    });
    
    it('removes config', function() {
      var configCollection = [
        {'name': 'cfg1'},
        {'name': 'cfg2'}
      ];
      instanceObject._removeConfigByRecommendation(configCollection[0], configCollection);
      expect(configCollection[0]).to.eql({'name': 'cfg2'});
      expect(instanceObject.applyRecommendation.calledOnce).to.be.true;
    });

    it('throws error', function() {
      expect(instanceObject._removeConfigByRecommendation.bind(instanceObject, null)).to.throw(App.ObjectTypeError);
    });

    it('throws error (2)', function() {
      expect(instanceObject._removeConfigByRecommendation.bind(instanceObject, {}, null)).to.throw(App.ArrayTypeError);
    });
  });

  describe('#_updateBoundaries', function() {
    it('sets appropriate attribute', function() {
      expect(instanceObject._updateBoundaries({}, 'attr1', 'v1')).to.eql({ valueAttributes: {'attr1': 'v1'}});
    });
  });

  describe('#_getCoreProperties', function() {
    var cases = [
      {
        'useInitialValue': true,
        'updateInitialOnRecommendations': true,
        'm': 'use init and update init on recommendation',
        'result': {
          'value': 'recommendedValue',
          'recommendedValue': 'recommendedValue',
          'initialValue': 'recommendedValue',
          'savedValue': null,
          'isNotSaved': false
        }
      },
      {
        'useInitialValue': true,
        'updateInitialOnRecommendations': false,
        'm': 'use init and do not update init on recommendation',
        'result': {
          'value': 'recommendedValue',
          'recommendedValue': 'recommendedValue',
          'initialValue': 'initValue',
          'savedValue': null,
          'isNotSaved': false
        }
      },
      {
        'useInitialValue': false,
        'updateInitialOnRecommendations': false,
        'm': 'do not use init and do not update init on recommendation',
        'result': {
          'value': 'recommendedValue',
          'recommendedValue': 'recommendedValue',
          'initialValue': 'initValue',
          'savedValue': 'initValue',
          'isNotSaved': false
        }
      }
    ];
    cases.forEach(function(c) {
      describe('get core object for different cases', function() {
        beforeEach(function() {
          sinon.stub(instanceObject, 'useInitialValue').returns(c.useInitialValue);
          sinon.stub(instanceObject, 'updateInitialOnRecommendations').returns(c.updateInitialOnRecommendations);
        });
        afterEach(function() {
          instanceObject.useInitialValue.restore();
          instanceObject.updateInitialOnRecommendations.restore();
        });
        it(c.m, function() {
          expect(instanceObject._getCoreProperties('serviceName', 'recommendedValue', 'initValue')).to.eql(c.result);
        })
      })
    });
  });

  describe('#_getInitialFromRecommendations', function() {
    beforeEach(function() {
      instanceObject.set('recommendations', [
        {
          propertyName: 'p1',
          propertyFileName: 'f1',
          configGroup: 'Default',
          initialValue: 'initValue'
        }
      ])
    });

    it('get init value from recommendations', function() {
      expect(instanceObject._getInitialFromRecommendations('p1','f1')).to.equal('initValue');
    });

    it('recommendation does not exist', function() {
      expect(instanceObject._getInitialFromRecommendations('p2','f2')).to.equal(null);
    });
  });

  describe('#_getInitialValue', function() {
    beforeEach(function() {
      sinon.stub(instanceObject, 'useInitialValue', function(serviceName) {
        return serviceName !== 'serviceNameInstalled'
      })
    });
    afterEach(function() {
      instanceObject.useInitialValue.restore();
    });

    it('use initialValue', function() {
      expect(instanceObject._getInitialValue({
        serviceName: 'serviceNameNotInstalled',
        initialValue: 'initV',
        savedValue: 'savedV'
      })).to.equal('initV');
    });

    it('use savedValue', function() {
      expect(instanceObject._getInitialValue({
        serviceName: 'serviceNameInstalled',
        initialValue: 'initV',
        savedValue: 'savedV'
      })).to.equal('savedV');
    });

    it('wrong params', function() {
      expect(instanceObject._getInitialValue()).to.be.null;
    });
  });

  describe('#updateInitialOnRecommendations', function() {
    it('default value for updateInitialOnRecommendations is true', function() {
      expect(instanceObject.updateInitialOnRecommendations()).to.be.false;
    })
  });

  describe('#useInitialValue', function() {
    it('default value for useInitialValue is false', function() {
      expect(instanceObject.useInitialValue()).to.be.false;
    })
  });

  describe('#allowUpdateProperty', function() {



    var cases = [{
      saveRecommended: true
    },{
      saveRecommended: false
    }];

    cases.forEach(function(c) {
      describe('allowUpdateProperty based on saveRecommended:' + c.saveRecommended, function() {
        beforeEach(function() {
          sinon.stub(instanceObject, 'getRecommendation').returns({saveRecommended: c.saveRecommended});
        });
        afterEach(function() {
          instanceObject.getRecommendation.restore();
        });
        it('default value for allowUpdateProperty is true', function() {
          expect(instanceObject.allowUpdateProperty()).to.equal(c.saveRecommended);
        });
      });
    });

    it('default value for allowUpdateProperty is true', function() {
      expect(instanceObject.allowUpdateProperty()).to.be.true;
    });
  });

  describe('#_configHasInitialValue', function() {
    it('throws error when config is null', function() {
      expect(instanceObject._configHasInitialValue.bind(instanceObject, null)).to.throw(App.ObjectTypeError);
    });

    it('throws error when config is not object', function() {
      expect(instanceObject._configHasInitialValue.bind(instanceObject, 'not object')).to.throw(App.ObjectTypeError);
    });

    it('returns true if initial and saved value is defined', function() {
      expect(instanceObject._configHasInitialValue({'savedValue': 'some', 'initialValue': 'most of all the same'})).to.be.true;
    });

    it('returns false if saved value is not defined', function() {
      expect(instanceObject._configHasInitialValue({'savedValue': null, 'initialValue': 'some'})).to.be.false;
    });

    it('returns false if initial value is not defined', function() {
      expect(instanceObject._configHasInitialValue({'savedValue': 'some', 'initialValue': null })).to.be.false;
    });
  });

  describe('#addModifiedFileName', function() {
    it('throws error when filename is not defined', function() {
      expect(instanceObject.addModifiedFileName.bind(instanceObject, null)).to.throw(App.NotNullTypeError);
    });

    it('add new file name', function() {
      instanceObject.set('modifiedFileNames', ['someFile']);
      instanceObject.addModifiedFileName('otherFile');
      expect(instanceObject.get('modifiedFileNames').join(',')).to.be.equal('someFile,otherFile');
    });

    it('do not add file that already in list', function() {
      instanceObject.set('modifiedFileNames', ['someFile']);
      instanceObject.addModifiedFileName('someFile');
      expect(instanceObject.get('modifiedFileNames').join(',')).to.be.equal('someFile');
    });
  });
});



});

require.register("test/mixins/common/configs/config_recommendations_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.ConfigRecommendations', function() {
  var mixinObject = Em.Controller.extend(App.ConfigRecommendations, {});
  var instanceObject = mixinObject.create({});

  beforeEach(function() {
    instanceObject.set('recommendations', []);
  });

  describe('#applyRecommendation', function() {
    beforeEach(function() {
      sinon.stub(instanceObject, 'formatParentProperties', function(parentProperties) { return parentProperties} );
      sinon.stub(App.config, 'get').withArgs('serviceByConfigTypeMap').returns({
        'pFile': Em.Object.create({serviceName: 'sName', displayName: 'sDisplayName'})
      });
    sinon.stub(Handlebars, 'SafeString');
    });
    afterEach(function() {
      instanceObject.formatParentProperties.restore();
      App.config.get.restore();
    Handlebars.SafeString.restore();
    });

    it('adds new recommendation', function() {
      var res = instanceObject.applyRecommendation('pName', 'pFile', 'pGroup', 'pRecommended', 'pInitial', ['p_id'], true);
      expect(res).to.eql({
        saveRecommended: true,
        saveRecommendedDefault: true,
        propertyFileName: 'pFile',
        propertyName: 'pName',
        isDeleted: false,
        notDefined: false,
        configGroup: 'pGroup',
        initialValue: 'pInitial',
        parentConfigs: ['p_id'],
        serviceName: 'sName',
        allowChangeGroup: false,
        serviceDisplayName: 'sDisplayName',
        recommendedValue: 'pRecommended',
        isEditable: true
      });
      expect(instanceObject.getRecommendation('pName', 'pFile', 'pGroup')).to.eql(res);
    });

    it('updates recommendation', function() {
      instanceObject.set('recommendations', [{
        saveRecommended: true,
        saveRecommendedDefault: true,
        propertyFileName: 'pFile',
        propertyName: 'pName',
        isDeleted: false,
        notDefined: false,
        configGroup: 'pGroup',
        initialValue: 'pInitial',
        parentConfigs: ['p_id'],
        serviceName: 'sName',
        allowChangeGroup: false,
        serviceDisplayName: 'sDisplayName',
        recommendedValue: 'pRecommended'
      }]);
      expect(instanceObject.applyRecommendation('pName', 'pFile', 'pGroup', 'pRecommended1', 'pInitial', ['p_id1'])).to.eql({
        saveRecommended: true,
        saveRecommendedDefault: true,
        propertyFileName: 'pFile',
        propertyName: 'pName',
        isDeleted: false,
        notDefined: false,
        configGroup: 'pGroup',
        initialValue: 'pInitial',
        parentConfigs: ['p_id1', 'p_id'],
        serviceName: 'sName',
        allowChangeGroup: false,
        serviceDisplayName: 'sDisplayName',
        recommendedValue: 'pRecommended1'
      });
    });
  });

  describe('#formatParentProperties', function() {
    beforeEach(function() {
      sinon.stub(App.config, 'configId', function(a,b) { return a + b; });
    });
    afterEach(function() {
      App.config.configId.restore();
    });

    it('returns empty array if nothing was passed', function() {
      expect(instanceObject.formatParentProperties(null)).to.eql([]);
    });

    it('returns config ids array', function() {
      expect(instanceObject.formatParentProperties([{name: "n1", type: "t1"}, {name: "n2", type: "t2"}])).to.eql(["n1t1", "n2t2"]);
    });
  });

  describe('#addRecommendation', function() {
    var cases = [
      {
        title: 'add recommendation for editable property with full info',
        name: 'pName', file: 'pFile.xml', group: 'pGroup', recommended: 'pRecommended', initial: 'pInitial', parent: ['p_id'], isEditable: true,
        service: Em.Object.create({serviceName: 'sName', displayName: 'sDisplayName'}),
        result: {
          saveRecommended: true,
          saveRecommendedDefault: true,
          propertyFileName: 'pFile',
          propertyName: 'pName',
          isDeleted: false,
          notDefined: false,
          configGroup: 'pGroup',
          initialValue: 'pInitial',
          parentConfigs: ['p_id'],
          serviceName: 'sName',
          allowChangeGroup: false,
          serviceDisplayName: 'sDisplayName',
          recommendedValue: 'pRecommended',
          isEditable: true
        }
      },
      {
        title: 'add recommendation for read-only property with full info',
        name: 'pName', file: 'pFile.xml', group: 'pGroup', recommended: 'pRecommended', initial: 'pInitial', parent: ['p_id'], isEditable: false,
        service: Em.Object.create({serviceName: 'sName', displayName: 'sDisplayName'}),
        result: {
          saveRecommended: true,
          saveRecommendedDefault: true,
          propertyFileName: 'pFile',
          propertyName: 'pName',
          isDeleted: false,
          notDefined: false,
          configGroup: 'pGroup',
          initialValue: 'pInitial',
          parentConfigs: ['p_id'],
          serviceName: 'sName',
          allowChangeGroup: false,
          serviceDisplayName: 'sDisplayName',
          recommendedValue: 'pRecommended',
          isEditable: false
        }
      },
      {
        title: 'add recommendation with min info',
        name: 'pName', file: 'pFile.xml',
        service: Em.Object.create({serviceName: 'sName', displayName: 'sDisplayName'}),
        result: {
          saveRecommended: true,
          saveRecommendedDefault: true,
          propertyFileName: 'pFile',
          propertyName: 'pName',
          isDeleted: true,
          notDefined: true,
          configGroup: 'Default',
          initialValue: undefined,
          parentConfigs: [],
          serviceName: 'sName',
          allowChangeGroup: false,
          serviceDisplayName: 'sDisplayName',
          recommendedValue: undefined,
          isEditable: true
        }
      }
    ];
    cases.forEach(function(c) {
      describe('successful add recommendation', function() {
        var recommendation;
        beforeEach(function() {
          instanceObject.set('recommendations', []);
          sinon.stub(App.config, 'get').withArgs('serviceByConfigTypeMap').returns({
            'pFile': c.service
          });
          sinon.stub(Handlebars, 'SafeString');
          recommendation = instanceObject.addRecommendation(c.name, c.file, c.group, c.recommended, c.initial, c.parent, c.isEditable);
        });

        afterEach(function() {
          App.config.get.restore();
          Handlebars.SafeString.restore();
        });

        it(c.title, function() {
          expect(recommendation).to.eql(c.result);
        });

        it(c.title + ' check recommendations collection', function() {
          expect(instanceObject.get('recommendations.0')).to.eql(c.result);
        });
      })
    });

    it('throw exception when name, fileName', function() {
      expect(instanceObject.addRecommendation.bind()).to.throw(Error, 'name and fileName should be defined');
      expect(instanceObject.addRecommendation.bind(null, 'fname')).to.throw(Error, 'name and fileName should be defined');
      expect(instanceObject.addRecommendation.bind('name', null)).to.throw(Error, 'name and fileName should be defined');
    });
  });

  describe('#removeRecommendationObject', function () {
    var recommendations = [
      {
        propertyName: 'p1',
        propertyFileName: 'f1'
      },
      {
        propertyName: 'p2',
        propertyFileName: 'f2'
      }
    ];

    beforeEach(function () {
      instanceObject.set('recommendations', recommendations);
    });

    it('remove recommendation', function () {
      instanceObject.removeRecommendationObject(recommendations[1]);

      expect(instanceObject.get('recommendations.length')).to.equal(1);
      expect(instanceObject.get('recommendations.0')).to.eql({
        propertyName: 'p1',
        propertyFileName: 'f1'
      });
    });

    it('remove recommendation that is not exist (don\'t do anything)', function () {
      instanceObject.removeRecommendationObject({propertyName: 'any', 'propertyFileName': 'aby'});
      expect(instanceObject.get('recommendations')).to.eql(recommendations);
    });

    it('throw error if recommendation is undefined ', function () {
      expect(instanceObject.removeRecommendationObject.bind()).to.throw(Error, 'recommendation should be defined object');
      expect(instanceObject.removeRecommendationObject.bind(null)).to.throw(Error, 'recommendation should be defined object');
    });

    it('throw error if recommendation is not an object ', function () {
      expect(instanceObject.removeRecommendationObject.bind('recommendation')).to.throw(Error, 'recommendation should be defined object');
      expect(instanceObject.removeRecommendationObject.bind(['recommendation'])).to.throw(Error, 'recommendation should be defined object');
    });
  });

  describe('#updateRecommendation', function () {
    it('update recommended value and parent properties', function () {
      expect(instanceObject.updateRecommendation({'recommendedValue': 'v2', parentConfigs: ['id1']}, 'v1', ['id2']))
        .to.eql({'recommendedValue': 'v1', parentConfigs: ['id2', 'id1']});
    });

    it('update recommended value and add parent properties', function () {
      expect(instanceObject.updateRecommendation({}, 'v1', ['id1'])).to.eql({'recommendedValue': 'v1', parentConfigs: ['id1']});
    });

    it('update recommended value', function () {
      expect(instanceObject.updateRecommendation({}, 'v1')).to.eql({'recommendedValue': 'v1'});
      expect(instanceObject.updateRecommendation({'recommendedValue': 'v1'}, 'v2')).to.eql({'recommendedValue': 'v2'});
    });

    it('throw error if recommendation is undefined ', function () {
      expect(instanceObject.updateRecommendation.bind()).to.throw(Error, 'recommendation should be defined object');
      expect(instanceObject.updateRecommendation.bind(null)).to.throw(Error, 'recommendation should be defined object');
    });

    it('throw error if recommendation is not an object ', function () {
      expect(instanceObject.updateRecommendation.bind('recommendation')).to.throw(Error, 'recommendation should be defined object');
      expect(instanceObject.updateRecommendation.bind(['recommendation'])).to.throw(Error, 'recommendation should be defined object');
    });
  });

  describe('#saveRecommendation', function() {

    it('skip update since values are same', function() {
      expect(instanceObject.saveRecommendation({saveRecommended: false, saveRecommendedDefault: false}, false)).to.be.false;
    });

    it('perform update since values are different', function() {
      expect(instanceObject.saveRecommendation({saveRecommended: false, saveRecommendedDefault: false}, true)).to.be.true;
    });

    it('updates "saveRecommended" and "saveRecommendedDefault", set "false"', function() {
      var res = {saveRecommended: true, saveRecommendedDefault: true};
      instanceObject.saveRecommendation(res, false);
      expect(res.saveRecommended).to.be.false;
      expect(res.saveRecommendedDefault).to.be.false;
    });

    it('throw error if recommendation is undefined ', function () {
      expect(instanceObject.updateRecommendation.bind()).to.throw(Error, 'recommendation should be defined object');
      expect(instanceObject.updateRecommendation.bind(null)).to.throw(Error, 'recommendation should be defined object');
    });

    it('throw error if recommendation is not an object ', function () {
      expect(instanceObject.updateRecommendation.bind('recommendation')).to.throw(Error, 'recommendation should be defined object');
      expect(instanceObject.updateRecommendation.bind(['recommendation'])).to.throw(Error, 'recommendation should be defined object');
    });
  });

  describe('#getRecommendation', function () {
    var recommendations = [
      {
        propertyName: 'p1',
        propertyFileName: 'f1',
        configGroup: 'Default'
      },
      {
        propertyName: 'p2',
        propertyFileName: 'f2',
        configGroup: 'group1'
      },
      {
        propertyName: 'p1',
        propertyFileName: 'f1',
        configGroup: 'group1'
      }
    ];

    beforeEach(function () {
      instanceObject.set('recommendations', recommendations);
    });

    it('get recommendation for default group', function () {
      expect(instanceObject.getRecommendation('p1', 'f1')).to.eql(recommendations[0]);
    });

    it('get recommendation for default group (2)', function () {
      expect(instanceObject.getRecommendation('p1', 'f1', 'group1')).to.eql(recommendations[2]);
    });

    it('get recommendation for wrong group', function () {
      expect(instanceObject.getRecommendation('p2', 'f2', 'group2')).to.equal(null);
    });

    it('get undefined recommendation', function () {
      expect(instanceObject.getRecommendation('some', 'amy')).to.equal(null);
    });

    it('get throw error if undefined name or fileName passed', function () {
      expect(instanceObject.getRecommendation.bind()).to.throw(Error, 'name and fileName should be defined');
      expect(instanceObject.getRecommendation.bind('name')).to.throw(Error, 'name and fileName should be defined');
      expect(instanceObject.getRecommendation.bind(null, 'fileName')).to.throw(Error, 'name and fileName should be defined');
    });
  });

  describe('#cleanUpRecommendations', function() {
    var cases = [
      {
        title: 'remove recommendations with same init and recommended values',
        recommendations: [{
          initialValue: 'v1', recommendedValue: 'v1'
        }, {
            initialValue: 'v1', recommendedValue: 'v2'
        }],
        cleanUpRecommendations: [{
          initialValue: 'v1', recommendedValue: 'v2'
        }]
      },
      {
        title: 'remove recommendations with null init and recommended values',
        recommendations: [{
          initialValue: null, recommendedValue: null
        }, {
          recommendedValue: null
        }, {
          initialValue: null
        },{
          initialValue: null, recommendedValue: 'v1'
        }, {
          initialValue: 'v1', recommendedValue: null
        }],
        cleanUpRecommendations: [{
          initialValue: null, recommendedValue: 'v1'
        }, {
          initialValue: 'v1', recommendedValue: null
        }
        ]
      }
    ];

    cases.forEach(function(c) {
      describe(c.title, function() {
        beforeEach(function() {
          instanceObject.set('recommendations', c.recommendations);
          instanceObject.cleanUpRecommendations()
        });
        it('do clean up', function() {
          expect(instanceObject.get('recommendations')).to.eql(c.cleanUpRecommendations);
        });
      });
    });
  });

  describe('#clearRecommendationsByServiceName', function () {
    beforeEach(function () {
      instanceObject.set('recommendations', [{serviceName: 's1'}, {serviceName: 's2'}, {serviceName: 's3'}]);
    });

    it('remove with specific service names ', function () {
      instanceObject.clearRecommendationsByServiceName(['s2','s3']);
      expect(instanceObject.get('recommendations')).to.eql([{serviceName: 's1'}]);
    });
  });

  describe('#clearAllRecommendations', function () {
    beforeEach(function () {
      instanceObject.set('recommendations', [{anyObject: 'o1'}, {anyObject: 'o2'}]);
    });

    it('remove all recommendations', function () {
      instanceObject.clearAllRecommendations();
      expect(instanceObject.get('recommendations.length')).to.equal(0);
    });
  });
});


});

require.register("test/mixins/common/configs/configs_saver_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.ConfigsSaverMixin', function() {
  var mixinObject = Em.Controller.extend(App.ConfigsSaverMixin, {});
  var instanceObject = mixinObject.create({});

  describe('#allowSaveCoreSite()', function () {
    var allowedType = 'CORETYPE';
    var allowedService = ['S1'];
    var stackServices = [
      Em.Object.create({
        serviceName: 'S4',
        serviceType: 'CORETYPE'
      }),
      Em.Object.create({
        serviceName: 'S1',
        serviceType: 'SOMEOTHERTYPE'
      }),
      Em.Object.create({
        serviceName: 'S2',
        serviceType: 'SOMEOTHERTYPE'
      })
    ];
    beforeEach(function () {
      instanceObject.setProperties({
        'content': {},
        'coreSiteServiceType': allowedType,
        'coreSiteServiceNames': allowedService
      });
    });

    [{
      currentServices: stackServices[0],
      res: true,
      m: 'service type is ok'
    }, {
      currentServices: stackServices[1],
      res: true,
      m: 'service name is ok'
    }, {
      currentServices: stackServices[2],
      res: false,
      m: 'not ok'
    }].forEach(function (c, index) {
        describe(c.m, function () {
          beforeEach(function () {
            instanceObject.reopen({
              currentServices: c.currentServices
            });
            it('test #' + index, function () {
              expect(instanceObject.allowSaveCoreSite()).to.be.equal(c.res);
            });
          });
        });
      });
  });

  describe('allowSaveSite', function() {
    [
      { fName: 'mapred-queue-acls', res: false, m: 'file name is restricted to be saved' },
      { fName: 'core-site', res: true, allowSaveCoreSite: true, m: 'core site is allowed to be saved' },
      { fName: 'core-site', res: false, allowSaveCoreSite: false, m: 'core site is not allowed to be saved' },
      { fName: 'other-file-name', res: true, m: 'file name has not restriction rule, so can be saved' }
    ].forEach(function (c, index) {
        describe(c.m, function () {
          beforeEach(function() {
            sinon.stub(instanceObject, 'allowSaveCoreSite').returns(c.allowSaveCoreSite);
          });
          afterEach(function() {
            instanceObject.allowSaveCoreSite.restore();
          });
          it('test #' + index, function () {
            expect(instanceObject.allowSaveSite(c.fName)).to.equal(c.res);
          });
        });
      });
  });

  describe('#createDesiredConfig()', function() {
    beforeEach(function() {
      sinon.stub(instanceObject, 'formatValueBeforeSave', function(property) {
        return property.get('value');
      })
    });
    afterEach(function() {
      instanceObject.formatValueBeforeSave.restore();
    });

    it('generates config wil throw error', function() {
      expect(instanceObject.createDesiredConfig.bind(instanceObject)).to.throw(Error, 'assertion failed');
    });

    it('generates config without properties', function() {
      expect(instanceObject.createDesiredConfig('type1', 'version1')).to.eql({
        "type": 'type1',
        "tag": 'version1',
        "properties": {},
        "service_config_version_note": ""
      })
    });

    it('generates config with properties', function() {
      expect(instanceObject.createDesiredConfig('type1', 'version1', [Em.Object.create({name: 'p1', value: 'v1', isRequiredByAgent: true}), Em.Object.create({name: 'p2', value: 'v2', isRequiredByAgent: true})], "note")).to.eql({
        "type": 'type1',
        "tag": 'version1',
        "properties": {
          "p1": 'v1',
          "p2": 'v2'
        },
        "service_config_version_note": 'note'
      })
    });

    it('generates config with properties and skip isRequiredByAgent', function() {
      expect(instanceObject.createDesiredConfig('type1', 'version1', [Em.Object.create({name: 'p1', value: 'v1', isRequiredByAgent: true}), Em.Object.create({name: 'p2', value: 'v2', isRequiredByAgent: false})], "note")).to.eql({
        "type": 'type1',
        "tag": 'version1',
        "properties": {
          p1: 'v1'
        },
        "service_config_version_note": 'note'
      })
    });

    it('generates config with properties and skip service_config_version_note', function() {
      expect(instanceObject.createDesiredConfig('type1', 'version1', [Em.Object.create({name: 'p1', value: 'v1', isRequiredByAgent: true})], "note", true)).to.eql({
        "type": 'type1',
        "tag": 'version1',
        "properties": {
          p1: 'v1'
        }
      })
    });

    it('generates config with final, password, user, group, text, additional_user_property, not_managed_hdfs_path, value_from_property_file', function() {
      expect(instanceObject.createDesiredConfig('type1', 'version1', [
          Em.Object.create({name: 'p1', value: 'v1', isFinal: true, isRequiredByAgent: true}),
          Em.Object.create({name: 'p2', value: 'v2', isRequiredByAgent: true}),
          Em.Object.create({name: 'p3', value: 'v3', isRequiredByAgent: true, propertyType: ["PASSWORD", "USER", "GROUP"]}),
          Em.Object.create({name: 'p4', value: 'v4', isRequiredByAgent: true, propertyType: ["PASSWORD", "TEXT", "ADDITIONAL_USER_PROPERTY"]}),
          Em.Object.create({name: 'p5', value: 'v5', isRequiredByAgent: true, propertyType: ["NOT_MANAGED_HDFS_PATH"]}),
          Em.Object.create({name: 'p6', value: 'v6', isRequiredByAgent: true, propertyType: ["TEXT", "VALUE_FROM_PROPERTY_FILE"]}),
          Em.Object.create({name: 'p7', value: 'v7', isRequiredByAgent: true, propertyType: ["PASSWORD"]})
        ], "note")).to.eql({
        "type": 'type1',
        "tag": 'version1',
        "properties": {
          p1: 'v1',
          p2: 'v2',
          p3: 'v3',
          p4: 'v4',
          p5: 'v5',
          p6: 'v6',
          p7: 'v7'
        },
        "properties_attributes": {
          final: {
            'p1': "true"
          },
          password: {
            "p3": "true",
            "p4": "true",
            "p7": "true"
          },
          user: {
            "p3": "true"
          },
          group: {
            "p3": "true"
          },
          text: {
            "p4": "true",
            "p6": "true"
          },
          additional_user_property: {
            "p4": "true"
          },
          not_managed_hdfs_path: {
            "p5": "true"
          },
          value_from_property_file: {
            "p6": "true"
          }
        },
        "service_config_version_note": 'note'
      })
    })
  });

  describe('#generateDesiredConfigsJSON()', function() {
    beforeEach(function() {
      sinon.stub(instanceObject, 'createDesiredConfig', function(type) {
        return 'desiredConfig_' + type;
      });
      sinon.stub(instanceObject, 'allowSaveSite', function() {
        return true;
      });

    });
    afterEach(function() {
      instanceObject.createDesiredConfig.restore();
      instanceObject.allowSaveSite.restore();
    });

    it('generates empty array as data is missing', function() {
      expect(instanceObject.generateDesiredConfigsJSON()).to.eql([]);
      expect(instanceObject.generateDesiredConfigsJSON(1,1)).to.eql([]);
      expect(instanceObject.generateDesiredConfigsJSON([],[])).to.eql([]);
    });

    it('generates array with desired configs', function() {
      expect(instanceObject.generateDesiredConfigsJSON([Em.Object.create({'name': 'p1', 'fileName': 'f1.xml'})], ['f1'])).to.eql(['desiredConfig_f1']);
      expect(instanceObject.createDesiredConfig).to.be.calledOnce
    })
  });

  describe('#getUniqueTag', function() {

    it('should generate unique tags', function() {
      var tags = [];
      for (var i = 0; i < 3; i++) {
        tags.push(instanceObject.getUniqueTag());
      }
      expect(tags[1]).to.not.be.equal(tags[0]);
      expect(tags[2]).to.not.be.equal(tags[1]);
      expect(tags[0]).to.not.be.equal(tags[2]);
    });
  });

  describe('#getModifiedConfigs', function () {
    var configs = [
      Em.Object.create({
        name: 'p1',
        filename: 'f1',
        isNotDefaultValue: true,
        value: 'v1'
      }),
      Em.Object.create({
        name: 'p2',
        filename: 'f1',
        isNotDefaultValue: false,
        value: 'v2'
      }),
      Em.Object.create({
        name: 'p3',
        filename: 'f2',
        isNotSaved: true,
        value: 'v4'
      }),
      Em.Object.create({
        name: 'p4',
        filename: 'f3',
        isNotDefaultValue: false,
        isNotSaved: false,
        value: 'v4'
      })
    ];
    it('filter out changed configs', function () {
      expect(instanceObject.getModifiedConfigs(configs).mapProperty('name')).to.eql(['p1','p2','p3']);
      expect(instanceObject.getModifiedConfigs(configs).mapProperty('filename').uniq()).to.eql(['f1','f2']);
    });

    it('filter out changed configs and modifiedFileNames', function () {
      instanceObject.set('modifiedFileNames', ['f3']);
      expect(instanceObject.getModifiedConfigs(configs).mapProperty('name')).to.eql(['p1','p2','p3','p4']);
      expect(instanceObject.getModifiedConfigs(configs).mapProperty('filename').uniq()).to.eql(['f1','f2','f3']);
    });
  });
});


});

require.register("test/mixins/common/configs/enhanced_configs_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');

describe('App.EnhancedConfigsMixin', function() {

  var mixinObject = Em.Controller.extend(App.EnhancedConfigsMixin, {});
  var instanceObject = mixinObject.create({});
  describe('#removeCurrentFromDependentList()', function() {
    it('update some fields', function() {
      instanceObject.get('recommendations').pushObject({
          saveRecommended: true,
          saveRecommendedDefault: true,
          configGroup: "Default",
          propertyName: 'p1',
          propertyFileName: 'f1',
          value: 'v1'
        });
      instanceObject.removeCurrentFromDependentList(Em.Object.create({name: 'p1', filename: 'f1.xml', value: 'v2'}));
      expect(instanceObject.get('recommendations')[0]).to.eql({
        saveRecommended: false,
        saveRecommendedDefault: false,
        configGroup: "Default",
        propertyName: 'p1',
        propertyFileName: 'f1',
        value: 'v1'
      });
    });
  });

  describe('#buildConfigGroupJSON()', function() {
    it('generates JSON based on config group info', function() {
      var configGroup = Em.Object.create({
        name: 'group1',
        isDefault: false,
        hosts: ['host1', 'host2']
      });
      var configs = [
        App.ServiceConfigProperty.create({
          name: 'p1',
          filename: 'f1',
          overrides: [
            App.ServiceConfigProperty.create({
              group: configGroup,
              value: 'v1'
            })
          ]
        }),
        App.ServiceConfigProperty.create({
          name: 'p2',
          filename: 'f1',
          overrides: [
            App.ServiceConfigProperty.create({
              group: configGroup,
              value: 'v2'
            })
          ]
        }),
        App.ServiceConfigProperty.create({
          name: 'p3',
          filename: 'f2'
        })
      ];
      expect(instanceObject.buildConfigGroupJSON(configs, configGroup)).to.eql({
        "configurations": [
          {
            "f1": {
              "properties": {
                "p1": "v1",
                "p2": "v2"
              }
            }
          }
        ],
        "hosts": ['host1', 'host2']
      })
    });

    it('throws error as group is null', function() {
      expect(instanceObject.buildConfigGroupJSON.bind(instanceObject)).to.throw(Error, 'configGroup can\'t be null');
    });
  });

  describe("#dependenciesMessage", function () {
    var mixinInstance = mixinObject.create({
      changedProperties: []
    });
    it("no properties changed", function() {
      mixinInstance.set('changedProperties', []);
      mixinInstance.propertyDidChange('dependenciesMessage');
      expect(mixinInstance.get('dependenciesMessage')).to.equal(
        Em.I18n.t('popup.dependent.configs.dependencies.config.plural').format(0) +
        Em.I18n.t('popup.dependent.configs.dependencies.service.plural').format(0)
      )
    });
    it("single property changed", function() {
      mixinInstance.set('changedProperties', [
        Em.Object.create({
          saveRecommended: true,
          serviceName: 'S1'
        })
      ]);
      mixinInstance.propertyDidChange('dependenciesMessage');
      expect(mixinInstance.get('dependenciesMessage')).to.equal(
        Em.I18n.t('popup.dependent.configs.dependencies.config.singular').format(1) +
        Em.I18n.t('popup.dependent.configs.dependencies.service.singular').format(1)
      )
    });
    it("two properties changed", function() {
      mixinInstance.set('changedProperties', [
        Em.Object.create({
          saveRecommended: true,
          serviceName: 'S1'
        }),
        Em.Object.create({
          saveRecommended: true,
          serviceName: 'S1'
        })
      ]);
      mixinInstance.propertyDidChange('dependenciesMessage');
      expect(mixinInstance.get('dependenciesMessage')).to.equal(
        Em.I18n.t('popup.dependent.configs.dependencies.config.plural').format(2) +
        Em.I18n.t('popup.dependent.configs.dependencies.service.singular').format(1)
      )
    });
    it("two properties changed, from different services", function() {
      mixinInstance.set('changedProperties', [
        Em.Object.create({
          saveRecommended: true,
          serviceName: 'S1'
        }),
        Em.Object.create({
          saveRecommended: true,
          serviceName: 'S2'
        })
      ]);
      mixinInstance.propertyDidChange('dependenciesMessage');
      expect(mixinInstance.get('dependenciesMessage')).to.equal(
        Em.I18n.t('popup.dependent.configs.dependencies.config.plural').format(2) +
        Em.I18n.t('popup.dependent.configs.dependencies.service.plural').format(2)
      )
    });
  });

  describe("#loadConfigRecommendations", function () {
    var mixinInstance;

    beforeEach(function(){
      mixinInstance = mixinObject.create({
        recommendationsConfigs: {},
        stepConfigs: [],
        hostGroups: {
          blueprint: {
            configurations: {}
          }
        }
      });
      this.mockedCallback = sinon.stub();
      sinon.stub(App.config, 'getClusterEnvConfigs').returns({
        done: function (callback) {
          callback([]);
        }
      });
    });

    afterEach(function(){
      App.config.getClusterEnvConfigs.restore();
    });

    it("should call callback if changedConfigs is empty array", function() {
      mixinInstance.loadConfigRecommendations([], this.mockedCallback);
      expect(testHelpers.findAjaxRequest('name', 'config.recommendations')).to.not.exist;
      expect(this.mockedCallback.calledOnce).to.be.true;
    });

    it("should call callback from ajax callback if changedConfigs is not empty", function() {
      mixinInstance.loadConfigRecommendations([{}], this.mockedCallback);
      var args = testHelpers.findAjaxRequest('name', 'config.recommendations');
      expect(args[0]).exists;
      args[0].callback();
      expect(this.mockedCallback.calledOnce).to.be.true;
    });

    it("should call getClusterEnvConfigs if there is no cluster-env configs in stepConfigs", function() {
      mixinInstance.loadConfigRecommendations([{}]);
      expect(App.config.getClusterEnvConfigs.calledOnce).to.be.true;
    });

    it("should not call getClusterEnvConfigs if there is cluster-env configs in stepConfigs", function() {
      mixinInstance.set('stepConfigs', [Em.Object.create({
        serviceName: 'MISC',
        configs: []
      })]);
      mixinInstance.loadConfigRecommendations([{}]);
      expect(App.config.getClusterEnvConfigs.calledOnce).to.be.false;
    });
  });

  describe("#changedDependentGroup", function () {
    var mixinInstance;

    beforeEach(function () {
      mixinInstance = mixinObject.create({
        selectedService: {
          serviceName: 'test',
          dependentServiceNames: ['test1', 'test2', 'test3'],
          configGroups: [
            {name: 'testCG'},
            {name: 'notTestCG'}
          ]
        },
        stepConfigs: [
          Em.Object.create({serviceName: 'test1'}),
          Em.Object.create({serviceName: 'test2'}),
          Em.Object.create({serviceName: 'test3'}),
          Em.Object.create({serviceName: 'test4'}),
          Em.Object.create({serviceName: 'test5'})
        ],
        selectedConfigGroup: {name: 'testCG'},
        recommendations: [1, 2, 3]
      });

      sinon.stub(App, 'showSelectGroupsPopup', Em.K);
      sinon.stub(App.Service, 'find').returns([
        {serviceName: 'test2'},
        {serviceName: 'test3'},
        {serviceName: 'test4'}
      ]);
    });

    afterEach(function () {
      App.showSelectGroupsPopup.restore();
      App.Service.find.restore();
    });

    it("should call showSelectGroupsPopup with appropriate arguments", function () {
      mixinInstance.changedDependentGroup();
      expect(App.showSelectGroupsPopup.calledWith(
          'test',
          {name: 'testCG'},
          [
            Em.Object.create({serviceName: 'test2'}),
            Em.Object.create({serviceName: 'test3'})
          ],
          [1, 2, 3]
      )).to.be.true;
    });
  });
});


});

require.register("test/mixins/common/configs/toggle_isrequired_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('#_overrideConfigIsRequired', function () {
  var instanceObject,
    configs,
    serviceConfig;

  beforeEach(function() {
    var mixinObject = Em.Controller.extend(App.ToggleIsRequiredMixin, {});

    instanceObject = mixinObject.create({});

    configs = Em.A([
      App.ServiceConfigProperty.create({ name: 'kdc_hosts', value: '', category: 'KDC', serviceName: 'KERBEROS', isRequired: true}),
      App.ServiceConfigProperty.create({ name: 'admin_server_host', value: '', category: 'KDC', serviceName: 'KERBEROS', isRequired: true}),
      App.ServiceConfigProperty.create({ name: 'admin_principal', value: '', category: 'KDC', serviceName: 'KERBEROS', isRequired: true}),
      App.ServiceConfigProperty.create({ name: 'admin_password', value: '', category: 'KDC', serviceName: 'KERBEROS', isRequired: true})
    ]);

    configs.forEach(function(config) {
      config.validate(); // make isRequired to trigger validation and to set every property's error flag to true
    });
    serviceConfig = App.ServiceConfig.create({
      'serviceName': 'KERBEROS',
      'configs': configs
    });

  });

  it('should make isRequired = false for kerberos properties', function () {
    instanceObject.overrideConfigIsRequired(serviceConfig);
    expect(configs.everyProperty('isRequired', false)).to.be.true;
    expect(configs.everyProperty('error', false)).to.be.true;
  });

  it('should make isRequired = true for kerberos properties', function () {
    // toggle to false
    instanceObject.overrideConfigIsRequired(serviceConfig);
    // toggle to true
    instanceObject.overrideConfigIsRequired(serviceConfig);
    expect(configs.everyProperty('isRequired', true)).to.be.true;
  });
});
});

require.register("test/mixins/common/kdc_credentials_controller_mixin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('mixins/common/kdc_credentials_controller_mixin');

var App = require('app');
var credentialsUtils = require('utils/credentials');

var mixedObject;

describe('App.KDCCredentialsControllerMixin', function() {

  beforeEach(function() {
    mixedObject = Em.Object.create(App.KDCCredentialsControllerMixin);
  });

  afterEach(function() {
    mixedObject.destroy();
  });

  describe('#initializeKDCStoreProperties', function() {
    [
      {
        isStorePersisted: true,
        e: {
          isEditable: true,
          hintMessage: Em.I18n.t('admin.kerberos.credentials.store.hint.supported')
        },
        message: 'Persistent store available, config should be editable, and appropriate hint shown'
      },
      {
        isStorePersisted: false,
        e: {
          isEditable: false,
          hintMessage: Em.I18n.t('admin.kerberos.credentials.store.hint.not.supported')
        },
        message: 'Only temporary store available, config should be disabled, and appropriate hint shown'
      }
    ].forEach(function(test) {
      describe(test.message, function() {

        var config;

        beforeEach(function () {
          var configs = [];
          mixedObject.reopen({
            isStorePersisted: function() {
              return test.isStorePersisted;
            }.property()
          });
          mixedObject.initializeKDCStoreProperties(configs);
          config = configs.findProperty('name', 'persist_credentials');
        });

        Object.keys(test.e).forEach(function(key) {
          it(key, function () {
            assert.equal(Em.get(config, key), test.e[key], 'validate attribute: ' + key);
          });
        });
      });
    });
  });

  describe('#updateKDCStoreProperties', function() {
    [
      {
        isStorePersisted: true,
        e: {
          isEditable: true,
          hintMessage: Em.I18n.t('admin.kerberos.credentials.store.hint.supported')
        },
        message: 'Persistent store available, config should be editable, and appropriate hint shown',
        configs: [
          Em.Object.create({
            name: 'persist_credentials',
            isEditable: false,
            hintMessage: ''
          })
        ]
      },
      {
        isStorePersisted: false,
        e: {
          isEditable: false,
          hintMessage: Em.I18n.t('admin.kerberos.credentials.store.hint.not.supported')
        },
        message: 'Only temporary store available, config should be disabled, and appropriate hint shown',
        configs: [
          Em.Object.create({
            name: 'persist_credentials',
            isEditable: true,
            hintMessage: ''
          })
        ]
      }
    ].forEach(function(test) {
        describe(test.message, function() {

          var config;

          beforeEach(function () {
            var configs = test.configs;
            mixedObject.reopen({
              isStorePersisted: function() {
                return test.isStorePersisted;
              }.property()
            });
            mixedObject.updateKDCStoreProperties(configs);
            config = configs.findProperty('name', 'persist_credentials');
          });

          Object.keys(test.e).forEach(function(key) {
            it(key, function () {
              assert.equal(Em.get(config, key), test.e[key], 'validate attribute: ' + key);
            });
          });
        });
      });
  });

  describe('#createKDCCredentials', function() {

    function createConfig (name, value) {
      return App.ServiceConfigProperty.create({
        name: name,
        value: value
      });
    }
    function resolveWith (data) {
      return $.Deferred().resolve(data).promise();
    }
    function rejectWith (data) {
      return $.Deferred().reject(data).promise();
    }

    beforeEach(function () {
      sinon.stub(App, 'get').withArgs('clusterName').returns('testName');
      sinon.stub(credentialsUtils, 'createCredentials', function() {
        return resolveWith();
      });
      sinon.stub(credentialsUtils, 'updateCredentials', function() {
        return resolveWith();
      });
      mixedObject.reopen({
        isStorePersisted: true
      });
    });

    afterEach(function () {
      App.get.restore();
      credentialsUtils.createCredentials.restore();
      credentialsUtils.updateCredentials.restore();
    });

    [
      {
        configs: [
          createConfig('admin_password', 'admin'),
          createConfig('admin_principal', 'admin/admin'),
          createConfig('persist_credentials', 'true')
        ],
        credentialsExists: false,
        createCredentialFnCalled: true,
        updateCredentialFnCalled: false,
        e: [
          'testName',
          'kdc.admin.credential',
          {
            type: 'persisted',
            key: 'admin',
            principal: 'admin/admin'
          }
        ],
        message: 'Save Admin credentials checkbox checked, credentials already stored and should be updated as `persisted`'
      },
      {
        configs: [
          createConfig('admin_password', 'admin'),
          createConfig('admin_principal', 'admin/admin'),
          createConfig('persist_credentials', 'true')
        ],
        credentialsExists: true,
        createCredentialFnCalled: false,
        updateCredentialFnCalled: true,
        e: [
          'testName',
          'kdc.admin.credential',
          {
            type: 'persisted',
            key: 'admin',
            principal: 'admin/admin'
          }
        ],
        message: 'Save Admin credentials checkbox checked, no stored credentials, should be created as `persisted`'
      },
      {
        configs: [
          createConfig('admin_password', 'admin'),
          createConfig('admin_principal', 'admin/admin'),
          createConfig('persist_credentials', 'false')
        ],
        credentialsExists: true,
        createCredentialFnCalled: false,
        updateCredentialFnCalled: true,
        e: [
          'testName',
          'kdc.admin.credential',
          {
            type: 'temporary',
            key: 'admin',
            principal: 'admin/admin'
          }
        ],
        message: 'Save Admin credentials checkbox unchecked, credentials already stored and should be updated as `temporary`'
      },
      {
        configs: [
          createConfig('admin_password', 'admin'),
          createConfig('admin_principal', 'admin/admin'),
          createConfig('persist_credentials', 'false')
        ],
        credentialsExists: false,
        createCredentialFnCalled: true,
        updateCredentialFnCalled: false,
        e: [
          'testName',
          'kdc.admin.credential',
          {
            type: 'temporary',
            key: 'admin',
            principal: 'admin/admin'
          }
        ],
        message: 'Save Admin credentials checkbox unchecked, credentials already stored and should be updated as `temporary`'
      }
    ].forEach(function(test) {
      describe(test.message, function() {
        beforeEach(function () {
          sinon.stub(credentialsUtils, 'getCredential', function() {
            return test.credentialsExists ? resolveWith() : rejectWith();
          });
          mixedObject.createKDCCredentials(test.configs);
        });

        afterEach(function () {
          credentialsUtils.getCredential.restore();
        });

        it('credentialsUtils#createCredentials called', function () {
          expect(credentialsUtils.createCredentials.calledOnce).to.equal(test.createCredentialFnCalled);
        });

        if (test.createCredentialFnCalled) {
          it('credentialsUtils#createCredentials called with correct arguments', function () {
            expect(credentialsUtils.createCredentials.args[0]).to.eql(test.e);
          });
        }
        it('credentialUtils#updateCredentials called', function () {
          expect(credentialsUtils.updateCredentials.calledOnce).to.equal(test.updateCredentialFnCalled);
        });

        if (test.updateCredentialFnCalled) {
          it('credentialUtils#updateCredentials called with correct arguments', function () {
            expect(credentialsUtils.updateCredentials.args[0]).to.eql(test.e);
          });
        }
      });
    });
  });

});

});

require.register("test/mixins/common/localStorage_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/common/localStorage');

var localStorage,
  nameCases = [
    {
      toSet: {
        name: 'name'
      },
      toExpect: 'Name'
    },
    {
      toSet: {
        name: null,
        controller: {
          name: 'samplecontroller'
        }
      },
      toExpect: 'Samplecontroller'
    },
    {
      toSet: {
        controller: {
          name: 'sampleController'
        }
      },
      toExpect: 'Sample'
    }
  ];

describe('App.LocalStorage', function () {

  beforeEach(function () {
    localStorage = Em.Object.create(App.LocalStorage);
  });

  after(function () {
    App.db.cleanUp();
  });

  describe('#dbNamespace', function () {
    nameCases.forEach(function (item) {
      it('should be ' + item.toExpect, function () {
        localStorage.setProperties(item.toSet);
        expect(localStorage.get('dbNamespace')).to.equal(item.toExpect)
      });
    });
  });

  describe('#getDBProperty', function () {
    it('should take value from DB', function () {
      localStorage.set('name', 'name');
      localStorage.setDBProperty('key', 'value');
      expect(localStorage.getDBProperty('key')).to.equal('value');
    });
  });

});

});

require.register("test/mixins/common/reload_popup_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/common/reload_popup');

describe('App.ReloadPopupMixin', function () {

  var obj;

  beforeEach(function () {
    obj = Em.Object.create(App.ReloadPopupMixin);
  });

  describe('#popupText', function () {
    var cases = [
      {
        result: Em.I18n.t('app.reloadPopup.text'),
        title: 'should show modal popup with default message'
      },
      {
        text: 'text',
        result: 'text',
        title: 'should show modal popup with custom message'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(obj.popupText(item.text)).to.equal(item.result);
      });
    });

  });

  describe('#closeReloadPopup', function () {

    it('should hide modal popup', function () {
      obj.showReloadPopup();
      obj.closeReloadPopup();
      expect(obj.get('reloadPopup')).to.be.null;
    });

  });

  describe('#reloadSuccessCallback', function () {

    it('should hide modal popup', function () {
      obj.showReloadPopup();
      obj.reloadSuccessCallback();
      expect(obj.get('reloadPopup')).to.be.null;
    });

  });

  describe('#reloadErrorCallback', function () {

    var clock,
      cases = [
        {
          args: [{status: 404}, null, null, {}, {shouldUseDefaultHandler: true}],
          closeReloadPopupCallCount: 1,
          defaultErrorHandlerCallCount: 1,
          showReloadPopupCallCount: 0,
          isCallbackCalled: false,
          title: 'status received, default error handler'
        },
        {
          args: [{status: 404}, null, null, {}, {}],
          closeReloadPopupCallCount: 1,
          defaultErrorHandlerCallCount: 0,
          showReloadPopupCallCount: 0,
          isCallbackCalled: false,
          title: 'status received, no default error handler'
        },
        {
          args: [{status: 0}, null, null, {}, {}],
          closeReloadPopupCallCount: 0,
          defaultErrorHandlerCallCount: 0,
          showReloadPopupCallCount: 1,
          isCallbackCalled: false,
          title: 'no status received, no callback'
        },
        {
          args: [{status: 0}, null, null, {}, {callback: Em.K, timeout: 2000}],
          timeout: 1999,
          closeReloadPopupCallCount: 0,
          defaultErrorHandlerCallCount: 0,
          showReloadPopupCallCount: 1,
          isCallbackCalled: false,
          title: 'no status received, callback specified, custom timeout, not enough time passed'
        },
        {
          args: [{status: 0}, null, null, {}, {callback: Em.K}],
          timeout: 999,
          closeReloadPopupCallCount: 0,
          defaultErrorHandlerCallCount: 0,
          showReloadPopupCallCount: 1,
          isCallbackCalled: false,
          title: 'no status received, callback specified, default timeout, not enough time passed'
        },
        {
          args: [{status: 0}, null, null, {}, {callback: Em.K, args: [{}], timeout: 2000}],
          timeout: 2000,
          closeReloadPopupCallCount: 0,
          defaultErrorHandlerCallCount: 0,
          showReloadPopupCallCount: 1,
          isCallbackCalled: true,
          callbackArgs: [{}],
          title: 'no status received, callback with arguments specified, custom timeout, enough time passed'
        },
        {
          args: [{status: 0}, null, null, {}, {callback: Em.K}],
          timeout: 1000,
          closeReloadPopupCallCount: 0,
          defaultErrorHandlerCallCount: 0,
          showReloadPopupCallCount: 1,
          isCallbackCalled: true,
          callbackArgs: [],
          title: 'no status received, callback with no arguments specified, default timeout, enough time passed'
        }
      ];

    cases.forEach(function (item) {
      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(obj, 'closeReloadPopup', Em.K);
          sinon.stub(App.ajax, 'defaultErrorHandler', Em.K);
          sinon.stub(obj, 'showReloadPopup', Em.K);
          sinon.stub(App, 'get').withArgs('timeout').returns(1000);
          if (item.args[4].callback) {
            sinon.spy(item.args[4], 'callback');
          }
          clock = sinon.useFakeTimers();
          obj.reloadErrorCallback.apply(obj, item.args);
          clock.tick(item.timeout);
        });

        afterEach(function () {
          obj.closeReloadPopup.restore();
          App.ajax.defaultErrorHandler.restore();
          obj.showReloadPopup.restore();
          App.get.restore();
          if (item.args[4].callback) {
            item.args[4].callback.restore();
          }
          clock.restore();
        });

        it('closeReloadPopup call', function () {
          expect(obj.closeReloadPopup.callCount).to.equal(item.closeReloadPopupCallCount);
        });
        it('defaultErrorHandler call', function () {
          expect(App.ajax.defaultErrorHandler.callCount).to.equal(item.defaultErrorHandlerCallCount);
        });
        it('showReloadPopup call', function () {
          expect(obj.showReloadPopup.callCount).to.equal(item.showReloadPopupCallCount);
        });

        if (item.isCallbackCalled) {
          it('callback call', function () {
            expect(item.args[4].callback.calledOnce).to.be.true;
          });
          it('callback context', function () {
            expect(item.args[4].callback.calledOn(obj)).to.be.true;
          });
          it('callback arguments', function () {
            expect(item.args[4].callback.firstCall.args).to.eql(item.callbackArgs);
          });
        }

      });
    });

  });

});

});

require.register("test/mixins/common/serverValidator_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.ServerValidatorMixin', function () {
  var mixinObject = Em.Object.extend(App.ServerValidatorMixin, {});
  var instanceObject;
  beforeEach(function () {
    instanceObject = mixinObject.create();
  });
  describe('#collectAllIssues', function () {
    var result = [];
    var stepConfigs = [
      Em.Object.create({
        serviceName: 'service1',
        configs: [
          Em.Object.create({
            id: 'c1_f1',
            name: 'c1',
            filename: 'f1',
            isVisible: true,
            hiddenBySection: false
          }),
          Em.Object.create({
            id: 'c2_f2',
            name: 'c2',
            filename: 'f2',
            isVisible: true,
            hiddenBySection: false
          }),
          Em.Object.create({
            id: 'c3_f3',
            name: 'c3',
            filename: 'f3',
            isVisible: true,
            hiddenBySection: false,
            warnMessage: 'warn3'
          }),
          Em.Object.create({
            id: 'c4_f4',
            name: 'c4',
            filename: 'f4',
            isVisible: false,
            hiddenBySection: false
          })
        ]
      })
    ];

    var response = {
      configErrorsMap: {
        'c1_f1': {
          type: 'WARN',
          messages: ['warn1']
        },
        'c2_f2': {
          type: 'ERROR',
          messages: ['error2']
        },
        'c4_f4': {
          type: 'ERROR',
          messages: ['error4']
        },
        'c5_f5': {
          type: 'ERROR',
          messages: ['error5']
        }
      },
      generalErrors: [{
        type: 'GENERAL',
        messages: ['general issue']
      }]
    };

    beforeEach(function () {
      instanceObject.set('stepConfigs', stepConfigs);
      result = instanceObject.collectAllIssues(response.configErrorsMap, response.generalErrors);
    });

    it('should add server warnings', function () {
      var error = result.find(function(r) { return r.propertyName === 'c1' && r.filename === 'f1'; });
      expect(error.type).to.equal('WARN');
      expect(error.messages).to.eql(['warn1']);
    });

    it('should add server errors', function () {
      var error = result.find(function(r) { return r.propertyName === 'c2' && r.filename === 'f2'; });
      expect(error.type).to.equal('ERROR');
      expect(error.messages).to.eql(['error2']);
    });

    it('should add ui warning', function () {
      var error = result.find(function(r) { return r.propertyName === 'c3' && r.filename === 'f3'; });
      expect(error.type).to.equal('WARN');
      expect(error.messages).to.eql(['warn3']);
    });

    it('should add general issues', function () {
      var error = result.findProperty('type', 'GENERAL');
      expect(error.messages).to.eql(['general issue']);
    });

    it('should ignore issues for hidden configs', function () {
      var error = result.find(function(r) { return r.propertyName === 'c4' && r.filename === 'f4'; });
      expect(error).to.be.undefined;
    });

    it('should add issues for deleted properties', function () {
      var error = result.find(function(r) { return r.id === 'c5_f5'; });
      expect(error.messages).to.eql(['error5']);
    });
  });

  describe('#createErrorMessage', function() {
    var property = {
      id: 'p1_f1',
      name: 'p1',
      filename: 'f1',
      value: 'v1',
      description: 'd1'
    };
    beforeEach(function() {
      sinon.stub(App.StackService, 'find', function() {
        return Em.Object.create({
          displayName: 'sName'
        });
      });
    });

    afterEach(function() {
      App.StackService.find.restore();
    });

    it('creates warn object', function() {
      expect(instanceObject.createErrorMessage('WARN', property, ['msg1'])).to.eql({
        type: 'WARN',
        isError: false,
        isWarn: true,
        isGeneral: false,
        messages: ['msg1'],
        propertyName: 'p1',
        filename: 'f1',
        value: 'v1',
        description: 'd1',
        serviceName: 'sName',
        id: 'p1_f1'
      });
    });

    it('creates error object', function() {
      expect(instanceObject.createErrorMessage('ERROR', $.extend({}, property, {serviceDisplayName: 'S Name'}), ['msg2'])).to.eql({
        type: 'ERROR',
        isError: true,
        isWarn: false,
        isGeneral: false,
        messages: ['msg2'],
        propertyName: 'p1',
        filename: 'f1',
        value: 'v1',
        description: 'd1',
        serviceName: 'S Name',
        id: 'p1_f1'
      });
    });

    it('creates general issue object', function() {
      expect(instanceObject.createErrorMessage('GENERAL', null, ['msg3'])).to.eql({
        type: 'GENERAL',
        isError: false,
        isWarn: false,
        isGeneral: true,
        messages: ['msg3']
      });
    });

    it('creates WRONG TYPE issue object', function() {
      expect(instanceObject.createErrorMessage.bind(instanceObject, 'WRONG TYPE', null, ['msg3']))
        .to.throw(Error, 'Unknown config error type WRONG TYPE');
    });
  });
});


});

require.register("test/mixins/common/table_server_view_mixin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mixins/common/table_server_view_mixin');
require('utils/load_timer');

describe('App.MainConfigHistoryView', function() {
  var view = Em.View.create(App.TableServerViewMixin, {
    filteredCount: 0,
    totalCount: 0,
    content: [],
    filteredContent: [],
    refresh: Em.K,
    saveFilterConditions: Em.K,
    controller: Em.Object.create({
      name: 'mainConfigHistoryController',
      paginationProps: [
        {
          name: 'displayLength',
          value: '25'
        },
        {
          name: 'startIndex',
          value: 0
        }
      ]
    })
  });

  describe('#pageContent', function() {
    beforeEach(function(){
      view.propertyDidChange('pageContent');
    });
    it('filtered content is empty', function() {
      view.set('filteredContent', []);
      expect(view.get('pageContent')).to.be.empty;
    });
    it('filtered content contain one item', function() {
      view.set('filteredCount', 1);
      view.set('filteredContent', [Em.Object.create()]);

      expect(view.get('pageContent')).to.eql([Em.Object.create()]);
    });
    it('filtered content contain two unsorted items', function() {
      view.set('filteredCount', 2);
      view.set('filteredContent', [
        Em.Object.create({index:2}),
        Em.Object.create({index:1})
      ]);

      expect(view.get('pageContent')).to.eql([
        Em.Object.create({index:1}),
        Em.Object.create({index:2})
      ]);
    });
  });

  describe('#updatePagination', function() {
    beforeEach(function () {
      sinon.spy(view, 'refresh');
      sinon.stub(App.db, 'setDisplayLength', Em.K);
      sinon.stub(App.db, 'setStartIndex', Em.K);
    });
    afterEach(function () {
      view.refresh.restore();
      App.db.setStartIndex.restore();
      App.db.setDisplayLength.restore();
    });

    describe('displayLength is correct', function() {
      beforeEach(function () {
        view.set('displayLength', '50');
        view.set('startIndex', null);
        view.updatePagination();
      });

      it('refresh is called once', function () {
        expect(view.refresh.calledOnce).to.be.true;
      });
      it('setStartIndex is called once', function () {
        expect(App.db.setStartIndex.called).to.be.false;
      });
      it('setDisplayLength is called with correct arguments', function () {
        expect(App.db.setDisplayLength.calledWith('mainConfigHistoryController', '50')).to.be.true;
      });
    });

    describe('startIndex is correct', function() {

      beforeEach(function () {
        view.set('displayLength', null);
        view.set('startIndex', 10);
        view.updatePagination();
      });
      it('refresh is called once', function () {
        expect(view.refresh.calledOnce).to.be.true;
      });
      it('setStartIndex is called with valid arguments', function () {
        expect(App.db.setStartIndex.calledWith('mainConfigHistoryController', 10)).to.be.true;
      });
      it('setDisplayLength is not called', function () {
        expect(App.db.setDisplayLength.called).to.be.false;
      });
    });

    describe('displayLength and startIndex are correct', function() {
      beforeEach(function () {
        view.set('displayLength', '100');
        view.set('startIndex', 20);
        view.updatePagination();
      });

      it('refresh is called once', function () {
        expect(view.refresh.calledOnce).to.be.true;
      });
      it('setStartIndex is called with valid arguments', function () {
        expect(App.db.setStartIndex.calledWith('mainConfigHistoryController', 20)).to.be.true;
      });
      it('setDisplayLength is called with valid arguments', function () {
        expect(App.db.setDisplayLength.calledWith('mainConfigHistoryController', '100')).to.be.true;
      });
    });

    describe('displayLength and startIndex are null', function() {
      beforeEach(function () {
        view.set('displayLength', null);
        view.set('startIndex', null);
        view.updatePagination();
      });
      it('refresh is called once', function () {
        expect(view.refresh.calledOnce).to.be.true;
      });
      it('setStartIndex is not called', function () {
      expect(App.db.setStartIndex.called).to.be.false;
      });
      it('setDisplayLength is not called', function () {
      expect(App.db.setDisplayLength.called).to.be.false;
      });
    });
  });

  describe('#updateFilter()', function() {
    beforeEach(function () {
      sinon.stub(view, 'saveFilterConditions', Em.K);
      sinon.stub(view, 'refresh', Em.K);
      sinon.stub(view, 'resetStartIndex');
      sinon.spy(view, 'updateFilter');
      this.clock = sinon.useFakeTimers();
    });
    afterEach(function () {
      view.saveFilterConditions.restore();
      view.updateFilter.restore();
      view.resetStartIndex.restore();
      view.refresh.restore();
      this.clock.restore();
    });
    it('filteringComplete is false', function() {


      view.set('filteringComplete', false);
      view.updateFilter(1, '1', 'string');
      expect(view.get('controller.resetStartIndex')).to.be.false;
      expect(view.saveFilterConditions.called).to.be.false;
      view.set('filteringComplete', true);
      this.clock.tick(view.get('filterWaitingTime'));
      expect(view.updateFilter.calledWith(1, '1', 'string')).to.be.true;

    });
    it('filteringComplete is true', function() {
      view.set('filteringComplete', true);

      view.updateFilter(1, '1', 'string');
      expect(view.get('controller.resetStartIndex')).to.be.true;
      expect(view.saveFilterConditions.calledWith(1, '1', 'string', false)).to.be.true;
      expect(view.refresh.calledOnce).to.be.true;
    });

    it('clear filters - refresh() clears timer', function () {

      //clear filters simulation
      view.set('filteringComplete', false);
      view.updateFilter(0, '', 'string');

      //filters cleared success
      view.updaterSuccessCb();

      //timeout in updateFilter() runs out
      this.clock.tick(view.get('filterWaitingTime'));

      //should not call update filter again
      expect(view.updateFilter.calledOnce).to.be.true;
    })
  });

  describe('#resetStartIndex()', function() {
    beforeEach(function () {
      sinon.stub(view, 'updatePagination');
      sinon.spy(view, 'saveStartIndex');
    });
    afterEach(function () {
      view.saveStartIndex.restore();
      view.updatePagination.restore();
    });
    it('resetStartIndex is false and filteredCount is 0', function() {
      view.set('filteredCount', 0);
      view.set('controller.resetStartIndex', false);
      view.set('startIndex', 0);
      view.resetStartIndex();
      expect(view.get('startIndex')).to.equal(0);
      expect(view.saveStartIndex.called).to.be.false;
      expect(view.updatePagination.called).to.be.false;
    });
    it('resetStartIndex is true and filteredCount is 0', function() {
      view.set('filteredCount', 0);
      view.set('controller.resetStartIndex', true);
      view.set('startIndex', 0);
      view.resetStartIndex();
      expect(view.get('startIndex')).to.equal(0);
      expect(view.saveStartIndex.called).to.be.false;
      expect(view.updatePagination.called).to.be.false;
    });
    it('resetStartIndex is false and filteredCount is 5', function() {
      view.set('filteredCount', 5);
      view.set('controller.resetStartIndex', false);
      view.set('startIndex', 0);
      view.resetStartIndex();
      expect(view.get('startIndex')).to.equal(0);
      expect(view.saveStartIndex.called).to.be.false;
      expect(view.updatePagination.called).to.be.false;
    });
    it('resetStartIndex is true and filteredCount is 5', function() {
      view.set('controller.resetStartIndex', true);
      view.set('filteredCount', 5);
      view.set('startIndex', 0);
      view.resetStartIndex();
      expect(view.get('startIndex')).to.equal(1);
      expect(view.saveStartIndex.called).to.be.true;
      expect(view.updatePagination.called).to.be.true;
    });
  });

  describe("#updaterSuccessCb()", function () {
    beforeEach(function () {
      sinon.stub(view, 'propertyDidChange');
      view.set('filteringComplete', false);
      view.updaterSuccessCb();
    });
    afterEach(function () {
      view.propertyDidChange.restore();
    });
    it('pageContent is forced to be recalculated', function () {
      expect(view.propertyDidChange.calledWith('pageContent')).to.be.true;
    });
    it('filteringComplete is updated', function () {
      expect(view.get('filteringComplete')).to.be.true;
    });
  });
});

});

require.register("test/mixins/common/widget_mixin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');

describe('App.WidgetMixin', function () {
  var mixinClass = Em.Object.extend(App.WidgetMixin, {metrics: [], content: {}});
  var mixinObject;

  beforeEach(function () {
    mixinObject = mixinClass.create();
  });

  afterEach(function () {
    clearTimeout(mixinObject.get('timeoutId'));
    mixinObject.destroy();
  });

  describe('#loadMetrics()', function () {
    beforeEach(function () {
      this.mock = sinon.stub(mixinObject, 'getRequestData');
      sinon.stub(App.WidgetLoadAggregator, 'add');
    });
    afterEach(function () {
      this.mock.restore();
      App.WidgetLoadAggregator.add.restore();
    });
    it('has host_component_criteria', function () {
      this.mock.returns({'key1': {host_component_criteria: 'criteria'}});
      mixinObject.set('isLoaded', false);
      mixinObject.loadMetrics();

      expect(App.WidgetLoadAggregator.add.calledOnce).to.be.true;
    });
    it('host_component_criteria is absent', function () {
      this.mock.returns({'key1': {}});
      mixinObject.set('isLoaded', false);
      mixinObject.loadMetrics();

      expect(App.WidgetLoadAggregator.add.calledOnce).to.be.true;
    });
  });

  describe("#extractExpressions()", function () {
    var testCases = [
      {
        data: '',
        result: []
      },
      {
        data: 'text',
        result: []
      },
      {
        data: 'text${a}',
        result: ['a']
      },
      {
        data: 'text${a} - ${a.b}',
        result: ['a', 'a.b']
      },
      {
        data: '${o.a-(b+4)/cc*tt}',
        result: ['o.a-(b+4)/cc*tt']
      }
    ];
    testCases.forEach(function (test) {
      it('input: ' + test.data, function () {
        var input = {value: test.data};
        expect(mixinObject.extractExpressions(input)).to.eql(test.result);
      });
    });
    it('input is null', function () {
      var input = null;
      expect(mixinObject.extractExpressions(input)).to.be.empty;
    });
  });

  describe("#getRequestData()", function () {
    var data = [
      {
        "name": "regionserver.Server.percentFilesLocal",
        "metric_path": "metrics/hbase/regionserver/percentFilesLocal",
        "service_name": "HBASE",
        "component_name": "HBASE_REGIONSERVER"
      },
      {
        "name": "regionserver.Server.percentFilesLocal2",
        "metric_path": "w2",
        "service_name": "HBASE",
        "component_name": "HBASE_REGIONSERVER"
      },
      {
        "name": "regionserver.Server.percentFilesLocal",
        "metric_path": "metrics/hbase/regionserver/percentFilesLocal",
        "service_name": "HBASE",
        "component_name": "HBASE_REGIONSERVER",
        "host_component_criteria": 'c1'
      },
      {
        "name": "regionserver.Server.percentFilesLocal",
        "metric_path": "metrics/hbase/regionserver/percentFilesLocal",
        "service_name": "HDFS",
        "component_name": "DATANODE",
        "host_component_criteria": 'c1'
      }
    ];

    beforeEach(function () {
      this.requestData = mixinClass.create().getRequestData(data);
    });

    it('HBASE_HBASE_REGIONSERVER', function () {
      var hbaseRegionServer = {
        "name": "regionserver.Server.percentFilesLocal",
        "service_name": "HBASE",
        "component_name": "HBASE_REGIONSERVER",
        "metric_paths": [
          {
            "metric_path": "metrics/hbase/regionserver/percentFilesLocal",
            "metric_type": "POINT_IN_TIME",
            "id": "metrics/hbase/regionserver/percentFilesLocal_POINT_IN_TIME",
            "context": {}
            },
          {
            "metric_path": "w2",
            "metric_type": "POINT_IN_TIME",
            "id": "w2_POINT_IN_TIME",
            "context": {}
            }
          ]
        };
      expect(JSON.stringify(this.requestData.HBASE_HBASE_REGIONSERVER)).to.equal(JSON.stringify(hbaseRegionServer));
    });

    it('HBASE_HBASE_REGIONSERVER_c1', function () {
      var hbaseRegionServerC1 = {
        "name": "regionserver.Server.percentFilesLocal",
        "service_name": "HBASE",
        "component_name": "HBASE_REGIONSERVER",
        "host_component_criteria": "c1",
        "metric_paths": [
          {
            "metric_path": "metrics/hbase/regionserver/percentFilesLocal",
            "metric_type": "POINT_IN_TIME",
            "id": "metrics/hbase/regionserver/percentFilesLocal_POINT_IN_TIME",
            "context": {}
          }
        ]
      };
      expect(JSON.stringify(this.requestData.HBASE_HBASE_REGIONSERVER_c1)).to.equal(JSON.stringify(hbaseRegionServerC1));
    });

    it('HDFS_DATANODE_c1', function () {
      var hdfsDataNodeC1 = {
        "name": "regionserver.Server.percentFilesLocal",
        "service_name": "HDFS",
        "component_name": "DATANODE",
        "host_component_criteria": "c1",
        "metric_paths": [
          {
            "metric_path": "metrics/hbase/regionserver/percentFilesLocal",
            "metric_type": "POINT_IN_TIME",
            "id": "metrics/hbase/regionserver/percentFilesLocal_POINT_IN_TIME",
            "context": {}
          }
        ]
      };
      expect(JSON.stringify(this.requestData.HDFS_DATANODE_c1)).to.equal(JSON.stringify(hdfsDataNodeC1));
    });

  });

  describe("#getServiceComponentMetrics()", function () {

    it("valid request is sent", function () {
      var request = {
        service_name: 'S1',
        component_name: 'C1',
        metric_paths: [
          {
            "metric_path": "w1",
            "metric_type": "POINT_IN_TIME",
            "id": "w1_POINT_IN_TIME",
            "context": {}
          },
          {
            "metric_path": "w2",
            "metric_type": "POINT_IN_TIME",
            "id": "w2_POINT_IN_TIME",
            "context": {}
          }
        ]
      };
      mixinObject.getServiceComponentMetrics(request);
      var args = testHelpers.findAjaxRequest('name', 'widgets.serviceComponent.metrics.get');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(mixinObject);
      expect(args[0].data).to.be.eql({
        serviceName: 'S1',
        componentName: 'C1',
        metricPaths: 'w1,w2'
      });
    });
  });

  describe("#getMetricsSuccessCallback()", function () {
    it("metric is mapped from provided path", function () {
      var data = {
        metrics: {
          "hbase": {
            "ipc": {
              "IPC": {
                "numOpenConnections": 11.5
              }
            }
          }
        }
      };
      mixinObject.set('content.metrics', [
        {
          metric_path: 'metrics/hbase/ipc/IPC/numOpenConnections'
        }
      ]);
      mixinObject.getMetricsSuccessCallback(data);
      expect(mixinObject.get('metrics').findProperty('metric_path', 'metrics/hbase/ipc/IPC/numOpenConnections').data).to.equal(11.5);
    });
  });

  describe("#disableGraph", function () {
    var graph = Em.Object.create({
        hasData: true,
        _showMessage: Em.K
      }),
      cases = [
        {
          graphView: null,
          childViews: [],
          hasData: true,
          isExportButtonHidden: false,
          showMessageCallCount: 0,
          title: 'no graph'
        },
        {
          graphView: {},
          childViews: [{}],
          hasData: true,
          isExportButtonHidden: false,
          showMessageCallCount: 0,
          title: 'no graph view rendered'
        },
        {
          graphView: {},
          childViews: [
            {},
            graph
          ],
          hasData: false,
          isExportButtonHidden: true,
          showMessageCallCount: 1,
          title: 'graph view rendered'
        }
      ];

    cases.forEach(function (item) {
      describe(item.title, function () {
        beforeEach(function() {
          mixinObject.setProperties({
            isExportButtonHidden: false,
            childViews: item.childViews,
            graphView: item.graphView,
            metrics: [
              {
                name: 'm1'
              },
              {
                name: 'm2'
              }
            ],
            content: {
              metrics: [
                {
                  name: 'm2'
                }
              ]
            }
          });
          sinon.stub(graph, '_showMessage');
          mixinObject.disableGraph();
        });

        afterEach(function() {
          graph._showMessage.restore();
        });

        it('hasData', function() {
          expect(graph.get('hasData')).to.equal(item.hasData);
        });

        it('isExportButtonHidden', function() {
          expect(mixinObject.get('isExportButtonHidden')).to.equal(item.isExportButtonHidden);
        });

        it('_showMessage call count', function() {
          expect(graph._showMessage.callCount).to.equal(item.showMessageCallCount);
        });

        it('metrics should be filtered', function() {
          expect(mixinObject.get('metrics').mapProperty('name')).to.eql(['m1']);
        });
      });
    });
  });

  describe("#getHostComponentMetrics()", function () {
    beforeEach(function () {
      sinon.stub(mixinObject, 'computeHostComponentCriteria').returns('criteria')
    });
    afterEach(function () {
      mixinObject.computeHostComponentCriteria.restore();
    });
    it("valid request is sent", function () {
      var request = {
        component_name: 'C1',
        metric_paths: [
          {
            "metric_path": "w1",
            "metric_type": "POINT_IN_TIME",
            "id": "w1_POINT_IN_TIME",
            "context": {}
          },
          {
            "metric_path": "w2",
            "metric_type": "POINT_IN_TIME",
            "id": "w2_POINT_IN_TIME",
            "context": {}
          }
        ],
        host_component_criteria: 'c1'
      };
      mixinObject.getHostComponentMetrics(request);
      var args = testHelpers.findAjaxRequest('name', 'widgets.hostComponent.metrics.get');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(mixinObject);
      expect(args[0].data).to.be.eql({
        componentName: 'C1',
        metricPaths: 'w1,w2',
        hostComponentCriteria: 'criteria'
      });
    });
  });

  describe("#calculateValues()", function () {

    beforeEach(function () {
      sinon.stub(mixinObject, 'extractExpressions');
      this.mock = sinon.stub(mixinObject, 'computeExpression');
    });
    afterEach(function () {
      mixinObject.extractExpressions.restore();
      this.mock.restore();
    });
    it("value compute correctly", function () {
      this.mock.returns({'${a}': 1});
      mixinObject.set('content.values', [{
        value: '${a}'
      }]);
      mixinObject.calculateValues();
      expect(mixinObject.get('content.values')[0].computedValue).to.equal('1');
    });
    it("value not available", function () {
      this.mock.returns({});
      mixinObject.set('content.values', [{
        value: '${a}'
      }]);
      mixinObject.calculateValues();
      expect(mixinObject.get('content.values')[0].computedValue).to.equal('<span class="grey">n/a</span>');
    });
    it("value is null", function () {
      this.mock.returns({'${a}': null});
      mixinObject.set('content.values', [{
        value: '${a}'
      }]);
      mixinObject.calculateValues();
      expect(mixinObject.get('content.values')[0].computedValue).to.equal('<span class="grey">n/a</span>');
    });
  });

  describe("#computeExpression()", function () {
    it("expression missing metrics", function () {
      var expressions = ['e.m1'];
      var metrics = [];
      expect(mixinObject.computeExpression(expressions, metrics)).to.eql({
        "${e.m1}": ""
      });
    });
    it("Value is not correct mathematical expression", function () {
      var expressions = ['e.m1'];
      var metrics = [{
        name: 'e.m1',
        data: 'a+1'
      }];
      expect(mixinObject.computeExpression(expressions, metrics)).to.eql({
        "${e.m1}": ""
      });
    });
    it("correct expression", function () {
      var expressions = ['e.m1+e.m1'];
      var metrics = [{
        name: 'e.m1',
        data: 1
      }];
      expect(mixinObject.computeExpression(expressions, metrics)).to.eql({
        "${e.m1+e.m1}": "2"
      });
    });
  });

  describe("#cloneWidget()", function () {
    var popup;
    beforeEach(function () {
      sinon.spy(App, 'showConfirmationPopup');
      sinon.stub(mixinObject, 'postWidgetDefinition', Em.K);
      popup = mixinObject.cloneWidget();
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      mixinObject.postWidgetDefinition.restore();
    });
    it("popup is shown", function () {
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
    });
    it('postWidgetDefinition is called', function () {
      popup.onPrimary();
      expect(mixinObject.postWidgetDefinition.calledOnce).to.be.true;
    });
  });

  describe("#postWidgetDefinition()", function () {
    beforeEach(function () {
      sinon.stub(mixinObject, 'collectWidgetData').returns({});
    });
    afterEach(function () {
      mixinObject.collectWidgetData.restore();
    });
    it("valid request is sent", function () {
      mixinObject.postWidgetDefinition();
      var args = testHelpers.findAjaxRequest('name', 'widgets.wizard.add');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(mixinObject);
      expect(args[0].data).to.be.eql({
        data: {}
      });
    });
  });

  describe('#getMetricsErrorCallback()', function () {

    var obj,
      view = Em.Object.create({
        _showMessage: Em.K
      }),
      metrics = [
        {
          name: 'n0'
        },
        {
          name: 'n1'
        }
      ],
      cases = [
        {
          graphView: null,
          isForcedAbort: false,
          metrics: metrics,
          showMessageCallCount: 0,
          isExportButtonHidden: false,
          title: 'no graph view'
        },
        {
          graphView: {},
          isForcedAbort: false,
          metrics: metrics,
          showMessageCallCount: 0,
          isExportButtonHidden: false,
          title: 'no childViews property'
        },
        {
          graphView: {},
          childViews: [],
          isForcedAbort: false,
          metrics: metrics,
          showMessageCallCount: 0,
          isExportButtonHidden: false,
          title: 'no child views'
        },
        {
          graphView: {},
          childViews: [Em.Object.create({})],
          isForcedAbort: false,
          metrics: metrics,
          showMessageCallCount: 0,
          isExportButtonHidden: false,
          title: 'no view with _showMessage method'
        },
        {
          graphView: {},
          childViews: [Em.Object.create({}), view],
          isForcedAbort: false,
          metrics: [
            {
              name: 'n1'
            }
          ],
          showMessageCallCount: 1,
          isExportButtonHidden: true,
          title: 'graph view is available'
        },
        {
          graphView: {},
          childViews: [Em.Object.create({}), view],
          isForcedAbort: true,
          metrics: metrics,
          showMessageCallCount: 0,
          isExportButtonHidden: false,
          title: 'request is aborted'
        }
      ],
      messageCases = [
        {
          readyState: 2,
          status: 0,
          textStatus: 'error',
          title: 'incomplete request'
        },
        {
          readyState: 4,
          status: 0,
          textStatus: 'error',
          title: 'no status code'
        },
        {
          readyState: 4,
          status: 404,
          textStatus: '404 error',
          title: 'status code available'
        }
      ];

    beforeEach(function () {
      sinon.spy(view, '_showMessage');
    });

    afterEach(function () {
      view._showMessage.restore();
    });

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          obj = Em.Object.create(App.WidgetMixin, {
            metrics: metrics,
            content: {
              metrics: [
                {
                  name: 'n0'
                }
              ]
            },
            isExportButtonHidden: false,
            graphView: item.graphView,
            childViews: item.childViews
          });
          obj.getMetricsErrorCallback({
            isForcedAbort: item.isForcedAbort
          });
        });

        it('metrics array', function () {
          expect(obj.get('metrics')).to.eql(item.metrics);
        });

        it('error message', function () {
          expect(view._showMessage.callCount).to.equal(item.showMessageCallCount);
        });

        it('export button display', function () {
          expect(obj.get('isExportButtonHidden')).to.equal(item.isExportButtonHidden);
        });

      });

    });

    messageCases.forEach(function (item) {

      it(item.title, function () {
        obj = Em.Object.create(App.WidgetMixin, {
          graphView: Em.Object.create({}),
          childViews: [view]
        });
        obj.getMetricsErrorCallback({
          readyState: item.readyState,
          status: item.status
        }, 'error', 'Not Found');
        expect(view._showMessage.firstCall.args).to.eql(['warn', Em.I18n.t('graphs.error.title'), Em.I18n.t('graphs.error.message').format(item.textStatus, 'Not Found')]);
      });

    });

  });
});


describe('App.WidgetLoadAggregator', function () {
  var aggregator = App.WidgetLoadAggregator;

  describe("#add()", function () {
    it("timeout started", function () {
      aggregator.set('timeoutId', 'timeId');
      aggregator.get('requests').clear();
      aggregator.add({});
      expect(aggregator.get('requests')).to.not.be.empty;
    });
    it("timeout started (2)", function () {
      aggregator.set('timeoutId', null);
      aggregator.get('requests').clear();
      aggregator.add({});
      expect(aggregator.get('requests')).to.not.be.empty;
    });
  });

  describe("#groupRequests()", function () {
    var result;

    beforeEach(function () {
      var requests = [
        {
          startCallName: 'n1',
          data: {
            component_name: 'C1',
            metric_paths: ['m1']
          },
          context: Em.Object.create({
            content: {
              widgetType: 'GRAPH'
            }
          })
        },
        {
          startCallName: 'n1',
          data: {
            component_name: 'C1',
            metric_paths: ['m2']
          },
          context: Em.Object.create({
            content: {
              widgetType: 'NUMBER'
            }
          })
        },
        {
          startCallName: 'n2',
          data: {
            component_name: 'C1',
            metric_paths: ['m3']
          },
          context: Em.Object.create({
            content: {
              widgetType: 'TEMPLATE'
            }
          })
        },
        {
          startCallName: 'n1',
          data: {
            component_name: 'C2',
            metric_paths: ['m4']
          },
          context: Em.Object.create({
            content: {
              widgetType: 'GAUGE'
            }
          })
        }
      ];
      result = aggregator.groupRequests(requests);
    });

    it("result.n1_C1.subRequests.length", function () {
      expect(result.n1_C1.subRequests.length).to.equal(1);
    });
    it("result.n1_C1.data.metric_paths.length", function () {
      expect(result.n1_C1.data.metric_paths.length).to.equal(1);
    });
    it("result.n1_C1_graph.subRequests.length", function () {
      expect(result.n1_C1_graph.subRequests.length).to.equal(1);
    });
    it("result.n1_C1_graph.data.metric_paths.length", function () {
      expect(result.n1_C1_graph.data.metric_paths.length).to.equal(1);
    });
    it("result.n2_C1.subRequests.length", function () {
      expect(result.n2_C1.subRequests.length).to.equal(1);
    });
    it("result.n2_C1.data.metric_paths.length", function () {
      expect(result.n2_C1.data.metric_paths.length).to.equal(1);
    });
    it("result.n1_C2.subRequests.length", function () {
      expect(result.n1_C2.subRequests.length).to.equal(1);
    });
    it("result.n1_C2.data.metric_paths.length", function () {
      expect(result.n1_C2.data.metric_paths.length).to.equal(1);
    });
  });

  describe("#runRequests()", function () {
    var mock = Em.Object.create({
      f1: function () {
        return {
          done: Em.K,
          fail: Em.K,
          always: Em.K
        }
      },
      state: 'inDOM'
    });
    beforeEach(function () {
      sinon.stub(aggregator, 'groupRequests', function (requests) {
        return requests;
      });
      sinon.spy(mock, 'f1');
    });
    afterEach(function () {
      aggregator.groupRequests.restore();
      mock.f1.restore();
    });
    it("view in DOM", function () {
      var requests = {
        'r1': {
          data: {
            metric_paths: ['m1', 'm1', 'm2']
          },
          context: mock,
          startCallName: 'f1'
        }
      };
      aggregator.runRequests(requests);
      expect(mock.f1.calledWith(requests.r1.data)).to.be.true;
    });
    it.skip("view destroyed", function () {
      var requests = {
        'r1': {
          data: {
            metric_paths: ['m1', 'm1', 'm2']
          },
          context: mock,
          startCallName: 'f1'
        }
      };
      mock.set('state', 'destroyed');
      aggregator.runRequests(requests);
      expect(mock.f1.called).to.be.false;
    });
  });
});

});

require.register("test/mixins/common/widgets/export_metrics_mixin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/common/widgets/export_metrics_mixin');
var fileUtils = require('utils/file_utils');
var testHelpers = require('test/helpers');

describe('App.ExportMetricsMixin', function () {

  var obj;

  beforeEach(function () {
    obj = Em.Object.create(App.ExportMetricsMixin);
  });

  describe('#toggleFormatsList', function () {

    var cases = [
      {
        isExportMenuHidden: true,
        title: 'menu should be visible'
      },
      {
        isExportMenuHidden: false,
        title: 'menu should be hidden'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        obj.set('isExportMenuHidden', !item.isExportMenuHidden);
        obj.toggleFormatsList();
        expect(obj.get('isExportMenuHidden')).to.equal(item.isExportMenuHidden);
      });
    });

  });

  describe('#exportGraphData', function () {

    var cases = [
      {
        isExportMenuHidden: true,
        event: {
          context: true
        },
        isCSV: true,
        title: 'CSV, menu should remain hidden'
      },
      {
        isExportMenuHidden: false,
        event: {},
        isCSV: false,
        title: 'JSON, menu should become hidden'
      }
    ];

    beforeEach(function () {
      obj.reopen({
        targetView: {
          ajaxIndex: 'index',
          getDataForAjaxRequest: function () {
            return {
              p: 'v'
            };
          }
        }
      });
    });

    cases.forEach(function (item) {
      describe(item.title, function () {

        beforeEach(function () {
          obj.set('isExportMenuHidden', item.isExportMenuHidden);
          obj.exportGraphData(item.event);
          this.ajaxParams = testHelpers.findAjaxRequest('name', 'index');
        });

        it('isExportMenuHidden is true', function () {
          expect(obj.get('isExportMenuHidden')).to.be.true;
        });
        it('one request was done', function () {
          expect(this.ajaxParams[0]).exists;
        });
        it('ajax-request with correct data', function () {
          expect(this.ajaxParams[0].data).to.eql({
            p: 'v',
            isCSV: item.isCSV
          });
        });
      });
    });

  });

  describe('#exportGraphDataSuccessCallback', function () {

    var cases = [
      {
        response: null,
        showAlertPopupCallCount: 1,
        downloadTextFileCallCount: 0,
        title: 'no response'
      },
      {
        response: {
          metrics: null
        },
        showAlertPopupCallCount: 1,
        downloadTextFileCallCount: 0,
        title: 'no metrics object in response'
      },
      {
        response: {
          metrics: {}
        },
        showAlertPopupCallCount: 1,
        downloadTextFileCallCount: 0,
        title: 'empty metrics object'
      },
      {
        response: {
          metrics: {
            m0: [0, 1]
          }
        },
        params: {
          isCSV: true
        },
        showAlertPopupCallCount: 0,
        downloadTextFileCallCount: 1,
        data: '0,1',
        fileType: 'csv',
        fileName: 'data.csv',
        title: 'export to CSV'
      },
      {
        response: {
          metrics: {
            m0: [0, 1]
          }
        },
        params: {
          isCSV: false
        },
        showAlertPopupCallCount: 0,
        downloadTextFileCallCount: 1,
        data: '[{"name":"m0","data":[0,1]}]',
        fileType: 'json',
        fileName: 'data.json',
        title: 'export to JSON'
      }
    ];

    beforeEach(function () {
      sinon.stub(App, 'showAlertPopup', Em.K);
      sinon.stub(fileUtils, 'downloadTextFile', Em.K);
      sinon.stub(obj, 'prepareCSV').returns('0,1');
      obj.reopen({
        targetView: {
          getData: function (response) {
            var data = [];
            if (response && response.metrics) {
              var name = Em.keys(response.metrics)[0];
              if (name && response.metrics[name]) {
                data = [
                  {
                    name: name,
                    data: response.metrics[name]
                  }
                ];
              }
            }
            return data;
          }
        }
      });
    });

    afterEach(function () {
      App.showAlertPopup.restore();
      fileUtils.downloadTextFile.restore();
      obj.prepareCSV.restore();
    });

    cases.forEach(function (item) {
      describe(item.title, function () {

        beforeEach(function () {
          obj.exportGraphDataSuccessCallback(item.response, null, item.params);
        });

        it('downloadTextFile was called needed number of times', function () {
          expect(fileUtils.downloadTextFile.callCount).to.equal(item.downloadTextFileCallCount);
        });

        if (item.downloadTextFileCallCount) {
          it('data is valid', function () {
            expect(fileUtils.downloadTextFile.firstCall.args[0].replace(/\s/g, '')).to.equal(item.data);
          });
          it('fileType is valid', function () {
            expect(fileUtils.downloadTextFile.firstCall.args[1]).to.equal(item.fileType);
          });
          it('fileName is valid', function () {
            expect(fileUtils.downloadTextFile.firstCall.args[2]).to.equal(item.fileName);
          });
        }
      });
    });

  });

  describe('#exportGraphDataErrorCallback', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, 'defaultErrorHandler', Em.K);
    });

    afterEach(function () {
      App.ajax.defaultErrorHandler.restore();
    });

    it('should display error popup', function () {
      obj.exportGraphDataErrorCallback({
          status: 404
        }, null, '', {
          url: 'url',
          type: 'GET'
        });
      expect(App.ajax.defaultErrorHandler.calledOnce).to.be.true;
      expect(App.ajax.defaultErrorHandler.calledWith({
          status: 404
        }, 'url', 'GET', 404)).to.be.true;
    });

  });

  describe('#prepareCSV', function () {

    var cases = [
        {
          displayUnit: 'B',
          result: 'Timestamp,n0 (B),n1 (B)\n1,0,4\n3,2,5\n',
          title: 'display unit set'
        },
        {
          result: 'Timestamp,n0,n1\n1,0,4\n3,2,5\n',
          title: 'display unit not set'
        }
      ],
      data = [
        {
          name: 'n0',
          data: [[0, 1], [2, 3]]
        },
        {
          name: 'n1',
          data: [[4, 1], [5, 3]]
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        obj.reopen({
          targetView: {
            displayUnit: item.displayUnit
          }
        });
        expect(obj.prepareCSV(data)).to.equal(item.result);
      });
    });

  });

  describe('#hideMenuForNoData', function () {

    var cases = [
      {
        isExportButtonHidden: true,
        isExportMenuHidden: true,
        title: 'menu should be hidden'
      },
      {
        isExportButtonHidden: false,
        isExportMenuHidden: false,
        title: 'menu should be visible'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        obj.setProperties({
          isExportButtonHidden: item.isExportButtonHidden,
          isExportMenuHidden: false
        });
        expect(obj.get('isExportMenuHidden')).to.equal(item.isExportMenuHidden);
      });
    });

  });

  describe('#jsonReplacer', function () {

    var cases = [
      {
        json: [
          {
            name: 'n0',
            data: [
              [0, 1],
              [1, 2]
            ]
          }
        ],
        result: '[{"name":"n0","data":[[0,1],[1,2]]}]',
        title: 'valid object'
      },
      {
        json: [
          {
            name: 'n1',
            data: [
              [0, 1],
              [1, 2]
            ],
            p1: 'v1'
          }
        ],
        result: '[{"name":"n1","data":[[0,1],[1,2]]}]',
        title: 'object with redundant property'
      },
      {
        json: [
          {
            name: 'n1',
            data: {
              p2: 'v2'
            }
          }
        ],
        result: '[{"name":"n1","data":{}}]',
        title: 'object with malformed data'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(JSON.stringify(item.json, obj.jsonReplacer())).to.equal(item.result);
      });
    });

  });

});

});

require.register("test/mixins/common/widgets/time_range_mixin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/common/widgets/time_range_mixin');

var timeRangePopup = require('views/common/custom_date_popup');

describe('App.TimeRangeMixin', function () {

  var obj;

  beforeEach(function () {
    obj = Em.Object.create(App.TimeRangeMixin);
  });

  describe('#currentTimeRange', function () {

    var cases = Em.Object.create(App.TimeRangeMixin).get('timeRangeOptions'),
      title = 'should set "{0}" time range';

    cases.forEach(function (item) {
      it(title.format(item.name), function () {
        obj.set('currentTimeRangeIndex', item.index);
        expect(obj.get('currentTimeRange')).to.eql(item);
      });
    });

  });

  describe('#setTimeRange', function () {

    var indexCases = [
        {
          index: 1,
          currentTimeRangeIndex: 1,
          showCustomDatePopupCallCount: 0,
          title: 'preset time range',
          popupTestTitle: 'popup should not be displayed'
        },
        {
          index: 8,
          currentTimeRangeIndex: 0,
          showCustomDatePopupCallCount: 1,
          title: 'custom time range',
          popupTestTitle: 'popup should be displayed'
        }
      ],
      rangeCases = [
        {
          index: 1,
          currentTimeRangeIndex: 1,
          customStartTime: null,
          customEndTime: null,
          customDurationFormatted: null,
          title: 'time range is preset',
          testTitle: 'should reset time range boundaries'
        },
        {
          index: 8,
          currentTimeRangeIndex: 0,
          customStartTime: 1,
          customEndTime: 1,
          customDurationFormatted: '1 hour',
          title: 'time range is custom',
          testTitle: 'should not reset time range boundaries'
        }
      ];

    beforeEach(function () {
      obj.set('currentTimeRangeIndex', 0);
      sinon.stub(timeRangePopup, 'showCustomDatePopup', Em.K);
    });

    afterEach(function () {
      timeRangePopup.showCustomDatePopup.restore();
    });

    indexCases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          obj.setTimeRange({
            context: {
              index: item.index
            }
          });
        });

        it('should set time range', function () {
          expect(obj.get('currentTimeRangeIndex')).to.equal(item.currentTimeRangeIndex);
        });

        it(item.popupTestTitle, function () {
          expect(timeRangePopup.showCustomDatePopup.callCount).to.equal(item.showCustomDatePopupCallCount);
        });

      });

    });

    rangeCases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          obj.setProperties({
            customStartTime: 1,
            customEndTime: 1,
            customDurationFormatted: '1 hour'
          });
          obj.setTimeRange({
            context: {
              index: item.index
            }
          });
        });

        it(item.testTitle, function () {
          expect(obj.getProperties(['currentTimeRangeIndex', 'customStartTime', 'customEndTime', 'customDurationFormatted'])).to.eql({
            currentTimeRangeIndex: item.currentTimeRangeIndex,
            customStartTime: item.customStartTime,
            customEndTime: item.customEndTime,
            customDurationFormatted: item.customDurationFormatted
          });
        });

      });

    });

  });

});

});

require.register("test/mixins/common/widgets/widget_section_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/common/widgets/widget_section');

describe('App.WidgetSectionMixin', function () {

  var obj;

  beforeEach(function () {
    obj = Em.Object.create(App.WidgetSectionMixin);
  });

  describe('#isAmbariMetricsInstalled', function () {

    var cases = [
      {
        services: [],
        isAmbariMetricsInstalled: false,
        title: 'Ambari Metrics not installed'
      },
      {
        services: [
          {
            serviceName: 'AMBARI_METRICS'
          }
        ],
        isAmbariMetricsInstalled: true,
        title: 'Ambari Metrics installed'
      }
    ];

    beforeEach(function () {
      this.stub = sinon.stub(App.Service, 'find');
    });

    afterEach(function () {
      App.Service.find.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        this.stub.returns(item.services);
        expect(obj.get('isAmbariMetricsInstalled')).to.equal(item.isAmbariMetricsInstalled);
      });
    });

  });

});
});

require.register("test/mixins/main/host/details/host_components/decommissionable_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var uiEffects = require('utils/ui_effects');
var testHelpers = require('test/helpers');

require('mixins/main/host/details/host_components/decommissionable');

var decommissionable,
  view,
  textCases = [
    {
      available: true,
      text: Em.I18n.t('common.decommission')
    },
    {
      available: false,
      text: Em.I18n.t('common.recommission')
    }
  ];

describe('App.Decommissionable', function () {

  beforeEach(function () {
    decommissionable = Em.Object.create(App.Decommissionable);
    decommissionable.set('$', Em.K);
  });

  describe('#decommissionView.text', function () {

    beforeEach(function () {
      view = decommissionable.decommissionView.create();
      view.reopen({
        parentView: decommissionable
      });
    });

    textCases.forEach(function (item) {
      it('should be ' + item.text, function () {
        view.set('parentView.isComponentDecommissionAvailable', item.available);
        expect(view.get('text')).to.equal(item.text);
      });
    });

  });

  describe("#isComponentDecommissionDisable", function() {

    beforeEach(function() {
      decommissionable.set('componentForCheckDecommission', 'MC1');
      decommissionable.set('content', Em.Object.create({service: Em.Object.create()}));
    });

    it("masterComponent is absent, service workStatus is STARTED", function() {
      decommissionable.set('content.service.hostComponents', []);
      decommissionable.set('content.service.workStatus', App.HostComponentStatus.started);
      expect(decommissionable.get('isComponentDecommissionDisable')).to.be.false;
    });

    it("masterComponent is absent, service workStatus is STOPPED", function() {
      decommissionable.set('content.service.hostComponents', []);
      decommissionable.set('content.service.workStatus', App.HostComponentStatus.stopped);
      expect(decommissionable.get('isComponentDecommissionDisable')).to.be.true;
    });

    it("masterComponent is present, component workStatus is STARTED", function() {
      decommissionable.set('content.service.hostComponents', [Em.Object.create({
        componentName: 'MC1',
        workStatus: App.HostComponentStatus.started
      })]);
      decommissionable.set('content.service.workStatus', App.HostComponentStatus.started);
      expect(decommissionable.get('isComponentDecommissionDisable')).to.be.false;
    });

    it("masterComponent is present, component workStatus is STOPPED", function() {
      decommissionable.set('content.service.hostComponents', [Em.Object.create({
        componentName: 'MC1',
        workStatus: App.HostComponentStatus.stopped
      })]);
      decommissionable.set('content.service.workStatus', App.HostComponentStatus.started);
      expect(decommissionable.get('isComponentDecommissionDisable')).to.be.true;
    });
  });

  describe("#isRestartableComponent", function() {

    beforeEach(function() {
      sinon.stub(App, 'get').returns(['C2']);
    });
    afterEach(function() {
      App.get.restore();
    });

    var testCases = [
      {
        input: {
          isDecomissionable: false,
          componentName: 'C1'
        },
        expected: false
      },
      {
        input: {
          isDecomissionable: true,
          componentName: 'C1'
        },
        expected: false
      },
      {
        input: {
          isDecomissionable: false,
          componentName: 'C2'
        },
        expected: false
      },
      {
        input: {
          isDecomissionable: true,
          componentName: 'C2'
        },
        expected: true
      }
    ];

    testCases.forEach(function(test) {
      it("isDecomissionable = " + test.input.isDecomissionable + "; " +
         "componentName=" + test.input.componentName, function() {
        decommissionable.setProperties({
          isComponentDecommissionAvailable: test.input.isDecomissionable,
          content: Em.Object.create({
            componentName: test.input.componentName
          })
        });
        expect(decommissionable.get('isRestartableComponent')).to.equal(test.expected);
      });
    }, this);
  });

  describe("#decommissionTooltipMessage", function() {

    beforeEach(function() {
      sinon.stub(App.format, 'role').returns('role');
    });
    afterEach(function() {
      App.format.role.restore();
    });

    var testCases = [
      {
        input: {
          isComponentDecommissionDisable: false,
          isComponentRecommissionAvailable: false,
          isComponentDecommissionAvailable: false
        },
        expected: ''
      },
      {
        input: {
          isComponentDecommissionDisable: true,
          isComponentRecommissionAvailable: false,
          isComponentDecommissionAvailable: false
        },
        expected: ''
      },
      {
        input: {
          isComponentDecommissionDisable: true,
          isComponentRecommissionAvailable: true,
          isComponentDecommissionAvailable: false
        },
        expected: Em.I18n.t('hosts.decommission.tooltip.warning').format(Em.I18n.t('common.recommission'), 'role')
      },
      {
        input: {
          isComponentDecommissionDisable: true,
          isComponentRecommissionAvailable: false,
          isComponentDecommissionAvailable: true
        },
        expected: Em.I18n.t('hosts.decommission.tooltip.warning').format(Em.I18n.t('common.decommission'), 'role')
      }
    ];

    testCases.forEach(function(test) {
      it("isComponentDecommissionDisable = " + test.input.isComponentDecommissionDisable + '; ' +
         "isComponentRecommissionAvailable = " + test.input.isComponentRecommissionAvailable + '; ' +
         "isComponentDecommissionAvailable = " + test.input.isComponentDecommissionAvailable
        , function() {
        decommissionable.reopen({
          isComponentDecommissionDisable: test.input.isComponentDecommissionDisable,
          isComponentRecommissionAvailable: test.input.isComponentRecommissionAvailable,
          isComponentDecommissionAvailable: test.input.isComponentDecommissionAvailable
        });
        expect(decommissionable.get('decommissionTooltipMessage')).to.equal(test.expected);
      });
    }, this);
  });

  describe("#loadComponentDecommissionStatus()", function() {

    beforeEach(function() {
      sinon.stub(decommissionable, 'getDesiredAdminState');
    });
    afterEach(function() {
      decommissionable.getDesiredAdminState.restore();
    });

    it("getDesiredAdminState should be called", function() {
      decommissionable.loadComponentDecommissionStatus();
      expect(decommissionable.getDesiredAdminState.calledOnce).to.be.true;
    });
  });

  describe("#getDesiredAdminStateSuccessCallback()", function() {

    beforeEach(function() {
      sinon.stub(decommissionable, 'setDesiredAdminState');
    });
    afterEach(function() {
      decommissionable.setDesiredAdminState.restore();
    });

    it("desired_admin_state is null", function() {
      var response = {
        HostRoles: {
          desired_admin_state: null
        }
      };

      expect(decommissionable.getDesiredAdminStateSuccessCallback(response)).to.be.null;
      expect(decommissionable.setDesiredAdminState.called).to.be.false;
    });

    it("setDesiredAdminState should be called", function() {
      var response = {
        HostRoles: {
          desired_admin_state: "STATUS"
        }
      };

      expect(decommissionable.getDesiredAdminStateSuccessCallback(response)).to.equal('STATUS');
      expect(decommissionable.setDesiredAdminState.calledWith('STATUS')).to.be.true;
    });
  });

  describe("#getDecommissionStatus()", function() {

    it("App.ajax.send should be called", function() {
      decommissionable.setProperties({
        componentForCheckDecommission: 'C1',
        content: Em.Object.create({
          hostName: 'host1',
          service: Em.Object.create({
            serviceName: 'S1'
          })
        })
      });
      decommissionable.getDecommissionStatus();
      var args = testHelpers.findAjaxRequest('name', 'host.host_component.decommission_status');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(decommissionable);
      expect(args[0].data).to.be.eql({
        hostName: 'host1',
        componentName: 'C1',
        serviceName: 'S1'
      });
    });
  });

  describe("#getDecommissionStatusSuccessCallback()", function() {

    beforeEach(function() {
      sinon.stub(decommissionable, 'setDecommissionStatus');
    });
    afterEach(function() {
      decommissionable.setDecommissionStatus.restore();
    });

    it("ServiceComponentInfo is null", function() {
      var response = {
        ServiceComponentInfo: null
      };

      expect(decommissionable.getDecommissionStatusSuccessCallback(response)).to.be.null;
      expect(decommissionable.setDecommissionStatus.called).to.be.false;
    });

    it("setDecommissionStatus should be called", function() {
      var response = {
        ServiceComponentInfo: {},
        host_components: [{
          HostRoles: {
            state: 'STATE'
          }
        }]
      };
      var statusObject = {
        component_state: 'STATE'
      };

      expect(decommissionable.getDecommissionStatusSuccessCallback(response)).to.eql(statusObject);
      expect(decommissionable.setDecommissionStatus.calledWith(statusObject)).to.be.true;
    });
  });

  describe("#setStatusAs()", function() {

    beforeEach(function() {
      sinon.stub(decommissionable, 'startBlinking');
    });
    afterEach(function() {
      decommissionable.startBlinking.restore();
    });

    describe("#INSERVICE status", function() {
      beforeEach(function() {
        decommissionable.set('isStart', false);
        decommissionable.setStatusAs('INSERVICE');
      });

      it("isComponentRecommissionAvailable should be false", function() {
        expect(decommissionable.get('isComponentRecommissionAvailable')).to.be.false;
      });
      it("isComponentDecommissioning should be false", function() {
        expect(decommissionable.get('isComponentDecommissioning')).to.be.false;
      });
      it("isComponentDecommissionAvailable should be false", function() {
        expect(decommissionable.get('isComponentDecommissionAvailable')).to.be.false;
      });
    });

    describe("#DECOMMISSIONING status", function() {
      beforeEach(function() {
        decommissionable.setStatusAs('DECOMMISSIONING')
      });

      it("isComponentRecommissionAvailable should be true", function() {
        expect(decommissionable.get('isComponentRecommissionAvailable')).to.be.true;
      });
      it("isComponentDecommissioning should be true", function() {
        expect(decommissionable.get('isComponentDecommissioning')).to.be.true;
      });
      it("isComponentDecommissionAvailable should be false", function() {
        expect(decommissionable.get('isComponentDecommissionAvailable')).to.be.false;
      });
    });

    describe("#DECOMMISSIONED status", function() {
      beforeEach(function() {
        decommissionable.setStatusAs('DECOMMISSIONED')
      });

      it("isComponentRecommissionAvailable should be true", function() {
        expect(decommissionable.get('isComponentRecommissionAvailable')).to.be.true;
      });
      it("isComponentDecommissioning should be false", function() {
        expect(decommissionable.get('isComponentDecommissioning')).to.be.false;
      });
      it("isComponentDecommissionAvailable should be false", function() {
        expect(decommissionable.get('isComponentDecommissionAvailable')).to.be.false;
      });
    });

    describe("#RS_DECOMMISSIONED status", function() {
      beforeEach(function() {
        decommissionable.set('isStart', false);
        decommissionable.setStatusAs('RS_DECOMMISSIONED');
      });

      it("isComponentRecommissionAvailable should be true", function() {
        expect(decommissionable.get('isComponentRecommissionAvailable')).to.be.true;
      });
      it("isComponentDecommissioning should be false", function() {
        expect(decommissionable.get('isComponentDecommissioning')).to.be.false;
      });
      it("isComponentDecommissionAvailable should be false", function() {
        expect(decommissionable.get('isComponentDecommissionAvailable')).to.be.false;
      });
    });
  });


  describe("#doBlinking()", function() {

    beforeEach(function() {
      sinon.stub(decommissionable, 'pulsate');
      sinon.spy(decommissionable, 'doBlinking');
      sinon.stub(decommissionable, 'startBlinking');
    });
    afterEach(function() {
      decommissionable.pulsate.restore();
      decommissionable.doBlinking.restore();
      decommissionable.startBlinking.restore();
    });

    it("INSTALLED status", function() {
      decommissionable.setProperties({
        workStatus: 'INSTALLED',
        content: Em.Object.create()
      });
      decommissionable.doBlinking();
      expect(decommissionable.pulsate.called).to.be.false;
    });

    it("STARTED status, content is null", function() {
      decommissionable.setProperties({
        workStatus: 'STARTED',
        content: null
      });
      decommissionable.doBlinking();
      expect(decommissionable.pulsate.called).to.be.false;
    });

    it("STARTED status, isDecommissioning = false", function() {
      decommissionable.setProperties({
        workStatus: 'STARTED',
        content: Em.Object.create(),
        isDecommissioning: false
      });
      decommissionable.doBlinking();
      expect(decommissionable.pulsate.called).to.be.false;
    });

    it("STARTED status, isDecommissioning = true, isBlinking = true", function() {
      decommissionable.setProperties({
        workStatus: 'STARTED',
        isDecommissioning: true,
        isBlinking: true,
        content: Em.Object.create()
      });
      decommissionable.doBlinking();
      expect(decommissionable.pulsate.called).to.be.false;
    });

    it("STARTED status, isDecommissioning = true, isBlinking = false", function() {
      decommissionable.setProperties({
        workStatus: 'STARTED',
        isDecommissioning: true,
        isBlinking: false,
        content: Em.Object.create()
      });
      decommissionable.doBlinking();
      expect(decommissionable.get('isBlinking')).to.be.true;
      expect(decommissionable.pulsate.calledOnce).to.be.true;
    });
  });

  describe("#pulsate()", function() {

    beforeEach(function() {
      sinon.stub(uiEffects, 'pulsate', function(node, time, callback) {
        callback();
      });
      sinon.stub(decommissionable, 'doBlinking');
      decommissionable.pulsate();
    });
    afterEach(function() {
      uiEffects.pulsate.restore();
      decommissionable.doBlinking.restore();
    });

    it("uiEffects.pulsate should be called", function() {
      expect(uiEffects.pulsate.calledOnce).to.be.true;
    });

    it("doBlinking should be called", function() {
      expect(decommissionable.doBlinking.calledOnce).to.be.true;
    });

    it("isBlinking should be false", function() {
      expect(decommissionable.get('isBlinking')).to.be.false;
    });
  });

  describe("#startBlinking()", function() {

    beforeEach(function() {
      sinon.stub(decommissionable, '$').returns({stop: Em.K, css: Em.K});
      sinon.stub(decommissionable, 'doBlinking');
    });
    afterEach(function() {
      decommissionable.$.restore();
      decommissionable.doBlinking.restore();
    });

    it("doBlinking should be called", function() {
      decommissionable.startBlinking();
      expect(decommissionable.doBlinking.calledOnce).to.be.true;
    });
  });
});

});

require.register("test/mixins/main/host/details/host_components/install_component_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mixins/main/host/details/host_components/install_component');
var testHelpers = require('test/helpers');
var installComponent;

describe('App.InstallComponent', function () {

  beforeEach(function () {
    installComponent = Em.Object.create(App.InstallComponent);
  });

  describe("#installHostComponentCall()", function() {
    var component = Em.Object.create({
      componentName: 'C1',
      displayName: 'c1'
    });

    beforeEach(function() {
      sinon.stub(installComponent, 'updateAndCreateServiceComponent').returns({done: Em.clb});
      installComponent.installHostComponentCall('host1', component);
      this.args = testHelpers.findAjaxRequest('name', 'host.host_component.add_new_component');
    });
    afterEach(function() {
      installComponent.updateAndCreateServiceComponent.restore();
    });

    it("updateAndCreateServiceComponent should be called", function() {
      expect(installComponent.updateAndCreateServiceComponent.calledWith('C1')).to.be.true;
    });

    it("App.ajax.send should be called", function() {
      expect(this.args[0]).exists;
      expect(this.args[0].sender).to.be.eql(installComponent);
      expect(this.args[0].data).to.be.eql({
        hostName: 'host1',
        component: component,
        data: JSON.stringify({
          RequestInfo: {
            "context": Em.I18n.t('requestInfo.installHostComponent') + ' c1'
          },
          Body: {
            host_components: [
              {
                HostRoles: {
                  component_name: 'C1'
                }
              }
            ]
          }
        })
      });
    });
  });

  describe("#addNewComponentSuccessCallback()", function() {
    var params = {
      hostName: 'host1',
      component: Em.Object.create({
        componentName: 'C1',
        serviceName: 'S1',
        displayName: 'c1'
      })
    };

    it("App.ajax.send should be called", function() {
      installComponent.addNewComponentSuccessCallback({}, {}, params);
      var args = testHelpers.findAjaxRequest('name', 'common.host.host_component.update');
      expect(args[0]).exists;
      expect(args[0].data).to.be.eql({
        hostName: 'host1',
        componentName: 'C1',
        serviceName: 'S1',
        component: params.component,
        "context": Em.I18n.t('requestInfo.installNewHostComponent') + ' c1',
        HostRoles: {
          state: 'INSTALLED'
        },
        urlParams: "HostRoles/state=INIT"
      });
    });
  });

  describe("#ajaxErrorCallback()", function() {

    beforeEach(function() {
      sinon.stub(App.ajax, 'defaultErrorHandler', Em.K);
    });
    afterEach(function() {
      App.ajax.defaultErrorHandler.restore();
    });

    it("App.ajax.defaultErrorHandler should be called", function() {
      installComponent.ajaxErrorCallback({}, {}, 'error', {type: 'method1', url: 'url1'}, {});
      expect(App.ajax.defaultErrorHandler.calledWith({}, 'url1', 'method1')).to.be.true;
    });
  });

  describe("#updateAndCreateServiceComponent()", function() {

    var updater = {
      updateComponentsState: Em.clb,
      updateServiceMetric: Em.clb
    };

    beforeEach(function() {
      sinon.spy(updater, 'updateComponentsState');
      sinon.spy(updater, 'updateServiceMetric');
      sinon.stub(App.router, 'get').returns(updater);
      sinon.stub(installComponent, 'createServiceComponent');
      installComponent.updateAndCreateServiceComponent('C1');
    });
    afterEach(function() {
      App.router.get.restore();
      installComponent.createServiceComponent.restore();
      updater.updateComponentsState.restore();
      updater.updateServiceMetric.restore();
    });

    it("updater.updateComponentsState should be called", function() {
      expect(updater.updateComponentsState.calledOnce).to.be.true;
    });

    it("updater.updateServiceMetric should be called", function() {
      expect(updater.updateServiceMetric.calledOnce).to.be.true;
    });

    it("createServiceComponent should be called", function() {
      expect(installComponent.createServiceComponent.calledWith('C1')).to.be.true;
    });
  });

  describe("#createServiceComponent()", function() {
    var dfd = {resolve: Em.K};

    beforeEach(function() {
      sinon.stub(App.StackServiceComponent, 'find').returns([Em.Object.create({
        componentName: 'C2',
        serviceName: 'S1'
      })]);
      sinon.spy(dfd, 'resolve');

      App.ajax.send.restore();
      sinon.stub(App.ajax, 'send').returns({complete: Em.clb});
      this.mock = sinon.stub(App.Service, 'find');
      this.mock.returns([{serviceName: "S1"}]);
      this.mock.withArgs('S1').returns(Em.Object.create({serviceComponents: ['C1']}))

    });
    afterEach(function() {
      App.StackServiceComponent.find.restore();
      dfd.resolve.restore();
      this.mock.restore();
    });

    it("component already created", function() {
      expect(installComponent.createServiceComponent('C1', dfd)).to.be.null;
      expect(dfd.resolve.calledOnce).to.be.true;
    });

    it("component not created", function() {
      installComponent.createServiceComponent('C2', dfd);
      var args = testHelpers.findAjaxRequest('name', 'common.create_component');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(installComponent);
      expect(args[0].data).to.be.eql({
        componentName: 'C2',
        serviceName: 'S1'
      });
      expect(dfd.resolve.calledOnce).to.be.true;
    });
  });
});
});

require.register("test/mixins/main/service/configs/component_actions_by_configs_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('mixins/main/service/configs/component_actions_by_configs');

var mixin;

describe('App.ComponentActionsByConfigs', function () {

  beforeEach(function() {
    mixin = Em.Object.create(App.ComponentActionsByConfigs, {
      content: Em.Object.create()
    });
  });

  describe('#showPopup', function () {

    var testCases = [
        {
          configActions: [],
          popupPrimaryButtonCallbackCallCount: 0,
          showHsiRestartPopupCallCount: 0,
          showConfirmationPopupCallCount: 0,
          title: 'no config actions'
        },
        {
          configActions: [
            {
              actionType: 'none'
            },
            {
              actionType: null
            },
            {}
          ],
          popupPrimaryButtonCallbackCallCount: 0,
          showHsiRestartPopupCallCount: 0,
          showConfirmationPopupCallCount: 0,
          title: 'no popup config actions'
        },
        {
          configActions: [
            Em.Object.create({
              actionType: 'showPopup',
              fileName: 'f0'
            })
          ],
          mixinProperties: {
            allConfigs: [
              Em.Object.create({
                filename: 'f1',
                value: 0,
                initialValue: 1
              })
            ]
          },
          popupPrimaryButtonCallbackCallCount: 0,
          showHsiRestartPopupCallCount: 0,
          showConfirmationPopupCallCount: 0,
          title: 'no associated configs'
        },
        {
          configActions: [
            Em.Object.create({
              actionType: 'showPopup',
              fileName: 'f2'
            })
          ],
          mixinProperties: {
            allConfigs: [
              Em.Object.create({
                filename: 'f2',
                value: 0,
                initialValue: 0
              })
            ]
          },
          popupPrimaryButtonCallbackCallCount: 0,
          showHsiRestartPopupCallCount: 0,
          showConfirmationPopupCallCount: 0,
          title: 'no changes in associated configs'
        },
        {
          configActions: [
            Em.Object.create({
              actionType: 'showPopup',
              fileName: 'f3'
            })
          ],
          mixinProperties: {
            allConfigs: [
              Em.Object.create({
                filename: 'f3',
                value: 0,
                initialValue: 1
              })
            ]
          },
          popupPrimaryButtonCallbackCallCount: 0,
          showHsiRestartPopupCallCount: 0,
          showConfirmationPopupCallCount: 0,
          title: 'no capacity-scheduler actions defined'
        },
        {
          configActions: [
            Em.Object.create({
              actionType: 'showPopup',
              fileName: 'capacity-scheduler.xml'
            })
          ],
          mixinProperties: {
            allConfigs: [
              Em.Object.create({
                filename: 'capacity-scheduler.xml',
                value: 0,
                initialValue: 1
              })
            ],
            isYarnQueueRefreshed: true
          },
          popupPrimaryButtonCallbackCallCount: 0,
          showHsiRestartPopupCallCount: 0,
          showConfirmationPopupCallCount: 0,
          title: 'YARN queue refreshed'
        },
        {
          configActions: [
            Em.Object.create({
              actionType: 'showPopup',
              fileName: 'capacity-scheduler.xml'
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'RESOURCEMANAGER'
            }),
            Em.Object.create({
              componentName: 'RESOURCEMANAGER',
              isRunning: false
            }),
            Em.Object.create({
              componentName: 'COMPONENT',
              isRunning: true
            })
          ],
          mixinProperties: {
            allConfigs: [
              Em.Object.create({
                filename: 'capacity-scheduler.xml',
                value: 0,
                initialValue: 1
              })
            ],
            isYarnQueueRefreshed: false
          },
          popupPrimaryButtonCallbackCallCount: 0,
          showHsiRestartPopupCallCount: 0,
          showConfirmationPopupCallCount: 0,
          title: 'no ResourceManagers running'
        },
        {
          configActions: [
            Em.Object.create({
              actionType: 'showPopup',
              fileName: 'capacity-scheduler.xml'
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'RESOURCEMANAGER'
            }),
            Em.Object.create({
              componentName: 'RESOURCEMANAGER',
              isRunning: false
            }),
            Em.Object.create({
              componentName: 'RESOURCEMANAGER',
              isRunning: true
            }),
            Em.Object.create({
              componentName: 'HIVE_SERVER_INTERACTIVE'
            })
          ],
          mixinProperties: {
            'allConfigs': [
              Em.Object.create({
                filename: 'capacity-scheduler.xml',
                value: 0,
                initialValue: 1
              })
            ],
            'isYarnQueueRefreshed': false,
            'content.serviceName': 'HIVE'
          },
          popupPrimaryButtonCallbackCallCount: 1,
          showHsiRestartPopupCallCount: 1,
          showConfirmationPopupCallCount: 0,
          title: 'change from Hive page, Hive Server Interactive present'
        },
        {
          configActions: [
            Em.Object.create({
              actionType: 'showPopup',
              fileName: 'capacity-scheduler.xml'
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'RESOURCEMANAGER'
            }),
            Em.Object.create({
              componentName: 'RESOURCEMANAGER',
              isRunning: false
            }),
            Em.Object.create({
              componentName: 'RESOURCEMANAGER',
              isRunning: true
            })
          ],
          mixinProperties: {
            'allConfigs': [
              Em.Object.create({
                filename: 'capacity-scheduler.xml',
                value: 0,
                initialValue: 1
              })
            ],
            'isYarnQueueRefreshed': false,
            'content.serviceName': 'HIVE'
          },
          popupPrimaryButtonCallbackCallCount: 1,
          showHsiRestartPopupCallCount: 0,
          showConfirmationPopupCallCount: 0,
          title: 'change from Hive page, no Hive Server Interactive'
        },
        {
          configActions: [
            Em.Object.create({
              actionType: 'showPopup',
              fileName: 'capacity-scheduler.xml',
              popupProperties: {
                primaryButton: {}
              }
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'RESOURCEMANAGER'
            }),
            Em.Object.create({
              componentName: 'RESOURCEMANAGER',
              isRunning: false
            }),
            Em.Object.create({
              componentName: 'RESOURCEMANAGER',
              isRunning: true
            })
          ],
          mixinProperties: {
            'allConfigs': [
              Em.Object.create({
                filename: 'capacity-scheduler.xml',
                value: 0,
                initialValue: 1
              })
            ],
            'isYarnQueueRefreshed': false,
            'content.serviceName': 'YARN'
          },
          popupPrimaryButtonCallbackCallCount: 0,
          showHsiRestartPopupCallCount: 0,
          showConfirmationPopupCallCount: 1,
          title: 'change from YARN page'
        }
      ];

    testCases.forEach(function (test) {

      describe(test.title, function () {

        beforeEach(function () {
          sinon.stub(App.ConfigAction, 'find').returns(test.configActions);
          sinon.stub(App.HostComponent, 'find').returns(test.hostComponents || []);
          sinon.stub(mixin, 'popupPrimaryButtonCallback', Em.K);
          sinon.stub(mixin, 'showHsiRestartPopup', Em.K);
          sinon.stub(App, 'showConfirmationPopup', Em.K);
          mixin.setProperties(test.mixinProperties);
          mixin.showPopup();
        });

        afterEach(function () {
          App.ConfigAction.find.restore();
          App.HostComponent.find.restore();
          mixin.popupPrimaryButtonCallback.restore();
          mixin.showHsiRestartPopup.restore();
          App.showConfirmationPopup.restore();
        });

        it('popup callback', function () {
          expect(mixin.popupPrimaryButtonCallback.callCount).to.eql(test.popupPrimaryButtonCallbackCallCount);
        });

        it('HSI restart popup', function () {
          expect(mixin.showHsiRestartPopup.callCount).to.eql(test.showHsiRestartPopupCallCount);
        });

        it('confirmation popup', function () {
          expect(App.showConfirmationPopup.callCount).to.eql(test.showConfirmationPopupCallCount);
        });

      });

    });

  });

});
});

require.register("test/mixins/main/service/configs/config_overridable_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/main/service/configs/config_overridable');

var configOverridable;

var configGroups = [
  Em.Object.create({name: 'configGroup1'}),
  Em.Object.create({name: 'configGroup2'}),
  Em.Object.create({name: 'configGroup3'})
];

describe('App.Decommissionable', function () {

  beforeEach(function () {
    configOverridable = Em.Object.create(App.ConfigOverridable);
  });

  describe('#validate of Config Group Selection Creation Dialog', function () {

    var testCases = [
      {
        text: 'fail validation because of disallowed symbols',
        name: '123=',
        isWarn: true,
        errorMessage: Em.I18n.t("form.validator.configGroupName"),
        option: false
      },
      {
        text: 'fail validation because of the same name',
        name: 'configGroup1',
        isWarn: true,
        errorMessage: Em.I18n.t("config.group.selection.dialog.err.name.exists"),
        option: false
      },
      {
        text: 'pass validation',
        name: '123',
        isWarn: false,
        errorMessage: '&nbsp;',
        option: false
      },
      {
        text: 'pass validation as another option is selected',
        name: '123',
        isWarn: false,
        errorMessage: '&nbsp;',
        option: true
      },
      {
        text: 'pass validation because there is no value entered',
        name: '',
        isWarn: false,
        errorMessage: '&nbsp;',
        option: true
      },
      {
        text: 'pass validation because there is no value entered',
        name: '      ',
        isWarn: false,
        errorMessage: '&nbsp;',
        option: true
      }
    ];

    testCases.forEach(function (item) {
      it('should ' + item.text, function () {
        var popup = configOverridable.launchConfigGroupSelectionCreationDialog('service', configGroups, Em.Object.create());
        popup.set('newConfigGroupName', item.name);
        popup.set('optionSelectConfigGroup', item.option);
        expect(popup.get('isWarning')).to.equal(item.isWarn);
        expect(popup.get('warningMessage')).to.equal(item.errorMessage);
      });
    });
  });

});

});

require.register("test/mixins/main/service/configs/widget_popover_support_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

describe('App.WidgetPopoverSupport', function () {});
});

require.register("test/mixins/routers/redirections_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var router, installerController, currentClusterStatus;

describe('App.RouterRedirections', function () {

  beforeEach(function () {

    installerController = Em.Object.create({
      currentStep: '',
      totalSteps: 11,
      setCurrentStep: function (k) {
        this.set('currentStep', k);
      }
    });
    App.router.get('installerController').setIsStepDisabled.call(installerController);
    installerController.setLowerStepsDisable = App.router.get('installerController').setLowerStepsDisable.bind(installerController);
    installerController.get('isStepDisabled').pushObject(Ember.Object.create({
      step: 0,
      value: true
    }));

    router = Em.Object.create(App.RouterRedirections, {
      transitionTo: Em.K,
      setAuthenticated: Em.K,
      installerController: installerController
    });

    currentClusterStatus = {};

    sinon.spy(router, 'transitionTo');
    sinon.spy(router, 'setAuthenticated');
    sinon.stub(App, 'get').withArgs('router').returns(router);

  });

  afterEach(function () {
    router.transitionTo.restore();
    router.setAuthenticated.restore();
    App.get.restore();
    currentClusterStatus = {};
  });

  describe('#redirectToInstaller', function () {

    it('CLUSTER_NOT_CREATED_1. user is on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_NOT_CREATED_1';
      installerController.set('currentStep', '4');
      router.redirectToInstaller(router, currentClusterStatus, true);
      expect(router.transitionTo.calledWith('step4')).to.be.true;
    });

    it('CLUSTER_NOT_CREATED_1. user is not on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_NOT_CREATED_1';
      installerController.set('currentStep', '4');
      router.redirectToInstaller(router, currentClusterStatus, false);
      expect(router.transitionTo.calledWith('installer.step4')).to.be.true;
    });

    it('CLUSTER_DEPLOY_PREP_2. user is on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_DEPLOY_PREP_2';
      router.redirectToInstaller(router, currentClusterStatus, true);
      expect(router.transitionTo.calledWith('step8')).to.be.true;
      expect(router.setAuthenticated.calledWith(true)).to.be.true;
    });

    it('CLUSTER_DEPLOY_PREP_2. user is not on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_DEPLOY_PREP_2';
      router.redirectToInstaller(router, currentClusterStatus, false);
      expect(router.transitionTo.calledWith('installer.step8')).to.be.true;
      expect(router.setAuthenticated.calledWith(true)).to.be.true;
    });

    it('CLUSTER_INSTALLING_3. user is on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_INSTALLING_3';
      router.redirectToInstaller(router, currentClusterStatus, true);
      expect(router.transitionTo.calledWith('step9')).to.be.true;
    });

    it('CLUSTER_INSTALLING_3. user is not on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_INSTALLING_3';
      router.redirectToInstaller(router, currentClusterStatus, false);
      expect(router.transitionTo.calledWith('installer.step9')).to.be.true;
    });

    it('SERVICE_STARTING_3. user is on installer', function () {
      currentClusterStatus.clusterState = 'SERVICE_STARTING_3';
      router.redirectToInstaller(router, currentClusterStatus, true);
      expect(router.transitionTo.calledWith('step9')).to.be.true;
    });

    it('SERVICE_STARTING_3. user is not on installer', function () {
      currentClusterStatus.clusterState = 'SERVICE_STARTING_3';
      router.redirectToInstaller(router, currentClusterStatus, false);
      expect(router.transitionTo.calledWith('installer.step9')).to.be.true;
    });

    it('CLUSTER_INSTALLED_4. user is on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_INSTALLED_4';
      router.redirectToInstaller(router, currentClusterStatus, true);
      expect(router.transitionTo.calledWith('step10')).to.be.true;
      expect(router.setAuthenticated.calledWith(true)).to.be.true;
    });

    it('CLUSTER_INSTALLED_4. user is not on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_INSTALLED_4';
      router.redirectToInstaller(router, currentClusterStatus, false);
      expect(router.transitionTo.calledWith('installer.step10')).to.be.true;
      expect(router.setAuthenticated.calledWith(true)).to.be.true;
    });

  });

});
});

require.register("test/mixins/unit_convert/base_unit_convert_mixin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.BaseUnitConvertMixin', function() {
  beforeEach(function() {
    this.mixin = Em.Object.create(App.BaseUnitConvertMixin, {});
  });

  describe('#convertValue', function() {
    var tests = [
      {
        value: "10",
        fromUnit: "b",
        toUnit: "b",
        e: 10
      },
      {
        value: "2048",
        fromUnit: "b",
        toUnit: "kb",
        e: 2
      },
      {
        value: "2097152",
        fromUnit: "b",
        toUnit: "mb",
        e: 2
      },
      {
        value: "1",
        fromUnit: "mb",
        toUnit: "kb",
        e: 1024
      },
      {
        value: "107374182400",
        fromUnit: "b",
        toUnit: "gb",
        e: 100
      },
      {
        value: "100",
        fromUnit: "gb",
        toUnit: "b",
        e: 107374182400
      },
      {
        value: "1294336",
        fromUnit: "b",
        toUnit: ["mb", "kb"],
        e: [
          { type: "mb", value: 1},
          { type: "kb", value: 240}
        ]
      },
      {
        value: [
          { type: "mb", value: 1},
          { type: "kb", value: 240}
        ],
        fromUnit: ["mb", "kb"],
        toUnit: "b",
        e: 1294336
      },
      {
        value: [
          { type: "mb", value: 1},
          { type: "kb", value: 240}
        ],
        fromUnit: "mb,kb",
        toUnit: "b",
        e: 1294336
      },
      {
        value: 60000,
        fromUnit: 'milliseconds',
        toUnit: "days,hours,minutes",
        e: [
          { type: 'days', value: 0},
          { type: 'hours', value: 0},
          { type: 'minutes', value: 1}
        ]
      },
      {
        value: 80,
        fromUnit: 'percent',
        toUnit: 'int',
        currentDimensionType: 'percent.percent_int',
        e: 80
      },
      {
        value: 80,
        fromUnit: 'int',
        toUnit: 'percent',
        currentDimensionType: 'percent.percent_int',
        e: 80
      },
      {
        value: 0.89,
        fromUnit: 'float',
        toUnit: 'percent',
        currentDimensionType: 'percent.percent_float',
        e: 89
      },
      {
        value: 89,
        fromUnit: 'percent',
        toUnit: 'float',
        currentDimensionType: 'percent.percent_float',
        e: 0.89
      },
      {
        value: 100,
        fromUnit: 'percent',
        toUnit: 'float',
        currentDimensionType: 'percent.percent_float',
        e: 1
      },
      {
        value: 1,
        fromUnit: 'float',
        toUnit: 'percent',
        currentDimensionType: 'percent.percent_float',
        e: 100
      }
    ];

    tests.forEach(function(test) {
      it('should convert {0} {1} to {2} {3}'.format(JSON.stringify(test.value), test.fromUnit, JSON.stringify(test.e), test.toUnit), function() {
        if (test.currentDimensionType) {
          this.mixin.set('currentDimensionType', test.currentDimensionType);
        }

        var result = this.mixin.convertValue(test.value, test.fromUnit, test.toUnit);
        if (Em.isArray(result)) {
          result = result.map(function(item) {
            return App.permit(item, ['type', 'value']);
          });
        }
        expect(result).to.be.eql(test.e);
      });
    }, this);
  });
});

});

require.register("test/mixins/wizard/addSeccurityConfigs_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var stackDescriptorData = require('test/mock_data_setup/stack_descriptors');
var stackDescriptor = stackDescriptorData.KerberosDescriptor.kerberos_descriptor;

require('mixins/wizard/addSecurityConfigs');

describe('App.AddSecurityConfigs', function () {

  var controller = Em.Object.extend(App.AddSecurityConfigs,{}).create({
    content: {},
    enableSubmit: function () {
      this._super();
    }
  });


  describe('#createServicesStackDescriptorConfigs', function() {
    var result = controller.createServicesStackDescriptorConfigs(stackDescriptorData);
    var propertyValidationTests = [
      {
        property: 'spnego_keytab',
        e: [
          { key: 'value', value: '${keytab_dir}/spnego.service.keytab' },
          { key: 'serviceName', value: 'Cluster' }
        ]
      },
      // principal name inherited from /spnego with predefined value
      {
        property: 'oozie.authentication.kerberos.principal',
        e: [
          { key: 'value', value: 'HTTP/${host}@${realm}' },
          { key: 'isEditable', value: true }
        ]
      },
      // keytab inherited from /spnego without predefined file value
      {
        property: 'oozie.authentication.kerberos.keytab',
        e: [
          { key: 'value', value: null },
          { key: 'isEditable', value: false },
          { key: 'referenceProperty', value: 'spnego:keytab' },
          { key: 'observesValueFrom', value: 'spnego_keytab' }
        ]
      }
    ];

    propertyValidationTests.forEach(function(test) {
      it('property {0} should be created'.format(test.property), function() {
        expect(result.findProperty('name', test.property)).to.be.ok;
      });
      test.e.forEach(function(expected) {
        it('property `{0}` should have `{1}` with value `{2}`'.format(test.property, expected.key, expected.value), function() {
          expect(result.findProperty('name', test.property)).to.have.deep.property(expected.key, expected.value);
        });
      });
    });
  });

  describe('#expandKerberosStackDescriptorProps', function() {
    var serviceName = 'Cluster';
    var result = controller.expandKerberosStackDescriptorProps(stackDescriptor.properties, serviceName);
    var testCases = [
      {
        property: 'realm',
        e: [
          { key: 'isEditable', value: false },
          { key: 'serviceName', value: 'Cluster' }
        ]
      },
      {
        property: 'keytab_dir',
        e: [
          { key: 'isEditable', value: true },
          { key: 'serviceName', value: 'Cluster' }
        ]
      }
    ];
    testCases.forEach(function(test) {
      it('property {0} should be created'.format(test.property), function() {
        expect(result.findProperty('name', test.property)).to.be.ok;
      });
      test.e.forEach(function(expected) {
        it('property `{0}` should have `{1}` with value `{2}`'.format(test.property, expected.key, expected.value), function() {
          expect(result.findProperty('name', test.property)).to.have.deep.property(expected.key, expected.value);
        });
      });
    });
  });

  describe('#createConfigsByIdentity', function() {
    var identitiesData = stackDescriptor.services[0].components[0].identities;
    var tests = [
      {
        property: 'dfs.namenode.kerberos.principal',
        e: [
          { key: 'value', value: 'nn/_HOST@${realm}' }
        ]
      },
      {
        property: 'dfs.web.authentication.kerberos.principal',
        e: [
          { key: 'referenceProperty', value: 'spnego:principal' },
          { key: 'isEditable', value: false }
        ]
      }     
    ];
    var properties = controller.createConfigsByIdentities(identitiesData, 'HDFS');
    tests.forEach(function(test) {
      it('property {0} should be created'.format(test.property), function() {
        expect(properties.findProperty('name', test.property)).to.be.ok;
      });
      test.e.forEach(function(expected) {
        it('property `{0}` should have `{1}` with value `{2}`'.format(test.property, expected.key, expected.value), function() {
          expect(properties.findProperty('name', test.property)).to.have.deep.property(expected.key, expected.value);
        });
      });
    });
  });

  describe('#parseIdentityObject', function() {
    var testCases = [
      {
        identity: stackDescriptor.services[0].components[0].identities[0],
        tests: [
          {
            property: 'dfs.namenode.kerberos.principal',
            e: [
              { key: 'filename', value: 'hdfs-site' }
            ]
          },
          {
            property: 'dfs.namenode.keytab.file',
            e: [
              { key: 'value', value: '${keytab_dir}/nn.service.keytab' }
            ]
          }
        ]
      },
      {
        identity: stackDescriptor.services[0].components[0].identities[1],
        tests: [
          {
            property: 'dfs.namenode.kerberos.https.principal',
            e: [
              { key: 'filename', value: 'hdfs-site' }
            ]
          }
        ]
      },
      {
        identity: stackDescriptor.identities[0],
        tests: [
          {
            property: 'spnego_principal',
            e: [
              { key: 'displayName', value: 'Spnego Principal' },
              { key: 'filename', value: 'cluster-env' }
            ]
          }
        ]
      },
      {
        identity: stackDescriptor.identities[0],
        tests: [
          {
            property: 'spnego_keytab',
            e: [
              { key: 'displayName', value: 'Spnego Keytab' },
              { key: 'filename', value: 'cluster-env' }
            ]
          }
        ]
      }
    ];
    
    testCases.forEach(function(testCase) {
      testCase.tests.forEach(function(test) {
        var result = controller.parseIdentityObject(testCase.identity);
        it('property `{0}` should be present'.format(test.property), function() {
          expect(result.findProperty('name', test.property)).to.be.ok;
        });
        test.e.forEach(function(expected) {
          it('property `{0}` should have `{1}` with value `{2}`'.format(test.property, expected.key, expected.value), function() {
            expect(result.findProperty('name', test.property)).to.have.deep.property(expected.key, expected.value);
          });
        });
      });
    });
  });

  describe('#processConfigReferences', function() {
    var generateProperty = function(name, reference) {
      return Em.Object.create({ name: name, referenceProperty: reference});
    };
    var descriptor = {
      identities: [
        { name: 'spnego', principal: { value: 'spnego_value' }, keytab: { file: 'spnego_file'} },
        { name: 'hdfs',
          principal: { value: 'hdfs_value', configuration: "hadoop-env/hdfs_user_principal_name" },
          keytab: { file: 'hdfs_file', configuration: "hadoop-env/hdfs_user_keytab"} }
      ],
      services: [
        {
          name: 'SERVICE',
          identities: [
            { name: '/spnego' },
            { name: '/hdfs' },
            {
              name: 'service_identity',
              keytab: { configuration: 'service-site/service.keytab' },
              principal: { configuration: 'service-site/service.principal' }
            }
          ]
        },
        {
          name: 'SERVICE2',
          components: [
            {
              name: 'COMPONENT',
              identities: [
                {
                  name: 'component_prop1',
                  keytab: { configuration: 'service2-site/component.keytab' },
                  principal: { configuration: null }
                },
                {
                  name: 'component_prop2',
                  keytab: { configuration: 'service2-site/component2.keytab' },
                  principal: { configuration: 'service2-site/component2.principal' }
                }
              ]
            }
          ]
        }
      ]
    };

    var configs = Em.A([
      generateProperty('spnego_inherited_keytab', 'spnego:keytab'),
      generateProperty('spnego_inherited_principal', 'spnego:principal'),
      generateProperty('hdfs_inherited_keytab', 'hdfs:keytab'),
      generateProperty('hdfs_inherited_principal', 'hdfs:principal'),
      generateProperty('component_prop1_inherited_principal', 'component_prop1:principal'),
      generateProperty('component_prop1_inherited_keytab', 'component_prop1:keytab'),
      generateProperty('component_prop2_inherited_keytab', 'component_prop2:keytab'),
      generateProperty('component_prop2_inherited_principal', 'component_prop2:principal'),
      generateProperty('component_prop2_inherited_principal', 'component_prop2:principal'),
      generateProperty('component_prop3_inherited_principal', 'SERVICE2/COMPONENT/component_prop2:principal'),
      generateProperty('service_prop1_inherited_principal', 'SERVICE/service_identity:principal')
    ]);

    var tests = [
      { name: 'spnego_inherited_keytab', e: 'spnego_keytab' },
      { name: 'spnego_inherited_principal', e: 'spnego_principal' },
      { name: 'hdfs_inherited_keytab', e: 'hdfs_user_keytab' },
      { name: 'hdfs_inherited_principal', e: 'hdfs_user_principal_name' },
      { name: 'component_prop1_inherited_keytab', e: 'component.keytab' },
      { name: 'component_prop1_inherited_principal', e: 'component_prop1_principal' },
      { name: 'component_prop2_inherited_keytab', e: 'component2.keytab' },
      { name: 'component_prop2_inherited_principal', e: 'component2.principal' },
      { name: 'component_prop3_inherited_principal', e: 'component2.principal' },
      { name: 'service_prop1_inherited_principal', e: 'service.principal' }
    ];
    before(function() {
      controller.processConfigReferences(descriptor, configs);
    });
    
    tests.forEach(function(test) {
      it('`{0}` should observe value from `{1}` property'.format(test.name, test.e), function() {
        expect(configs.findProperty('name', test.name).get('observesValueFrom')).to.be.eql(test.e); 
      });
    });
  });

  describe('#_getDisplayNameForConfig', function () {

    var configIdentitiesMap = {
      'otherCoolName__some-site': {
        displayName: 'otherCoolDisplayName'
      }
    };

    beforeEach(function() {
      sinon.stub(App.config, 'get').withArgs('kerberosIdentitiesMap').returns(configIdentitiesMap)
    });

    afterEach(function() {
      App.config.get.restore();
    });

    it('config from `cluster-env`', function () {
      var config = {
        fileName: 'cluster-env',
        name: 'someCoolName'
      };
      var displayName = controller._getDisplayNameForConfig(config.name, config.fileName);
      expect(displayName).to.equal(App.format.normalizeName(config.name));
    });

    it('config from UI', function () {
      var config = {
        fileName: 'some-site',
        name: 'otherCoolName'
      };
      var displayName = controller._getDisplayNameForConfig(config.name, config.fileName);
      expect(displayName).to.equal('otherCoolDisplayName');
    });
  });

});

});

require.register("test/mixins/wizard/assign_master_components_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mixins/wizard/assign_master_components');
var c;

describe('App.AssignMasterComponents', function () {
  var baseObject = Em.Object.extend(App.AssignMasterComponents);
  var data;

  beforeEach(function () {
    c = baseObject.create();
    c.set('content', {});

    var hosts = [];
    for(var i = 1; i <= 4; ++i) {
      hosts.push(App.Host.createRecord({
        'host_name': 'h' + i
      }));
    }
    c.set('hosts', hosts);

    data = {
      "resources": [
        {
          "recommendations": {
            "blueprint": {
              "host_groups": [
                {
                  "name": "host-group-1",
                  "components": [{"name": "c1"}, {"name": "c3"}, {"name": "c2"}]
                },
                {
                  "name": "host-group-2",
                  "components": [{"name": "c1"}, {"name": "c2"}]
                },
                {
                  "name": "host-group-3",
                  "components": [{"name": "c1"}]
                }
              ]
            },
            "blueprint_cluster_binding": {
              "host_groups": [
                {
                  "name": "host-group-1",
                  "hosts": [{"fqdn": "h1"}]
                },
                {
                  "name": "host-group-3",
                  "hosts": [{"fqdn": "h3"}]
                },
                {
                  "name": "host-group-2",
                  "hosts": [{"fqdn": "h2"}, {"fqdn": "h4"}]
                }
              ]
            }
          }
        }
      ]
    };
  });

  describe('#loadRecommendationsSuccessCallback', function () {

    it('should set recommendations', function() {
      c.loadRecommendationsSuccessCallback(data);
      expect(c.get('recommendations')).to.eq(data.resources[0].recommendations);
    });

    it('should set recommendedHostsForComponents and content.recommendations for wizard page', function() {
      c.set('content.controllerName','installerController');
      c.loadRecommendationsSuccessCallback(data);
      var expected = {
        "c1": ["h1", "h2", "h4", "h3"],
        "c3": ["h1"],
        "c2": ["h1", "h2", "h4"]
      };

      expect(JSON.stringify(c.get('content.recommendedHostsForComponents'))).to.equal(JSON.stringify(expected));
      expect(c.get('content.recommendations')).to.eq(data.resources[0].recommendations);
    });
  });

  describe('#getHostForMaster', function () {

    var allMasters;

    beforeEach(function () {
      allMasters = [
        {
          "component_name": "c1",
          "selectedHost": "h1"
        },
        {
          "component_name": "c1",
          "selectedHost": "h2"
        },
        {
          "component_name": "c1",
          "selectedHost": "h3"
        },
        {
          "component_name": "c1",
          "selectedHost": "h4"
        },
        {
          "component_name": "c2",
          "selectedHost": "h1"
        },
        {
          "component_name": "c5",
          "selectedHost": "h1"
        }
      ];
    });

    it('should return the recommended host', function() {
      c.loadRecommendationsSuccessCallback(data);
      expect(c.getHostForMaster('c2', allMasters)).to.eq('h2');
    });

    it('should return the first available host from the list of existing hosts', function() {
      c.loadRecommendationsSuccessCallback(data);
      expect(c.getHostForMaster('c6', allMasters)).to.eq('h1');
    });

    it('should return the next available host from the list of existing hosts', function() {
      c.loadRecommendationsSuccessCallback(data);
      expect(c.getHostForMaster('c5', allMasters)).to.eq('h2');
    });

    it('should return false if the component is already on all hosts', function() {
      c.loadRecommendationsSuccessCallback(data);
      expect(c.getHostForMaster('c1', allMasters)).to.eq(false);
    });

  });


  describe('#sortComponentsByServiceName', function () {

    var components = [{
      "component_name": "METRICS_COLLECTOR",
      "serviceId": "AMBARI_METRICS"
    }, {
      "component_name": "ZOOKEEPER_SERVER",
      "serviceId": "ZOOKEEPER"
    }, {
      "component_name": "NAMENODE",
      "serviceId": "HDFS"
    }, {
      "component_name": "DRPC_SERVER",
      "serviceId": "STORM"
    }, {
      "component_name": "APP_TIMELINE_SERVER",
      "serviceId": "YARN"
    }, {
      "component_name": "RESOURCEMANAGER",
      "serviceId": "YARN"
    }, {
      "component_name": "SECONDARY_NAMENODE",
      "serviceId": "HDFS"
    }, {
      "component_name": "ZOOKEEPER_SERVER",
      "serviceId": "ZOOKEEPER"
    }, {
      "component_name": "HISTORYSERVER",
      "serviceId": "MAPREDUCE2"
    }, {
      "component_name": "HAWQSTANDBY",
      "serviceId": "HAWQ"
    }, {
      "component_name": "NIMBUS",
      "serviceId": "STORM"
    }, {
      "component_name": "HAWQMASTER",
      "serviceId": "HAWQ"
    }, {
      "component_name": "STORM_UI_SERVER",
      "serviceId": "STORM"
    }];

    it('should place ZOOKEEPER_SERVER one after another', function () {
      var sorted = c.sortComponentsByServiceName(components);
      expect(sorted.mapProperty('component_name').join('|').contains('ZOOKEEPER_SERVER|ZOOKEEPER_SERVER')).to.be.true;
    });

    it('should place HAWQMASTER just before HAWQSTANDBY', function () {
      var sorted = c.sortComponentsByServiceName(components);
      expect(sorted.mapProperty('component_name').join('|').contains('HAWQMASTER|HAWQSTANDBY')).to.be.true;
    });

  });

  App.TestAliases.testAsComputedOr(baseObject.create(),
    'nextButtonDisabled', ['App.router.btnClickInProgress', 'submitDisabled', 'validationInProgress']);

});
});

require.register("test/mixins/wizard/wizardEnableDone_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.WizardEnableDone', function () {
  var baseObject = Em.Object.extend({
        statusChangeCallback: function () {}
      }),
      mixedObject = baseObject.extend(App.WizardEnableDone),
      mixedObjectInstance;
  beforeEach(function () {
    mixedObjectInstance = mixedObject.create({
      tasks: [{status: 'COMPLETED'}, {status: 'FAILED'}],
      content: Em.Object.create({
        controllerName: 'wizardControllerName'
      })
    });
    sinon.stub(App.router, 'get', function () {
          return Em.Object.create({
            totalSteps: 6,
            currentStep: 6
          });
        }
    );
  });

  afterEach(function () {
    App.router.get.restore();
  });

  it('#statusChangeCallback should enable done/complete button', function () {
    mixedObjectInstance.statusChangeCallback();
    expect(mixedObjectInstance.isSubmitDisabled).to.be.false;
  });
});

});

require.register("test/mixins/wizard/wizardProgressPageController_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');

describe('App.wizardProgressPageControllerMixin', function() {
  var mixedObject = Em.Object.extend(App.wizardProgressPageControllerMixin, {});

  describe('#createComponent', function() {
    var mixedObjectInstance;
    beforeEach(function() {
      mixedObjectInstance = mixedObject.create({});
      sinon.stub(mixedObjectInstance, "updateAndCreateServiceComponent").returns({
        done: Em.clb
      });
      sinon.spy(mixedObjectInstance, 'onCreateComponent');
      sinon.spy(mixedObjectInstance, 'updateComponent');
      sinon.stub(mixedObjectInstance, 'checkInstalledComponents', function(componentName) {
        var def = $.Deferred();
        var data = {
          'ZOOKEEPER_SERVER': {
            items: []
          },
          'ZOOKEEPER_CLIENT': {
            items: [
              { HostRoles: { host_name: 'host1' } }
            ]
          }
        };
        def.resolve(data[componentName]);
        return def.promise();
      });
      sinon.stub(App.StackServiceComponent, 'find', function(){
        return [
          Em.Object.create({
          componentName: 'ZOOKEEPER_CLIENT',
          serviceName: 'ZOOKEEPER'
        }),
          Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          serviceName: 'ZOOKEEPER'
        })
        ];
      });
      App.serviceComponents = ['ZOOKEEPER_SERVER', 'ZOOKEEPER_CLIENT'];
    });

    afterEach(function() {
      App.StackServiceComponent.find.restore();
      mixedObjectInstance.updateAndCreateServiceComponent.restore();
      mixedObjectInstance.onCreateComponent.restore();
      mixedObjectInstance.updateComponent.restore();
      mixedObjectInstance.checkInstalledComponents.restore();
    });

    it('should call `checkInstalledComponents` method', function() {
      mixedObjectInstance.createComponent('ZOOKEEPER_SERVER', 'host1', 'ZOOKEEPER');
      expect(mixedObjectInstance.checkInstalledComponents.called).to.be.true;
    });

    it('should call `checkInstalledComponents` method with host name converted to Array', function() {
      mixedObjectInstance.createComponent('ZOOKEEPER_SERVER', 'host1', 'ZOOKEEPER');
      expect(mixedObjectInstance.checkInstalledComponents.calledWith('ZOOKEEPER_SERVER', ['host1'])).to.be.true;
    });

    describe('no ZooKeeper Servers installed. install on host1, host2. ajax request should be called with appropriate params', function() {
      beforeEach(function () {
        mixedObjectInstance.createComponent('ZOOKEEPER_SERVER', ['host1', 'host2'], 'ZOOKEEPER');
        this.args = testHelpers.findAjaxRequest('name', 'wizard.step8.register_host_to_component')[0];
        this.queryObject = JSON.parse(this.args.data.data);
      });
      it('hostName is valid array', function () {
        expect(this.args.data.hostName).to.be.eql(['host1', 'host2']);
      });
      it('RequestInfo.query is valid', function () {
        expect(this.queryObject.RequestInfo.query).to.be.equal('Hosts/host_name=host1|Hosts/host_name=host2');
      });
      it('affected component is valid', function () {
        expect(this.queryObject.Body.host_components[0].HostRoles.component_name).to.be.equal('ZOOKEEPER_SERVER');
      });
      it('taskNum = 1', function () {
        expect(this.args.data.taskNum).to.be.equal(1);
      });
      it('updateComponent is called', function () {
        // invoke callback
        this.args.sender[this.args.success](null, null, this.args.data);
        expect(mixedObjectInstance.updateComponent.called).to.be.true;
      });
    });

    describe('ZooKeeper Client installed on host1. install on host1, host2. ajax request should be called with appropriate params', function() {
      beforeEach(function () {
        mixedObjectInstance.createComponent('ZOOKEEPER_CLIENT', ['host1', 'host2'], 'ZOOKEEPER');
        this.args = testHelpers.findAjaxRequest('name', 'wizard.step8.register_host_to_component')[0];
        this.queryObject = JSON.parse(this.args.data.data);
      });
      it('hostName is valid array', function () {
        expect(this.args.data.hostName).to.be.eql(['host1', 'host2']);
      });
      it('RequestInfo.query is valid', function () {
        expect(this.queryObject.RequestInfo.query).to.be.equal('Hosts/host_name=host2');
      });
      it('affected component is valid', function () {
        expect(this.queryObject.Body.host_components[0].HostRoles.component_name).to.be.equal('ZOOKEEPER_CLIENT');
      });
      it('onCreateComponent is not called', function () {
        expect(mixedObjectInstance.onCreateComponent.called).to.be.false;
      });
      it('updateComponent is called', function () {
        // invoke callback
        this.args.sender[this.args.success](null, null, this.args.data);
        expect(mixedObjectInstance.updateComponent.called).to.be.true;
      });
    });
  });

  describe('#updateComponent', function() {
    var testsAjax = [
      {
        callParams: ['ZOOKEEPER_SERVER', 'host1', 'ZOOKEEPER', 'Install', 1],
        e: [
          { key: 'data.HostRoles.state', value: 'INSTALLED'},
          { key: 'data.hostName[0]', value: 'host1'},
          { key: 'data.query', value: 'HostRoles/component_name=ZOOKEEPER_SERVER&HostRoles/host_name.in(host1)&HostRoles/maintenance_state=OFF'}
        ]
      },
      {
        callParams: ['ZOOKEEPER_SERVER', ['host1', 'host2'], 'ZOOKEEPER', 'start', 1],
        e: [
          { key: 'data.HostRoles.state', value: 'STARTED'},
          { key: 'data.hostName[0]', value: 'host1'},
          { key: 'data.hostName[1]', value: 'host2'},
          { key: 'data.query', value: 'HostRoles/component_name=ZOOKEEPER_SERVER&HostRoles/host_name.in(host1,host2)&HostRoles/maintenance_state=OFF'}
        ]
      }
    ];

    testsAjax.forEach(function(test) {
      describe('called with params: ' + JSON.stringify(test.callParams), function() {
        beforeEach(function() {
          var mixedObjectInstance = mixedObject.create({});
          mixedObjectInstance.updateComponent.apply(mixedObjectInstance, test.callParams);
        });

        test.e.forEach(function(eKey) {
          it('key: {0} should have value: {1}'.format(eKey.key, eKey.value), function() {
            var args = testHelpers.findAjaxRequest('name', 'common.host_components.update')[0];
            expect(args).to.have.deep.property(eKey.key, eKey.value);
          });
        });
      });
    });
  });

  describe('#createInstallComponentTask', function() {
    var mixedObjectInstance;
    beforeEach(function() {
      mixedObjectInstance = mixedObject.create({});
      sinon.stub(mixedObjectInstance, 'createComponent', Em.K);
      sinon.stub(mixedObjectInstance, 'onTaskError', Em.K);
      this.KDCStub = sinon.stub(App, 'get').withArgs('router.mainAdminKerberosController');
    });

    afterEach(function() {
      mixedObjectInstance.createComponent.restore();
      mixedObjectInstance.onTaskError.restore();
      mixedObjectInstance.destroy();
      mixedObjectInstance = null;
      App.get.restore();
      this.KDCStub = null;
    });

    it('when credentials are ok, createComponent method called', function() {
      this.KDCStub.returns({
        getKDCSessionState: Em.clb
      });
      mixedObjectInstance.createInstallComponentTask('componentName', 'hostName', 'serviceName');
      assert.isTrue(mixedObjectInstance.createComponent.calledOnce, 'createComponent should be called');
      assert.equal(JSON.stringify(mixedObjectInstance.createComponent.args[0]), JSON.stringify(['componentName', 'hostName', 'serviceName']), 'passed argument order should be the same');
    });

    it('when credentials are expired and KDC dialog cancelled task status should be changed to failed', function() {
      this.KDCStub.returns({
        getKDCSessionState: function(sCallback, eCallback) {
          eCallback();
        }
      });
      mixedObjectInstance.createInstallComponentTask('componentName', 'hostName', 'serviceName');
      assert.isFalse(mixedObjectInstance.createComponent.calledOnce, 'createComponent should not be called');
      assert.isTrue(mixedObjectInstance.onTaskError.called, 'onTaskError handler called');
    });
  });
});

});

require.register("test/mixins/wizard/wizard_menu_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var view;

describe('App.WizardMenuMixin', function () {

  beforeEach(function () {
    view = Em.View.create(App.WizardMenuMixin, {
      controller: Em.Object.create({
        isStepDisabled: []
      })
    });
  });

  describe("#isStepDisabled()", function () {
    it("step 1 disabled", function () {
      view.set('controller.isStepDisabled', [Em.Object.create({
        step: 1,
        value: true
      })]);
      expect(view.isStepDisabled(1)).to.be.true;
    });
  });

  describe("#isStep#Disabled", function () {
    var testCases = [
      {
        property: 'isStep0Disabled',
        step: 0
      },
      {
        property: 'isStep1Disabled',
        step: 1
      },
      {
        property: 'isStep2Disabled',
        step: 2
      },
      {
        property: 'isStep3Disabled',
        step: 3
      },
      {
        property: 'isStep4Disabled',
        step: 4
      },
      {
        property: 'isStep5Disabled',
        step: 5
      },
      {
        property: 'isStep6Disabled',
        step: 6
      },
      {
        property: 'isStep7Disabled',
        step: 7
      },
      {
        property: 'isStep8Disabled',
        step: 8
      },
      {
        property: 'isStep9Disabled',
        step: 9
      },
      {
        property: 'isStep10Disabled',
        step: 10
      }
    ];

    testCases.forEach(function (test) {
      it("step" + test.step + " disabled", function () {
        view.set('controller.isStepDisabled', [Em.Object.create({
          step: test.step,
          value: true
        })]);
        view.propertyDidChange(test.property);
        expect(view.get(test.property)).to.be.true;
      });
    }, this);
  });

});
});

require.register("test/mock_data_setup/configs_mock_data", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = {
  setupConfigGroupsObject: function(serviceName) {
    var serviceGroups = this.setupServiceConfigTagsObject(serviceName).mapProperty('siteName');
    var configGroups = [
      {
        "tag":"version1",
        "type":"core-site",
        "properties": {
          "fs.defaultFS" : "hdfs://c6401.ambari.apache.org:8020",
          "fs.trash.interval" : "360"
        }
      },
      {
        "tag":"version1",
        "type":"hadoop-env",
        "properties":{
          "hadoop_heapsize":"1024",
          "hdfs_user": "hdfs"
        }
      },
      {
        "tag":"version1",
        "type":"hdfs-site",
        "properties": {
          "dfs.datanode.data.dir": "/b,/a",
          "dfs.namenode.name.dir": "/b,/a,/c",
          "dfs.namenode.checkpoint.dir": "/b,/d,/a,/c",
          "dfs.datanode.failed.volumes.tolerated": "2",
          "content": "custom mock property"
        }
      },
      {
        "tag":"version1",
        "type":"hdfs-log4j",
        "properties": {
          "content": "hdfs log4j content"
        }
      },
      {
        "tag":"version1",
        "type":"zoo.cfg",
        "properties": {
          "custom.zoo.cfg": "zoo cfg content"
        }
      },
      {
        "tag":"version1",
        "type":"storm-site",
        "properties": {
          "storm.zookeeper.servers": "['c6401.ambari.apache.org','c6402.ambari.apache.org']",
          "single_line_property": "value",
          "multi_line_property": "value \n value"
        }
      },
      {
        "tag": "version1",
        "type": "storm-env",
        "properties": {
          "nonexistent_property": "some value",
          "storm_log_dir": "/var/log/storm",
          "stormuiserver_host": "c6401.ambari.apache.org"
        }
      },
      {
        "tag":"version1",
        "type":"zoo.cfg",
        "properties": {
          "custom.zoo.cfg": "value"
        }
      }
    ];
    return configGroups.filter(function(configGroup) {
      return serviceGroups.contains(configGroup.type);
    });
  },
  setupServiceConfigTagsObject: function(serviceName) {
    var configTags = {
      STORM: ['storm-env','storm-site'],
      HDFS: ['hadoop-env','hdfs-site','core-site','hdfs-log4j'],
      ZOOKEEPER: ['hadoop-env', 'zoo.cfg']
    };
    var configTagsObject = [];
    if (serviceName) {
      configTags[serviceName].forEach(function(tag) {
        configTagsObject.push({
          siteName: tag,
          tagName: "version1",
          newTagName: null
        });
      });
    } else {
      Object.keys(configTags).forEach(function (sName) {
        configTags[sName].forEach(function(tag) {
          configTagsObject.push({
            siteName: tag,
            tagName: "version1",
            newTagName: null
          });
        });
      });
    }
    return configTagsObject.uniq();
  },
  setupAdvancedConfigsObject: function() {
    return [
      {
        "serviceName": "HDFS",
        "name": "fs.defaultFS",
        "value": "hdfs://c6401.ambari.apache.org:8020",
        "description": "fs.defaultFS",
        "filename": "core-site.xml"
      },
      {
        "serviceName": "STORM",
        "name": "storm.zookeeper.servers",
        "value": "['localhost']",
        "description": "desc",
        "filename": "storm-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.datanode.data.dir",
        "value": "/hadoop/hdfs/data",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.namenode.name.dir",
        "value": "/hadoop/hdfs/namenode",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.namenode.checkpoint.dir",
        "value": "/hadoop/hdfs/namesecondary",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.datanode.failed.volumes.tolerated",
        "value": "2",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "content",
        "value": "custom mock property",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "content",
        "value": "hdfs log4j content",
        "description": "desc",
        "filename": "hdfs-log4j.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "content",
        "value": "custom hdfs log4j content",
        "description": "desc",
        "filename": "custom-hdfs-log4j.xml"
      },
      {
        "serviceName": "ZOOKEEPER",
        "name": "content",
        "value": "zookeeper log4j.xml content",
        "description": "desc",
        "filename": "zookeeper-log4j.xml"
      },
      {
        "serviceName": "ZOOKEEPER",
        "name": "custom.zoo.cfg",
        "value": "zoo cfg content",
        "description": "zoo.cfg config",
        "filename": "zoo.cfg"
      },
      {
        "serviceName": "YARN",
        "name": "content",
        "value": " value \n value",
        "filename": "capacity-scheduler.xml"
      },
      {
        "name": "hbase_log_dir",
        "value": "/hadoop/hbase",
        "serviceName": "HBASE",
        "filename": "hbase-env.xml"
      },
      {
        "name": "hbase_log_dir",
        "value": "/hadoop/ams-hbase",
        "serviceName": "AMBARI_METRICS",
        "filename": "ams-hbase-env.xml"
      }
    ];
  },
  setupStoredConfigsObject: function() {
    return [
      {
        "name":"storm.zookeeper.servers",
        "value":[
          "c6401.ambari.apache.org",
          "c6402.ambari.apache.org"
        ],
        "recommendedValue":"['c6401.ambari.apache.org','c6402.ambari.apache.org']",
        "filename":"storm-site.xml",
        "isUserProperty":false,
        "isOverridable":false,
        "showLabel":true,
        "serviceName":"STORM",
        "displayType":"componentHosts",
        "isVisible":true,
        "description":"desc",
        "isSecureConfig":false,
        "category":"General",
        "displayName":"storm.zookeeper.servers"
      },
      {
        "name":"single_line_property",
        "value":"value",
        "recommendedValue":"value",
        "filename":"storm-site.xml",
        "isUserProperty":true,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "displayType":"string",
        "displayName":"single_line_property",
        "category":"AdvancedStormSite"
      },
      {
        "name":"multi_line_property",
        "value":"value \n value",
        "recommendedValue":"value \n value",
        "filename":"storm-site.xml",
        "isUserProperty":true,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "displayType":"multiLine",
        "displayName":"multi_line_property",
        "category":"AdvancedStormSite"
      },
      {
        "name":"nonexistent_property",
        "value":"some value",
        "recommendedValue":"some value",
        "filename":"storm-env.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "isVisible":false,
        "displayName":null,
        "options":null
      },
      {
        "name":"dfs.datanode.data.dir",
        "value":"/a,/b",
        "recommendedValue":"/a,/b",
        "filename":"hdfs-site.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"HDFS",
        "displayType":"directories",
        "isRequired":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"desc",
        "index":1,
        "isSecureConfig":false,
        "category":"DataNode",
        "displayName":"DataNode directories"
      },
      {
        "name":"content",
        "value":"custom mock property",
        "recommendedValue":"custom mock property",
        "filename":"hdfs-site.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":false,
        "serviceName":"HDFS",
        "displayType":"content",
        "isRequired":true,
        "isRequiredByAgent":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"desc",
        "isSecureConfig":false,
        "category":"AdvancedHDFSLog4j",
        "displayName":"content"
      },
      {
        "name":"content",
        "value":"hdfs log4j content",
        "recommendedValue":"hdfs log4j content",
        "filename":"hdfs-log4j.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":false,
        "serviceName":"HDFS",
        "displayType":"content",
        "isRequired":true,
        "isRequiredByAgent":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"desc",
        "isSecureConfig":false,
        "category":"AdvancedHDFSLog4j",
        "displayName":"content"
      },
      {
        "name":"storm_log_dir",
        "value":"/var/log/storm",
        "recommendedValue":"/var/log/storm",
        "filename":"storm-env.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "displayType":"directory",
        "isRequired":true,
        "isRequiredByAgent":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"Storm log directory",
        "isSecureConfig":false,
        "category":"General",
        "displayName":"storm_log_dir"
      }
    ];
  },

  advancedConfigs: {
    items: [
      {
        "StackConfigurations" : {
          "final" : "false",
          "property_description" : "Proxy user group.",
          "property_name" : "proxyuser_group",
          "property_type" : [
            "GROUP"
          ],
          "property_value" : "users",
          "service_name" : "HDFS",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "hadoop-env.xml"
        }
      },
      {
        "StackConfigurations" : {
          "final" : "true",
          "property_description" : "dfs.datanode.data.dir description",
          "property_name" : "dfs.datanode.data.dir",
          "property_type" : [ ],
          "property_value" : "/hadoop/hdfs/data",
          "service_name" : "HDFS",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "hdfs-site.xml"
        }
      },
      {
        "StackConfigurations" : {
          "final" : "true",
          "property_description" : "to enable dfs append",
          "property_name" : "dfs.support.append",
          "property_type" : [ ],
          "property_value" : "true",
          "service_name" : "HDFS",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "hdfs-site.xml"
        }
      },
      {
        "StackConfigurations" : {
          "final" : "false",
          "property_description" : "User to run HDFS as",
          "property_name" : "hdfs_user",
          "property_type" : [
            "USER"
          ],
          "property_value" : "hdfs",
          "service_name" : "HDFS",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "hadoop-env.xml"
        }
      },
      {
        "StackConfigurations" : {
          "final" : "false",
          "property_description" : "The permissions that should be there on dfs.datanode.data.dir\n      directories. The datanode will not come up if the permissions are\n      different on existing dfs.datanode.data.dir directories. If the directories\n      don't exist, they will be created with this permission.",
          "property_name" : "dfs.datanode.data.dir.perm",
          "property_type" : [ ],
          "property_value" : "750",
          "service_name" : "HDFS",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "hdfs-site.xml"
        }
      },
      {
        "StackConfigurations" : {
          "final" : "false",
          "property_description" : "\n      DB user password.\n\n      IMPORTANT: if password is emtpy leave a 1 space string, the service trims the value,\n      if empty Configuration assumes it is NULL.\n    ",
          "property_name" : "oozie.service.JPAService.jdbc.password",
          "property_type" : [
            "PASSWORD"
          ],
          "property_value" : " ",
          "service_name" : "OOZIE",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "oozie-site.xml"
        }
      },
      {
        "StackConfigurations" : {
          "final" : "false",
          "property_description" : "prop description",
          "property_name" : "storm_log_dir",
          "property_type" : [],
          "property_value" : " ",
          "service_name" : "STORM",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "storm-env.xml"
        }
      }

    ]
  },
  
  advancedClusterConfigs: {
    items: [
      {
        "StackLevelConfigurations" : {
          "final" : "false",
          "property_description" : "Whether to ignore failures on users and group creation",
          "property_name" : "ignore_groupsusers_create",
          "property_type" : [ ],
          "property_value" : "false",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "cluster-env.xml"
        }
      },
      {
        "StackLevelConfigurations" : {
          "final" : "false",
          "property_description" : "Hadoop user group.",
          "property_name" : "user_group",
          "property_type" : [
            "GROUP"
          ],
          "property_value" : "hadoop",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "cluster-env.xml"
        }
      },
      {
        "StackLevelConfigurations" : {
          "final" : "false",
          "property_description" : "",
          "property_name" : "smokeuser",
          "property_type" : [
            "USER"
          ],
          "property_value" : "ambari-qa",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "cluster-env.xml"
        }
      },
      {
        "StackLevelConfigurations" : {
          "final" : "false",
          "property_description" : "",
          "property_name" : "zk_user",
          "property_type" : [
            "USER"
          ],
          "property_value" : "zookeeper",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "cluster-env.xml"
        }
      },
      {
        "StackLevelConfigurations" : {
          "final" : "false",
          "property_description" : "",
          "property_name" : "mapred_user",
          "property_type" : [
            "USER"
          ],
          "property_value" : "mapreduce",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "cluster-env.xml"
        }
      }
    ]
  }
  
}

});

;require.register("test/mock_data_setup/stack_descriptors", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = {
  "Artifacts": {
    "artifact_name": "kerberos_descriptor",
    "stack_name": "HDP",
    "stack_version": "2.2"
  },
  "KerberosDescriptor": {
    "kerberos_descriptor": {
      "properties": {
        "realm": "${cluster-env/kerberos_domain}",
        "keytab_dir": "/etc/security/keytabs"
      },
      "identities": [
        {
          "principal": {
            "value": "HTTP/_HOST@${realm}",
            "configuration": null
          },
          "name": "spnego",
          "keytab": {
            "file": "${keytab_dir}/spnego.service.keytab",
            "owner": {
              "name": "root",
              "access": "r"
            },
            "configuration": null,
            "group": {
              "name": "${hadoop-env/user_group}",
              "access": "r"
            }
          }
        },
        {
          "principal": {
            "value": "hdfs@${realm}",
            "configuration": "cluster-env/hdfs_principal_name"
          },
          "name": "hdfs",
          "keytab": {
            "file": "${keytab_dir}/hdfs.headless.keytab",
            "owner": {
              "name": "root",
              "access": "r"
            },
            "configuration": "hadoop-env/hdfs_user_keytab",
            "group": {
              "name": "${cluster-env/user_group}",
              "access": "r"
            }
          }
        },
        {
          "principal": {
            "value": "hbase@${realm}",
            "configuration": "hbase-env/hbase_principal_name"
          },
          "name": "hbase",
          "keytab": {
            "file": "${keytab_dir}/hbase.headless.keytab",
            "owner": {
              "name": "root",
              "access": "r"
            },
            "configuration": "hbase-env/hbase_user_keytab",
            "group": {
              "name": "${cluster-env/user_group}",
              "access": "r"
            }
          }
        },
        {
          "principal": {
            "value": "ambari-qa@${realm}",
            "configuration": "cluster-env/smokeuser_principal_name"
          },
          "name": "smokeuser",
          "keytab": {
            "file": "${keytab_dir}/smokeuser.headless.keytab",
            "owner": {
              "name": "root",
              "access": "r"
            },
            "configuration": "cluster-env/smokeuser_keytab",
            "group": {
              "name": "${cluster-env/user_group}",
              "access": "r"
            }
          }
        }
      ],
      "configurations": [
        {
          "core-site": {
            "hadoop.security.authentication": "kerberos",
            "hadoop.rpc.protection": "authentication; integrity; privacy",
            "hadoop.security.authorization": "true"
          }
        }
      ],
      "services": [
        {
          "name": "HDFS",
          "components": [
            {
              "name": "NAMENODE",
              "identities": [
                {
                  "name": "namenode_nn",
                  "principal": {
                    "value": "nn/_HOST@${realm}",
                    "configuration": "hdfs-site/dfs.namenode.kerberos.principal"
                  },
                  "keytab": {
                    "file": "${keytab_dir}/nn.service.keytab",
                    "owner": {
                      "name": "${hadoop-env/hdfs_user}",
                      "access": "r"
                    },
                    "group": {
                      "name": "${cluster-env/user_group}",
                      "access": ""
                    },
                    "configuration": "hdfs-site/dfs.namenode.keytab.file"
                  }
                },
                {
                  "name": "namenode_host",
                  "principal": {
                    "value": "host/_HOST@${realm}",
                    "configuration": "hdfs-site/dfs.namenode.kerberos.https.principal"
                  },
                  "keytab": {
                    "file": "${keytab_dir}/host.keytab",
                    "owner": {
                      "name": "${hadoop-env/hdfs_user}",
                      "access": "r"
                    },
                    "group": {
                      "name": "${cluster-env/user_group}",
                      "access": ""
                    },
                    "configuration": "hdfs-site/dfs.namenode.keytab.file"
                  }
                },
                {
                  "name": "/spnego",
                  "principal": {
                    "configuration": "hdfs-site/dfs.web.authentication.kerberos.principal"
                  },
                  "keytab": {
                    "configuration": "hdfs/dfs.web.authentication.kerberos.keytab"
                  }
                }
              ]
            },
            {
              "name": "DATANODE",
              "identities": [
                {
                  "name": "datanode_dn",
                  "principal": {
                    "value": "dn/_HOST@${realm}",
                    "configuration": "hdfs-site/dfs.namenode.kerberos.principal"
                  },
                  "keytab": {
                    "file": "${keytab_dir}/dn.service.keytab",
                    "owner": {
                      "name": "${hadoop-env/hdfs_user}",
                      "access": "r"
                    },
                    "group": {
                      "name": "${cluster-env/user_group}",
                      "access": ""
                    },
                    "configuration": "hdfs-site/dfs.namenode.keytab.file"
                  }
                },
                {
                  "name": "datanode_host",
                  "principal": {
                    "value": "host/_HOST@${realm}",
                    "configuration": "hdfs-site/dfs.datanode.kerberos.https.principal"
                  },
                  "keytab": {
                    "file": "${keytab_dir}/host.keytab.file",
                    "owner": {
                      "name": "${hadoop-env/hdfs_user}",
                      "access": "r"
                    },
                    "group": {
                      "name": "${cluster-env/user_group}",
                      "access": ""
                    },
                    "configuration": "hdfs-site/dfs.namenode.secondary.keytab.file"
                  }
                }
              ]
            },
            {
              "name": "SECONDARY_NAMENODE",
              "identities": [
                {
                  "name": "secondary_namenode_nn",
                  "principal": {
                    "value": "nn/_HOST@${realm}",
                    "configuration": "hdfs-site/dfs.namenode.secondary.kerberos.principal"
                  },
                  "keytab": {
                    "file": "${keytab_dir}/snn.service.keytab",
                    "owner": {
                      "name": "${hadoop-env/hdfs_user}",
                      "access": "r"
                    },
                    "group": {
                      "name": "${cluster-env/user_group}",
                      "access": ""
                    },
                    "configuration": "hdfs-site/dfs.namenode.secondary.keytab.file"
                  }
                },
                {
                  "name": "secondary_namenode_host",
                  "principal": {
                    "value": "host/_HOST@${realm}",
                    "configuration": "hdfs-site/dfs.namenode.secondary.kerberos.https.principal"
                  },
                  "keytab": {
                    "file": "${keytab_dir}/host.keytab.file",
                    "owner": {
                      "name": "${hadoop-env/hdfs_user}",
                      "access": "r"
                    },
                    "group": {
                      "name": "${cluster-env/user_group}",
                      "access": ""
                    },
                    "configuration": "hdfs-site/dfs.namenode.secondary.keytab.file"
                  }
                },
                {
                  "name": "/spnego",
                  "principal": {
                    "configuration": "hdfs-site/dfs.web.authentication.kerberos.principal"
                  },
                  "keytab": {
                    "configuration": "hdfs/dfs.web.authentication.kerberos.keytab"
                  }
                }
              ]
            }
          ]
        },
        {
          "name": "FALCON",
          "identities": [
            {
              "name": "/spnego"
            },
            {
              "name": "/smokeuser"
            },
            {
              "name": "/hdfs"
            }
          ],
          "configurations": [
            {
              "falcon-startup.properties": {
                "*.falcon.http.authentication.type": "kerberos",
                "*.falcon.authentication.type": "kerberos",
                "*.dfs.namenode.kerberos.principal": "nn/_HOST@${realm}"
              }
            }
          ],
          "components": [
            {
              "name": "FALCON_SERVER",
              "identities": [
                {
                  "principal": {
                    "value": "falcon/${host}@${realm}",
                    "configuration": "falcon-startup.properties/*.falcon.service.authentication.kerberos.principal"
                  },
                  "name": "falcon_server",
                  "keytab": {
                    "file": "${keytab_dir}/falcon.service.keytab",
                    "owner": {
                      "name": "${falcon-env/falcon_user}",
                      "access": "r"
                    },
                    "configuration": "falcon-startup.properties/*.falcon.service.authentication.kerberos.keytab",
                    "group": {
                      "name": "${cluster-env/user_group}",
                      "access": ""
                    }
                  }
                },
                {
                  "principal": {
                    "value": "HTTP/${host}@${realm}",
                    "configuration": "falcon-startup.properties/oozie.authentication.kerberos.principal"
                  },
                  "name": "/spnego",
                  "keytab": {
                    "file": null,
                    "owner": {
                      "name": null,
                      "access": null
                    },
                    "configuration": "falcon-startup.properties/oozie.authentication.kerberos.keytab",
                    "group": {
                      "name": null,
                      "access": null
                    }
                  }
                }
              ]
            }
          ]
        }
      ]
    }
  }
};

});

require.register("test/models/alerts/alert_config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/alerts/alert_config');

var model;

describe('App.AlertConfigProperties', function () {

  describe('Parameter', function () {

    function getModel() {
      return App.AlertConfigProperties.Parameter.create();
    }

    App.TestAliases.testAsComputedAlias(getModel(), 'badge', 'threshold');

  });

  describe('App.AlertConfigProperties.Parameters', function () {

    describe('StringMixin', function () {

      var obj;

      beforeEach(function () {
        obj = App.AlertConfigProperties.Parameter.create(App.AlertConfigProperties.Parameters.StringMixin, {});
      });

      describe('#isValid', function () {
        Em.A([
          {value: '', expected: false},
          {value: '\t', expected: false},
          {value: '    ', expected: false},
          {value: '\n', expected: false},
          {value: '\r', expected: false},
          {value: 'some not empty string', expected: true}
        ]).forEach(function (test) {
          it('value: ' + JSON.stringify(test.value) + ' ;result - ' + test.expected, function () {
            obj.set('value', test.value);
            expect(obj.get('isValid')).to.be.equal(test.expected);
          });
        });
      });

    });

    describe('NumericMixin', function () {

      var obj;

      beforeEach(function () {
        obj = App.AlertConfigProperties.Parameter.create(App.AlertConfigProperties.Parameters.NumericMixin, {});
      });

      describe('#isValid', function () {
        Em.A([
          {value: '', expected: false},
          {value: 'abc', expected: false},
          {value: 'g1', expected: false},
          {value: '1g', expected: false},
          {value: '123', expected: true},
          {value: '123.8', expected: true},
          {value: 123, expected: true},
          {value: 123.8, expected: true},
        ]).forEach(function (test) {
          it('value: ' + JSON.stringify(test.value) + ' ;result - ' + test.expected, function () {
            obj.set('value', test.value);
            expect(obj.get('isValid')).to.be.equal(test.expected);
          });
        });
      });

    });

    describe('PercentageMixin', function () {

      var obj;

      beforeEach(function () {
        obj = App.AlertConfigProperties.Parameter.create(App.AlertConfigProperties.Parameters.PercentageMixin, {});
      });

      describe('#isValid', function () {
        Em.A([
          {value: '', expected: false},
          {value: 'abc', expected: false},
          {value: 'g1', expected: false},
          {value: '1g', expected: false},
          {value: '123', expected: true},
          {value: '23', expected: true},
          {value: '123.8', expected: true},
          {value: '5.8', expected: true},
          {value: 123, expected: true},
          {value: 23, expected: true},
          {value: 123.8, expected: true},
          {value: 5.8, expected: true}
        ]).forEach(function (test) {
          it('value: ' + JSON.stringify(test.value) + ' ;result - ' + test.expected, function () {
            obj.set('value', test.value);
            expect(obj.get('isValid')).to.be.equal(test.expected);
          });
        });
      });

    });

  });

  describe('Threshold', function () {

    beforeEach(function () {
      model = App.AlertConfigProperties.Threshold.create({});
    });

    describe('#apiFormattedValue', function () {

      it('should be based on showInputForValue and showInputForText', function () {

        model.setProperties({
          value: 'value',
          text: 'text',
          showInputForValue: false,
          showInputForText: false
        });
        expect(model.get('apiFormattedValue')).to.eql([]);

        model.set('showInputForValue', true);
        expect(model.get('apiFormattedValue')).to.eql(['value']);

        model.set('showInputForText', true);
        expect(model.get('apiFormattedValue')).to.eql(['value', 'text']);

      });

    });

    describe('#badgeCssClass', function () {

      it ('should be based on badge', function () {

        model.set('badge', 'OK');
        expect(model.get('badgeCssClass')).to.equal('alert-state-OK');

      });

    });

    describe('#wasChanged', function () {

      Em.A([
          {
            p: {
              previousValue: null,
              previousText: null,
              value: '',
              text: ''
            },
            e: false
          },
          {
            p: {
              previousValue: 'not null',
              previousText: null,
              value: '',
              text: ''
            },
            e: true
          },
          {
            p: {
              previousValue: null,
              previousText: 'not null',
              value: '',
              text: ''
            },
            e: true
          },
          {
            p: {
              previousValue: 'not null',
              previousText: 'not null',
              value: '',
              text: ''
            },
            e: true
          }
        ]).forEach(function (test, i) {
        it('test #' + (i + 1), function () {
          model.setProperties(test.p);
          expect(model.get('wasChanged')).to.equal(test.e);
        });
      });

    });

    describe('#isValid', function () {

      it('should be true if showInputForValue is false', function () {
        model.set('showInputForValue', false);
        expect(model.get('isValid')).to.be.true;
      });

      it('should be false if displayValue is null', function () {
        model.set('displayValue', null);
        expect(model.get('isValid')).to.be.false;

        model.set('displayValue', undefined);
        expect(model.get('isValid')).to.be.false;
      });

      it('should be false if METRIC displayValue is not valid float', function () {
        model.set('displayValue', '$1234.444');
        expect(model.get('isValid')).to.be.false;

        model.set('displayValue', 'hello-world!');
        expect(model.get('isValid')).to.be.false;
      });

      it('should be true if METRIC displayValue is valid float with at most one decimal', function () {
        model.set('displayValue', '123.4');
        expect(model.get('isValid')).to.be.true;

        model.set('displayValue', '123.0');
        expect(model.get('isValid')).to.be.true;

        model.set('displayValue', '666');
        expect(model.get('isValid')).to.be.true;
      });

      it('should be false if METRIC displayValue is valid float with more than one decimal', function () {
        model.set('displayValue', '123.48');
        expect(model.get('isValid')).to.be.false;
      });

      it('should be true for AGGREGATE percentage with precision of 1', function () {
        model = Em.Object.create(App.AlertConfigProperties.Thresholds.PercentageMixin, {
          displayValue: '1',
          showInputForValue: true
        });

        expect(model.get('isValid')).to.be.true;

        model.set('displayValue', '88');
        expect(model.get('isValid')).to.be.true;
      });

      it('should be false for AGGREGATE percentage values with precision smaller than 1', function () {
        model = Em.Object.create(App.AlertConfigProperties.Thresholds.PercentageMixin, {
          displayValue: '70.01',
          showInputForValue: true
        });

        expect(model.get('isValid')).to.be.false;

        model.set('displayValue', '70.0');
        expect(model.get('isValid')).to.be.false;

        model.set('displayValue', '80.000');
        expect(model.get('isValid')).to.be.false;
      });

      it('should be true for PORT percentage values with precision of 1/10th', function () {
        model = App.AlertConfigProperties.Threshold.create({
          value: '0.4',
          showInputForValue: true
        })

        expect(model.get('isValid')).to.be.true;

        model.set('value', '3');
        expect(model.get('isValid')).to.be.true;

        model.set('value', '33.0');
        expect(model.get('isValid')).to.be.true;
      });

      it('should be false for PORT percentage values with precision greater than 1/10th', function() {
        model = App.AlertConfigProperties.Threshold.create({
          value: '4.234',
          showInputForValue: true
        });

        expect(model.get('isValid')).to.be.false;

        model.set('value', '44.001');
        expect(model.get('isValid')).to.be.false;

        model.set('value', '112.01');
        expect(model.get('isValid')).to.be.false;
      });

    });

  });

  describe('App.AlertConfigProperties.Thresholds', function () {

    describe('OkThreshold', function () {

      beforeEach(function () {
        model = App.AlertConfigProperties.Thresholds.OkThreshold.create();
      });

      describe('#apiProperty', function () {

        it('should be based on showInputForValue and showInputForText', function () {

          model.setProperties({
            showInputForValue: false,
            showInputForText: false
          });
          expect(model.get('apiProperty')).to.eql([]);

          model.set('showInputForValue', true);
          expect(model.get('apiProperty')).to.eql(['source.reporting.ok.value']);

          model.set('showInputForText', true);
          expect(model.get('apiProperty')).to.eql(['source.reporting.ok.value', 'source.reporting.ok.text']);

        });

      });

    });

    describe('WarningThreshold', function () {

      beforeEach(function () {
        model = App.AlertConfigProperties.Thresholds.WarningThreshold.create();
      });

      describe('#apiProperty', function () {

        it('should be based on showInputForValue and showInputForText', function () {

          model.setProperties({
            showInputForValue: false,
            showInputForText: false
          });
          expect(model.get('apiProperty')).to.eql([]);

          model.set('showInputForValue', true);
          expect(model.get('apiProperty')).to.eql(['source.reporting.warning.value']);

          model.set('showInputForText', true);
          expect(model.get('apiProperty')).to.eql(['source.reporting.warning.value', 'source.reporting.warning.text']);

        });

      });

    });

    describe('CriticalThreshold', function () {

      beforeEach(function () {
        model = App.AlertConfigProperties.Thresholds.CriticalThreshold.create();
      });

      describe('#apiProperty', function () {

        it('should be based on showInputForValue and showInputForText', function () {

          model.setProperties({
            showInputForValue: false,
            showInputForText: false
          });
          expect(model.get('apiProperty')).to.eql([]);

          model.set('showInputForValue', true);
          expect(model.get('apiProperty')).to.eql(['source.reporting.critical.value']);

          model.set('showInputForText', true);
          expect(model.get('apiProperty')).to.eql(['source.reporting.critical.value', 'source.reporting.critical.text']);

        });

      });

    });

  });

});

});

require.register("test/models/alerts/alert_definition_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/alerts/alert_definition');

var model;

function getModel() {
  return App.AlertDefinition.createRecord();
}

describe('App.AlertDefinition', function () {

  beforeEach(function () {
    model = getModel();
  });

  App.TestAliases.testAsComputedAnd(getModel(), 'isHostAlertDefinition', ['isAmbariService', 'isAmbariAgentComponent']);

  describe('#isCriticalOrWarning', function () {

    Em.A([
      {summary: {CRITICAL: {count: 1, maintenanceCount: 0}}, e: true},
      {summary: {CRITICAL: {count: 0, maintenanceCount: 1}}, e: false},
      {summary: {CRITICAL: {count: 1, maintenanceCount: 1}}, e: true},
      {summary: {WARNING: {count: 1, maintenanceCount: 0}}, e: true},
      {summary: {OK: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {UNKNOWN: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {}, e: false}
    ]).forEach(function (test, i) {
      it('test ' + (i + 1), function () {
        model.set('summary', test.summary);
        expect(model.get('isCriticalOrWarning')).to.equal(test.e);
      });
    });

  });

  describe('#isCritical', function () {

    Em.A([
      {summary: {CRITICAL: {count: 1, maintenanceCount: 0}}, e: true},
      {summary: {WARNING: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {OK: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {UNKNOWN: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {}, e: false}
    ]).forEach(function (test, i) {
      it('test ' + (i + 1), function () {
        model.set('summary', test.summary);
        expect(model.get('isCritical')).to.equal(test.e);
      });
    });

  });

  describe('#isWarning', function () {

    Em.A([
      {summary: {CRITICAL: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {WARNING: {count: 1, maintenanceCount: 0}}, e: true},
      {summary: {OK: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {UNKNOWN: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {}, e: false}
    ]).forEach(function (test, i) {
      it('test ' + (i + 1), function () {
        model.set('summary', test.summary);
        expect(model.get('isWarning')).to.equal(test.e);
      });
    });

  });

  describe('#isOK', function () {

    Em.A([
      {summary: {CRITICAL: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {WARNING: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {OK: {count: 1, maintenanceCount: 0}}, e: true},
      {summary: {UNKNOWN: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {}, e: false}
    ]).forEach(function (test, i) {
      it('test ' + (i + 1), function () {
        model.set('summary', test.summary);
        expect(model.get('isOK')).to.equal(test.e);
      });
    });

  });

  describe('#isUnknown', function () {

    Em.A([
      {summary: {CRITICAL: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {WARNING: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {OK: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {UNKNOWN: {count: 1, maintenanceCount: 0}}, e: true},
      {summary: {}, e: false}
    ]).forEach(function (test, i) {
      it('test ' + (i + 1), function () {
        model.set('summary', test.summary);
        expect(model.get('isUnknown')).to.equal(test.e);
      });
    });

  });

  describe('#lastTriggeredAgoFormatted', function () {

    it('should be empty', function () {
      model.set('lastTriggeredRaw', 0);
      expect(model.get('lastTriggeredAgoFormatted')).to.equal('');
    });

    it('should not be empty', function () {
      model.set('lastTriggeredRaw', new Date().getTime() - 61000);
      expect(model.get('lastTriggeredAgoFormatted')).to.equal('about a minute ago');
    });

  });

  describe('#serviceDisplayName', function () {

    it('should get name for non-existing service', function () {
      model.set('serviceName', 'FOOBAR');
      expect(model.get('serviceDisplayName')).to.equal('Foobar');
    });

  });

  describe('#componentNameFormatted', function () {

    beforeEach(function () {
      sinon.stub(App.format, 'role', function (a) {
        return 'role ' + a;
      });
    });

    it('should wrap component name by App.format.role method', function () {
      model.set('componentName', 'test');
      var result = model.get('componentNameFormatted');
      expect(result).to.equal('role test');
    });

    afterEach(function () {
      App.format.role.restore();
    });


  });

  App.TestAliases.testAsComputedGetByKey(getModel(), 'typeIconClass', 'typeIcons', 'type', {map: {
    METRIC: 'icon-bolt',
    SCRIPT: 'icon-file-text',
    WEB: 'icon-globe',
    PORT: 'icon-signin',
    AGGREGATE: 'icon-plus',
    SERVER: 'icon-desktop',
    RECOVERY: 'icon-desktop'
  }});

  describe('REOPEN', function () {

    describe('#getSortDefinitionsByStatus', function () {

      Em.A([
          {
            a: App.AlertDefinition.createRecord({summary: {OK: {count: 1, maintenanceCount: 0}, WARNING: {count: 1, maintenanceCount: 0}}}),
            b: App.AlertDefinition.createRecord({summary: {WARNING: {count: 1, maintenanceCount: 0}}}),
            order: true,
            e: -1
          },
          {
            a: App.AlertDefinition.createRecord({summary: {OK: {count: 1, maintenanceCount: 0}, WARNING: {count: 2, maintenanceCount: 0}}}),
            b: App.AlertDefinition.createRecord({summary: {OK: {count: 1, maintenanceCount: 0}, WARNING: {count: 1, maintenanceCount: 0}}}),
            order: true,
            e: -1
          },
          {
            a: App.AlertDefinition.createRecord({summary: {OK: {count: 1, maintenanceCount: 0}, WARNING: {count: 1, maintenanceCount: 0}}}),
            b: App.AlertDefinition.createRecord({summary: {WARNING: {count: 1, maintenanceCount: 0}}}),
            order: false,
            e: 1
          },
          {
            a: App.AlertDefinition.createRecord({summary: {OK: {count: 1, maintenanceCount: 0}, WARNING: {count: 2, maintenanceCount: 0}}}),
            b: App.AlertDefinition.createRecord({summary: {OK: {count: 1, maintenanceCount: 0}, WARNING: {count: 1, maintenanceCount: 0}}}),
            order: false,
            e: 1
          }
        ]).forEach(function(test, i) {
          it('test #' + (i + 1), function () {
            var func = App.AlertDefinition.getSortDefinitionsByStatus(test.order);
            expect(func(test.a, test.b)).to.equal(test.e);
          });
        });

    });

  });

});

});

require.register("test/models/alerts/alert_group_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

function getModel() {
  return App.AlertGroup.createRecord();
}

describe('App.AlertGroup', function() {

  App.TestAliases.testAsComputedAlias(getModel(), 'isAddDefinitionsDisabled', 'default', 'boolean');

});
});

require.register("test/models/alerts/alert_instance_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/alerts/alert_instance');

var model;

function getModel() {
  return App.AlertInstance.createRecord();
}

describe('App.AlertInstance', function () {

  beforeEach(function () {
    model = getModel();
  });

  App.TestAliases.testAsComputedGetByKey(getModel(), 'shortStateMsg', 'shortState', 'state', {
    map: {
      CRITICAL: 'CRIT',
      WARNING: 'WARN',
      OK: 'OK',
      UNKNOWN: 'UNKWN',
      PENDING: 'NONE'
    }
  });

  describe('#serviceDisplayName', function () {

    it('should get name for non-existing service', function () {
      model.set('serviceName', 'FOOBAR');
      expect(model.get('serviceDisplayName')).to.equal('Foobar');
    });

  });

  describe('#statusChangedAndLastCheckedFormatted', function () {

    it('should Status Changed before Last Checked', function () {

      var lastCheckedFormatted = '123',
        lastTriggeredFormatted = '321';

      model.reopen({
        lastCheckedFormatted: lastCheckedFormatted,
        lastTriggeredFormatted: lastTriggeredFormatted
      });
      var status = model.get('statusChangedAndLastCheckedFormatted');
      expect(status.indexOf(lastCheckedFormatted)).to.be.above(status.indexOf(lastTriggeredFormatted));
    });

  });

  describe('#escapeSpecialCharactersFromTooltip', function () {
    it('it Should Display Alert Without special characters "<" and ">"', function () {

      model.set('text', '<urlopen error [Errno 111] Connection refused>');
      var resultedText = model.get('escapeSpecialCharactersFromTooltip');

      expect(resultedText).to.equal('urlopen error [Errno 111] Connection refused');
    });
  });

});

});

require.register("test/models/authentication_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/authentication');

var form,
  methods = [
    {
      name: 'method',
      fields: ['primaryServer', 'searchBaseDn', 'usernameAttribute']
    },
    {
      name: 'bindMethod',
      fields: ['bindUser', 'password', 'passwordRetype']
    }
  ],
  classCases = [
    {
      result: 0,
      message: 'fail',
      className: 'error'
    },
    {
      result: 1,
      message: 'success',
      className: 'success'
    }
  ];

describe('App.AuthenticationForm', function () {

  beforeEach(function() {
    form = App.AuthenticationForm.create();
  });

  methods.forEach(function (method) {
    method.fields.forEach(function (field) {
      describe('#' + field + '.isRequired', function () {
        [2, 1, 0].forEach(function (i) {
          it('should be ' + i + ' dependent on ' + method.name + ' value', function () {
            form.getField(method.name).set('value', i);
            expect(form.getField(field).get('isRequired')).to.equal(i);
          });
        });
      });
    });
  });

  App.TestAliases.testAsComputedIfThenElse(App.AuthenticationForm.create(), 'testConfigurationMessage', 'testResult', Em.I18n.t('admin.authentication.form.test.success'), Em.I18n.t('admin.authentication.form.test.fail'));

  App.TestAliases.testAsComputedIfThenElse(App.AuthenticationForm.create(), 'testConfigurationClass', 'testResult', 'text-success', 'text-error');

  describe('#testResult', function () {
    it('should be 0 or 1', function () {
      form.testConfiguration();
      expect([0, 1]).to.include(Number(form.get('testResult')));
    });
  });

  describe('#testConfigurationMessage', function () {
    classCases.forEach(function (item) {
      it('should indicate ' + item.message, function () {
        form.set('testResult', item.result);
        expect(form.get('testConfigurationMessage')).to.equal(Em.I18n.t('admin.authentication.form.test.' + item.message));
      });
    });
  });

  describe('#testConfigurationClass', function () {
    classCases.forEach(function (item) {
      it('should indicate ' + item.className, function () {
        form.set('testResult', item.result);
        expect(form.get('testConfigurationClass')).to.equal('text-' + item.className);
      });
    });
  });

});

});

require.register("test/models/client_component_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/client_component');

describe('App.ClientComponent', function () {

  var clientComponent;

  beforeEach(function () {
    clientComponent = App.ClientComponent.createRecord();
  });

  describe('#allowToDelete', function () {

    var cases = [
      {
        statesCounts: {
          installedCount: 1,
          installFailedCount: 2,
          initCount: 3,
          unknownCount: 4,
          totalCount: 10
        },
        allowToDelete: true,
        title: 'delete allowed'
      },
      {
        statesCounts: {
          installedCount: 1,
          installFailedCount: 2,
          initCount: 3,
          unknownCount: 4,
          totalCount: 11
        },
        allowToDelete: false,
        title: 'delete not allowed'
      }
    ];

    cases.forEach(function (item) {

      it(item.title, function () {
        clientComponent.setProperties(item.statesCounts);
        expect(clientComponent.get('allowToDelete')).to.equal(item.allowToDelete);
      });

    });

  });

  describe('#summaryLabelClassName', function () {

    it('should use lower case of component name', function () {
      clientComponent.set('componentName', 'ZOOKEEPER_CLIENT');
      expect(clientComponent.get('summaryLabelClassName')).to.equal('label_for_zookeeper_client');
    });

  });

  describe('#summaryValueClassName', function () {

    it('should use lower case of component name', function () {
      clientComponent.set('componentName', 'ZOOKEEPER_CLIENT');
      expect(clientComponent.get('summaryValueClassName')).to.equal('value_for_zookeeper_client');
    });

  });

  describe('#displayNamePluralized', function () {

    var cases = [
      {
        installedCount: 1,
        displayNamePluralized: 'Zookeeper Client',
        title: 'singular'
      },
      {
        installedCount: 2,
        displayNamePluralized: 'Zookeeper Clients',
        title: 'plural'
      }
    ];

    cases.forEach(function (item) {

      it(item.title, function () {
        clientComponent.setProperties({
          displayName: 'Zookeeper Client',
          installedCount: item.installedCount
        });
        expect(clientComponent.get('displayNamePluralized')).to.equal(item.displayNamePluralized);
      });

    });

  });

});
});

require.register("test/models/cluster_states_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var LZString = require('utils/lz-string');
require('models/cluster_states');

var status = App.clusterStatus,
  notInstalledStates = ['CLUSTER_NOT_CREATED_1', 'CLUSTER_DEPLOY_PREP_2', 'CLUSTER_INSTALLING_3', 'SERVICE_STARTING_3'],
  values = {
    clusterName: 'name',
    clusterState: 'STACK_UPGRADING',
    wizardControllerName: 'wizardStep0Controller',
    localdb: {}
  },
  response = {
    clusterState: 'DEFAULT',
    clusterName: 'cluster'
  },
  response2 = {
    clusterState: 'DEFAULT2',
    clusterName: 'cluster2'
  },
  newValue = {
    clusterName: 'name',
    clusterState: 'STACK_UPGRADING',
    wizardControllerName: 'wizardStep0Controller'
  };
var compressedResponse = LZString.compressToBase64(JSON.stringify(response2));

describe('App.clusterStatus', function () {

  App.TestAliases.testAsComputedNotExistsIn(status, 'isInstalled', 'clusterState', notInstalledStates);

  describe('#value', function () {
    it('should be set from properties', function () {
      Em.keys(values).forEach(function (key) {
        status.set(key, values[key]);
      });
      expect(status.get('value')).to.eql(values);
    });
  });

  describe('#getUserPrefSuccessCallback', function () {
    describe('response', function () {
      beforeEach(function () {
        status.getUserPrefSuccessCallback(response);
      });
      Em.keys(response).forEach(function (key) {
        it(key, function () {
          expect(status.get(key)).to.equal(response[key]);
        });
      });
    });
    describe('compressedResponse', function () {
      beforeEach(function () {
        status.getUserPrefSuccessCallback(compressedResponse);
      });
      Em.keys(response2).forEach(function (key) {
        it(key, function () {
          expect(status.get(key)).to.equal(response2[key]);
        });
      });
    });
  });

  describe('#setClusterStatus', function () {

    beforeEach(function() {
      sinon.stub(status, 'postUserPref', function() {
        return $.ajax();
      });
    });

    afterEach(function () {
      status.postUserPref.restore();
    });

    it('should set cluster status in non-test mode', function () {
      var clusterStatus = status.setClusterStatus(newValue);
      expect(clusterStatus).to.eql(newValue);
    });

  });

});

});

require.register("test/models/cluster_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/cluster');

describe('App.Cluster', function () {

  var cluster;

  beforeEach(function () {
    cluster = App.Cluster.createRecord();
  });

  describe('#isKerberosEnabled', function () {

    var cases = [
      {
        securityType: 'KERBEROS',
        isKerberosEnabled: true,
        title: 'Kerberos enabled'
      },
      {
        securityType: 'NONE',
        isKerberosEnabled: false,
        title: 'Kerberos disabled'
      }
    ];

    cases.forEach(function (item) {

      it(item.title, function () {
        cluster.set('securityType', item.securityType);
        expect(cluster.get('isKerberosEnabled')).to.equal(item.isKerberosEnabled);
      });

    });

    describe('#isCredentialStorePersistent', function () {

      var cases = [
        {
          propertyValue: 'false',
          isCredentialStorePersistent: false,
          title: 'no persistent credential store'
        },
        {
          propertyValue: true,
          isCredentialStorePersistent: false,
          title: 'malformed value'
        },
        {
          propertyValue: 'true',
          isCredentialStorePersistent: true,
          title: 'persistent credential store'
        }
      ];

      cases.forEach(function (item) {

        it(item.title, function () {
          cluster.set('credentialStoreProperties', {
            'storage.persistent': item.propertyValue
          });
          expect(cluster.get('isCredentialStorePersistent')).to.equal(item.isCredentialStorePersistent);
        });

      });

    });

  });

});
});

require.register("test/models/configs/config_group_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var model;

function getModel() {
  return App.ServiceConfigGroup.createRecord({
    parentConfigGroup: Em.Object.create({
      hosts: []
    })
  });
}

describe('App.ServiceConfigGroup', function () {

  beforeEach(function () {
    model = getModel();
  });

  describe("#displayName", function() {

    before(function () {
      sinon.stub(App.config, 'truncateGroupName');
    });
    after(function () {
      App.config.truncateGroupName.restore();
    });

    it("App.config.truncateGroupName should be called", function() {
      model.set('name', 'group1');
      model.get('displayName');
      expect(App.config.truncateGroupName.called).to.be.true;
    });
  });

  describe("#availableHosts", function() {

    it("default group", function() {
      model.reopen({
        isDefault: true
      });
      expect(model.get('availableHosts')).to.be.empty;
    });

    it("no cluster hosts", function() {
      model.reopen({
        isDefault: false,
        clusterHosts: []
      });
      expect(model.get('availableHosts')).to.be.empty;
    });

    it("cluster hosts used", function() {
      model.reopen({
        isDefault: false,
        clusterHosts: [
          Em.Object.create({id: 'g1'})
        ]
      });
      expect(model.get('availableHosts')).to.be.empty;
    });

    describe("cluster hosts not used", function() {
      var host = Em.Object.create({
        id: 'g1',
        hostComponents: [{componentName: 'c1'}]
      });

      beforeEach(function () {
        model.reopen({
          isDefault: false,
          clusterHosts: [host]
        });
        model.set('parentConfigGroup.hosts', ['g1']);
      });
      it('availableHosts is not empty', function () {
        expect(model.get('availableHosts')).to.be.not.empty;
      });
      it('1st host is selected', function () {
        expect(model.get('availableHosts')[0].get('selected')).to.be.false;
      });
      it('1st host components are correct', function () {
        expect(model.get('availableHosts')[0].get('hostComponentNames')).to.eql(['c1']);
      });
      it('1st host `host` is correct', function () {
        expect(model.get('availableHosts')[0].get('host')).to.eql(host);
      });
    });
  });

  describe("#propertiesList", function() {

    it("properties is null", function() {
      model.set('properties', null);
      expect(model.get('propertiesList')).to.be.empty;
    });

    it("properties is correct", function() {
      model.set('properties', [
        {
          name: 'p1',
          value: 'v1'
        }
      ]);
      expect(model.get('propertiesList')).to.equal('p1 : v1<br/>');
    });
  });

  describe("#getParentConfigGroupId()", function () {

    before(function () {
      sinon.stub(App.ServiceConfigGroup, 'groupId');
    });
    after(function () {
      App.ServiceConfigGroup.groupId.restore();
    });

    it("App.ServiceConfigGroup.groupId should be called", function () {
      App.ServiceConfigGroup.getParentConfigGroupId('S1');
      expect(App.ServiceConfigGroup.groupId.calledWith('S1', 'Default')).to.be.true;
    });
  });

  describe("#groupId()", function () {

    it("should return group id", function () {
      expect(App.ServiceConfigGroup.groupId('S1', 'g1')).to.be.equal('S1_g1');
    });
  });
});

});

require.register("test/models/configs/objects/service_config_category_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/configs/objects/service_config_category');
require('models/configs/objects/service_config_property');

var serviceConfigCategory;

function getCategory() {
  return App.ServiceConfigCategory.create();
}

describe('App.ServiceConfigCategory', function () {

  beforeEach(function () {
    serviceConfigCategory = getCategory();
  });

  describe('#isAdvanced', function () {
    it('should be true', function () {
      serviceConfigCategory.set('name', 'Advanced');
      expect(serviceConfigCategory.get('isAdvanced')).to.be.true;
    });
    it('should be false', function () {
      serviceConfigCategory.set('name', 'name');
      expect(serviceConfigCategory.get('isAdvanced')).to.be.false;
    });
  });

});

});

require.register("test/models/configs/objects/service_config_property_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/configs/objects/service_config_category');
require('models/configs/objects/service_config_property');

var serviceConfigProperty,
  serviceConfigPropertyInit,
  configsData = [
    Ember.Object.create({
      category: 'c0',
      overrides: [
        {
          error: true,
          errorMessage: 'error'
        },
        {
          error: true
        },
        {}
      ]
    }),
    Ember.Object.create({
      category: 'c1',
      isValid: false,
      isVisible: true
    }),
    Ember.Object.create({
      category: 'c0',
      isValid: true,
      isVisible: true
    }),
    Ember.Object.create({
      category: 'c1',
      isValid: false,
      isVisible: false
    })
  ],

  overridableFalseData = [
    {
      isOverridable: false
    },
    {
      isEditable: false,
      overrides: configsData[0].overrides
    },
    {
      displayType: 'componentHost'
    }
  ],
  overridableTrueData = [
    {
      isOverridable: true,
      isEditable: true
    },
    {
      isOverridable: true,
      overrides: []
    },
    {
      isOverridable: true
    }
  ],
  overriddenFalseData = [
    {
      overrides: null,
      isOriginalSCP: true
    },
    {
      overrides: [],
      isOriginalSCP: true
    }
  ],
  overriddenTrueData = [
    {
      overrides: configsData[0].overrides
    },
    {
      isOriginalSCP: false
    }
  ],
  removableFalseData = [
    {
      isEditable: false
    },
    {
      hasOverrides: true
    },
    {
      isUserProperty: false,
      isOriginalSCP: true
    }
  ],
  removableTrueData = [
    {
      isEditable: true,
      hasOverrides: false,
      isUserProperty: true
    },
    {
      isEditable: true,
      hasOverrides: false,
      isOriginalSCP: false
    }
  ],
  initPropertyData = [
    {
      initial: {
        displayType: 'password',
        value: 'value',
        recommendedValue: 'recommended'
      },
      result: {
        retypedPassword: 'value',
        recommendedValue: ''
      }
    },
    {
      initial: {
        value: '',
        savedValue: 'default',
        recommendedValue: 'recommended'
      },
      result: {
        value: '',
        recommendedValue: 'recommended'
      }
    },
    {
      initial: {
        value: null,
        savedValue: 'default',
        recommendedValue: 'recommended'
      },
      result: {
        value: 'default',
        recommendedValue: 'recommended'
      }
    }
  ],
  notDefaultFalseData = [
    {
      isEditable: false
    },
    {
      savedValue: null
    },
    {
      value: 'value',
      savedValue: 'value'
    }
  ],
  notDefaultTrueData = {
    isEditable: true,
    value: 'value',
    savedValue: 'default'
  },
  types = ['componentHost', 'componentHosts', 'radio button'];


function getProperty() {
  return App.ServiceConfigProperty.create();
}

describe('App.ServiceConfigProperty', function () {

  beforeEach(function () {
    serviceConfigProperty = getProperty();
  });

  App.TestAliases.testAsComputedAnd(getProperty(), 'hideFinalIcon', ['!isFinal', 'isNotEditable']);

  describe('#placeholder', function () {
    it('should equal foo', function() {
      serviceConfigProperty.set('isEditable', true);
      var testCases = [
        {
          placeholderText: 'foo',
          savedValue: ''
        },
        {
          placeholderText: '',
          savedValue: 'foo'
        },
        {
          placeholderText: 'foo',
          savedValue: 'bar'
        }
      ];
      testCases.forEach(function (item) {
        serviceConfigProperty.set('placeholderText', item.placeholderText);
        serviceConfigProperty.set('savedValue', item.savedValue);
        expect(serviceConfigProperty.get('placeholder')).to.equal('foo');
      });
    });
    it('should equal null', function() {
      serviceConfigProperty.set('isEditable', false);
      var testCases = [
        {
          placeholderText: 'foo',
          savedValue: 'bar'
        }
      ];
      testCases.forEach(function (item) {
        serviceConfigProperty.set('placeholderText', item.placeholderText);
        serviceConfigProperty.set('savedValue', item.savedValue);
        expect(serviceConfigProperty.get('placeholder')).to.equal(null);
      });
    });
  });
  describe('#isPropertyOverridable', function () {
    overridableFalseData.forEach(function (item) {
      it('should be false', function () {
        serviceConfigProperty.setProperties(item);
        expect(serviceConfigProperty.get('isPropertyOverridable')).to.be.false;
      });
    });
    overridableTrueData.forEach(function (item) {
      it('should be true', function () {
        serviceConfigProperty.setProperties(item);
        expect(serviceConfigProperty.get('isPropertyOverridable')).to.be.true;
      });
    });
  });

  describe('#isOverridden', function () {
    overriddenFalseData.forEach(function (item) {
      it('should be false', function () {
        serviceConfigProperty.setProperties(item);
        expect(serviceConfigProperty.get('isOverridden')).to.be.false;
      });
    });
    overriddenTrueData.forEach(function (item) {
      it('should be true', function () {
        serviceConfigProperty.setProperties(item);
        expect(serviceConfigProperty.get('isOverridden')).to.be.true;
      });
    });
  });

  describe('#isRemovable', function () {
    removableFalseData.forEach(function (item) {
      it('should be false', function () {
        serviceConfigProperty.setProperties(item);
        expect(serviceConfigProperty.get('isRemovable')).to.be.false;
      });
    });
    removableTrueData.forEach(function (item) {
      it('should be true', function () {
        serviceConfigProperty.setProperties(item);
        expect(serviceConfigProperty.get('isRemovable')).to.be.true;
      });
    });
  });

  describe('#init', function () {
    initPropertyData.forEach(function (item) {
      describe('should set initial data for ' + JSON.stringify(item), function () {
        beforeEach(function () {
          serviceConfigPropertyInit = App.ServiceConfigProperty.create(item.initial);
        });
        Em.keys(item.result).forEach(function (prop) {
          it(prop, function () {
            expect(serviceConfigPropertyInit.get(prop)).to.equal(item.result[prop]);
          });
        });
      });
    });
  });

  describe('#isNotDefaultValue', function () {
    notDefaultFalseData.forEach(function (item) {
      it('should be false', function () {
        serviceConfigProperty.setProperties(item);
        expect(serviceConfigProperty.get('isNotDefaultValue')).to.be.false;
      });
    });
    it('should be true', function () {
      Em.keys(notDefaultTrueData).forEach(function (prop) {
        serviceConfigProperty.set(prop, notDefaultTrueData[prop]);
      });
      expect(serviceConfigProperty.get('isNotDefaultValue')).to.be.true;
    });
  });

  describe('#cantBeUndone', function () {
    types.forEach(function (item) {
      it('should be true', function () {
        serviceConfigProperty.set('displayType', item);
        expect(serviceConfigProperty.get('cantBeUndone')).to.be.true;
      });
    });
    it('should be false', function () {
      serviceConfigProperty.set('displayType', 'type');
      expect(serviceConfigProperty.get('cantBeUndone')).to.be.false;
    });
  });

  describe('#isValid', function () {
    it('should be true', function () {
      serviceConfigProperty.set('errorMessage', '');
      expect(serviceConfigProperty.get('isValid')).to.be.true;
    });
    it('should be false', function () {
      serviceConfigProperty.set('errorMessage', 'message');
      expect(serviceConfigProperty.get('isValid')).to.be.false;
    });
  });

  describe('#overrideIsFinalValues', function () {
    it('should be defined as empty array', function () {
      expect(serviceConfigProperty.get('overrideIsFinalValues')).to.eql([]);
    });
  });

  describe('custom validation for `ranger_admin_password`', function () {

    beforeEach(function () {
      this.config = App.ServiceConfigProperty.create({
        name: 'ranger_admin_password',
        displayType: 'password'
      });
    });

    it('value less than 9 symbols is invalid', function () {
      this.config.set('value', 12345678);
      this.config.set('retypedPassword', 12345678);
      expect(this.config.get('isValid')).to.be.false;
      expect(this.config.get('errorMessage')).to.be.equal(Em.I18n.t('errorMessage.config.password.length').format(9));
    });

    it('value with 9 symbols is valid', function () {
      this.config.set('value', 123456789);
      this.config.set('retypedPassword', 123456789);
      expect(this.config.get('isValid')).to.be.true;
      expect(this.config.get('errorMessage')).to.be.equal('');
    });

  });

});

});

require.register("test/models/configs/objects/service_config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/configs/objects/service_config');

var serviceConfig,
    configs = [
      App.ServiceConfigProperty.create({
        'name': 'p1',
        'isVisible': true,
        'hiddenBySection': false,
        'hiddenBySubSection': false,
        'isRequiredByAgent': true,
        'isValid': true,
        'isValidOverride': true
      }),
      App.ServiceConfigProperty.create({
        'name': 'p2',
        'isVisible': false,
        'hiddenBySection': false,
        'hiddenBySubSection': false,
        'isRequiredByAgent': true,
        'isValid': true,
        'isValidOverride': true
      }),
      App.ServiceConfigProperty.create({
        'name': 'p3',
        'isVisible': true,
        'hiddenBySection': true,
        'hiddenBySubSection': true,
        'isRequiredByAgent': true,
        'isValid': true,
        'isValidOverride': true
      }),
      App.ServiceConfigProperty.create({
        'name': 'p4',
        'isVisible': true,
        'hiddenBySection': false,
        'hiddenBySubSection': false,
        'isRequiredByAgent': true,
        'isValid': false,
        'isValidOverride': true
      }),
      App.ServiceConfigProperty.create({
        'name': 'p5',
        'isVisible': true,
        'hiddenBySection': false,
        'hiddenBySubSection': false,
        'isRequiredByAgent': true,
        'isValid': true,
        'isValidOverride': false
      }),
      App.ServiceConfigProperty.create({
        'name': 'p6',
        'isVisible': true,
        'hiddenBySection': false,
        'hiddenBySubSection': false,
        'isRequiredByAgent': false,
        'isRequired': false,
        'isValid': true,
        'isValidOverride': false
      }),
      App.ServiceConfigProperty.create({
        'name': 'p7',
        'isVisible': true,
        'hiddenBySection': false,
        'hiddenBySubSection': false,
        'isRequiredByAgent': false,
        'isValid': true,
        'isRequired': true,
        'isValidOverride': false
      })
  ];

describe('App.ServiceConfig', function () {

  beforeEach(function () {
    serviceConfig = App.ServiceConfig.create({
      configs: configs
    });
  });

  describe('#activeProperties', function() {
    it('returns collection of properties that should be shown', function() {
      serviceConfig.setActivePropertiesOnce();
      expect(serviceConfig.get('activeProperties').mapProperty('name')).to.be.eql(['p1','p4','p5','p7']);
    });
  });

  describe('#configsWithErrors', function() {
    it('returns collection of properties with errors', function() {
      serviceConfig.set('activeProperties', configs);
      serviceConfig.setConfigsWithErrorsOnce();
      expect(serviceConfig.get('configsWithErrors').mapProperty('name')).to.be.eql(['p4', 'p5', 'p6', 'p7']);
    });
  });

  describe('#errorCount', function() {
    it('returns collection of properties with errors', function() {
      serviceConfig.reopen({
        configsWithErrors: [{}, {}]
      });
      expect(serviceConfig.get('errorCount')).to.equal(2);
    });
  });
});

});

require.register("test/models/configs/section_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var model;

function getModel() {
  return App.Section.createRecord();
}

describe('App.Section', function () {

  beforeEach(function () {
    model = getModel();
  });

  describe('#errorsCount', function () {

    beforeEach(function () {
      model.reopen({subSections: [
        App.SubSection.createRecord({configs: [
          App.ServiceConfigProperty.create({isValid: true}),
          App.ServiceConfigProperty.create({isValid: false})
        ]}),
        App.SubSection.createRecord({configs: [
          App.ServiceConfigProperty.create({isValid: true}),
          App.ServiceConfigProperty.create({isValid: false})
        ]})
      ]});
    });

    it('should use subsections.@each.errorsCount', function () {
      expect(model.get('errorsCount')).to.equal(2);
    });

  });

  App.TestAliases.testAsComputedEveryBy(getModel(), 'isHiddenByFilter', 'subSections', 'isSectionVisible', false);

});

});

require.register("test/models/configs/service_config_version_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/configs/service_config_version');

var model;

function getModel() {
  return App.ServiceConfigVersion.createRecord({});
}

describe('App.ServiceConfigVersion', function () {

  beforeEach(function () {
    model = getModel();
  });

  App.TestAliases.testAsComputedAnd(getModel(), 'canBeMadeCurrent', ['isCompatible', '!isCurrent']);

  App.TestAliases.testAsComputedTruncate(getModel(), 'authorFormatted', 'author', 15, 15);

  App.TestAliases.testAsComputedTruncate(getModel(), 'briefNotes', 'fullNotes', 81, 81, '');

  App.TestAliases.testAsComputedNotEqualProperties(getModel(), 'moreNotesExists', 'fullNotes', 'briefNotes');

  describe("#configGroupName", function() {

    it("not default group", function() {
      model.reopen({
        groupName: 'g1',
        isDefault: false
      });
      expect(model.get('configGroupName')).to.equal('g1');
    });

    it("default group", function() {
      model.reopen({
        isDefault: true
      });
      expect(model.get('configGroupName')).to.equal(Em.I18n.t('common.default'));
    });

  });

  describe("#fullNotes", function() {

    it("notes is null", function() {
      model.set('notes', null);
      expect(model.get('fullNotes')).to.equal(Em.I18n.t('dashboard.configHistory.table.notes.no'));
    });

    it("notes is empty", function() {
      model.set('notes', "");
      expect(model.get('fullNotes')).to.equal(Em.I18n.t('dashboard.configHistory.table.notes.no'));
    });

    it("notes has value", function() {
      model.set('notes', "notes-value");
      expect(model.get('fullNotes')).to.equal('notes-value');
    });

  });

  describe("#createdDate", function() {

    it("should return created date", function() {
      model.set('createTime', 1450267588961);
      moment.tz.setDefault('America/Los_Angeles');
      expect(model.get('createdDate')).to.equal('Wed, Dec 16, 2015 04:06');
    });

  });

  describe("#timeSinceCreated", function () {

    before(function () {
      sinon.stub($, 'timeago').returns('timeago');
    });
    after(function () {
      $.timeago.restore()
    });

    it("should return time since created", function () {
      model.set('rawCreateTime', 1450267588961);
      expect(model.get('timeSinceCreated')).to.equal('timeago');
    });

  });

  describe("#isRestartRequired", function() {

    it("service.isRestartRequired is false", function() {
      model.set('service', Em.Object.create({
        isRestartRequired: false
      }));
      expect(model.get('isRestartRequired')).to.be.false;
    });

    it("non-current version", function() {
      model.set('service', Em.Object.create({
        isRestartRequired: true
      }));
      model.set('isCurrent', false);
      expect(model.get('isRestartRequired')).to.be.false;
    });

    it("version has no hosts", function() {
      model.setProperties({
        service: Em.Object.create({
          isRestartRequired: true
        }),
        isCurrent: true,
        hosts: []
      });
      expect(model.get('isRestartRequired')).to.be.false;
    });

    it("version hosts don't need restart", function() {
      model.setProperties({
        service: Em.Object.create({
          isRestartRequired: true,
          restartRequiredHostsAndComponents: {}
        }),
        isCurrent: true,
        hosts: ['host1']
      });
      expect(model.get('isRestartRequired')).to.be.false;
    });

    it("version hosts need restart", function() {
      model.setProperties({
        service: Em.Object.create({
          isRestartRequired: true,
          restartRequiredHostsAndComponents: {'host1': {}}
        }),
        isCurrent: true,
        hosts: ['host1']
      });
      expect(model.get('isRestartRequired')).to.be.true;
    });

  });

  describe("#disabledActionMessages", function() {
    var testCases = [
      {
        input: {
          isDisplayed: false,
          isCurrent: false
        },
        expected: {
          view: '',
          compare: '',
          revert: ''
        }
      },
      {
        input: {
          isDisplayed: true,
          isCurrent: false
        },
        expected: {
          view: Em.I18n.t('dashboard.configHistory.info-bar.view.button.disabled'),
          compare: Em.I18n.t('dashboard.configHistory.info-bar.compare.button.disabled'),
          revert: ''
        }
      },
      {
        input: {
          isDisplayed: false,
          isCurrent: true
        },
        expected: {
          view: '',
          compare: '',
          revert: Em.I18n.t('dashboard.configHistory.info-bar.revert.button.disabled')
        }
      },
      {
        input: {
          isDisplayed: true,
          isCurrent: true
        },
        expected: {
          view: Em.I18n.t('dashboard.configHistory.info-bar.view.button.disabled'),
          compare: Em.I18n.t('dashboard.configHistory.info-bar.compare.button.disabled'),
          revert: Em.I18n.t('dashboard.configHistory.info-bar.revert.button.disabled')
        }
      }
    ];

    testCases.forEach(function(test) {
      it("isDisplayed = " + test.input.isDisplayed + ", isCurrent = " + test.input.isCurrent, function() {
        model.setProperties(test.input);
        expect(model.get('disabledActionMessages')).to.eql(test.expected);
      });
    });

  });

  describe("#disabledActionAttr", function() {
    var testCases = [
      {
        input: {
          isDisplayed: false,
          isCurrent: false,
          isDisabled: false
        },
        expected: {
          view: false,
          compare: false,
          revert: false
        }
      },
      {
        input: {
          isDisplayed: true,
          isCurrent: false,
          isDisabled: false
        },
        expected: {
          view: 'disabled',
          compare: 'disabled',
          revert: false
        }
      },
      {
        input: {
          isDisplayed: false,
          isCurrent: false,
          isDisabled: true
        },
        expected: {
          view: false,
          compare: 'disabled',
          revert: 'disabled'
        }
      },
      {
        input: {
          isDisplayed: false,
          isCurrent: true,
          isDisabled: false
        },
        expected: {
          view: false,
          compare: false,
          revert: 'disabled'
        }
      },
      {
        input: {
          isDisplayed: true,
          isCurrent: true,
          isDisabled: true
        },
        expected: {
          view: 'disabled',
          compare: 'disabled',
          revert: 'disabled'
        }
      }
    ];

    testCases.forEach(function(test) {
      it("isDisplayed = " + test.input.isDisplayed + ", isCurrent = " + test.input.isCurrent + ", isDisabled = " + test.input.isDisabled, function() {
        model.setProperties(test.input);
        expect(model.get('disabledActionAttr')).to.eql(test.expected);
      });
    });

  });

});

});

require.register("test/models/configs/stack_config_property_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var model;

function getModel() {
  return App.StackConfigProperty.createRecord();
}

describe('App.StackConfigProperty', function () {

  beforeEach(function () {
    model = getModel();
  });

  describe("#Attributes", function() {
    var testCases = [
      {
        propertyKey: 'type',
        propertyName: 'displayType',
        value: 't1',
        expectedValue: 't1',
        defaultValue: 'string'
      },
      {
        propertyKey: 'overridable',
        propertyName: 'isOverridable',
        value: false,
        expectedValue: false,
        defaultValue: true
      },
      {
        propertyKey: 'visible',
        propertyName: 'isVisible',
        value: false,
        expectedValue: false,
        defaultValue: true
      },
      {
        propertyKey: 'empty_value_valid',
        propertyName: 'isRequired',
        value: true,
        expectedValue: false,
        defaultValue: true
      },
      {
        propertyKey: 'editable_only_at_install',
        propertyName: 'isReconfigurable',
        value: true,
        expectedValue: false,
        defaultValue: true
      },
      {
        propertyKey: 'show_property_name',
        propertyName: 'showLabel',
        value: false,
        expectedValue: false,
        defaultValue: true
      },
      {
        propertyKey: 'read_only',
        propertyName: 'isEditable',
        value: false,
        expectedValue: false,
        defaultValue: true
      },
      {
        propertyKey: 'unit',
        propertyName: 'unit',
        value: 'mb',
        expectedValue: 'mb',
        defaultValue: ''
      }
    ];

    testCases.forEach(function(test) {

      it("valueAttributes is null, " + test.propertyName + " should be " + test.defaultValue, function() {
        model.set('valueAttributes', null);
        expect(model.get(test.propertyName)).to.equal(test.defaultValue);
      });

      it("valueAttributes is object, " + test.propertyName + " should be " + test.expectedValue, function() {
        var valueAttributes = {};
        valueAttributes[test.propertyKey] = test.value;
        model.set('valueAttributes', valueAttributes);
        expect(model.get(test.propertyName)).to.equal(test.expectedValue);
      });

    });
  });

  describe("#getAttribute()", function() {

    it("valueAttributes is null", function() {
      model.set('valueAttributes', null);
      expect(model.getAttribute('attr1', 'defVal')).to.equal('defVal');
    });

    it("valueAttributes is empty object", function() {
      model.set('valueAttributes', {});
      expect(model.getAttribute('attr1', 'defVal')).to.equal('defVal');
    });

    it("valueAttributes is correct object", function() {
      model.set('valueAttributes', {attr1: 'val'});
      expect(model.getAttribute('attr1', 'defVal')).to.equal('val');
    });

  });

});

});

require.register("test/models/configs/sub_section_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var model;

function getModel() {
  return App.SubSection.createRecord();
}

describe('App.SubSection', function () {

  beforeEach(function () {
    model = getModel();
  });

  App.TestAliases.testAsComputedAnd(getModel(), 'showTabs', ['hasTabs', 'someSubSectionTabIsVisible']);

  App.TestAliases.testAsComputedAnd(getModel(), 'addLeftVerticalSplitter', ['!isFirstColumn', 'leftVerticalSplitter']);

  App.TestAliases.testAsComputedAnd(getModel(), 'showTopSplitter', ['!isFirstRow', '!border']);

  App.TestAliases.testAsComputedAnd(getModel(), 'isSectionVisible', ['!isHiddenByFilter', '!isHiddenByConfig', 'someConfigIsVisible']);

  describe('#errorsCount', function () {

    beforeEach(function () {
      model.set('configs', [
        App.ServiceConfigProperty.create({isValid: true}),
        App.ServiceConfigProperty.create({isValid: false}),
        App.ServiceConfigProperty.create({isValid: false}),
        App.ServiceConfigProperty.create({isValid: false}),
      ]);
    });

    it('should use configs.@each.isValid', function () {
      expect(model.get('errorsCount')).to.equal(3);
    });

    it('should use configs.@each.isValidOverride', function() {
      // original value is valid
      var validOriginalSCP = model.get('configs').objectAt(0);
      // add override with not valid value
      validOriginalSCP.set('isValidOverride', false);
      validOriginalSCP.set('isValid', true);
      expect(model.get('errorsCount')).to.equal(3);
    });

  });

  describe('#isHiddenByFilter', function () {

    Em.A([
        {
          configs: [],
          e: false,
          m: 'Can\'t be hidden if there is no configs'
        },
        {
          configs: [Em.Object.create({isHiddenByFilter: true, isVisible: true}), Em.Object.create({isHiddenByFilter: true, isVisible: true})],
          e: true,
          m: 'All configs are hidden'
        },
        {
          configs: [Em.Object.create({isHiddenByFilter: false, isVisible: true}), Em.Object.create({isHiddenByFilter: true, isVisible: true})],
          e: false,
          m: 'Some configs are hidden'
        },
        {
          configs: [Em.Object.create({isHiddenByFilter: false, isVisible: true}), Em.Object.create({isHiddenByFilter: true, isVisible: true})],
          e: false,
          m: 'Some configs are hidden'
        },
        {
          configs: [Em.Object.create({isHiddenByFilter: false, isVisible: true}), Em.Object.create({isHiddenByFilter: false, isVisible: true})],
          e: false,
          m: 'No configs are hidden'
        }
    ]).forEach(function (test) {
        it(test.m, function () {
          model.set('configs', test.configs);
          expect(model.get('isHiddenByFilter')).to.equal(test.e);
        })
      });

  });

});

});

require.register("test/models/configs/theme/sub_section_tab_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/configs/theme/sub_section_tab');

describe('App.SubSectionTab', function () {

  var subSectionTab,
    getModel = function () {
      return App.SubSectionTab.createRecord();
    };

  beforeEach(function () {
    subSectionTab = getModel();
  });

  describe('#visibleProperties', function () {

    var configs = [
      Em.Object.create({
        id: 0,
        isVisible: false,
        hiddenBySection: false
      }),
      Em.Object.create({
        id: 1,
        isVisible: false,
        hiddenBySection: true
      }),
      Em.Object.create({
        id: 2,
        isVisible: true,
        hiddenBySection: false
      }),
      Em.Object.create({
        id: 3,
        isVisible: true,
        hiddenBySection: true
      }),
      Em.Object.create({
        id: 4,
        isVisible: false
      }),
      Em.Object.create({
        id: 5,
        isVisible: true
      })
    ];

    it('should include visible properties from visible sections only', function () {
      subSectionTab.set('configs', configs);
      expect(subSectionTab.get('visibleProperties').mapProperty('id')).to.eql([2, 5]);
    });

  });

  describe('#errorsCount', function () {

    var configs = [
      Em.Object.create({
        isVisible: true,
        isValid: true,
        isValidOverride: true
      }),
      Em.Object.create({
        isVisible: false,
        isValid: true,
        isValidOverride: true
      }),
      Em.Object.create({
        isVisible: true,
        isValid: true,
        isValidOverride: false
      }),
      Em.Object.create({
        isVisible: false,
        isValid: true,
        isValidOverride: false
      }),
      Em.Object.create({
        isVisible: true,
        isValid: false,
        isValidOverride: true
      }),
      Em.Object.create({
        isVisible: false,
        isValid: false,
        isValidOverride: true
      }),
      Em.Object.create({
        isVisible: true,
        isValid: false,
        isValidOverride: false
      }),
      Em.Object.create({
        isVisible: false,
        isValid: false,
        isValidOverride: false
      }),
      Em.Object.create({
        isVisible: true,
        isValid: true
      }),
      Em.Object.create({
        isVisible: false,
        isValid: true
      }),
      Em.Object.create({
        isVisible: true,
        isValid: false
      }),
      Em.Object.create({
        isVisible: false,
        isValid: false
      }),
      Em.Object.create({
        isVisible: true,
        isValidOverride: true
      }),
      Em.Object.create({
        isVisible: false,
        isValidOverride: true
      }),
      Em.Object.create({
        isVisible: true,
        isValidOverride: false
      }),
      Em.Object.create({
        isVisible: false,
        isValidOverride: false
      }),
      Em.Object.create({
        isVisible: true
      }),
      Em.Object.create({
        isVisible: false
      })
    ];

    it('should include visible properties with errors', function () {
      subSectionTab.set('configs', configs);
      expect(subSectionTab.get('errorsCount')).to.be.equal(8);
    });

  });

  describe('#isHiddenByFilter', function () {

    Em.A([
      {
        configs: [],
        e: false,
        m: 'Can\'t be hidden if there is no configs'
      },
      {
        configs: [Em.Object.create({isHiddenByFilter: true, isVisible: true}), Em.Object.create({isHiddenByFilter: true, isVisible: true})],
        e: true,
        m: 'All configs are hidden'
      },
      {
        configs: [Em.Object.create({isHiddenByFilter: false, isVisible: true}), Em.Object.create({isHiddenByFilter: true, isVisible: true})],
        e: false,
        m: 'Some configs are hidden'
      },
      {
        configs: [Em.Object.create({isHiddenByFilter: false, isVisible: true}), Em.Object.create({isHiddenByFilter: true, isVisible: true})],
        e: false,
        m: 'Some configs are hidden'
      },
      {
        configs: [Em.Object.create({isHiddenByFilter: false, isVisible: true}), Em.Object.create({isHiddenByFilter: false, isVisible: true})],
        e: false,
        m: 'No configs are hidden'
      }
    ]).forEach(function (test) {
      it(test.m, function () {
        subSectionTab.set('configs', test.configs);
        expect(subSectionTab.get('isHiddenByFilter')).to.equal(test.e);
      })
    });

  });});
});

require.register("test/models/configs/theme/tab_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

function getModel() {
  return App.Tab.createRecord();
}

describe('App.Tab', function () {

  App.TestAliases.testAsComputedSumBy(getModel(), 'errorsCount', 'sections', 'errorsCount');

  App.TestAliases.testAsComputedIfThenElse(getModel(), 'tooltipMsg', 'isHiddenByFilter', Em.I18n.t('services.service.config.nothing.to.display') , '');

});

});

require.register("test/models/finished_upgrade_entity_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/finished_upgrade_entity');

function getModel() {
  return App.finishedUpgradeEntity.create();
}

describe('App.finishedUpgradeEntity', function () {
  var model;

  beforeEach(function () {
    model = getModel();
  });

  App.TestAliases.testAsComputedNotEqual(getModel(), 'isVisible', 'status', 'PENDING');

  describe("#progress", function() {
    it("progress_percent = 1.9", function() {
      model.set('progress_percent', 1.9);
      model.propertyDidChange('progress');
      expect(model.get('progress')).to.equal(1);
    });
    it("progress_percent = 1", function() {
      model.set('progress_percent', 1);
      model.propertyDidChange('progress');
      expect(model.get('progress')).to.equal(1);
    });
  });

  describe("#isActive", function() {
    it("status IN_PROGRESS", function() {
      model.set('status', 'IN_PROGRESS');
      model.propertyDidChange('isActive');
      expect(model.get('isActive')).to.be.true;
    });
    it("status PENDING", function() {
      model.set('status', 'PENDING');
      model.propertyDidChange('isActive');
      expect(model.get('isActive')).to.be.false;
    });
  });

  describe('#isExpandableGroup', function () {

    var cases = [
      {
        input: {
          type: 'ITEM'
        },
        isExpandableGroup: false,
        title: 'not upgrade group'
      },
      {
        input: {
          type: 'GROUP',
          status: 'PENDING',
          hasExpandableItems: false
        },
        isExpandableGroup: false,
        title: 'pending upgrade group without expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'ABORTED',
          hasExpandableItems: false
        },
        isExpandableGroup: true,
        title: 'aborted upgrade group without expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'ABORTED',
          hasExpandableItems: true
        },
        isExpandableGroup: true,
        title: 'aborted upgrade group with expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'IN_PROGRESS',
          hasExpandableItems: false
        },
        isExpandableGroup: true,
        title: 'active upgrade group'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        model.setProperties(item.input);
        expect(model.get('isExpandableGroup')).to.equal(item.isExpandableGroup);
      });
    });

  });

  describe('#upgradeGroupStatus', function () {

    var cases = [
      {
        input: {
          type: 'ITEM',
          upgradeSuspended: false
        },
        upgradeGroupStatus: undefined,
        title: 'not upgrade group'
      },
      {
        input: {
          type: 'GROUP',
          status: 'PENDING',
          hasExpandableItems: false,
          upgradeSuspended: false
        },
        upgradeGroupStatus: 'PENDING',
        title: 'pending upgrade group'
      },
      {
        input: {
          type: 'GROUP',
          status: 'PENDING',
          hasExpandableItems: true,
          upgradeSuspended: false
        },
        upgradeGroupStatus: 'SUBITEM_FAILED',
        title: 'pending upgrade group with expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'ABORTED',
          hasExpandableItems: false,
          upgradeSuspended: false
        },
        upgradeGroupStatus: 'ABORTED',
        title: 'aborted upgrade group with expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'ABORTED',
          hasExpandableItems: true,
          upgradeSuspended: true
        },
        upgradeGroupStatus: 'ABORTED',
        title: 'aborted upgrade group with expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'IN_PROGRESS',
          hasExpandableItems: false,
          upgradeSuspended: false
        },
        upgradeGroupStatus: 'IN_PROGRESS',
        title: 'active upgrade'
      }
    ];

    beforeEach(function() {
      this.mock = sinon.stub(App, 'get');
    });
    afterEach(function() {
      this.mock.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        this.mock.returns(item.input.upgradeSuspended);
        model.setProperties(item.input);
        expect(model.get('upgradeGroupStatus')).to.equal(item.upgradeGroupStatus);
      });
    });

  });
});
});

require.register("test/models/form_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/form');

var form,
  field,
  formField,
  resultCases = [
    {
      text: Em.I18n.t('form.saveError'),
      result: -1
    },
    {
      text: Em.I18n.t('form.saveSuccess'),
      result: 1
    },
    {
      text: '',
      result: 0
    }
  ],
  hiddenCases = [
    {
      displayType: 'password',
      type: 'hidden',
      value: false
    },
    {
      displayType: 'hidden',
      type: 'hidden',
      value: true
    }
  ];


describe('App.Form', function () {

  beforeEach(function () {
    form = App.Form.create({
      fieldsOptions: [
        {
          name: 'field0',
          value: 'value0',
          isRequired: false
        }
      ]
    });
    field = form.get('fields').objectAt(0);
  });

  describe('#fields', function () {
    it('should get data from formFields', function () {
      var fields = form.get('fields');
      expect(fields).to.have.length(1);
      expect(field.get('name')).to.equal('field0');
    });
  });

  describe('#field', function () {
    it('should get data from formFields', function () {
      var field0 = form.get('field.field0');
      expect(form.get('field')).to.not.be.empty;
      expect(field0.get('name')).to.equal('field0');
      expect(field0.get('form')).to.eql(form);
    });
  });

  describe('#getField', function () {
    it('should get field0', function () {
      expect(form.getField('field0')).to.eql(form.get('field.field0'));
    });
    it('should be empty', function () {
      form.set('fields', []);
      expect(form.getField()).to.be.empty;
    });
  });

  describe('#isValid', function () {
    it('should be true', function () {
      field.set('isRequired', false);
      expect(form.isValid()).to.be.true;
    });
    it('should be false', function () {
      field.setProperties({
        isRequired: true,
        value: ''
      });
      expect(form.isValid()).to.be.false;
    });
  });

  describe('#updateValues', function () {
    it('should update field0 value', function () {
      form.set('object', Em.Object.create({field0: 'value0upd'}));
      expect(field.get('value')).to.equal('value0upd');
    });
    it('should empty password value', function () {
      field.set('displayType', 'password');
      form.set('object', Em.Object.create());
      expect(field.get('value')).to.be.empty;
    });
    it('should clear values', function () {
      form.set('object', []);
      expect(field.get('value')).to.be.empty;
    });
  });

  describe('#clearValues', function () {
    it('should clear values', function () {
      var field0 = form.get('fields').objectAt(0);
      field0.set('value', 'value0');
      form.clearValues();
      expect(field0.get('value')).to.be.empty;
    });
  });

  describe('#resultText', function () {
    resultCases.forEach(function (item) {
      it('should be ' + item.text, function () {
        form.set('result', item.result);
        expect(form.get('resultText')).to.equal(item.text);
      });
    });
  });

});

describe('App.FormField', function () {

  beforeEach(function () {
    formField = App.FormField.create();
  });

  describe('#isValid', function () {
    it('should be true', function () {
      expect(formField.get('isValid')).to.be.true;
    });
    it('should be false', function () {
      formField.set('errorMessage', 'error');
      expect(formField.get('isValid')).to.be.false;
    });
  });

  /*eslint-enable mocha-cleanup/asserts-limit */

  describe('#isHiddenField', function () {
    hiddenCases.forEach(function (item) {
      it('should be ' + item.value, function () {
        formField.setProperties(item);
        expect(formField.get('isHiddenField')).to.equal(item.value);
      });
    });
  });

});

});

require.register("test/models/host_component_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host_component');

describe('App.HostComponent', function() {

  App.store.safeLoad(App.HostComponent, {
    id: 'COMP_host',
    component_name: 'COMP1'
  });
  var hc = App.HostComponent.find('COMP_host');

  describe('#getStatusesList', function() {
    it('allowed statuses', function() {
      var statuses = ["STARTED","STARTING","INSTALLED","STOPPING","INSTALL_FAILED","INSTALLING","UPGRADE_FAILED","UNKNOWN","DISABLED","INIT"];
      expect(App.HostComponentStatus.getStatusesList()).to.include.members(statuses);
      expect(statuses).to.include.members(App.HostComponentStatus.getStatusesList());
    });
  });

  describe('#isClient', function() {

    beforeEach(function () {
      sinon.stub(App.get('components.clients'), 'contains', Em.K);
      hc.propertyDidChange('isClient');
      hc.get('isClient');
    });

    afterEach(function () {
      App.get('components.clients').contains.restore();
    });

    it('components.clients is called with correct data', function() {
      expect(App.get('components.clients').contains.calledWith('COMP1')).to.be.true;
    });
  });

  describe('#isMaster', function() {

    beforeEach(function () {
      sinon.stub(App.get('components.masters'), 'contains', Em.K);
      hc.propertyDidChange('isMaster');
      hc.get('isMaster');
    });

    afterEach(function () {
      App.get('components.masters').contains.restore();
    });

    it('components.masters is called with correct data', function() {
      expect(App.get('components.masters').contains.calledWith('COMP1')).to.be.true;
    });
  });

  describe('#isSlave', function() {

    beforeEach(function () {
      sinon.stub(App.get('components.slaves'), 'contains', Em.K);
      hc.propertyDidChange('isSlave');
      hc.get('isSlave');
    });

    afterEach(function () {
      App.get('components.slaves').contains.restore();
    });

    it('components.slaves is called with correct data', function() {
      expect(App.get('components.slaves').contains.calledWith('COMP1')).to.be.true;
    });
  });

  describe('#isDeletable', function() {

    beforeEach(function () {
      sinon.stub(App.get('components.deletable'), 'contains', Em.K);
      hc.propertyDidChange('isDeletable');
      hc.get('isDeletable');
    });

    afterEach(function () {
      App.get('components.deletable').contains.restore();
    });

    it('components.deletable is called with correct data', function() {
      expect(App.get('components.deletable').contains.calledWith('COMP1')).to.be.true;
    });
  });

  App.TestAliases.testAsComputedIfThenElse(hc, 'passiveTooltip', 'isActive', '', Em.I18n.t('hosts.component.passive.mode'));

  App.TestAliases.testAsComputedExistsIn(hc, 'isRunning', 'workStatus', ['STARTED', 'STARTING']);

  describe('#isDecommissioning', function() {
    var mock = [];
    beforeEach(function () {
      sinon.stub(App.HDFSService, 'find', function () {
        return mock;
      })
    });
    afterEach(function () {
      App.HDFSService.find.restore();
    });
    it('component name is not DATANODE', function() {
      hc.propertyDidChange('isDecommissioning');
      expect(hc.get('isDecommissioning')).to.be.false;
    });
    it('component name is DATANODE but no HDFS service', function() {
      hc.set('componentName', 'DATANODE');
      hc.propertyDidChange('isDecommissioning');
      expect(hc.get('isDecommissioning')).to.be.false;
    });
    it('HDFS has no decommission DataNodes', function() {
      hc.set('componentName', 'DATANODE');
      mock.push(Em.Object.create({
        decommissionDataNodes: []
      }));
      hc.propertyDidChange('isDecommissioning');
      expect(hc.get('isDecommissioning')).to.be.false;
    });
    it('HDFS has decommission DataNodes', function() {
      hc.set('componentName', 'DATANODE');
      hc.set('hostName', 'host1');
      mock.clear();
      mock.push(Em.Object.create({
        decommissionDataNodes: [{hostName: 'host1'}]
      }));
      hc.propertyDidChange('isDecommissioning');
      expect(hc.get('isDecommissioning')).to.be.true;
    });
  });

  App.TestAliases.testAsComputedEqual(hc, 'isActive', 'passiveState', 'OFF');

  App.TestAliases.testAsComputedIfThenElse(hc, 'passiveTooltip', 'isActive', '', Em.I18n.t('hosts.component.passive.mode'));

  describe('#isActive', function() {
    it('passiveState is ON', function() {
      hc.set('passiveState', "ON");
      hc.propertyDidChange('isActive');
      expect(hc.get('isActive')).to.be.false;
    });
    it('passiveState is OFF', function() {
      hc.set('passiveState', "OFF");
      hc.propertyDidChange('isActive');
      expect(hc.get('isActive')).to.be.true;
    });
  });

  describe('#statusClass', function() {
    it('isActive is false', function() {
      hc.reopen({
        isActive: false
      });
      hc.propertyDidChange('statusClass');
      expect(hc.get('statusClass')).to.equal('icon-medkit');
    });
    it('isActive is true', function() {
      var status = 'INSTALLED';
      hc.set('isActive', true);
      hc.set('workStatus', status);
      hc.propertyDidChange('statusClass');
      expect(hc.get('statusClass')).to.equal(status);
    });
  });

  App.TestAliases.testAsComputedGetByKey(hc, 'statusIconClass', 'statusIconClassMap', 'statusClass', {defaultValue: '', map: {
    STARTED: App.healthIconClassGreen,
    STARTING: App.healthIconClassGreen,
    INSTALLED: App.healthIconClassRed,
    STOPPING: App.healthIconClassRed,
    UNKNOWN: App.healthIconClassYellow
  }});

  describe('#componentTextStatus', function () {
    before(function () {
      sinon.stub(App.HostComponentStatus, 'getTextStatus', Em.K);
    });
    after(function () {
      App.HostComponentStatus.getTextStatus.restore();
    });
    it('componentTextStatus should be changed', function () {
      var status = 'INSTALLED';
      hc.set('workStatus', status);
      hc.propertyDidChange('componentTextStatus');
      hc.get('componentTextStatus');
      expect(App.HostComponentStatus.getTextStatus.calledWith(status)).to.be.true;
    });
  });

  describe("#getCount", function () {
    var testCases = [
      {
        t: 'unknown component',
        data: {
          componentName: 'CC',
          type: 'totalCount',
          stackComponent: Em.Object.create()
        },
        result: 0
      },
      {
        t: 'master component',
        data: {
          componentName: 'C1',
          type: 'totalCount',
          stackComponent: Em.Object.create({componentCategory: 'MASTER'})
        },
        result: 3
      },
      {
        t: 'slave component',
        data: {
          componentName: 'C1',
          type: 'installedCount',
          stackComponent: Em.Object.create({componentCategory: 'SLAVE'})
        },
        result: 4
      },
      {
        t: 'client component',
        data: {
          componentName: 'C1',
          type: 'startedCount',
          stackComponent: Em.Object.create({componentCategory: 'CLIENT'})
        },
        result: 5
      },
      {
        t: 'client component, unknown type',
        data: {
          componentName: 'C1',
          type: 'unknownCount',
          stackComponent: Em.Object.create({componentCategory: 'CLIENT'})
        },
        result: 0
      }
    ];

    beforeEach(function () {
      this.mock = sinon.stub(App.StackServiceComponent, 'find');
      sinon.stub(App.MasterComponent, 'find').returns(Em.Object.create({totalCount: 3}));
      sinon.stub(App.SlaveComponent, 'find').returns(Em.Object.create({installedCount: 4}));
      sinon.stub(App.ClientComponent, 'find').returns(Em.Object.create({startedCount: 5, unknownCount: null}));
    });
    afterEach(function () {
      this.mock.restore();
      App.MasterComponent.find.restore();
      App.SlaveComponent.find.restore();
      App.ClientComponent.find.restore();
    });

    testCases.forEach(function (test) {
      it(test.t, function () {
        this.mock.returns(test.data.stackComponent);
        expect(App.HostComponent.getCount(test.data.componentName, test.data.type)).to.equal(test.result);
      });
    });
  });

  App.TestAliases.testAsComputedExistsIn(hc, 'isNotInstalled', 'workStatus', ['INIT', 'INSTALL_FAILED']);

  describe("#getDisplayName",function(){
    var testCases = [
      {
        testName: 'for displayName of length < 19',
        displayName: 'abc',
        result: 'abc'
      },
      {
        testName:'for displayName of length = 19',
        displayName: '1234567890123456789',
        result: '1234567890123456789'
      },
      {
        testName:'for displayName of length > 19',
        displayName: '12345678901234567890',
        result: '1234567890123456...'
      }
    ];

    testCases.forEach(function(test){
      it(test.testName, function(){
        hc.set('displayName',test.displayName);
        expect(hc.get('getDisplayName')).to.equal(test.result);
      });
    });
  });

  describe("#getDisplayNameAdvanced",function(){
    var testCases = [
      {
        testName: 'for displayNameAdvanced of length < 19',
        displayNameAdvanced: 'abc',
        result: 'abc'
      },
      {
        testName:'for displayNameAdvanced of length = 19',
        displayNameAdvanced: '1234567890123456789',
        result: '1234567890123456789'
      },
      {
        testName:'for displayNameAdvanced of length > 19',
        displayNameAdvanced: '12345678901234567890',
        result: '1234567890123456...'
      }
    ];

    testCases.forEach(function(test){
      it(test.testName, function(){
        hc.set('displayNameAdvanced',test.displayNameAdvanced);
        expect(hc.get('getDisplayNameAdvanced')).to.equal(test.result);
      });
    });
  });


  App.TestAliases.testAsComputedTruncate(hc, 'serviceDisplayName', 'service.displayName', 14, 11);
  App.TestAliases.testAsComputedTruncate(hc, 'getDisplayName', 'displayName', 19, 16);
  App.TestAliases.testAsComputedTruncate(hc, 'getDisplayNameAdvanced', 'displayNameAdvanced', 19, 16);

  describe("#serviceDisplayName",function(){
    var testCases = [
      {
        testName: 'for service.displayName of length < 14',
        serviceDisplayName: 'abc',
        result: 'abc'
      },
      {
        testName:'for service.displayName of length = 14',
        serviceDisplayName: '12345678901234',
        result: '12345678901234'
      },
      {
        testName:'for service.displayName of length > 14',
        serviceDisplayName: '123456789012345',
        result: '12345678901...'
      }
    ];

    testCases.forEach(function(test){
      it(test.testName, function(){
        hc.set('service',Em.Object.create({displayName:test.serviceDisplayName}));
        expect(hc.get('serviceDisplayName')).to.equal(test.result);
      });
    });
  });
});

});

require.register("test/models/host_stack_version_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/host_stack_version');

describe('App.HostStackVersion', function () {

  describe("#displayStatus", function () {
    var testCases = [
      {
        status: 'OUT_OF_SYNC',
        result: Em.I18n.t('hosts.host.stackVersions.status.out_of_sync')
      },
      {
        status: 'INSTALLED',
        result: Em.I18n.t('hosts.host.stackVersions.status.installed')
      },
      {
        status: 'INSTALLING',
        result: Em.I18n.t('hosts.host.stackVersions.status.installing')
      },
      {
        status: 'INSTALL_FAILED',
        result: Em.I18n.t('hosts.host.stackVersions.status.install_failed')
      },
      {
        status: 'UPGRADE_FAILED',
        result: Em.I18n.t('hosts.host.stackVersions.status.upgrade_failed')
      },
      {
        status: 'UPGRADING',
        result: Em.I18n.t('hosts.host.stackVersions.status.upgrading')
      },
      {
        status: 'CURRENT',
        result: Em.I18n.t('hosts.host.stackVersions.status.current')
      },
      {
        status: 'ANY',
        result: 'Any'
      }
    ];
    afterEach(function () {
      App.HostStackVersion.find().clear();
    });
    testCases.forEach(function (test) {
      it('status is ' + test.status, function () {
        App.store.safeLoad(App.HostStackVersion, {
          id: 1,
          status: test.status
        });
        expect(App.HostStackVersion.find().objectAt(0).get('displayStatus')).to.equal(test.result);
      });
    }, this);
  });

  describe("#installEnabled", function () {
    var testCases = [
      {
        status: 'OUT_OF_SYNC',
        result: true
      },
      {
        status: 'INSTALLED',
        result: false
      },
      {
        status: 'INSTALLING',
        result: false
      },
      {
        status: 'INSTALL_FAILED',
        result: true
      },
      {
        status: '',
        result: false
      }
    ];
    afterEach(function () {
      App.HostStackVersion.find().clear();
    });
    testCases.forEach(function (test) {
      it('status is ' + test.status, function () {
        App.store.safeLoad(App.HostStackVersion, {
          id: 1,
          status: test.status
        });
        expect(App.HostStackVersion.find().objectAt(0).get('installEnabled')).to.equal(test.result);
      });
    }, this);
  });

  describe("#isCurrent", function () {
    afterEach(function () {
      App.HostStackVersion.find().clear();
    });
    it("status is CURRENT", function () {
      App.store.safeLoad(App.HostStackVersion, {
        id: 1,
        status: 'CURRENT'
      });
      expect(App.HostStackVersion.find(1).get('isCurrent')).to.be.true;
    });
    it("status is not CURRENT", function () {
      App.store.safeLoad(App.HostStackVersion, {
        id: 1,
        status: 'INSTALLED'
      });
      expect(App.HostStackVersion.find(1).get('isCurrent')).to.be.false;
    });
  });

  describe("#isInstalling", function () {
    afterEach(function () {
      App.HostStackVersion.find().clear();
    });
    it("status is INSTALLING", function () {
      App.store.safeLoad(App.HostStackVersion, {
        id: 1,
        status: 'INSTALLING'
      });
      expect(App.HostStackVersion.find(1).get('isInstalling')).to.be.true;
    });
    it("status is not INSTALLING", function () {
      App.store.safeLoad(App.HostStackVersion, {
        id: 1,
        status: 'INSTALLED'
      });
      expect(App.HostStackVersion.find(1).get('isInstalling')).to.be.false;
    });
  });
});

});

require.register("test/models/host_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var misc = require('utils/misc');

require('models/host');

describe('App.Host', function () {

  var data = [
    {
      id: 'host1',
      host_name: 'host1',
      memory: 200000,
      disk_total: 100.555,
      disk_free: 90.555,
      health_status: 'HEALTHY',
      last_heart_beat_time: (new Date()).getTime() - 18100000
    },
    {
      id: 'host2',
      host_name: 'host2',
      memory: 99999,
      disk_total: 90,
      disk_free: 90,
      health_status: 'HEALTHY',
      last_heart_beat_time: (new Date()).getTime() - 170000
    },
    {
      id: 'host3',
      host_name: 'host3',
      memory: 99999,
      disk_total: 99.999,
      disk_free: 0,
      health_status: 'UNKNOWN',
      last_heart_beat_time: (new Date()).getTime()
    }
  ];

  App.Host.reopen({
    hostComponents: []
  });

  App.store.loadMany(App.Host, data);

  var host1 = App.Host.find('host1');

  App.TestAliases.testAsComputedAlias(host1, 'componentsInPassiveStateCount', 'componentsInPassiveState.length', 'number');

  App.TestAliases.testAsComputedAlias(host1, 'componentsWithStaleConfigsCount', 'componentsWithStaleConfigs.length', 'number');

  App.TestAliases.testAsComputedAlias(host1, 'disksMounted', 'diskInfo.length', 'number');

  describe('#diskUsedFormatted', function () {

    it('host1 - 10GB ', function () {
      expect(host1.get('diskUsedFormatted')).to.equal('10GB');
    });
    it('host2 - 0GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('diskUsedFormatted')).to.equal('0GB');
    });
    it('host3 - 100GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('diskUsedFormatted')).to.equal('100GB');
    });
  });

  describe('#diskTotalFormatted', function () {

    it('host1 - 100.56GB ', function () {
      expect(host1.get('diskTotalFormatted')).to.equal('100.56GB');
    });
    it('host2 - 90GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('diskTotalFormatted')).to.equal('90GB');
    });
    it('host3 - 100GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('diskTotalFormatted')).to.equal('100GB');
    });
  });

  describe('#diskUsageFormatted', function () {

    it('host1 - 9.94% ', function () {
      expect(host1.get('diskUsageFormatted')).to.equal('9.94%');
    });
    it('host2 - 0%', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('diskUsageFormatted')).to.equal('0%');
    });
    it('host3 - 100%', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('diskUsageFormatted')).to.equal('100%');
    });
  });

  describe('#isNotHeartBeating', function () {
    it('host2 - false', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('isNotHeartBeating')).to.equal(false);
    });
    it('host3 - false', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('isNotHeartBeating')).to.equal(true);
    });
  });

  describe('#cpuUsage', function () {
    var testCases = [
      {
        params: {
          cpuSystem: undefined,
          cpuUser: undefined
        },
        result: 0
      },
      {
        params: {
          cpuSystem: 0,
          cpuUser: 0
        },
        result: 0
      },
      {
        params: {
          cpuSystem: 1,
          cpuUser: 0
        },
        result: 0
      },
      {
        params: {
          cpuSystem: 0,
          cpuUser: 1
        },
        result: 0
      },
      {
        params: {
          cpuSystem: 1,
          cpuUser: 1
        },
        result: 2
      }
    ];
    testCases.forEach(function (test) {
      it('cpuSystem - ' + test.params.cpuSystem + ', cpuUser - ' + test.params.cpuUser, function () {
        host1.set('cpuSystem', test.params.cpuSystem);
        host1.set('cpuUser', test.params.cpuUser);
        host1.propertyDidChange('cpuUsage');

        expect(host1.get('cpuUsage')).to.equal(test.result);
      });
    });
  });

  describe('#memoryUsage', function () {
    var testCases = [
      {
        params: {
          memFree: undefined,
          memTotal: undefined
        },
        result: 0
      },
      {
        params: {
          memFree: 0,
          memTotal: 0
        },
        result: 0
      },
      {
        params: {
          memFree: 1,
          memTotal: 0
        },
        result: 0
      },
      {
        params: {
          memFree: 0,
          memTotal: 1
        },
        result: 0
      },
      {
        params: {
          memFree: 1,
          memTotal: 2
        },
        result: 50
      }
    ];
    testCases.forEach(function (test) {
      it('memFree - ' + test.params.memFree + ', memTotal - ' + test.params.memTotal, function () {
        host1.set('memFree', test.params.memFree);
        host1.set('memTotal', test.params.memTotal);
        host1.propertyDidChange('memoryUsage');

        expect(host1.get('memoryUsage')).to.equal(test.result);
      });
    });
  });

  describe.skip('#componentsWithStaleConfigs', function () {
    it('One component with stale configs', function () {
      host1.set('hostComponents', [Em.Object.create({
        staleConfigs: true
      })]);
      host1.propertyDidChange('componentsWithStaleConfigs');
      expect(host1.get('componentsWithStaleConfigs')).to.eql([Em.Object.create({
        staleConfigs: true
      })]);
    });
    it('No components with stale configs', function () {
      host1.set('hostComponents', [Em.Object.create({
        staleConfigs: false
      })]);
      host1.propertyDidChange('componentsWithStaleConfigs');
      expect(host1.get('componentsWithStaleConfigs')).to.be.empty;
    });
  });

  describe.skip('#componentsInPassiveStateCount', function () {
    it('No component in passive state', function () {
      host1.set('hostComponents', [Em.Object.create({
        passiveState: 'OFF'
      })]);
      host1.propertyDidChange('componentsInPassiveStateCount');

      expect(host1.get('componentsInPassiveStateCount')).to.equal(0);
    });
    it('One component in passive state', function () {
      host1.set('hostComponents', [Em.Object.create({
        passiveState: 'ON'
      })]);
      host1.propertyDidChange('componentsInPassiveStateCount');

      expect(host1.get('componentsInPassiveStateCount')).to.equal(1);
    });
  });

  describe('#disksMounted', function () {
    it('depends on diskInfo count', function () {
      host1.set('diskInfo', [
        {}
      ]);
      host1.propertyDidChange('disksMounted');
      expect(host1.get('disksMounted')).to.equal(1);
    });
  });

  describe('#coresFormatted', function () {
    it('depends on cpu, cpuPhysical', function () {
      host1.set('cpu', 1);
      host1.set('cpuPhysical', 2);
      host1.propertyDidChange('coresFormatted');
      expect(host1.get('coresFormatted')).to.equal('1 (2)');
    });
  });

  describe('#diskUsed', function () {
    it('diskFree and diskTotal are 0', function () {
      host1.set('diskFree', 0);
      host1.set('diskTotal', 0);
      host1.propertyDidChange('diskUsed');
      expect(host1.get('diskUsed')).to.equal(0);
    });
    it('diskFree is 0 and diskTotal is 10', function () {
      host1.set('diskFree', 0);
      host1.set('diskTotal', 10);
      host1.propertyDidChange('diskUsed');
      expect(host1.get('diskUsed')).to.equal(10);
    });
  });

  describe('#diskUsage', function () {
    it('depends on diskTotal, diskUsed', function () {
      host1.reopen({
        diskUsed: 10
      });
      host1.set('diskTotal', 100);
      host1.propertyDidChange('diskUsage');
      expect(host1.get('diskUsage')).to.equal(10);
    });
  });

  describe('#memoryFormatted', function () {

    beforeEach(function () {
      sinon.stub(misc, 'formatBandwidth', Em.K);
    });

    afterEach(function () {
      misc.formatBandwidth.restore();
    });

    it('depends on memory', function () {
      host1.set('memory', 1024);
      host1.propertyDidChange('memoryFormatted');
      host1.get('memoryFormatted');
      expect(misc.formatBandwidth.calledWith(1048576)).to.be.true;
    });
  });

  describe('#loadAvg', function () {
    var testCases = [
      {
        params: {
          loadOne: null,
          loadFive: null,
          loadFifteen: null
        },
        result: null
      },
      {
        params: {
          loadOne: 1.111,
          loadFive: 5.555,
          loadFifteen: 15.555
        },
        result: '1.11'
      },
      {
        params: {
          loadOne: null,
          loadFive: 5.555,
          loadFifteen: 15.555
        },
        result: '5.55'
      },
      {
        params: {
          loadOne: null,
          loadFive: null,
          loadFifteen: 15.555
        },
        result: '15.55'
      }
    ];

    testCases.forEach(function (test) {
      it('loadOne - ' + test.params.loadOne + ', loadFive - ' + test.params.loadFive + ', loadFifteen - ' + test.params.loadFifteen, function () {
        host1.set('loadOne', test.params.loadOne);
        host1.set('loadFive', test.params.loadFive);
        host1.set('loadFifteen', test.params.loadFifteen);
        host1.propertyDidChange('loadAvg');
        expect(host1.get('loadAvg')).to.equal(test.result);
      });
    });
  });

  describe('#healthClass', function () {
    var testCases = [
      {
        params: {
          passiveState: 'ON',
          healthStatus: null
        },
        result: 'icon-medkit'
      },
      {
        params: {
          passiveState: 'OFF',
          healthStatus: 'UNKNOWN'
        },
        result: 'health-status-DEAD-YELLOW'
      },
      {
        params: {
          passiveState: 'OFF',
          healthStatus: 'HEALTHY'
        },
        result: 'health-status-LIVE'
      },
      {
        params: {
          passiveState: 'OFF',
          healthStatus: 'UNHEALTHY'
        },
        result: 'health-status-DEAD-RED'
      },
      {
        params: {
          passiveState: 'OFF',
          healthStatus: 'ALERT'
        },
        result: 'health-status-DEAD-ORANGE'
      },
      {
        params: {
          passiveState: 'OFF',
          healthStatus: null
        },
        result: 'health-status-DEAD-YELLOW'
      }
    ];

    testCases.forEach(function (test) {
      it('passiveState - ' + test.params.passiveState + ', healthStatus - ' + test.params.healthStatus, function () {
        host1.set('passiveState', test.params.passiveState);
        host1.set('healthStatus', test.params.healthStatus);
        host1.propertyDidChange('healthClass');
        expect(host1.get('healthClass')).to.equal(test.result);
      });
    });
  });

  App.TestAliases.testAsComputedGetByKey(host1, 'healthIconClass', 'healthIconClassMap', 'healthClass', {defaultValue: '', map: {
    'health-status-LIVE': App.healthIconClassGreen,
    'health-status-DEAD-RED': App.healthIconClassRed,
    'health-status-DEAD-YELLOW': App.healthIconClassYellow,
    'health-status-DEAD-ORANGE': App.healthIconClassOrange
  }});

});

});

require.register("test/models/hosts_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/hosts');

function getModel() {
  return App.HostInfo.create();
}

describe('App.HostInfo', function () {

  App.TestAliases.testAsComputedGetByKey(getModel(), 'bootStatusForDisplay', 'bootStatusForDisplayMap', 'bootStatus', {defaultValue: 'Registering', map: {PENDING: 'Preparing',
    REGISTERED: 'Success',
    FAILED: 'Failed',
    RUNNING: 'Installing',
    DONE: 'Registering',
    REGISTERING: 'Registering'}});

  App.TestAliases.testAsComputedGetByKey(getModel(), 'bootBarColor', 'bootBarColorMap', 'bootStatus', {defaultValue: 'progress-info', map: {
    REGISTERED: 'progress-success',
    FAILED: 'progress-danger',
    PENDING: 'progress-info',
    RUNNING: 'progress-info',
    DONE: 'progress-info',
    REGISTERING: 'progress-info'
  }});

  App.TestAliases.testAsComputedGetByKey(getModel(), 'bootStatusColor', 'bootStatusColorMap', 'bootStatus', {defaultValue: 'text-info', map: {
    REGISTERED: 'text-success',
    FAILED: 'text-error',
    PENDING: 'text-info',
    RUNNING: 'text-info',
    DONE: 'text-info',
    REGISTERING: 'text-info'
  }});

  App.TestAliases.testAsComputedExistsIn(getModel(), 'isBootDone', 'bootStatus', ['REGISTERED', 'FAILED']);

});

});

require.register("test/models/master_component_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/master_component');

describe('App.MasterComponent', function () {

  var masterComponent;

  beforeEach(function () {
    masterComponent = App.MasterComponent.createRecord();
  });

  describe('#displayNamePluralized', function () {

    var cases = [
      {
        startedCount: 1,
        displayNamePluralized: 'Zookeeper Server',
        title: 'singular'
      },
      {
        startedCount: 2,
        displayNamePluralized: 'Zookeeper Servers',
        title: 'plural'
      }
    ];

    cases.forEach(function (item) {

      it(item.title, function () {
        masterComponent.setProperties({
          displayName: 'Zookeeper Server',
          startedCount: item.startedCount
        });
        expect(masterComponent.get('displayNamePluralized')).to.equal(item.displayNamePluralized);
      });

    });

  });

});
});

require.register("test/models/operating_system_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/operating_system');

describe('App.OperatingSystem', function () {

  var os;

  beforeEach(function () {
    os = App.OperatingSystem.createRecord();
  });

  describe('#isDeselected', function () {

    it('should be opposite to isSelected', function () {
      os.set('isSelected', true);
      expect(os.get('isDeselected')).to.be.false;
      os.set('isSelected', false);
      expect(os.get('isDeselected')).to.be.true;
    });

  });

});

});

require.register("test/models/rack_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/host');
require('models/rack');

describe('App.Rack', function () {

  var data = {
    id: 'rack1',
    name: 'rack1'
  };

  App.store.safeLoad(App.Rack, data);

  describe('#liveHostsCount', function () {

    it('rack1 has two live hosts', function () {
      var rack = App.Rack.find().findProperty('name', 'rack1');
      expect(rack.get('liveHostsCount')).to.equal(2);
    });

    it('rack1 has three live hosts', function () {
      App.store.safeLoad(App.Host, {
        id: 'host3',
        host_name: 'host3',
        health_status: 'HEALTHY'
      });
      var rack = App.Rack.find().findProperty('name', 'rack1');
      rack.set('name', 'rack1');
      expect(rack.get('liveHostsCount')).to.equal(3);
    });
  });


});

});

require.register("test/models/repository_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/repository');

function getModel() {
  return App.Repository.createRecord();
}

describe('App.Repository', function () {

  var model;

  beforeEach(function () {
    model = getModel();
  });

  App.TestAliases.testAsComputedNotEqualProperties(getModel(), 'undo', 'baseUrl', 'baseUrlInit');

  App.TestAliases.testAsComputedAlias(getModel(), 'isSelected', 'operatingSystem.isSelected', 'boolean');

  App.TestAliases.testAsComputedAlias(getModel(), 'clearAll', 'baseUrl', 'string'); // string??

  describe('#invalidFormatError', function () {

    var cases = [
      {
        baseUrl: 'http://domain-name_0.com/path/subpath?p0=v0&p1=v1@v2.v3#!~hash0,(hash1)+hash2[hash3]/*;hash_4%2F',
        invalidFormatError: false,
        title: 'valid http url'
      },
      {
        baseUrl: 'https://domain.com/path?p=v',
        invalidFormatError: false,
        title: 'valid https url'
      },
      {
        baseUrl: 'ftp://domain.com:123',
        invalidFormatError: false,
        title: 'valid ftp url'
      },
      {
        baseUrl: 'ftp://user_:password0@domain.com',
        invalidFormatError: false,
        title: 'valid ftp url with authorization'
      },
      {
        baseUrl: 'ftp://user :password/@domain.com',
        invalidFormatError: true,
        title: 'ftp url with disallowed characters'
      },
      {
        baseUrl: 'http://domain.com:/path',
        invalidFormatError: true,
        title: 'no port specified when expected'
      },
      {
        baseUrl: 'file://etc/file.repo',
        invalidFormatError: false,
        title: 'valid Unix file url'
      },
      {
        baseUrl: 'file:///etc/file.repo',
        invalidFormatError: false,
        title: 'valid Unix file url (3 slashes)'
      },
      {
        baseUrl: 'file://c:/file.repo',
        invalidFormatError: false,
        title: 'valid Windows file url'
      },
      {
        baseUrl: 'file:///c:/file.repo',
        invalidFormatError: false,
        title: 'valid Windows file url (3 slashes)'
      },
      {
        baseUrl: 'file://c|/file.repo',
        invalidFormatError: false,
        title: 'valid Windows file url (| separator)'
      },
      {
        baseUrl: 'file://C:/file.repo',
        invalidFormatError: false,
        title: 'valid Windows file url (capital drive char)'
      },
      {
        baseUrl: 'file://etc /file.repo',
        invalidFormatError: true,
        title: 'file url with disallowed characters'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        model.set('baseUrl', item.baseUrl);
        expect(model.get('invalidFormatError')).to.equal(item.invalidFormatError);
      });
    });

  });

});

});

require.register("test/models/root_service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/root_service');

var roleMock = function (str, flag) {
  return flag ? str.toLowerCase() : str.toCapital();
};

describe('App.RootService', function () {

  var rootService;

  beforeEach(function () {
    rootService = App.RootService.createRecord();
  });

  describe('#displayName', function () {

    beforeEach(function () {
      sinon.stub(App.format, 'role', roleMock);
    });

    afterEach(function () {
      App.format.role.restore();
    });

    it('should format service name', function () {
      rootService.set('serviceName', 'HDFS');
      expect(rootService.get('displayName')).to.equal('hdfs');
    });

  });

});

describe('App.RootServiceComponents', function () {

  var rootServiceComponents;

  beforeEach(function () {
    rootServiceComponents = App.RootServiceComponents.createRecord();
  });

  describe('#displayName', function () {

    beforeEach(function () {
      sinon.stub(App.format, 'role', roleMock);
    });

    afterEach(function () {
      App.format.role.restore();
    });

    it('should format component name', function () {
      rootServiceComponents.set('componentName', 'DATANODE');
      expect(rootServiceComponents.get('displayName')).to.equal('Datanode');
    });

  });

});
});

require.register("test/models/service/flume_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/service/flume');

var flumeAgent,
  flumeAgentData = {
    id: 'agent',
    name: 'agent'
  };

function getModel() {
  return App.FlumeAgent.createRecord();
}

describe('App.FlumeAgent', function () {

  beforeEach(function () {
    flumeAgent = App.FlumeAgent.createRecord(flumeAgentData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(flumeAgent);
  });

  App.TestAliases.testAsComputedGetByKey(getModel(), 'healthClass', 'healthClassMap', 'status', {defaultValue: App.healthIconClassYellow, map: {
    RUNNING: App.healthIconClassGreen,
    NOT_RUNNING: App.healthIconClassRed,
    UNKNOWN: App.healthIconClassYellow
  }});

  App.TestAliases.testAsComputedGetByKey(getModel(), 'displayStatus', 'displayStatusMap', 'status', {defaultValue: Em.I18n.t('common.unknown'), map: {
    RUNNING: Em.I18n.t('common.running'),
    NOT_RUNNING: Em.I18n.t('common.stopped'),
    UNKNOWN: Em.I18n.t('common.unknown')
  }});

});

});

require.register("test/models/service/hdfs_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * License); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/service/hdfs');

describe('App.HDFSService', function () {

    describe('#isNnHaEnabled', function () {
      var record = App.HDFSService.createRecord({
        id: 'hdfs'
      });
      it('ha disabled', function () {
        record.reopen({
          hostComponents: [Em.Object.create({componentName: 'NAMENODE'})],
          snameNode: true
        });
        record.propertyDidChange('isNnHaEnabled');
        expect(record.get('isNnHaEnabled')).to.be.false;
      });
      it('ha enabled', function () {
        record.setProperties({
          hostComponents: [
            Em.Object.create({componentName: 'NAMENODE'}),
            Em.Object.create({componentName: 'NAMENODE'})
          ],
          snameNode: null
        });
        record.propertyDidChange('isNnHaEnabled');
        expect(record.get('isNnHaEnabled')).to.be.true;
      });
    });


});

});

require.register("test/models/service/yarn_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * License); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/service/yarn');

var yarnService,
  yarnServiceData = {
    id: 'yarn'
  },
  configs = [
    {
      properties: {
        'yarn.timeline-service.webapp.address': '0.0.0.0:0000'
      },
      tag: 'version2',
      type: 'yarn-site'
    }
  ];

describe('App.YARNService', function () {

  beforeEach(function () {
    yarnService = App.YARNService.createRecord(yarnServiceData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(yarnService);
  });

  describe('#ahsWebPort', function () {

    afterEach(function () {
      App.db.setConfigs([]);
    });

    it('should be 8188 as default', function () {
      App.db.setConfigs([]);
      expect(yarnService.get('ahsWebPort')).to.equal('8188');
    });

    it('should get value from configs', function () {
      App.db.setConfigs(configs);
      expect(yarnService.get('ahsWebPort')).to.equal('0000');
    });

  });

  describe('#queueFormatted', function () {
    it('should return formatted string', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('queueFormatted')).to.equal('default (/root)<br/>');
    });
  });

  describe('#queuesCount', function () {
    it('should be 1', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('queuesCount')).to.equal(1);
    });
  });

  describe('#maxMemory', function () {
    it('should add availableMemory to allocatedMemory', function () {
      yarnService.set('allocatedMemory', 1024);
      yarnService.set('availableMemory', 2048);
      expect(yarnService.get('maxMemory')).to.equal(3072);
    });
  });

  describe('#allQueueNames', function () {
    it('should list all queue names as array', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('allQueueNames')).to.eql(['root', 'root/default']);
    });
  });

  describe('#childQueueNames', function () {
    it('should list child queue names as array', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('childQueueNames')).to.eql(['root/default']);
    });
  });
/*
  describe('#nodeManagersCountLost', function () {
    nodeCountCases.forEach(function (item) {
      it('should be ' + item.nodeManagersCountLost, function () {
        setHostComponents();
        for (var prop in item.assets) {
          yarnService.set(prop, item.assets[prop]);
        };
        expect(yarnService.get('nodeManagersCountLost')).to.equal(item.nodeManagersCountLost);
      });
    });
  });
*/
});

});

require.register("test/models/service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/service');

var service,
  serviceData = {
    id: 'service'
  },
  statusPropertiesCases = [
    {
      status: 'INSTALLED',
      property: 'isStopped'
    },
    {
      status: 'STARTED',
      property: 'isStarted'
    }
  ],
  hostComponentsDataFalse = [
    [],
    [
      {
        staleConfigs: false
      }
    ],
    [
      {
        service: {
          serviceName: 'HIVE'
        },
        staleConfigs: false
      }
    ]
  ],
  hostComponentsDataTrue = [
    [
      Em.Object.create({
        service: {
          serviceName: 'HDFS'
        },
        staleConfigs: true,
        displayName: 'service0'
      })
    ],
    [
      Em.Object.create({
        host: {
          publicHostName: 'host0'
        },
        service: {
          serviceName: 'HDFS'
        },
        staleConfigs: true,
        displayName: 'service1'
      })
    ]
  ],
  restartData = {
    host0: ['service0', 'service1']
};

function getModel() {
  return App.Service.createRecord(serviceData);
}

describe('App.Service', function () {

  beforeEach(function () {
    service = App.Service.createRecord(serviceData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(service);
  });

  describe('#isInPassive', function () {
    it('should be true', function () {
      service.set('passiveState', 'ON');
      expect(service.get('isInPassive')).to.be.true;
    });
    it('should be false', function () {
      service.set('passiveState', 'OFF');
      expect(service.get('isInPassive')).to.be.false;
    });
  });

  App.TestAliases.testAsComputedGetByKey(getModel(), 'healthStatus', 'healthStatusMap', 'workStatus', {defaultValue: 'yellow', map: {
    STARTED: 'green',
    STARTING: 'green-blinking',
    INSTALLED: 'red',
    STOPPING: 'red-blinking',
    UNKNOWN: 'yellow'
  }});

  statusPropertiesCases.forEach(function (item) {
    var status = item.status,
      property = item.property;
    describe('#' + property, function () {
      it('status ' + status + ' is for ' + property, function () {
        service.set('workStatus', status);
        expect(service.get(property)).to.be.true;
        var falseStates = statusPropertiesCases.mapProperty('property').without(property);
        var falseStatuses = [];
        falseStates.forEach(function (state) {
          falseStatuses.push(service.get(state));
        });
        expect(falseStatuses).to.eql([false]);
      });
    });
  });

  describe('#isRestartRequired', function () {

    beforeEach(function () {
      service.reopen({
        serviceName: 'HDFS',
        clientComponents: [],
        slaveComponents: [],
        masterComponents: []
      });
    });
    it('should be false when no component has stale configs', function () {
      expect(service.get('isRestartRequired')).to.be.false;
    });
    it('should be true when clientComponents has stale configs', function () {
      service.set('clientComponents', [Em.Object.create({staleConfigHosts: ['host1']})]);
      expect(service.get('isRestartRequired')).to.be.true;
    });
    it('should be true when slaveComponents has stale configs', function () {
      service.set('slaveComponents', [Em.Object.create({staleConfigHosts: ['host1']})]);
      expect(service.get('isRestartRequired')).to.be.true;
    });
    it('should be true when masterComponents has stale configs', function () {
      service.set('masterComponents', [Em.Object.create({staleConfigHosts: ['host1']})]);
      expect(service.get('isRestartRequired')).to.be.true;
    });
  });

  describe('#restartRequiredMessage', function () {
    it('should form message for 2 services on 1 host', function () {
      service.set('restartRequiredHostsAndComponents', restartData);
      expect(service.get('restartRequiredMessage')).to.contain('host0');
      expect(service.get('restartRequiredMessage')).to.contain('service0');
      expect(service.get('restartRequiredMessage')).to.contain('service1');
    });
  });

  describe('#serviceTypes', function () {
    var testCases = [
      {
        serviceName: 'PIG',
        result: []
      },
      {
        serviceName: 'GANGLIA',
        result: ['MONITORING']
      },
      {
        serviceName: 'HDFS',
        result: ['HA_MODE']
      },
      {
        serviceName: 'YARN',
        result: ['HA_MODE']
      }
    ];
    testCases.forEach(function (test) {
      it('service name - ' + test.serviceName, function () {
        service.set('serviceName', test.serviceName);
        service.propertyDidChange('serviceTypes');
        expect(service.get('serviceTypes')).to.eql(test.result);
      });
    });
  });

  describe('#allowToDelete', function () {

    beforeEach(function () {
      this.stub = sinon.stub(service, 'get');
    });

    afterEach(function () {
      this.stub.restore();
    });

    Em.A([
      {
        m: 'may be deleted (1)',
        slaveComponents: [{allowToDelete: true}],
        masterComponents: [{allowToDelete: true}],
        workStatus: 'INIT',
        e: true
      },
      {
        m: 'may be deleted (2)',
        slaveComponents: [{allowToDelete: true}],
        masterComponents: [{allowToDelete: true}],
        workStatus: 'INSTALL_FAILED',
        e: true
      },
      {
        m: 'may be deleted (3)',
        slaveComponents: [{allowToDelete: true}],
        masterComponents: [{allowToDelete: true}],
        workStatus: 'INSTALLED',
        e: true
      },
      {
        m: 'may be deleted (4)',
        slaveComponents: [{allowToDelete: true}],
        masterComponents: [{allowToDelete: true}],
        workStatus: 'UNKNOWN',
        e: true
      },
      {
        m: 'deleting is not allowed (1)',
        slaveComponents: [{allowToDelete: false}],
        masterComponents: [{allowToDelete: true}],
        workStatus: 'UNKNOWN',
        e: false
      },
      {
        m: 'deleting is not allowed (2)',
        slaveComponents: [{allowToDelete: false}],
        masterComponents: [{allowToDelete: false}],
        workStatus: 'UNKNOWN',
        e: false
      },
      {
        m: 'deleting is not allowed (3)',
        slaveComponents: [{allowToDelete: true}],
        masterComponents: [{allowToDelete: false}],
        workStatus: 'UNKNOWN',
        e: false
      },
      {
        m: 'deleting is not allowed (4)',
        slaveComponents: [{allowToDelete: true}],
        masterComponents: [{allowToDelete: true}],
        workStatus: 'STARTED',
        e: false
      }
    ]).forEach(function (test) {
      it(test.m, function () {
        this.stub.withArgs('workStatus').returns(test.workStatus);
        this.stub.withArgs('slaveComponents').returns(test.slaveComponents);
        this.stub.withArgs('masterComponents').returns(test.masterComponents);
        expect(Em.get(service, 'allowToDelete')).to.be.equal(test.e);
      });
    });

  });

});

});

require.register("test/models/slave_component_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/slave_component');

describe('App.SlaveComponent', function () {

  var slaveComponent;

  beforeEach(function () {
    slaveComponent = App.SlaveComponent.createRecord();
  });

  describe('#displayNamePluralized', function () {

    var cases = [
      {
        startedCount: 1,
        displayNamePluralized: 'DataNode',
        title: 'singular'
      },
      {
        startedCount: 2,
        displayNamePluralized: 'DataNodes',
        title: 'plural'
      }
    ];

    cases.forEach(function (item) {

      it(item.title, function () {
        slaveComponent.setProperties({
          displayName: 'DataNode',
          startedCount: item.startedCount
        });
        expect(slaveComponent.get('displayNamePluralized')).to.equal(item.displayNamePluralized);
      });

    });

  });

});
});

require.register("test/models/stack_service_component_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/stack_service_component');

/**

  Component properties template:

  {
    componentName: 'SUPERVISOR',
    expected: {
      displayName: 'Supervisor',
      minToInstall: 1,
      maxToInstall: Infinity,
      isRequired: true,
      isMultipleAllowed: true,
      isSlave: true,
      isMaster: false,
      isClient: false,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: false,
      isShownOnInstallerSlaveClientPage: true,
      isShownOnAddServiceAssignMasterPage: false,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      defaultNoOfMasterHosts: 1,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false,
      selectionSchemeForMasterComponent: {"else": 0}
    }
  }

**/
var componentPropertiesValidationTests = [
  {
    componentName: 'SUPERVISOR',
    expected: {
      displayName: 'Supervisor',
      minToInstall: 1,
      maxToInstall: Infinity,
      isRequired: true,
      isMultipleAllowed: true,
      isSlave: true,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: true,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerSlaveClientPage: true,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'ZOOKEEPER_SERVER',
    expected: {
      minToInstall: 1,
      maxToInstall: Infinity,
      isRequired: true,
      isMultipleAllowed: true,
      isMaster: true,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: false,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: true,
      isShownOnInstallerSlaveClientPage: false,
      isShownOnAddServiceAssignMasterPage: true,
      isMasterWithMultipleInstances: true,
      isMasterAddableInstallerWizard: true,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      defaultNoOfMasterHosts: 3,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'APP_TIMELINE_SERVER',
    expected: {
      displayName: 'App Timeline Server',
      minToInstall: 0,
      maxToInstall: 1,
      isRequired: false,
      isMultipleAllowed: false,
      isSlave: false,
      isMaster: true,
      isRestartable: true,
      isReassignable: true,
      isDeletable: false,
      isRollinRestartAllowed: false,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: false,
      isShownOnInstallerAssignMasterPage: true,
      isShownOnInstallerSlaveClientPage: false,
      isShownOnAddServiceAssignMasterPage: true,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'GANGLIA_MONITOR',
    expected: {
      displayName: 'Ganglia Monitor',
      minToInstall: Infinity,
      maxToInstall: Infinity,
      isRequired: true,
      isMultipleAllowed: true,
      isSlave: true,
      isMaster: false,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: false,
      isShownOnInstallerSlaveClientPage: false,
      isShownOnAddServiceAssignMasterPage: false,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: true,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'FLUME_HANDLER',
    expected: {
      displayName: 'Flume',
      minToInstall: 0,
      maxToInstall: Infinity,
      isRequired: false,
      isMultipleAllowed: true,
      isSlave: true,
      isMaster: false,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: true,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: false,
      isShownOnInstallerSlaveClientPage: true,
      isShownOnAddServiceAssignMasterPage: false,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'HIVE_METASTORE',
    expected: {
      displayName: 'Hive Metastore',
      minToInstall: 1,
      maxToInstall: 1,
      isRequired: true,
      isMultipleAllowed: false,
      isSlave: false,
      isMaster: true,
      isRestartable: true,
      isReassignable: true,
      isDeletable: true,
      isRollinRestartAllowed: false,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: true,
      isShownOnInstallerSlaveClientPage: false,
      isShownOnAddServiceAssignMasterPage: true,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'HIVE_SERVER',
    expected: {
      displayName: 'HiveServer2',
      minToInstall: 1,
      maxToInstall: 1,
      isRequired: true,
      isMultipleAllowed: false,
      isSlave: false,
      isMaster: true,
      isRestartable: true,
      isReassignable: true,
      isDeletable: true,
      isRollinRestartAllowed: false,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: true,
      isShownOnInstallerSlaveClientPage: false,
      isShownOnAddServiceAssignMasterPage: true,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      coHostedComponents: ['WEBHCAT_SERVER'],
      isOtherComponentCoHosted: true,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'DATANODE',
    expected: {
      displayName: 'DataNode',
      minToInstall: 1,
      maxToInstall: Infinity,
      isRequired: true,
      isMultipleAllowed: true,
      isSlave: true,
      isMaster: false,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: true,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: false,
      isShownOnInstallerSlaveClientPage: true,
      isShownOnAddServiceAssignMasterPage: false,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'POSTGRESQL_SERVER',
    expected: {
      isShownOnInstallerAssignMasterPage: false
    }
  },
  {
    componentName: 'MYSQL_SERVER',
    expected: {
      isShownOnInstallerAssignMasterPage: false,
      isDeletable: true
    }
  }
];

describe('App.StackServiceComponent', function() {
  before(function() {
    modelSetup.setupStackServiceComponent();
  });

  App.TestAliases.testAsComputedAnd(App.StackServiceComponent.createRecord(), 'isMasterAddableInstallerWizard', ['isMaster', 'isMultipleAllowed', '!isMasterAddableOnlyOnHA', '!isNotAddableOnlyInInstall']);

  describe('component properties validation', function() {
    componentPropertiesValidationTests.forEach(function(test) {
      describe('properties validation for ' + test.componentName + ' component', function() {
        var component = App.StackServiceComponent.find(test.componentName);
        var properties = Em.keys(test.expected);
        properties.forEach(function(property) {
          it('#{0} should be {1}'.format(property, JSON.stringify(test.expected[property])), function() {
            expect(component.get(property)).to.be.eql(test.expected[property]);
          })
        });
      });
    });
  });

  describe('#isMasterAddableOnlyOnHA', function () {

    var cases = [
      {
        componentName: 'NAMENODE',
        isMasterAddableOnlyOnHA: true
      },
      {
        componentName: 'RESOURCEMANAGER',
        isMasterAddableOnlyOnHA: true
      },
      {
        componentName: 'RANGER_ADMIN',
        isMasterAddableOnlyOnHA: true
      },
      {
        componentName: 'OOZIE_SERVER',
        isMasterAddableOnlyOnHA: false
      }
    ];

    cases.forEach(function (item) {
      it(item.componentName, function () {
        expect(App.StackServiceComponent.find().findProperty('componentName', item.componentName).get('isMasterAddableOnlyOnHA')).to.equal(item.isMasterAddableOnlyOnHA);
      });
    });

  });

  describe('#isNotAddableOnlyInInstall', function () {

    var cases = [
      {
        componentName: 'HIVE_METASTORE',
        isNotAddableOnlyInInstall: true
      },
      {
        componentName: 'HIVE_SERVER',
        isNotAddableOnlyInInstall: true
      },
      {
        componentName: 'RANGER_KMS_SERVER',
        isNotAddableOnlyInInstall: true
      },
      {
        componentName: 'OOZIE_SERVER',
        isNotAddableOnlyInInstall: true
      },
      {
        componentName: 'NAMENODE',
        isNotAddableOnlyInInstall: false
      }
    ];

    cases.forEach(function (item) {
      it(item.componentName, function () {
        expect(App.StackServiceComponent.find().findProperty('componentName', item.componentName).get('isNotAddableOnlyInInstall')).to.equal(item.isNotAddableOnlyInInstall);
      });
    });

  });

  after(function() {
    modelSetup.cleanStackServiceComponent();
  });
});

});

require.register("test/models/stack_service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/stack_service');

describe('App.StackService', function () {

  App.store.safeLoad(App.StackService, {
    id: 'S1'
  });

  var ss = App.StackService.find('S1');
  ss.reopen({
    serviceComponents: []
  });

  describe('#isDFS', function () {
    it('service name is "SERVICE"', function () {
      ss.set('serviceName', 'SERVICE');
      ss.propertyDidChange('isDFS');
      expect(ss.get('isDFS')).to.be.false;
    });
    it('service name is "HDFS"', function () {
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('isDFS');
      expect(ss.get('isDFS')).to.be.true;
    });
    it('service name is "GLUSTERFS"', function () {
      ss.set('serviceName', 'GLUSTERFS');
      ss.propertyDidChange('isDFS');
      expect(ss.get('isDFS')).to.be.true;
    });
  });

  describe('#isPrimaryDFS', function () {
    it('service name is "SERVICE"', function () {
      ss.set('serviceName', 'SERVICE');
      ss.propertyDidChange('isPrimaryDFS');
      expect(ss.get('isPrimaryDFS')).to.be.false;
    });
    it('service name is "HDFS"', function () {
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('isPrimaryDFS');
      expect(ss.get('isPrimaryDFS')).to.be.true;
    });
  });

  describe('#configTypesRendered', function () {
    ss.set('configTypes', {
      'core-site': {},
      'hdfs-site': {},
      'oozie-site': {}
    });
    it('service name is "SERVICE"', function () {
      ss.set('serviceName', 'SERVICE');
      ss.propertyDidChange('configTypesRendered');
      expect(ss.get('configTypesRendered')).to.eql({'core-site': {},'hdfs-site': {}, 'oozie-site': {}});
    });
    it('service name is "GLUSTERFS"', function () {
      ss.set('serviceName', 'GLUSTERFS');
      ss.propertyDidChange('configTypesRendered');
      expect(ss.get('configTypesRendered')).to.eql({'core-site': {},'hdfs-site': {}, 'oozie-site': {}});
    });
    it('service name is "HDFS"', function () {
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('configTypesRendered');
      expect(ss.get('configTypesRendered')).to.eql({'core-site': {}, 'hdfs-site': {}, 'oozie-site': {}});
    });
    it('service name is "FALCON"', function () {
      ss.set('serviceName', 'FALCON');
      ss.propertyDidChange('configTypesRendered');
      expect(ss.get('configTypesRendered')).to.eql({'core-site': {}, 'hdfs-site': {}});
    });
  });

  describe('#displayNameOnSelectServicePage', function () {
    it('No coSelectedServices', function () {
      ss.set('serviceName', 'HDFS');
      ss.set('displayName', 'HDFS');
      ss.propertyDidChange('displayNameOnSelectServicePage');
      expect(ss.get('displayNameOnSelectServicePage')).to.equal('HDFS');
    });
    it('Present coSelectedServices', function () {
      ss.set('serviceName', 'YARN');
      ss.set('displayName', 'YARN');
      ss.propertyDidChange('displayNameOnSelectServicePage');
      expect(ss.get('displayNameOnSelectServicePage')).to.equal('YARN + MapReduce2');
    });
  });

  describe('#isHiddenOnSelectServicePage', function () {
    var testCases = [
      {
        serviceName: 'HDFS',
        isInstallable: true,
        result: false
      },
      {
        serviceName: 'MAPREDUCE2',
        isInstallable: true,
        result: true
      },
      {
        serviceName: 'KERBEROS',
        isInstallable: false,
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it('service name - ' + test.serviceName, function () {
        ss.set('serviceName', test.serviceName);
        ss.set('isInstallable', test.isInstallable);
        ss.propertyDidChange('isHiddenOnSelectServicePage');
        expect(ss.get('isHiddenOnSelectServicePage')).to.equal(test.result);
      });
    });
  });

  describe('#isMonitoringService', function () {
    var testCases = [
      {
        serviceName: 'HDFS',
        result: false
      },
      {
        serviceName: 'GANGLIA',
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it('service name - ' + test.serviceName, function () {
        ss.set('serviceName', test.serviceName);
        ss.propertyDidChange('isMonitoringService');
        expect(ss.get('isMonitoringService')).to.equal(test.result);
      });
    });
  });

  describe('#hasClient', function () {
    it('No client serviceComponents', function () {
      ss.set('serviceComponents', []);
      ss.propertyDidChange('hasClient');
      expect(ss.get('hasClient')).to.be.false;
    });
    it('Has client serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({isClient: true})]);
      ss.propertyDidChange('hasClient');
      expect(ss.get('hasClient')).to.be.true;
    });
  });

  describe('#hasMaster', function () {
    it('No master serviceComponents', function () {
      ss.set('serviceComponents', []);
      ss.propertyDidChange('hasMaster');
      expect(ss.get('hasMaster')).to.be.false;
    });
    it('Has master serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({isMaster: true})]);
      ss.propertyDidChange('hasMaster');
      expect(ss.get('hasMaster')).to.be.true;
    });
  });

  describe('#hasSlave', function () {
    it('No slave serviceComponents', function () {
      ss.set('serviceComponents', []);
      ss.propertyDidChange('hasSlave');
      expect(ss.get('hasSlave')).to.be.false;
    });
    it('Has slave serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({isSlave: true})]);
      ss.propertyDidChange('hasSlave');
      expect(ss.get('hasSlave')).to.be.true;
    });
  });

  describe('#hasNonMastersWithCustomAssignment', function () {
    it('No serviceComponents', function () {
      ss.set('serviceComponents', []);
      ss.propertyDidChange('hasNonMastersWithCustomAssignment');
      expect(ss.get('hasNonMastersWithCustomAssignment')).to.be.false;
    });
    it('All non-master serviceComponents are required on all hosts', function () {
      ss.set('serviceComponents', [Em.Object.create({isMaster: true}), Em.Object.create({isSlave: true, cardinality: 'ALL'}), Em.Object.create({isClient: true, cardinality: 'ALL'})]);
      ss.propertyDidChange('hasNonMastersWithCustomAssignment');
      expect(ss.get('hasNonMastersWithCustomAssignment')).to.be.false;
    });
    it('Has non-master serviceComponents not required on all hosts', function () {
      ss.set('serviceComponents', [Em.Object.create({isSlave: true}), Em.Object.create({isClient: true})]);
      ss.propertyDidChange('hasNonMastersWithCustomAssignment');
      expect(ss.get('hasNonMastersWithCustomAssignment')).to.be.true;
    });
  });

  App.TestAliases.testAsComputedEveryBy(ss, 'isClientOnlyService', 'serviceComponents', 'isClient', true);

  describe('#isNoConfigTypes', function () {
    it('configTypes is null', function () {
      ss.set('configTypes', null);
      ss.propertyDidChange('isNoConfigTypes');
      expect(ss.get('isNoConfigTypes')).to.be.true;
    });
    it('configTypes is empty', function () {
      ss.set('configTypes', {});
      ss.propertyDidChange('isNoConfigTypes');
      expect(ss.get('isNoConfigTypes')).to.be.true;
    });
    it('configTypes is correct', function () {
      ss.set('configTypes', {'key': {}});
      ss.propertyDidChange('isNoConfigTypes');
      expect(ss.get('isNoConfigTypes')).to.be.false;
    });
  });

  describe('#customReviewHandler', function () {
    it('service name is HDFS', function () {
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('customReviewHandler');
      expect(ss.get('customReviewHandler')).to.be.undefined;
    });
    it('service name is HIVE', function () {
      ss.set('serviceName', 'HIVE');
      ss.propertyDidChange('customReviewHandler');
      expect(ss.get('customReviewHandler')).to.eql({
        "Database": "loadHiveDbValue"
      });
    });
  });

  describe('#configCategories', function () {
    it('HDFS service with no serviceComponents', function () {
      ss.set('serviceComponents', []);
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('configCategories');
      expect(ss.get('configCategories').mapProperty('name')).to.eql([
        "General",
        "Advanced",
        "Advanced key"
      ]);
    });
    it('HDFS service with DATANODE serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({componentName: 'DATANODE'})]);
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('configCategories');
      expect(ss.get('configCategories').mapProperty('name')).to.eql([
        "DATANODE",
        "General",
        "Advanced",
        "Advanced key"]);
    });

    it('HDFS service with custom serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({componentName: 'DATANODE'})]);
      ss.set('serviceName', 'HDFS');
      ss.set('configTypes', { key: { supports: {adding_forbidden: "false"}}});
      ss.propertyDidChange('configCategories');
      expect(ss.get('configCategories').mapProperty('name')).to.eql([
        "DATANODE",
        "General",
        "Advanced",
        "Advanced key",
        "Custom key"]);
    });
  });

  describe('#isDisabled', function () {

    var cases = [
      {
        isInstalled: true,
        isMandatory: true,
        clusterInstallCompleted: true,
        isDisabled: true
      },
      {
        isInstalled: true,
        isMandatory: true,
        clusterInstallCompleted: false,
        isDisabled: true
      },
      {
        isInstalled: true,
        isMandatory: false,
        clusterInstallCompleted: true,
        isDisabled: true
      },
      {
        isInstalled: true,
        isMandatory: false,
        clusterInstallCompleted: false,
        isDisabled: true
      },
      {
        isInstalled: false,
        isMandatory: true,
        clusterInstallCompleted: true,
        isDisabled: false
      },
      {
        isInstalled: false,
        isMandatory: true,
        clusterInstallCompleted: false,
        isDisabled: true
      },
      {
        isInstalled: false,
        isMandatory: false,
        clusterInstallCompleted: true,
        isDisabled: false
      },
      {
        isInstalled: false,
        isMandatory: false,
        clusterInstallCompleted: false,
        isDisabled: false
      }
    ];

    cases.forEach(function (testCase) {

      var title = 'isInstalled: {0}, isMandatory: {1}, clusterInstallCompleted: {2}, isDisabled: {3}'
        .format(testCase.isInstalled, testCase.isMandatory, testCase.clusterInstallCompleted, testCase.isDisabled);

      it(title, function () {
        ss.setProperties({
          isInstalled: testCase.isInstalled,
          isMandatory: testCase.isMandatory
        });
        App.set('router.clusterInstallCompleted', testCase.clusterInstallCompleted);
        expect(ss.get('isDisabled')).to.equal(testCase.isDisabled);
      });

    });

  });


});

});

require.register("test/models/stack_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/stack');

describe('App.Stack', function () {

  var stack;

  beforeEach(function () {
    stack = App.Stack.createRecord();
  });

  describe('#stackNameVersion', function () {

    it('should concat stack name and stack version', function () {
      stack.setProperties({
        stackName: 'HDP',
        stackVersion: '2.5'
      });
      expect(stack.get('stackNameVersion')).to.equal('HDP-2.5');
    });

  });

  describe('#isPatch', function () {

    var cases = [
      {
        type: 'PATCH',
        isPatch: true
      },
      {
        type: 'STANDARD',
        isPatch: false
      }
    ];

    cases.forEach(function (item) {

      it(item.type, function () {
        stack.set('type', item.type);
        expect(stack.get('isPatch')).to.equal(item.isPatch);
      });

    });

  });

  describe('#displayName', function () {

    it('should concat stack name and stack version', function () {
      stack.setProperties({
        stackName: 'HDP',
        repositoryVersion: '2.5.0.0-999'
      });
      expect(stack.get('displayName')).to.equal('HDP-2.5.0.0-999');
    });

  });

  describe('#repositories', function () {

    beforeEach(function () {
      stack.reopen({
        operatingSystems: [
          Em.Object.create({
            isSelected: false,
            repositories: [
              {
                id: 0
              },
              {
                id: 1
              }
            ]
          }),
          Em.Object.create({
            isSelected: false,
            repositories: [
              {
                id: 2
              },
              {
                id: 3
              }
            ]
          }),
          Em.Object.create({
            isSelected: false,
            repositories: [
              {
                id: 4
              },
              {
                id: 5
              }
            ]
          })
        ]
      });
    });

    it('no OSes selected', function () {
      expect(stack.get('repositories')).to.be.empty;
    });

    it('some OSes selected', function () {
      stack.get('operatingSystems')[0].isSelected = true;
      stack.get('operatingSystems')[2].isSelected = true;
      expect(stack.get('repositories').toArray()).to.eql([
        {
          id: 0
        },
        {
          id: 1
        },
        {
          id: 4
        },
        {
          id: 5
        }
      ]);
    });

  });

  describe('#cleanReposBaseUrls', function () {

    beforeEach(function () {
      stack.reopen({
        operatingSystems: [
          Em.Object.create({
            isSelected: true,
            repositories: [
              Em.Object.create({
                baseUrl: 'http://localhost/repo0'
              }),
              Em.Object.create({
                baseUrl: 'http://localhost/repo1'
              })
            ]
          }),
          Em.Object.create({
            isSelected: true,
            repositories: [
              Em.Object.create({
                baseUrl: 'http://localhost/repo2'
              }),
              Em.Object.create({
                baseUrl: 'http://localhost/repo3'
              })
            ]
          })
        ]
      });
      stack.cleanReposBaseUrls();
    });

    it('should clear repo urls', function () {
      expect(stack.get('repositories').mapProperty('baseUrl')).to.eql(['', '', '', '']);
    });

  });

  describe('#restoreReposBaseUrls', function () {

    beforeEach(function () {
      stack.reopen({
        operatingSystems: [
          Em.Object.create({
            isSelected: true,
            repositories: [
              Em.Object.create({
                baseUrlInit: 'http://localhost/repo0'
              }),
              Em.Object.create({
                baseUrlInit: 'http://localhost/repo1'
              })
            ]
          }),
          Em.Object.create({
            isSelected: true,
            repositories: [
              Em.Object.create({
                baseUrlInit: 'http://localhost/repo2'
              }),
              Em.Object.create({
                baseUrlInit: 'http://localhost/repo3'
              })
            ]
          })
        ]
      });
      stack.restoreReposBaseUrls();
    });

    it('should reset repo urls', function () {
      expect(stack.get('repositories').mapProperty('baseUrl')).to.eql([
        'http://localhost/repo0',
        'http://localhost/repo1',
        'http://localhost/repo2',
        'http://localhost/repo3'
      ]);
    });

  });

});
});

require.register("test/models/stack_version/repository_version_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var model;

function getModel() {
  return App.RepositoryVersion.createRecord();
}

describe('App.RepositoryVersion', function () {

  beforeEach(function () {
    model = getModel();
  });

  App.TestAliases.testAsComputedFirstNotBlank(getModel(), 'status', ['stackVersion.state', 'defaultStatus']);

  App.TestAliases.testAsComputedIfThenElse(getModel(), 'noInitHostsTooltip', 'noInitHosts', Em.I18n.t('admin.stackVersions.version.emptyHostsTooltip'), Em.I18n.t('admin.stackVersions.version.hostsTooltip'));

  App.TestAliases.testAsComputedIfThenElse(getModel(), 'noCurrentHostsTooltip', 'noCurrentHosts', Em.I18n.t('admin.stackVersions.version.emptyHostsTooltip'), Em.I18n.t('admin.stackVersions.version.hostsTooltip'));

  App.TestAliases.testAsComputedIfThenElse(getModel(), 'noInstalledHostsTooltip', 'noInstalledHosts', Em.I18n.t('admin.stackVersions.version.emptyHostsTooltip'), Em.I18n.t('admin.stackVersions.version.hostsTooltip'));

  describe("#notInstalledHosts", function() {

    before(function () {
      sinon.stub(App, 'get').returns(['host1']);
    });

    beforeEach(function () {
      model = getModel();
    });

    after(function () {
      App.get.restore();
    });

    it("stackVersion is null", function() {
      model.set('stackVersion', null);
      model.propertyDidChange('notInstalledHosts');
      expect(model.get('notInstalledHosts')).to.eql(['host1']);
    });

    it("stackVersion has notInstalledHosts array", function() {
      model.set('stackVersion', Em.Object.create({
        notInstalledHosts: ['host2']
      }));
      model.propertyDidChange('notInstalledHosts');
      expect(model.get('notInstalledHosts')).to.eql(['host2']);
    });
  });

});

});

require.register("test/models/upgrade_entity_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/upgrade_entity');

function getModel() {
  return App.upgradeEntity.create();
}

describe('App.upgradeEntity', function () {
  var model;

  beforeEach(function () {
    model = getModel();
  });

  App.TestAliases.testAsComputedNotEqual(getModel(), 'isVisible', 'status', 'PENDING');

  describe("#isRunning", function() {
    it("status IN_PROGRESS", function() {
      model.set('status', 'IN_PROGRESS');
      model.propertyDidChange('isRunning');
      expect(model.get('isRunning')).to.be.true;
    });
    it("status PENDING", function() {
      model.set('status', 'PENDING');
      model.propertyDidChange('isRunning');
      expect(model.get('isRunning')).to.be.false;
    });
  });

  describe("#progress", function() {
    it("progress_percent = 1.9", function() {
      model.set('progress_percent', 1.9);
      model.propertyDidChange('progress');
      expect(model.get('progress')).to.equal(1);
    });
    it("progress_percent = 1", function() {
      model.set('progress_percent', 1);
      model.propertyDidChange('progress');
      expect(model.get('progress')).to.equal(1);
    });
  });

  describe("#isActive", function() {
    it("status IN_PROGRESS", function() {
      model.set('status', 'IN_PROGRESS');
      model.propertyDidChange('isActive');
      expect(model.get('isActive')).to.be.true;
    });
    it("status PENDING", function() {
      model.set('status', 'PENDING');
      model.propertyDidChange('isActive');
      expect(model.get('isActive')).to.be.false;
    });
  });

  describe('#isExpandableGroup', function () {

    var cases = [
      {
        input: {
          type: 'ITEM'
        },
        isExpandableGroup: false,
        title: 'not upgrade group'
      },
      {
        input: {
          type: 'GROUP',
          status: 'PENDING',
          hasExpandableItems: false
        },
        isExpandableGroup: false,
        title: 'pending upgrade group without expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'ABORTED',
          hasExpandableItems: false
        },
        isExpandableGroup: false,
        title: 'aborted upgrade group without expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'ABORTED',
          hasExpandableItems: true
        },
        isExpandableGroup: true,
        title: 'aborted upgrade group with expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'IN_PROGRESS',
          hasExpandableItems: false
        },
        isExpandableGroup: true,
        title: 'active upgrade group'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        model.setProperties(item.input);
        expect(model.get('isExpandableGroup')).to.equal(item.isExpandableGroup);
      });
    });

  });

  describe('#upgradeGroupStatus', function () {

    var cases = [
      {
        input: {
          type: 'ITEM',
          upgradeSuspended: false
        },
        upgradeGroupStatus: undefined,
        title: 'not upgrade group'
      },
      {
        input: {
          type: 'GROUP',
          status: 'PENDING',
          hasExpandableItems: false,
          upgradeSuspended: false
        },
        upgradeGroupStatus: 'PENDING',
        title: 'pending upgrade group'
      },
      {
        input: {
          type: 'GROUP',
          status: 'PENDING',
          hasExpandableItems: true,
          upgradeSuspended: false
        },
        upgradeGroupStatus: 'SUBITEM_FAILED',
        title: 'pending upgrade group with expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'ABORTED',
          hasExpandableItems: false,
          upgradeSuspended: false
        },
        upgradeGroupStatus: 'ABORTED',
        title: 'aborted upgrade group with expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'ABORTED',
          hasExpandableItems: true,
          upgradeSuspended: true
        },
        upgradeGroupStatus: 'SUSPENDED',
        title: 'suspended upgrade group with expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'IN_PROGRESS',
          hasExpandableItems: false,
          upgradeSuspended: false
        },
        upgradeGroupStatus: 'IN_PROGRESS',
        title: 'active upgrade'
      }
    ];

    beforeEach(function() {
      this.mock = sinon.stub(App, 'get');
    });
    afterEach(function() {
      this.mock.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        this.mock.returns(item.input.upgradeSuspended);
        model.setProperties(item.input);
        expect(model.get('upgradeGroupStatus')).to.equal(item.upgradeGroupStatus);
      });
    });

  });
});
});

require.register("test/models/user_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/user');

var user,
  form,
  userNameField,
  userData = {
    id: 'user'
  };

function getUser() {
  return App.User.createRecord(userData);
}

describe('App.User', function () {

  beforeEach(function () {
    user = getUser();
  });

  afterEach(function () {
    modelSetup.deleteRecord(user);
  });

  App.TestAliases.testAsComputedAlias(getUser(), 'id', 'userName', 'string');

  describe('#id', function () {
    it('should take value from userName', function () {
      user.set('userName', 'name');
      expect(user.get('id')).to.equal('name');
    });
  });

  describe('#isLdap', function() {
    it('User userType value is "LDAP" should return "true"', function() {
      user.set('userType', 'LDAP');
      expect(user.get('isLdap')).to.be.true;
    });
    it('User userType value is "LOCAL" should return "false"', function() {
      user.set('userType', 'LOCAL');
      expect(user.get('isLdap')).to.be.false;
    });
  });
});

function getForm() {
  return App.CreateUserForm.create();
}

describe('App.CreateUserForm', function () {

  beforeEach(function () {
    form = getForm();
  });

  App.TestAliases.testAsComputedAlias(getForm(), 'object', 'App.router.mainAdminUserCreateController.content', 'object');

  describe('#field.userName.toLowerCase', function () {
    it('should convert userName into lower case', function () {
      userNameField = form.getField('userName');
      userNameField.set('value', 'NAME');
      expect(userNameField.get('value')).to.equal('name');
    });
  });

  describe('#isValid', function () {
    it('should be false as default', function () {
      expect(form.isValid()).to.be.false;
    });
    it('should be true', function () {
      form.get('fields').forEach(function (item) {
        if (item.get('isRequired')) {
          item.set('value', 'value');
        }
      });
      expect(form.isValid()).to.be.true;
    });
  });

  describe('#isWarn', function () {
    it('should be false as default', function () {
      expect(form.isWarn()).to.be.false;
    });
    it('should be true', function () {
      form.getField('userName').set('value', '1');
      expect(form.isWarn()).to.be.true;
    });
    it('should be false', function () {
      form.getField('userName').set('value', 'name');
      expect(form.isWarn()).to.be.false;
    });
  });

});

});

require.register("test/models/view_instance_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var model;

describe('App.ViewInstance', function () {

  beforeEach(function () {
    model = App.ViewInstance.create();
  });

  describe('#internalAmbariUrl', function () {

    [
      {
        props: {
          shortUrl: '',
          viewName: 'CAPACITY-SCHEDULER',
          version: '1.0.0',
          instanceName: 'AUTO_CS_INSTANCE'
        },
        e: 'main/views/CAPACITY-SCHEDULER/1.0.0/AUTO_CS_INSTANCE',
        m: '`shortUrl` does not exist'
      },
      {
        props: {
          shortUrl: 'auto_cs_instance',
          viewName: 'CAPACITY-SCHEDULER',
          version: '1.0.0',
          instanceName: 'AUTO_CS_INSTANCE'
        },
        e: 'main/view/CAPACITY-SCHEDULER/auto_cs_instance',
        m: '`shortUrl` exists'
      }
    ].forEach(function (test) {
      it(test.m, function () {
        model.setProperties(test.props);
        expect(model.get('internalAmbariUrl')).to.be.equal(test.e);
      });
    });

  });

});
});

require.register("test/models/widget_property_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/widget_property');

describe('App.WidgetProperty', function () {

  var widgetProperty,
    unit = App.WidgetPropertyTypes.findProperty('name', 'display_unit'),
    threshold = App.WidgetPropertyTypes.findProperty('name', 'threshold'),
    validate = function (value) {
      return !isNaN(value);
    };

  beforeEach(function () {
    widgetProperty = App.WidgetProperty.create();
  });

  describe('#viewClass', function () {

    var cases = [
      {
        displayType: 'textField',
        viewClass: App.WidgetPropertyTextFieldView
      },
      {
        displayType: 'threshold',
        viewClass: App.WidgetPropertyThresholdView
      },
      {
        displayType: 'select',
        viewClass: App.WidgetPropertySelectView
      },
      {
        displayType: 'none',
        viewClass: undefined
      }
    ];

    cases.forEach(function (item) {

      it(item.displayType, function () {
        widgetProperty.set('displayType', item.displayType);
        expect(widgetProperty.get('viewClass')).to.eql(item.viewClass);
      });

    });

  });

  describe('#isValid', function () {

    describe('display_unit', function () {

      var cases = [
        {
          isRequired: true,
          value: 'MB',
          isValid: true,
          title: 'valid value'
        },
        {
          isRequired: true,
          value: '0',
          isValid: true,
          title: 'non-empty value'
        },
        {
          isRequired: true,
          value: '',
          isValid: false,
          title: 'empty value'
        },
        {
          isRequired: false,
          value: '',
          isValid: true,
          title: 'value not required'
        }
      ];

      beforeEach(function () {
        widgetProperty.reopen(unit);
      });

      cases.forEach(function (item) {

        it(item.title, function () {
          widgetProperty.setProperties({
            isRequired: item.isRequired,
            value: item.value
          });
          expect(widgetProperty.get('isValid')).to.equal(item.isValid);
        });

      });

    });

    describe('threshold', function () {

      var cases = [
        {
          isSmallValueValid: true,
          isBigValueValid: true,
          isValid: true,
          title: 'both threshold values are valid'
        },
        {
          isSmallValueValid: false,
          isBigValueValid: true,
          isValid: false,
          title: 'warning threshold value is invalid'
        },
        {
          isSmallValueValid: true,
          isBigValueValid: false,
          isValid: false,
          title: 'error threshold value is invalid'
        },
        {
          isSmallValueValid: false,
          isBigValueValid: false,
          isValid: false,
          title: 'both threshold values are invalid'
        }
      ];

      cases.forEach(function (item) {

        it(item.title, function () {
          widgetProperty.reopen(threshold, {
            isSmallValueValid: item.isSmallValueValid,
            isBigValueValid: item.isBigValueValid
          });
          expect(widgetProperty.get('isValid')).to.equal(item.isValid);
        });

      });

    });

  });

  describe('#isSmallValueValid', function () {

    var cases = [
      {
        smallValue: '1',
        isSmallValueValid: true,
        title: 'valid value'
      },
      {
        smallValue: 'value',
        isSmallValueValid: false,
        title: 'invalid value'
      }
    ];

    beforeEach(function () {
      widgetProperty.reopen(threshold);
      sinon.stub(widgetProperty, 'validate', validate);
    });

    afterEach(function () {
      widgetProperty.validate.restore();
    });

    cases.forEach(function (item) {

      it(item.title, function () {
        widgetProperty.set('smallValue', item.smallValue);
        expect(widgetProperty.get('isSmallValueValid')).to.equal(item.isSmallValueValid);
      });

    });

  });

  describe('#isBigValueValid', function () {

    var cases = [
      {
        bigValue: '1',
        isBigValueValid: true,
        title: 'valid value'
      },
      {
        bigValue: 'value',
        isBigValueValid: false,
        title: 'invalid value'
      }
    ];

    beforeEach(function () {
      widgetProperty.reopen(threshold);
      sinon.stub(widgetProperty, 'validate', validate);
    });

    afterEach(function () {
      widgetProperty.validate.restore();
    });

    cases.forEach(function (item) {

      it(item.title, function () {
        widgetProperty.set('bigValue', item.bigValue);
        expect(widgetProperty.get('isBigValueValid')).to.equal(item.isBigValueValid);
      });

    });

  });

  describe('#validate', function () {

    var cases = [
      {
        value: '',
        validateResult: true,
        title: 'empty value'
      },
      {
        value: ' \r\n\t ',
        validateResult: true,
        title: 'spaces only'
      },
      {
        value: 'v',
        validateResult: false,
        title: 'invalid value'
      },
      {
        value: ' v \r\n\t',
        validateResult: false,
        title: 'invalid value with spaces'
      },
      {
        value: '-1',
        validateResult: false,
        title: 'value below the minimum'
      },
      {
        value: ' -1 \r\n\t',
        validateResult: false,
        title: 'value below the minimum with spaces'
      },
      {
        value: '2',
        validateResult: false,
        title: 'value above the minimum'
      },
      {
        value: ' 2 \r\n\t',
        validateResult: false,
        title: 'value above the minimum with spaces'
      },
      {
        value: '0,5',
        validateResult: false,
        title: 'malformed number'
      },
      {
        value: ' 0,5 \r\n\t',
        validateResult: false,
        title: 'malformed number with spaces'
      },
      {
        value: '0.5',
        validateResult: true,
        title: 'valid value'
      },
      {
        value: ' 0.5 \r\n\t',
        validateResult: true,
        title: 'valid value with spaces'
      },
      {
        value: '2E-1',
        validateResult: true,
        title: 'exponentially formatted value'
      },
      {
        value: ' 2E-1 \r\n\t',
        validateResult: true,
        title: 'exponentially formatted value with spaces'
      }
    ];

    beforeEach(function () {
      widgetProperty.reopen(threshold);
    });

    cases.forEach(function (item) {

      it(item.title, function () {
        expect(widgetProperty.validate(item.value)).to.equal(item.validateResult);
      });

    });

  });

});
});

require.register("test/models/widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/widget');

describe('App.Widget', function () {

  var widget;

  beforeEach(function () {
    widget = App.Widget.createRecord();
  });

  describe('#viewClass', function () {

    var cases = [
      {
        widgetType: 'GRAPH',
        viewClass: App.GraphWidgetView
      },
      {
        widgetType: 'TEMPLATE',
        viewClass: App.TemplateWidgetView
      },
      {
        widgetType: 'NUMBER',
        viewClass: App.NumberWidgetView
      },
      {
        widgetType: 'GAUGE',
        viewClass: App.GaugeWidgetView
      },
      {
        widgetType: 'HEATMAP',
        viewClass: App.HeatmapWidgetView
      },
      {
        widgetType: 'NONE',
        viewClass: Em.View
      }
    ];

    cases.forEach(function (item) {

      it(item.widgetType, function () {
        widget.set('widgetType', item.widgetType);
        expect(widget.get('viewClass')).to.eql(item.viewClass);
      });

    });

  });

});
});

require.register("test/router_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');

require('router');

describe('App.Router', function () {
  var router = App.Router.create();

  describe('#initAdmin()', function () {

    var cases = [
      {
        user: {
          admin: true
        },
        isAdmin: true,
        isOperator: false,
        isPermissionDataLoaded: true,
        title: 'admin'
      },
      {
        user: {
          operator: true
        },
        isAdmin: false,
        isOperator: true,
        isPermissionDataLoaded: true,
        title: 'operator'
      },
      {
        user: {},
        isAdmin: false,
        isOperator: false,
        isPermissionDataLoaded: true,
        title: 'read only access'
      },
      {
        user: null,
        isAdmin: false,
        isOperator: false,
        isPermissionDataLoaded: false,
        title: 'no user'
      }
    ];

    beforeEach(function () {
      this.getUser = sinon.stub(App.db, 'getUser');
      App.setProperties({
        isAdmin: false,
        isOperator: false,
        isPermissionDataLoaded: false
      });
    });

    afterEach(function () {
      this.getUser.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        this.getUser.returns(item.user);
        router.initAdmin();
        expect(App.get('isAdmin')).to.equal(item.isAdmin);
        expect(App.get('isOperator')).to.equal(item.isOperator);
        expect(App.get('isPermissionDataLoaded')).to.equal(item.isPermissionDataLoaded);
      });
    });

  });

  describe('#adminViewInfoSuccessCallback', function () {
    beforeEach(function () {
      sinon.stub(window.location, 'replace', Em.K);
    });
    afterEach(function () {
      window.location.replace.restore();
    });

    var tests = [{
      mockData: {
        components: [{
          'RootServiceComponents': {
            'component_version': '1.9.0'
          }
        }, {
          'RootServiceComponents': {
            'component_version': '2.0.0'
          }
        }]
      },
      expected: '/views/ADMIN_VIEW/2.0.0/INSTANCE/#/'
    }, {
      mockData: {
        components: [{
          'RootServiceComponents': {
            'component_version': '1.9.0'
          }
        }, {
          'RootServiceComponents': {
            'component_version': '2.1.0'
          }
        }, {
          'RootServiceComponents': {
            'component_version': '2.0.0'
          }
        }]
      },
      expected: '/views/ADMIN_VIEW/2.1.0/INSTANCE/#/'
    }, {
      mockData: {
        components: [{
          'RootServiceComponents': {
            component_version: '2.1.0'
          }
        }]
      },
      expected: '/views/ADMIN_VIEW/2.1.0/INSTANCE/#/'
    }];

    tests.forEach(function (data, index) {
      it('should redirect to the latest version of admin view ("' + data.expected + '") #' + (index + 1), function () {
        router.adminViewInfoSuccessCallback(data.mockData);
        expect(window.location.replace.calledWith(data.expected)).to.be.true;
      });
    });
  });

  describe.skip("#savePreferedPath()", function () {
    beforeEach(function () {
      router.set('preferedPath', null);
    });
    it("has no key", function () {
      router.savePreferedPath('path');
      expect(router.get('preferedPath')).to.equal('path');
    });
    it("path does not contain key", function () {
      router.savePreferedPath('path', 'key');
      expect(router.get('preferedPath')).to.be.null;
    });
    it("path contains key", function () {
      router.savePreferedPath('key=path', 'key=');
      expect(router.get('preferedPath')).to.equal('path');
    });
  });

  describe.skip("#restorePreferedPath()", function () {
    it("preferedPath is null", function () {
      router.set('preferedPath', null);
      expect(router.restorePreferedPath()).to.be.false;
      expect(router.get('preferedPath')).to.be.null;
    });
    it("preferedPath is '/relativeURL'", function () {
      router.set('preferedPath', '/relativeURL');
      expect(router.restorePreferedPath()).to.be.true;
      expect(router.get('preferedPath')).to.be.null;
    });
    it("preferedPath is '#/relativeURL'", function () {
      router.set('preferedPath', '#/relativeURL');
      expect(router.restorePreferedPath()).to.be.true;
      expect(router.get('preferedPath')).to.be.null;
    });
    it("preferedPath is '#/login'", function () {
      router.set('preferedPath', '#/login');
      expect(router.restorePreferedPath()).to.be.false;
      expect(router.get('preferedPath')).to.be.null;
    });
    it("preferedPath is 'http://absoluteURL'", function () {
      router.set('preferedPath', 'http://absoluteURL');
      expect(router.restorePreferedPath()).to.be.false;
      expect(router.get('preferedPath')).to.be.null;
    });
  });

  describe.skip("#loginGetClustersSuccessCallback()", function () {
    var mock = {dataLoading: Em.K};
    beforeEach(function () {
      sinon.stub(router, 'setClusterInstalled', Em.K);
      sinon.stub(router, 'transitionToApp', Em.K);
      sinon.stub(router, 'transitionToViews', Em.K);
      sinon.stub(router, 'transitionToAdminView', Em.K);
      sinon.stub(App.router, 'get').returns(mock);
      sinon.spy(mock, 'dataLoading');
      App.setProperties({
        isAdmin: false,
        isOperator: false,
        isPermissionDataLoaded: false
      });
    });
    afterEach(function () {
      router.setClusterInstalled.restore();
      router.transitionToApp.restore();
      router.transitionToViews.restore();
      router.transitionToAdminView.restore();
      App.router.get.restore();
      mock.dataLoading.restore();
    });
    it("cluster exists, OPERATOR privileges", function () {
      var clusterData = {
        items: [{
          Clusters: {
            cluster_name: 'c1'
          }
        }]
      };
      var params = {
        loginData: {
          privileges: [{
            PrivilegeInfo: {
              cluster_name: 'c1',
              permission_name: 'CLUSTER.ADMINISTRATOR'
            }
          }]
        }
      };
      router.loginGetClustersSuccessCallback(clusterData, {}, params);
      expect(router.setClusterInstalled.calledWith(clusterData)).to.be.true;
      expect(router.transitionToApp.calledOnce).to.be.true;
      expect(App.get('isAdmin')).to.be.true;
      expect(App.get('isOperator')).to.be.true;
      expect(App.get('isPermissionDataLoaded')).to.be.true;
      expect(mock.dataLoading.calledOnce).to.be.true;
    });

    it("cluster exists, READ privileges", function () {
      var clusterData = {
        items: [{
          Clusters: {
            cluster_name: 'c1'
          }
        }]
      };
      var params = {
        loginData: {
          privileges: [{
            PrivilegeInfo: {
              cluster_name: 'c1',
              permission_name: 'CLUSTER.USER'
            }
          }]
        }
      };
      router.loginGetClustersSuccessCallback(clusterData, {}, params);
      expect(router.setClusterInstalled.calledWith(clusterData)).to.be.true;
      expect(router.transitionToApp.calledOnce).to.be.true;
      expect(App.get('isAdmin')).to.be.false;
      expect(App.get('isOperator')).to.be.false;
      expect(App.get('isPermissionDataLoaded')).to.be.true;
      expect(mock.dataLoading.calledOnce).to.be.true;
    });
    it("cluster exists, ADMIN privileges", function () {
      var clusterData = {
        items: [{
          Clusters: {
            cluster_name: 'c1'
          }
        }]
      };
      var params = {
        loginData: {
          privileges: [{
            PrivilegeInfo: {
              cluster_name: 'c1',
              permission_name: 'AMBARI.ADMINISTRATOR'
            }
          }]
        }
      };
      router.loginGetClustersSuccessCallback(clusterData, {}, params);
      expect(router.setClusterInstalled.calledWith(clusterData)).to.be.true;
      expect(router.transitionToApp.calledOnce).to.be.true;
      expect(App.get('isAdmin')).to.be.true;
      expect(App.get('isOperator')).to.be.false;
      expect(App.get('isPermissionDataLoaded')).to.be.true;
      expect(mock.dataLoading.calledOnce).to.be.true;
    });
    it("cluster exists, no privileges", function () {
      var clusterData = {
        items: [{
          Clusters: {
            cluster_name: 'c1'
          }
        }]
      };
      var params = {
        loginData: {
          privileges: []
        }
      };
      router.loginGetClustersSuccessCallback(clusterData, {}, params);
      expect(router.setClusterInstalled.calledWith(clusterData)).to.be.true;
      expect(router.transitionToViews.calledOnce).to.be.true;
      expect(App.get('isAdmin')).to.be.false;
      expect(App.get('isOperator')).to.be.false;
      expect(App.get('isPermissionDataLoaded')).to.be.true;
      expect(mock.dataLoading.calledOnce).to.be.true;
    });
    it("cluster not installed, ADMIN privileges", function () {
      var clusterData = {
        items: []
      };
      var params = {
        loginData: {
          privileges: [{
            PrivilegeInfo: {
              cluster_name: 'c1',
              permission_name: 'AMBARI.ADMINISTRATOR'
            }
          }]
        }
      };
      router.loginGetClustersSuccessCallback(clusterData, {}, params);
      expect(router.transitionToAdminView.calledOnce).to.be.true;
      expect(App.get('isAdmin')).to.be.true;
      expect(App.get('isOperator')).to.be.false;
      expect(App.get('isPermissionDataLoaded')).to.be.true;
      expect(mock.dataLoading.calledOnce).to.be.true;
    });
    it("cluster not installed, non-admin privileges", function () {
      var clusterData = {
        items: []
      };
      var params = {
        loginData: {
          privileges: []
        }
      };
      router.loginGetClustersSuccessCallback(clusterData, {}, params);
      expect(router.transitionToViews.calledOnce).to.be.true;
      expect(App.get('isAdmin')).to.be.false;
      expect(App.get('isOperator')).to.be.false;
      expect(App.get('isPermissionDataLoaded')).to.be.true;
      expect(mock.dataLoading.calledOnce).to.be.true;
    });
  });

  describe("#transitionToAdminView()", function () {

    it("valid request is sent", function () {
      router.transitionToAdminView();
      var args = testHelpers.findAjaxRequest('name', 'ambari.service.load_server_version');
      expect(args[0]).to.exists;
    });
  });

  describe("#transitionToApp()", function () {
    beforeEach(function () {
      this.mock = sinon.stub(router, 'restorePreferedPath');
      sinon.stub(router, 'getSection', function (callback) {
        callback('route');
      });
      sinon.stub(router, 'transitionTo');
    });
    afterEach(function () {
      this.mock.restore();
      router.getSection.restore();
      router.transitionTo.restore();
    });
    it("has restore path", function () {
      this.mock.returns(true);
      router.transitionToApp();
      expect(router.getSection.called).to.be.false;
      expect(router.transitionTo.called).to.be.false;
    });
    it("does not have restore path", function () {
      this.mock.returns(false);
      router.transitionToApp();
      expect(router.getSection.calledOnce).to.be.true;
      expect(router.transitionTo.calledWith('route')).to.be.true;
    });
  });

  describe("#transitionToViews()", function () {
    var mock = {loadAmbariViews: Em.K};
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns(mock);
      sinon.stub(router, 'transitionTo');
      sinon.spy(mock, 'loadAmbariViews');
    });
    afterEach(function () {
      App.router.get.restore();
      router.transitionTo.restore();
      mock.loadAmbariViews.restore();
    });
    it("transitionTo called with corrent route", function () {
      router.transitionToViews();
      expect(mock.loadAmbariViews.calledOnce).to.be.true;
      expect(router.transitionTo.calledWith('main.views.index')).to.be.true;
    });
  });

  describe("#adminViewInfoErrorCallback()", function () {
    beforeEach(function () {
      sinon.stub(router, 'transitionToViews');
    });
    afterEach(function () {
      router.transitionToViews.restore();
    });
    it("transitionToViews called once", function () {
      router.adminViewInfoErrorCallback();
      expect(router.transitionToViews.calledOnce).to.be.true;
    });
  });

  describe("#getAuthenticated", function () {
    beforeEach(function () {
      router = App.Router.create();
      this.mockGetCurrentLocationUrl = sinon.stub(router, 'getCurrentLocationUrl');
      sinon.stub(router, 'redirectByURL', Em.K);
    });

    afterEach(function () {
      router.getCurrentLocationUrl.restore();
      router.redirectByURL.restore();
      this.mockGetCurrentLocationUrl.restore();
    });

    [
      {
        lastSetURL: '/login/local',
        isResolved: false,
        responseData: {
          responseText: "",
          status: 403
        },
        redirectCalled: false,
        m: 'no jwtProviderUrl in auth response, no redirect'
      },
      {
        lastSetURL: '/main/dashboard',
        isResolved: false,
        responseData: {
          responseText: JSON.stringify({jwtProviderUrl: 'http://some.com?originalUrl='}),
          status: 403
        },
        redirectCalled: true,
        m: 'jwtProviderUrl is present, current location not local login url, redirect according to jwtProviderUrl value'
      },
      {
        lastSetURL: '/login/local',
        isResolved: false,
        responseData: {
          responseText: JSON.stringify({jwtProviderUrl: 'http://some.com?originalUrl='}),
          status: 403
        },
        redirectCalled: false,
        m: 'jwtProviderUrl is present, current location is local login url, no redirect'
      }
    ].forEach(function (test) {
      describe(test.m, function () {
        var mockCurrentUrl;
        beforeEach(function () {
          mockCurrentUrl = 'http://localhost:3333/#/some/hash';
          router.set('location.lastSetURL', test.lastSetURL);
          App.ajax.send.restore(); // default ajax-mock can't be used here
          sinon.stub(App.ajax, 'send', function () {
            if (!test.isResolved) {
              router.onAuthenticationError(test.responseData);
            }
            return {
              complete: function () {
              }
            };
          });
          this.mockGetCurrentLocationUrl.returns(mockCurrentUrl);
          router.getAuthenticated();
        });

        it('redirectByURL is ' + (test.redirectCalled ? '' : 'not') + ' called', function () {
          expect(router.redirectByURL.calledOnce).to.be.eql(test.redirectCalled);
        });


        if (test.redirectCalled) {
          it('redirectByURL is correct', function () {
            expect(router.redirectByURL.args[0][0]).to.be.eql(JSON.parse(test.responseData.responseText).jwtProviderUrl + encodeURIComponent(mockCurrentUrl));
          });
        }
      });
    });

  });

  describe('#setClusterData', function () {

    var data = {
        loginName: 'user',
        loginData: {
          PrivilegeInfo: {}
        }
      },
      clusterData = {
        items: []
      },
      cases = [
        {
          clusterData: clusterData,
          callbackCallCount: 1,
          isAjaxCalled: false,
          title: 'cluster data available'
        },
        {
          clusterData: null,
          callbackCallCount: 0,
          isAjaxCalled: true,
          title: 'no cluster data'
        }
      ];

    beforeEach(function () {
      sinon.stub(router, 'loginGetClustersSuccessCallback', Em.K);
    });

    afterEach(function () {
      router.loginGetClustersSuccessCallback.restore();
    });

    cases.forEach(function (item) {

      describe(item.title, function () {

        var ajaxCallArgs;

        beforeEach(function () {
          router.set('clusterData', item.clusterData);
          router.setClusterData({}, {}, data);
          ajaxCallArgs = testHelpers.findAjaxRequest('name', 'router.login.clusters');
        });

        it('loginGetClustersSuccessCallback', function () {
          expect(router.loginGetClustersSuccessCallback.callCount).to.equal(item.callbackCallCount);
        });

        if (item.isAjaxCalled) {
          it('App.ajax.send is called', function () {
            expect(ajaxCallArgs).to.have.length(1);
          });
          it('data for AJAX request', function () {
            expect(ajaxCallArgs).to.eql([
              {
                name: 'router.login.clusters',
                sender: router,
                data: data,
                success: 'loginGetClustersSuccessCallback'
              }
            ]);
          });
        } else {
          it('App.ajax.send is not called', function () {
            expect(ajaxCallArgs).to.be.undefined;
          });
          it('arguments for callback', function () {
            expect(router.loginGetClustersSuccessCallback.firstCall.args).to.eql([clusterData, {}, data]);
          });
        }

      });

    });

  });

});

describe('App.StepRoute', function () {

  beforeEach(function () {
    this.route = App.StepRoute.create();
    this.nextTransitionSpy = sinon.spy(this.route, 'nextTransition');
    this.backTransitionSpy = sinon.spy(this.route, 'backTransition');
    this.appGetStub = sinon.stub(App, 'get');
    this.appSetStub = sinon.stub(App, 'set');
    this.runNextStub = sinon.stub(Em.run, 'next', Em.clb);
  });

  afterEach(function () {
    this.nextTransitionSpy.restore();
    this.backTransitionSpy.restore();
    this.appGetStub.restore();
    this.appSetStub.restore();
    this.runNextStub.restore();
  });

  describe('#back', function () {

    [
      {
        btnClickInProgress: true,
        backBtnClickInProgressIsSet: false,
        backTransitionIsCalled: false,
        m: 'backTransition is not called'
      },
      {
        btnClickInProgress: false,
        backBtnClickInProgressIsSet: true,
        backTransitionIsCalled: true,
        m: 'backTransition is called'
      }
    ].forEach(function (test) {
      describe(test.m, function () {

        beforeEach(function () {
          this.appGetStub.withArgs('router.btnClickInProgress').returns(test.btnClickInProgress);
          this.route.back({});
        });

        it('backTransition call', function () {
          expect(this.backTransitionSpy.called).to.be.equal(test.backTransitionIsCalled);
        });

        it('backBtnClickInProgress is set', function () {
          expect(this.appSetStub.calledWith('router.backBtnClickInProgress')).to.be.equal(test.backBtnClickInProgressIsSet);
        });

      });
    });

  });

  describe('#next', function () {

    [
      {
        btnClickInProgress: true,
        nextBtnClickInProgressIsSet: false,
        nextTransitionIsCalled: false,
        m: 'nextTransition is not called'
      },
      {
        btnClickInProgress: false,
        nextBtnClickInProgressIsSet: true,
        nextTransitionIsCalled: true,
        m: 'nextTransition is called'
      }
    ].forEach(function (test) {
      describe(test.m, function () {

        beforeEach(function () {
          this.appGetStub.withArgs('router.btnClickInProgress').returns(test.btnClickInProgress);
          this.route.next({});
        });

        it('nextTransition call', function () {
          expect(this.nextTransitionSpy.called).to.be.equal(test.nextTransitionIsCalled);
        });

        it('nextBtnClickInProgress is set', function () {
          expect(this.appSetStub.calledWith('router.nextBtnClickInProgress')).to.be.equal(test.nextBtnClickInProgressIsSet);
        });

      });
    });
  });

});
});

require.register("test/routes/views_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var routeClass = require('routes/views');

describe('routes/views', function() {

  var route = routeClass.create().get('viewDetails').create();

  describe("#parseViewPath", function() {
    [
      {
        url: 'viewName',
        result: ''
      },
      {
        url: 'viewName?foo=bar&count=1',
        result: '?foo=bar&count=1'
      },
      {
        url: 'viewName?viewPath=%2Fuser%2Fadmin%2Faddress',
        result: '/user/admin/address'
      },
      {
        url: 'viewName?viewPath=%2Fuser%2Fadmin%2Faddress&foo=bar&count=1',
        result: '/user/admin/address?foo=bar&count=1'
      }
    ].forEach(function(test){
        it("url = " + test.url, function() {
          expect(route.parseViewPath(test.url)).to.equal(test.result);
        });
      });
  });

});

});

require.register("test/service_components", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = {
  "items" : [
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/FALCON",
      "StackServices" : {
        "comments" : "Data management and processing platform",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "FALCON",
        "display_name" : "Falcon",
        "service_version" : "0.5.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "config_types" : {
          "falcon-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "falcon-runtime.properties" : {
            "supports" : {
              "final" : "false"
            }
          },
          "falcon-startup.properties" : {
            "supports" : {
              "final" : "false"
            }
          },
          "oozie-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        },
        "required_services" : [
          "OOZIE"
        ]
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/FALCON/components/FALCON_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "FALCON_CLIENT",
            "display_name" : "Falcon Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "FALCON",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/FALCON/components/FALCON_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "FALCON_SERVER",
            "display_name" : "Falcon Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "FALCON",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/FALCON/components/FALCON_SERVER/dependencies/OOZIE_CLIENT",
              "Dependencies" : {
                "component_name" : "OOZIE_CLIENT",
                "dependent_component_name" : "FALCON_SERVER",
                "dependent_service_name" : "FALCON",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/FALCON/components/FALCON_SERVER/dependencies/OOZIE_SERVER",
              "Dependencies" : {
                "component_name" : "OOZIE_SERVER",
                "dependent_component_name" : "FALCON_SERVER",
                "dependent_service_name" : "FALCON",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/FLUME",
      "StackServices" : {
        "comments" : "Data management and processing platform",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "FLUME",
        "display_name" : "Flume",
        "service_version" : "1.4.0.2.1.1.0",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "config_types" : {
          "flume-conf" : {
            "supports" : {
              "final" : "false"
            }
          },
          "flume-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "flume-log4j" : {
            "supports" : {
              "final" : "false"
            }
          }
        },
        "required_services" : [
          "HDFS"
        ]
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/FLUME/components/FLUME_HANDLER",
          "StackServiceComponents" : {
            "cardinality" : "0+",
            "component_category" : "SLAVE",
            "component_name" : "FLUME_HANDLER",
            "display_name" : "Flume",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "FLUME",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/GANGLIA",
      "StackServices" : {
        "comments" : "Ganglia Metrics Collection system (<a href=\"http://oss.oetiker.ch/rrdtool/\" target=\"_blank\">RRDTool</a> will be installed too)",
        "custom_commands" : [ ],
        "service_check_supported" : false,
        "service_name" : "GANGLIA",
        "display_name" : "Ganglia",
        "service_version" : "3.5.0",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : null,
        "config_types" : {
          "ganglia-env" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/GANGLIA/components/GANGLIA_MONITOR",
          "StackServiceComponents" : {
            "cardinality" : "ALL",
            "component_category" : "SLAVE",
            "component_name" : "GANGLIA_MONITOR",
            "display_name" : "Ganglia Monitor",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "GANGLIA",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "auto_deploy" : {
            "enabled" : true
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/GANGLIA/components/GANGLIA_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "GANGLIA_SERVER",
            "display_name" : "Ganglia Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "GANGLIA",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HBASE",
      "StackServices" : {
        "comments" : "Non-relational distributed database and centralized service for configuration management &\n        synchronization\n      ",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "HBASE",
        "display_name" : "HBase",
        "service_version" : "0.98.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "ZOOKEEPER",
          "HDFS"
        ],
        "config_types" : {
          "hbase-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hbase-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hbase-policy" : {
            "supports" : {
              "final" : "true"
            }
          },
          "hbase-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HBASE/components/HBASE_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "HBASE_CLIENT",
            "display_name" : "HBase Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HBASE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HBASE/components/HBASE_MASTER",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "MASTER",
            "component_name" : "HBASE_MASTER",
            "display_name" : "HBase Master",
            "custom_commands" : [
              "DECOMMISSION"
            ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HBASE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HBASE/components/HBASE_MASTER/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "HBASE_MASTER",
                "dependent_service_name" : "HBASE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HBASE/components/HBASE_MASTER/dependencies/ZOOKEEPER_SERVER",
              "Dependencies" : {
                "component_name" : "ZOOKEEPER_SERVER",
                "dependent_component_name" : "HBASE_MASTER",
                "dependent_service_name" : "HBASE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HBASE/components/HBASE_REGIONSERVER",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "SLAVE",
            "component_name" : "HBASE_REGIONSERVER",
            "display_name" : "RegionServer",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "HBASE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HDFS",
      "StackServices" : {
        "comments" : "Apache Hadoop Distributed File System",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "HDFS",
        "display_name" : "HDFS",
        "service_version" : "2.4.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "ZOOKEEPER"
        ],
        "config_types" : {
          "core-site" : {
            "supports" : {
              "final" : "true"
            }
          },
          "hadoop-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hadoop-policy" : {
            "supports" : {
              "final" : "true"
            }
          },
          "hdfs-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hdfs-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HDFS/components/DATANODE",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "SLAVE",
            "component_name" : "DATANODE",
            "display_name" : "DataNode",
            "custom_commands" : [ ],
            "decommission_allowed" : true,
            "is_client" : false,
            "is_master" : false,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HDFS/components/HDFS_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "HDFS_CLIENT",
            "display_name" : "HDFS Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HDFS/components/JOURNALNODE",
          "StackServiceComponents" : {
            "cardinality" : "0+",
            "component_category" : "SLAVE",
            "component_name" : "JOURNALNODE",
            "display_name" : "JournalNode",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HDFS/components/NAMENODE",
          "StackServiceComponents" : {
            "cardinality" : "1-2",
            "component_category" : "MASTER",
            "component_name" : "NAMENODE",
            "display_name" : "NameNode",
            "custom_commands" : [
              "DECOMMISSION"
            ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HDFS/components/SECONDARY_NAMENODE",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "SECONDARY_NAMENODE",
            "display_name" : "SNameNode",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HDFS/components/ZKFC",
          "StackServiceComponents" : {
            "cardinality" : "0+",
            "component_category" : "SLAVE",
            "component_name" : "ZKFC",
            "display_name" : "ZKFailoverController",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE",
      "StackServices" : {
        "comments" : "Data warehouse system for ad-hoc queries & analysis of large datasets and table & storage management service",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "HIVE",
        "display_name" : "Hive",
        "service_version" : "0.13.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "ZOOKEEPER",
          "YARN"
        ],
        "config_types" : {
          "hive-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hive-exec-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hive-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hive-site" : {
            "supports" : {
              "final" : "true"
            }
          },
          "tez-site" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HIVE_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "HIVE_CLIENT",
            "display_name" : "Hive Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HIVE_METASTORE",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "HIVE_METASTORE",
            "display_name" : "Hive Metastore",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "reassign_allowed" : true,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "auto_deploy" : {
            "enabled" : true,
            "location" : "HIVE/HIVE_SERVER"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HIVE_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "HIVE_SERVER",
            "display_name" : "HiveServer2",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "reassign_allowed" : true,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HIVE_SERVER/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "HIVE_SERVER",
                "dependent_service_name" : "HIVE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HIVE_SERVER/dependencies/TEZ_CLIENT",
              "Dependencies" : {
                "component_name" : "TEZ_CLIENT",
                "dependent_component_name" : "HIVE_SERVER",
                "dependent_service_name" : "HIVE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HIVE_SERVER/dependencies/YARN_CLIENT",
              "Dependencies" : {
                "component_name" : "YARN_CLIENT",
                "dependent_component_name" : "HIVE_SERVER",
                "dependent_service_name" : "HIVE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HIVE_SERVER/dependencies/ZOOKEEPER_SERVER",
              "Dependencies" : {
                "component_name" : "ZOOKEEPER_SERVER",
                "dependent_component_name" : "HIVE_SERVER",
                "dependent_service_name" : "HIVE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/WEBHCAT/components/WEBHCAT_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "WEBHCAT_SERVER",
            "display_name" : "WebHCat Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/WEBHCAT_SERVER/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "WEBHCAT_SERVER",
                "dependent_service_name" : "WEBHCAT",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/WEBHCAT_SERVER/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "WEBHCAT_SERVER",
                "dependent_service_name" : "WEBHCAT",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/WEBHCAT/components/WEBHCAT_SERVER/dependencies/YARN_CLIENT",
              "Dependencies" : {
                "component_name" : "YARN_CLIENT",
                "dependent_component_name" : "WEBHCAT_SERVER",
                "dependent_service_name" : "WEBHCAT",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/WEBHCAT/components/WEBHCAT_SERVER/dependencies/ZOOKEEPER_CLIENT",
              "Dependencies" : {
                "component_name" : "ZOOKEEPER_CLIENT",
                "dependent_component_name" : "WEBHCAT_SERVER",
                "dependent_service_name" : "WEBHCAT",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/WEBHCAT/components/WEBHCAT_SERVER/dependencies/ZOOKEEPER_SERVER",
              "Dependencies" : {
                "component_name" : "ZOOKEEPER_SERVER",
                "dependent_component_name" : "WEBHCAT_SERVER",
                "dependent_service_name" : "WEBHCAT",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/MYSQL_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "0-1",
            "component_category" : "MASTER",
            "component_name" : "MYSQL_SERVER",
            "display_name" : "MySQL Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HCAT",
          "StackServiceComponents" : {
            "cardinality" : null,
            "component_category" : "CLIENT",
            "component_name" : "HCAT",
            "display_name" : "HCat",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/MAPREDUCE2",
      "StackServices" : {
        "comments" : "Apache Hadoop NextGen MapReduce (YARN)",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "MAPREDUCE2",
        "display_name" : "MapReduce2",
        "service_version" : "2.1.0.2.0.6.0",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "YARN"
        ],
        "config_types" : {
          "core-site" : {
            "supports" : {
              "final" : "true"
            }
          },
          "mapred-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "mapred-queue-acls" : {
            "supports" : {
              "final" : "true"
            }
          },
          "mapred-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/MAPREDUCE2/components/HISTORYSERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "HISTORYSERVER",
            "display_name" : "History Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "MAPREDUCE2",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "auto_deploy" : {
            "enabled" : true,
            "location" : "YARN/RESOURCEMANAGER"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/MAPREDUCE2/components/HISTORYSERVER/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "HISTORYSERVER",
                "dependent_service_name" : "MAPREDUCE2",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/MAPREDUCE2/components/MAPREDUCE2_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "0+",
            "component_category" : "CLIENT",
            "component_name" : "MAPREDUCE2_CLIENT",
            "display_name" : "MapReduce2 Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "MAPREDUCE2",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE",
      "StackServices" : {
        "comments" : "System for workflow coordination and execution of Apache Hadoop jobs.  This also includes the installation of the optional Oozie Web Console which relies on and will install the <a target=\"_blank\" href=\"http://www.sencha.com/legal/open-source-faq/\">ExtJS</a> Library.\n      ",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "OOZIE",
        "display_name" : "Oozie",
        "service_version" : "4.0.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "YARN"
        ],
        "config_types" : {
          "oozie-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "oozie-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "oozie-site" : {
            "supports" : {
              "final" : "true"
            }
          },
          "yarn-site" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE/components/OOZIE_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "OOZIE_CLIENT",
            "display_name" : "Oozie Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "OOZIE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE/components/OOZIE_CLIENT/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "OOZIE_CLIENT",
                "dependent_service_name" : "OOZIE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE/components/OOZIE_CLIENT/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "OOZIE_CLIENT",
                "dependent_service_name" : "OOZIE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE/components/OOZIE_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "OOZIE_SERVER",
            "display_name" : "Oozie Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "OOZIE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE/components/OOZIE_SERVER/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "OOZIE_SERVER",
                "dependent_service_name" : "OOZIE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE/components/OOZIE_SERVER/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "OOZIE_SERVER",
                "dependent_service_name" : "OOZIE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE/components/OOZIE_SERVER/dependencies/YARN_CLIENT",
              "Dependencies" : {
                "component_name" : "YARN_CLIENT",
                "dependent_component_name" : "OOZIE_SERVER",
                "dependent_service_name" : "OOZIE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/PIG",
      "StackServices" : {
        "comments" : "Scripting platform for analyzing large datasets",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "PIG",
        "display_name" : "Pig",
        "service_version" : "0.12.1.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "YARN"
        ],
        "config_types" : {
          "pig-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "pig-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "pig-properties" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/PIG/components/PIG",
          "StackServiceComponents" : {
            "cardinality" : "0+",
            "component_category" : "CLIENT",
            "component_name" : "PIG",
            "display_name" : "Pig",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "PIG",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/SQOOP",
      "StackServices" : {
        "comments" : "Tool for transferring bulk data between Apache Hadoop and\n        structured data stores such as relational databases\n      ",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "SQOOP",
        "display_name" : "Sqoop",
        "service_version" : "1.4.4.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "HDFS"
        ],
        "config_types" : {
          "sqoop-env" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/SQOOP/components/SQOOP",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "SQOOP",
            "display_name" : "Sqoop",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "SQOOP",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/SQOOP/components/SQOOP/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "SQOOP",
                "dependent_service_name" : "SQOOP",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/SQOOP/components/SQOOP/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "SQOOP",
                "dependent_service_name" : "SQOOP",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/STORM",
      "StackServices" : {
        "comments" : "Apache Hadoop Stream processing framework",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "STORM",
        "display_name" : "Storm",
        "service_version" : "0.9.1.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "ZOOKEEPER"
        ],
        "config_types" : {
          "storm-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "storm-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/STORM/components/DRPC_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "DRPC_SERVER",
            "display_name" : "DRPC Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/STORM/components/NIMBUS",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "NIMBUS",
            "display_name" : "Nimbus",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/STORM/components/NIMBUS/dependencies/ZOOKEEPER_SERVER",
              "Dependencies" : {
                "component_name" : "ZOOKEEPER_SERVER",
                "dependent_component_name" : "NIMBUS",
                "dependent_service_name" : "STORM",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/STORM/components/STORM_REST_API",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "STORM_REST_API",
            "display_name" : "Storm REST API Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/STORM/components/STORM_UI_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "STORM_UI_SERVER",
            "display_name" : "Storm UI Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/STORM/components/SUPERVISOR",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "SLAVE",
            "component_name" : "SUPERVISOR",
            "display_name" : "Supervisor",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/TEZ",
      "StackServices" : {
        "comments" : "Tez is the next generation Hadoop Query Processing framework written on top of YARN.",
        "custom_commands" : [ ],
        "service_check_supported" : false,
        "service_name" : "TEZ",
        "display_name" : "Tez",
        "service_version" : "0.4.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "YARN"
        ],
        "config_types" : {
          "tez-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "tez-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/TEZ/components/TEZ_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "TEZ_CLIENT",
            "display_name" : "Tez Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "TEZ",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/YARN",
      "StackServices" : {
        "comments" : "Apache Hadoop NextGen MapReduce (YARN)",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "YARN",
        "display_name" : "YARN",
        "service_version" : "2.4.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "HDFS",
          "TEZ"
        ],
        "config_types" : {
          "capacity-scheduler" : {
            "supports" : {
              "final" : "true"
            }
          },
          "core-site" : {
            "supports" : {
              "final" : "true"
            }
          },
          "yarn-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "yarn-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "yarn-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/YARN/components/APP_TIMELINE_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "0-1",
            "component_category" : "MASTER",
            "component_name" : "APP_TIMELINE_SERVER",
            "display_name" : "App Timeline Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "reassign_allowed" : true,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/YARN/components/NODEMANAGER",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "SLAVE",
            "component_name" : "NODEMANAGER",
            "display_name" : "NodeManager",
            "custom_commands" : [ ],
            "decommission_allowed" : false,
            "is_client" : false,
            "is_master" : false,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/YARN/components/RESOURCEMANAGER",
          "StackServiceComponents" : {
            "cardinality" : "1-2",
            "component_category" : "MASTER",
            "component_name" : "RESOURCEMANAGER",
            "display_name" : "ResourceManager",
            "custom_commands" : [
              "DECOMMISSION",
              "REFRESHQUEUES"
            ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/YARN/components/YARN_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "YARN_CLIENT",
            "display_name" : "YARN Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/ZOOKEEPER",
      "StackServices" : {
        "comments" : "Centralized service which provides highly reliable distributed\n        coordination.",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "ZOOKEEPER",
        "display_name" : "ZooKeeper",
        "service_version" : "3.4.5.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [ ],
        "config_types" : {
          "zoo.cfg" : {
            "supports" : {
              "final" : "false"
            }
          },
          "zookeeper-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "zookeeper-log4j" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/ZOOKEEPER/components/ZOOKEEPER_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "ZOOKEEPER_CLIENT",
            "display_name" : "ZooKeeper Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "ZOOKEEPER",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/ZOOKEEPER/components/ZOOKEEPER_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "MASTER",
            "component_name" : "ZOOKEEPER_SERVER",
            "display_name" : "ZooKeeper Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "ZOOKEEPER",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.2/services/RANGER",
      "StackServices" : {
        "comments" : "Comprehensive security for Hadoop",
        "custom_commands" : [ ],
        "display_name" : "Ranger",
        "required_services" : [ ],
        "service_check_supported" : true,
        "service_name" : "RANGER",
        "service_version" : "0.4.0",
        "stack_name" : "HDP",
        "stack_version" : "2.2",
        "user_name" : null,
        "config_types" : {
          "admin-properties" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "ranger-env" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "true"
            }
          },
          "ranger-site" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "usersync-properties" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.2/services/RANGER/components/RANGER_ADMIN",
          "StackServiceComponents" : {
            "component_name" : "RANGER_ADMIN",
            "service_name" : "RANGER",
            "stack_name" : "HDP",
            "stack_version" : "2.2"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.2/services/RANGER/components/RANGER_USERSYNC",
          "StackServiceComponents" : {
            "component_name" : "RANGER_USERSYNC",
            "service_name" : "RANGER",
            "stack_name" : "HDP",
            "stack_version" : "2.2"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/services/RANGER_KMS",
      "StackServices" : {
        "comments" : "Key Management Server",
        "custom_commands" : [ ],
        "display_name" : "Ranger KMS",
        "required_services" : [
          "RANGER",
          "HDFS"
        ],
        "service_check_supported" : true,
        "service_name" : "RANGER_KMS",
        "service_version" : "0.5.0.2.3",
        "stack_name" : "HDP",
        "stack_version" : "2.3",
        "user_name" : null,
        "config_types" : {
          "dbks-site" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "kms-env" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "kms-log4j" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "kms-properties" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "kms-site" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "ranger-kms-audit" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "ranger-kms-policymgr-ssl" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "ranger-kms-security" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "ranger-kms-site" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          }
        }
      },
      "themes" : [ ],
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/services/RANGER_KMS/components/RANGER_KMS_SERVER",
          "StackServiceComponents" : {
            "component_name" : "RANGER_KMS_SERVER",
            "service_name" : "RANGER_KMS",
            "stack_name" : "HDP",
            "stack_version" : "2.3"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    }
  ]
};

});

require.register("test/stack", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


module.exports = {
  "items": [
    {
      "Versions": {
        "active": true,
        "min_upgrade_version": null,
        "parent_stack_version": "1.3.3",
        "stack_name": "HDP",
        "stack_version": "1.3"
      },
      "operating_systems": [
        {
          "OperatingSystems": {
            "os_type": "redhat5",
            "stack_name": "HDP",
            "stack_version": "1.3"
          },
          "repositories": [
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/1.x/updates/1.3.7.0",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/1.x/updates/1.3.7.0",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/1.x/updates/1.3.8.0",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-1.3",
                "repo_name": "HDP",
                "stack_name": "HDP",
                "stack_version": "1.3"
              }
            },
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos5",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos5",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos5",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-UTILS-1.1.0.16",
                "repo_name": "HDP-UTILS",
                "stack_name": "HDP",
                "stack_version": "1.3"
              }
            }
          ]
        },
        {
          "OperatingSystems": {
            "os_type": "redhat6",
            "stack_name": "HDP",
            "stack_version": "1.3"
          }, "repositories": [
          {
            "Repositories": {
              "base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/1.x/updates/1.3.7.0",
              "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/1.x/updates/1.3.7.0",
              "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/1.x/updates/1.3.8.0",
              "mirrors_list": null,
              "os_type": "redhat6",
              "repo_id": "HDP-1.3",
              "repo_name": "HDP",
              "stack_name": "HDP",
              "stack_version": "1.3"
            }
          },
          {
            "Repositories": {
              "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos6",
              "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos6",
              "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos6",
              "mirrors_list": null,
              "os_type": "redhat6",
              "repo_id": "HDP-UTILS-1.1.0.16",
              "repo_name": "HDP-UTILS",
              "stack_name": "HDP",
              "stack_version": "1.3"
            }
          }
        ]
        }
      ]
    },
    {
      "Versions": {
        "active": false,
        "min_upgrade_version": null,
        "parent_stack_version": null,
        "stack_name": "HDP",
        "stack_version": "2.0.6"
      },
      "operating_systems": [
        {
          "OperatingSystems": {
            "os_type": "redhat5",
            "stack_name": "HDP",
            "stack_version": "2.0.6"
          },
          "repositories": [
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-2.0.6",
                "repo_name": "HDP",
                "stack_name": "HDP",
                "stack_version": "2.0.6"
              }
            },
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-UTILS-1.1.0.17",
                "repo_name": "HDP-UTILS",
                "stack_name": "HDP",
                "stack_version": "2.0.6"
              }
            }
          ]
        },
        {
          "OperatingSystems": {
            "os_type": "redhat6",
            "stack_name": "HDP",
            "stack_version": "2.0.6"
          },
          "repositories": [
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "mirrors_list": null,
                "os_type": "redhat6",
                "repo_id": "HDP-2.0.6",
                "repo_name": "HDP",
                "stack_name": "HDP",
                "stack_version": "2.0.6"
              }
            },
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "mirrors_list": null,
                "os_type": "redhat6",
                "repo_id": "HDP-UTILS-1.1.0.17",
                "repo_name": "HDP-UTILS",
                "stack_name": "HDP",
                "stack_version": "2.0.6"
              }
            }
          ]
        }
      ]
    },
    {
      "Versions": {
        "active": true,
        "min_upgrade_version": null,
        "parent_stack_version": null,
        "stack_name": "HDP",
        "stack_version": "2.1"
      },
      "operating_systems": [
        {
          "OperatingSystems": {
            "os_type": "redhat5",
            "stack_name": "HDP",
            "stack_version": "2.1"
          },
          "repositories": [
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-2.1",
                "repo_name": "HDP",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            },
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-UTILS-1.1.0.17",
                "repo_name": "HDP-UTILS",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            }
          ]
        },
        {
          "OperatingSystems": {
            "os_type": "redhat6",
            "stack_name": "HDP",
            "stack_version": "2.1"
          },
          "repositories": [
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "mirrors_list": null,
                "os_type": "redhat6",
                "repo_id": "HDP-2.1",
                "repo_name": "HDP",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            },
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "mirrors_list": null,
                "os_type": "redhat6",
                "repo_id": "HDP-UTILS-1.1.0.17",
                "repo_name": "HDP-UTILS",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            }
          ]
        }
      ]
    }
  ]
};

});

require.register("test/utils/action_sequence_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/action_sequence');

describe('App.actionSequence', function () {

  var actionSequence;

  beforeEach(function () {
    actionSequence = App.actionSequence.create();
  });

  describe('#setSequence', function () {

    var cases = [
        {
          sequenceIn: [{}, {}],
          sequenceOut: [{}, {}],
          title: 'array passed'
        },
        {
          sequenceIn: {
            '0': {},
            '1': {},
            'length': 2
          },
          sequenceOut: [{}],
          title: 'array-like object passed'
        },
        {
          sequenceIn: 0,
          sequenceOut: [{}],
          title: 'primitive passed'
        }
      ],
      result;

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          actionSequence.set('sequence', [{}]);
          result = actionSequence.setSequence(item.sequenceIn);
        });

        it('should return context', function () {
          expect(result).to.eql(actionSequence);
        });

        it('sequence property', function () {
          expect(actionSequence.get('sequence')).to.eql(item.sequenceOut);
        });

      });

    });

  });

  describe('#start', function () {

    beforeEach(function () {
      actionSequence.setProperties({
        actionCounter: 0,
        sequence: [{}]
      });
      sinon.stub(actionSequence, 'runNextAction', Em.K);
      actionSequence.start();
    });

    afterEach(function () {
      actionSequence.runNextAction.restore();
    });

    it('should set the counter', function () {
      expect(actionSequence.get('actionCounter')).to.equal(1);
    });

    it('should start the sequence', function () {
      expect(actionSequence.runNextAction.calledOnce).to.be.true;
    });

    it('should call runNextAction with correct arguments', function () {
      expect(actionSequence.runNextAction.calledWith(0, null)).to.be.true;
    });

  });

  describe('#onFinish', function () {

    var cases = [
        {
          callbackIn: Em.isNone,
          callbackOut: Em.isNone,
          title: 'function passed'
        },
        {
          callbackIn: 'function () {}',
          callbackOut: Em.clb,
          title: 'array-like object passed'
        },
        {
          callbackIn: 'function () {}',
          callbackOut: Em.clb,
          title: 'primitive passed'
        }
      ],
      result;

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          actionSequence.set('finishedCallback', Em.clb);
          result = actionSequence.onFinish(item.callbackIn);
        });

        it('should return context', function () {
          expect(result).to.eql(actionSequence);
        });

        it('finishedCallback property', function () {
          expect(actionSequence.get('finishedCallback')).to.eql(item.callbackOut);
        });

      });

    });

  });

  describe('#runNextAction', function () {

    var actions = {
        callback: Em.K,
        sync: function (prevResponse) {
          actions.callback(prevResponse);
          return prevResponse;
        },
        async: function (prevResponse) {
          actions.callback(prevResponse);
          return {
            done: function (callback) {
              return callback.call(this, prevResponse);
            }
          };
        }
      },
      prevResponse = {},
      cases = [
        {
          index: 0,
          actionCounter: 0,
          sequence: [
            {
              callback: actions.sync,
              type: 'sync'
            }
          ],
          actionCallCount: 0,
          title: 'no iterations left (case 1)'
        },
        {
          index: 3,
          actionCounter: 3,
          sequence: [
            {
              callback: actions.sync,
              type: 'sync'
            },
            {
              callback: actions.sync,
              type: 'sync'
            },
            {
              callback: actions.sync,
              type: 'sync'
            }
          ],
          actionCallCount: 0,
          title: 'no iterations left (case 2)'
        },
        {
          index: 1,
          actionCounter: 3,
          sequence: [
            {
              callback: actions.sync,
              type: 'sync'
            },
            {
              callback: actions.sync,
              type: 'sync'
            },
            {
              callback: actions.sync,
              type: 'sync'
            }
          ],
          actionCallCount: 2,
          title: 'starting from the middle'
        },
        {
          index: 0,
          actionCounter: 2,
          sequence: [
            {
              callback: actions.sync,
              type: 'sync'
            },
            {
              callback: actions.sync,
              type: 'sync'
            },
            {
              callback: actions.sync,
              type: 'sync'
            }
          ],
          actionCallCount: 2,
          title: 'ending at the middle'
        },
        {
          index: 0,
          actionCounter: 3,
          sequence: [
            {
              callback: actions.sync,
              type: 'sync'
            },
            {
              callback: actions.sync,
              type: 'sync'
            },
            {
              callback: actions.sync,
              type: 'sync'
            }
          ],
          actionCallCount: 3,
          title: 'all iterations'
        },
        {
          index: 0,
          actionCounter: 3,
          sequence: [
            {
              callback: actions.sync,
              type: 'sync'
            },
            {
              callback: actions.async,
              type: 'async'
            },
            {
              callback: actions.sync,
              type: 'sync'
            }
          ],
          actionCallCount: 3,
          title: 'asynchronous action'
        }
      ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          sinon.spy(actions, 'callback');
          sinon.stub(actionSequence, 'finishedCallback', Em.K);
          actionSequence.setProperties({
            context: actionSequence,
            actionCounter: item.actionCounter,
            sequence: item.sequence
          });
          actionSequence.runNextAction(item.index, prevResponse);
        });

        afterEach(function () {
          actions.callback.restore();
          actionSequence.finishedCallback.restore();
        });

        it('number of calls', function () {
          expect(actions.callback.callCount).to.equal(item.actionCallCount);
        });

        if (item.actionCallCount) {
          it('argument passed to callback', function () {
            expect(actions.callback.alwaysCalledWith(prevResponse)).to.be.true;
          });
        }

        it('finish callback', function () {
          expect(actionSequence.finishedCallback.calledOnce).to.be.true;
        });

      });
    });

  });

});

});

require.register("test/utils/ajax/ajax_queue_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var ajaxQueue;

describe('App.ajaxQueue', function () {

  beforeEach(function() {
    ajaxQueue = App.ajaxQueue.create();
    sinon.spy(ajaxQueue, 'runNextRequest');
    sinon.spy(ajaxQueue, 'finishedCallback');
  });

  afterEach(function() {
    ajaxQueue.clear();
    ajaxQueue.runNextRequest.restore();
    ajaxQueue.finishedCallback.restore();
  });

  describe('#clear', function() {
    it('should clear queue', function() {
      ajaxQueue.addRequest({name:'some', sender: Em.Object.create()});
      ajaxQueue.clear();
      expect(ajaxQueue.get('queue.length')).to.equal(0);
    });
  });

  describe('#addRequest', function() {
    it('should add request', function() {
      ajaxQueue.addRequest({name:'some', sender: Em.Object.create()});
      expect(ajaxQueue.get('queue.length')).to.equal(1);
    });
    it('should throw `name` error', function() {
      expect(function() {ajaxQueue.addRequest({name:'', sender: Em.Object.create()})}).to.throw(Error);
    });
    it('should throw `sender` error', function() {
      expect(function() {ajaxQueue.addRequest({name:'some', sender: {}})}).to.throw(Error);
    });
  });

  describe('#addRequests', function() {
    it('should add requests', function() {
      ajaxQueue.addRequests(Em.A([
        {name:'some', sender: Em.Object.create()},
        {name:'some2', sender: Em.Object.create()}
      ]));
      expect(ajaxQueue.get('queue.length')).to.equal(2);
    });

    it('should throw `name` error', function() {
      expect(function() {ajaxQueue.addRequests(Em.A([
        {name:'some', sender: Em.Object.create()},
        {name:'', sender: Em.Object.create()}
      ]));}).to.throw(Error);
    });

    it('should throw `sender` error', function() {
      expect(function() {ajaxQueue.addRequests(Em.A([
        {name:'some', sender: Em.Object.create()},
        {name:'some2', sender: {}}
      ]));}).to.throw(Error);
    });

  });

  describe('#start', function() {
    it('should call runNextRequest', function() {
      ajaxQueue.start();
      expect(ajaxQueue.runNextRequest.called).to.equal(true);
    });
  });

  describe('#runNextRequest', function() {
    it('for empty queue App.ajax.send shouldn\'t be called', function() {
      ajaxQueue.clear();
      ajaxQueue.runNextRequest();
      expect(App.ajax.send.called).to.equal(false); // eslint-disable-line mocha-cleanup/disallowed-usage
    });
    it('when queue is empty finishedCallback should be called', function() {
      ajaxQueue.clear();
      ajaxQueue.runNextRequest();
      expect(ajaxQueue.finishedCallback.called).to.equal(true);
    });
  });

});

});

require.register("test/utils/ajax/ajax_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/ajax/ajax');

describe('App.ajax', function() {

  beforeEach(function() {
    App.ajax.send.restore();
    sinon.stub(App.logger, 'setTimer');
    sinon.spy(App.ajax, 'send'); // no sense to test stubbed function, so going to spy on it
    App.set('apiPrefix', '/api/v1');
    App.set('clusterName', 'tdk');
  });

  afterEach(function() {
    App.logger.setTimer.restore();
  });

  describe('#send', function() {
    it('Without sender', function() {
      expect(App.ajax.send({})).to.equal(null);
      expect($.ajax.called).to.equal(false);
    });

    it('Invalid config.name', function() {
      expect(App.ajax.send({name:'fake_name', sender: this})).to.equal(null);
      expect($.ajax.called).to.equal(false);
    });

    it('With proper data', function() {
      App.ajax.send({name: 'router.logoff', sender: this});
      expect($.ajax.calledOnce).to.equal(true);
    });

  });

  describe('#formatUrl', function() {

    var tests = [
      {
        url: null,
        data: {},
        e: null,
        m: 'url is null'
      },
      {
        url: 'site/{param}',
        data: null,
        e: 'site/',
        m: 'url with one param, but data is null'
      },
      {
        url: 'clean_url',
        data: {},
        e: 'clean_url',
        m: 'url without placeholders'
      },
      {
        url: 'site/{param}',
        data: {},
        e: 'site/',
        m: 'url with param, but there is no such param in the data'
      },
      {
        url: 'site/{param}/{param}',
        data: {param: 123},
        e: 'site/123/123',
        m: 'url with param which appears two times'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = App.ajax.fakeFormatUrl(test.url, test.data);
        expect(r).to.equal(test.e);
      });
    });
  });

  describe('Check "real" property for each url object', function() {
    var names = App.ajax.fakeGetUrlNames();
    names.forEach(function(name) {
      it('`' + name + '`', function() {
        var url = App.ajax.fakeGetUrl(name);
        expect(url.real).to.be.a('string');
      });
      it('`' + name + '` should not contain spaces', function () {
        var url = App.ajax.fakeGetUrl(name);
        expect(url.real.contains(' ')).to.be.false;
      });
    });
  });

  describe('#formatRequest', function() {

    var tests = [
      {
        urlObj: {
          real: '/real_url',
          format: function() {
            return {
              type: 'PUT'
            }
          }
        },
        data: {},
        m: '',
        e: {type: 'PUT', url: '/api/v1/real_url'}
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        var r = App.ajax.fakeFormatRequest(test.urlObj, test.data);
        expect(r.type).to.equal(test.e.type);
        expect(r.url).to.equal(test.e.url);
      });
    });
  });

  describe("#doGetAsPost()", function () {
    beforeEach(function () {
      sinon.stub(App, 'dateTime').returns(1);
    });
    afterEach(function () {
      App.dateTime.restore();
    });
    it("url does not have '?'", function () {
      var opt = {
        type: 'GET',
        url: '',
        headers: {}
      };
      expect(App.ajax.fakeDoGetAsPost({}, opt)).to.eql({
        type: 'POST',
        url: '?_=1',
        headers: {"X-Http-Method-Override": "GET"}
      });
    });
    it("url has '?params'", function () {
      var opt = {
        type: 'GET',
        url: 'root?params',
        headers: {}
      };
      expect(App.ajax.fakeDoGetAsPost({}, opt)).to.eql({
        type: 'POST',
        url: 'root?_=1',
        headers: {"X-Http-Method-Override": "GET"},
        data: "{\"RequestInfo\":{\"query\":\"params\"}}"
      });
    });
    it("url has '?params&fields'", function () {
      var opt = {
        type: 'GET',
        url: 'root?params&fields',
        headers: {}
      };
      expect(App.ajax.fakeDoGetAsPost({}, opt)).to.eql({
        type: 'POST',
        url: 'root?fields&_=1',
        headers: {"X-Http-Method-Override": "GET"},
        data: "{\"RequestInfo\":{\"query\":\"params\"}}"
      });
    });
  });

  describe('#abortRequests', function () {

    var xhr = {
        abort: Em.K
      },
      requests;

    beforeEach(function () {
      sinon.spy(xhr, 'abort');
      xhr.isForcedAbort = false;
      requests = [xhr, xhr];
      App.ajax.abortRequests(requests);
    });

    afterEach(function () {
      xhr.abort.restore();
    });

    it('should abort all requests', function () {
      expect(xhr.abort.calledTwice).to.be.true;
    });

    it('should mark request as aborted', function () {
      expect(xhr.isForcedAbort).to.be.true;
    });

    it('should clear requests array', function () {
      expect(requests).to.have.length(0);
    });

  });
});

});

require.register("test/utils/array_utils_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var arrayUtils = require('utils/array_utils');

describe('array_utils', function () {

  describe('#uniqObjectsbyId', function () {

    var arr = [
        {
          n: 0,
          v: 'v0'
        },
        {
          n: 0,
          v: 'v01'
        },
        {
          n: 1,
          v: 'v1'
        },
        {
          n: '1',
          v: 'v11'
        },
        {
          n: 2,
          v: 'v2'
        }
      ],
      result = [
        {
          n: 0,
          v: 'v0'
        },
        {
          n: 1,
          v: 'v1'
        },
        {
          n: '1',
          v: 'v11'
        },
        {
          n: 2,
          v: 'v2'
        }
      ];

    it('should return one element for one id', function () {
      expect(arrayUtils.uniqObjectsbyId(arr, 'n').toArray()).to.eql(result);
    });

  });

  describe('#intersect', function () {

    var cases = [
      {
        arr1: [Infinity, 0, 1, 2, {a: 1}, {b: 2}, null, undefined],
        arr2: ['undefined', null, {b: '2'}, {a: 1}, 2.0, '1', 0, Infinity],
        result: [null, 2, 0, Infinity],
        title: 'arrays of the same length have common items'
      },
      {
        arr1: [true, false, [0, 1], [2, 3], [4, 5], [6], null, undefined],
        arr2: [undefined, 'null', 6, [4, 5], ['2', '3'], [String(0), String(1)], '0,1', false, 'true'],
        result: [false, undefined],
        title: 'arrays of different length have common items'
      },
      {
        arr1: ['1', function () {}, NaN],
        arr2: ['function () {}', Number('1'), NaN],
        result: [],
        title: 'arrays have no common items'
      },
      {
        arr1: [[0], undefined, null],
        arr2: [],
        result: [],
        title: 'one of arrays is empty'
      },
      {
        arr1: [],
        arr2: [],
        result: [],
        title: 'both arrays are empty'
      }
    ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        it('arrays intersection', function () {
          expect(arrayUtils.intersect(item.arr1, item.arr2)).to.eql(item.result);
        });

        it('commutativity', function () {
          expect(arrayUtils.intersect(item.arr1, item.arr2).sort()).to.eql(arrayUtils.intersect(item.arr2, item.arr1).sort());
        });

      });

    });

  });

  describe('#sortByIdAsVersion', function () {

    Em.A([
      {
        c: [{id: '1.2.4'}, {id: '1.2.5'}, {id: '1.2.3'}],
        m: 'Items without letters and with same length',
        e: ['1.2.3', '1.2.4', '1.2.5']
      },
      {
        c: [{id: 'HDP-1.2.4'}, {id: 'HDP-1.2.5'}, {id: 'HDP-1.2.3'}],
        m: 'Items with letters and with same length',
        e: ['HDP-1.2.3', 'HDP-1.2.4', 'HDP-1.2.5']
      },
      {
        c: [{id: 'HDP-1.2.4.2'}, {id: 'HDP-1.2.4.1'}, {id: 'HDP-1.2.3'}],
        m: 'Items with letters and with custom length',
        e: ['HDP-1.2.3', 'HDP-1.2.4.1', 'HDP-1.2.4.2']
      },
      {
        c: [{id: 'HDP-1.2.4.2.3'}, {id: 'HDP-1.2.4.11.3'}, {id: 'HDP-1.2.3'}],
        m: 'Items with letters and with double digits',
        e: ['HDP-1.2.3', 'HDP-1.2.4.2.3', 'HDP-1.2.4.11.3']
      },
      {
        c: [{id: 'HDP-1.2.3.2'}, {id: 'HDP-1.2.4'}, {id: 'HDP-1.2.3'}],
        m: 'Items with letters and with custom length (2)',
        e: ['HDP-1.2.3', 'HDP-1.2.3.2', 'HDP-1.2.4']
      },
      {
        c: [{id: 'HDP-1.2.3'}, {id: 'HDP-1.2.4'}, {id: 'HDP-1.2.3'}],
        m: 'Items with letters and equal ids',
        e: ['HDP-1.2.3', 'HDP-1.2.3', 'HDP-1.2.4']
      }
    ]).forEach(function (test) {

      it(test.m, function () {
        expect(test.c.sort(arrayUtils.sortByIdAsVersion).mapProperty('id')).to.be.eql(test.e);
      });

    });

  });

});

});

require.register("test/utils/batch_scheduled_requests_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('utils/helper');
require('views/common/rolling_restart_view');
var batchUtils = require('utils/batch_scheduled_requests');
var modelSetup = require('test/init_model_test');
describe('batch_scheduled_requests', function() {

  beforeEach(function(){
    modelSetup.setupStackServiceComponent();
  });
  afterEach(function(){
    modelSetup.cleanStackServiceComponent();
  });

  describe('#getRollingRestartComponentName', function() {
    var tests = [
      {serviceName: 'HDFS', componentName: 'DATANODE'},
      {serviceName: 'YARN', componentName: 'NODEMANAGER'},
      {serviceName: 'HBASE', componentName: 'HBASE_REGIONSERVER'},
      {serviceName: 'STORM', componentName: 'SUPERVISOR'},
      {serviceName: 'SOME_INVALID_SERVICE', componentName: null}
    ];

    tests.forEach(function(test) {
      it(test.serviceName + ' - ' + test.componentName, function() {
        expect(batchUtils.getRollingRestartComponentName(test.serviceName)).to.equal(test.componentName);
      });
    });

  });

  describe('#getBatchesForRollingRestartRequest', function() {
    var tests = [
      {
        hostComponents: Em.A([
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host1'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host2'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host3'}})
        ]),
        batchSize: 2,
        m: 'DATANODES on three hosts, batchSize = 2',
        e: {
          batchCount: 2
        }
      },
      {
        hostComponents: Em.A([
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host1'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host2'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host3'}})
        ]),
        batchSize: 3,
        m: 'DATANODES on 3 hosts, batchSize = 3',
        e: {
          batchCount: 1
        }
      },
      {
        hostComponents: Em.A([
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host1'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host2'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host3'}})
        ]),
        batchSize: 1,
        m: 'DATANODES on 3 hosts, batchSize = 1',
        e: {
          batchCount: 3
        }
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        expect(batchUtils.getBatchesForRollingRestartRequest(test.hostComponents, test.batchSize).length).to.equal(test.e.batchCount);
      });
    });
  });

  describe('#launchHostComponentRollingRestart', function() {

    beforeEach(function() {
      sinon.spy(batchUtils, 'showRollingRestartPopup');
      sinon.spy(batchUtils, 'showWarningRollingRestartPopup');
      sinon.stub(App, 'get', function(k) {
        if ('components.rollinRestartAllowed' === k) {
          return ['DATANODE', 'TASKTRACKER', 'NODEMANAGER', 'HBASE_REGIONSERVER', 'SUPERVISOR'];
        }
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      batchUtils.showRollingRestartPopup.restore();
      batchUtils.showWarningRollingRestartPopup.restore();
      App.get.restore();
    });

    var tests = Em.A([
      {componentName: 'DATANODE', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'TASKTRACKER', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'NODEMANAGER', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'HBASE_REGIONSERVER', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'SUPERVISOR', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'SOME_OTHER_COMPONENT', e:{showRollingRestartPopup:false, showWarningRollingRestartPopup:true}}
    ]);

    tests.forEach(function(test) {
      it(test.componentName, function() {
        batchUtils.launchHostComponentRollingRestart(test.componentName);
        expect(batchUtils.showRollingRestartPopup.calledOnce).to.equal(test.e.showRollingRestartPopup);
        expect(batchUtils.showWarningRollingRestartPopup.calledOnce).to.equal(test.e.showWarningRollingRestartPopup);
      });
    });

  });

});

});

require.register("test/utils/blueprint_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var blueprintUtils = require('utils/blueprint');

describe('utils/blueprint', function() {
  var masterBlueprint = {
    blueprint: {
      host_groups: [
        {
          name: "host-group-1",
          components: [
            { name: "ZOOKEEPER_SERVER" },
            { name: "NAMENODE" },
            { name: "HBASE_MASTER" }
          ]
        },
        {
          name: "host-group-2",
          components: [
            { name: "SECONDARY_NAMENODE" }
          ]
        }
      ]
    },
    blueprint_cluster_binding: {
      host_groups: [
        {
          name: "host-group-1",
          hosts: [
            { fqdn: "host1" },
            { fqdn: "host2" }
          ]
        },
        {
          name: "host-group-2",
          hosts: [
            { fqdn: "host3" }
          ]
        }
      ]
    }
  };

  var slaveBlueprint = {
    blueprint: {
      host_groups: [
        {
          name: "host-group-1",
          components: [
            { name: "DATANODE" }
          ]
        },
        {
          name: "host-group-2",
          components: [
            { name: "DATANODE" },
            { name: "HDFS_CLIENT" },
            { name: "ZOOKEEPER_CLIENT" }
          ]
        }
      ]
    },
    blueprint_cluster_binding: {
      host_groups: [
        {
          name: "host-group-1",
          hosts: [
            { fqdn: "host3" }
          ]
        },
        {
          name: "host-group-2",
          hosts: [
            { fqdn: "host4" },
            { fqdn: "host5" }
          ]
        }
      ]
    }
  };

  describe('#matchGroups', function() {
    it('should compose same host group into pairs', function() {
      expect(blueprintUtils.matchGroups(masterBlueprint, slaveBlueprint)).to.deep.equal([
        { g1: "host-group-1" },
        { g1: "host-group-2", g2: "host-group-1" },
        { g2: "host-group-2" }
      ]);
    });
  });

  describe('#filterByComponents', function() {
    it('should remove all components except', function() {
      expect(blueprintUtils.filterByComponents(masterBlueprint, ["NAMENODE"])).to.deep.equal({
        blueprint: {
          host_groups: [
            {
              name: "host-group-1",
              components: [
                { name: "NAMENODE" }
              ]
            }
          ]
        },
        blueprint_cluster_binding: {
          host_groups: [
            {
              name: "host-group-1",
              hosts: [
                { fqdn: "host1" },
                { fqdn: "host2" }
              ]
            }
          ]
        }
      });
    });
  });

  describe('#addComponentsToBlueprint', function() {
    it('should add components to blueprint', function() {
      var components = ["FLUME_HANDLER", "HCAT"];
      expect(blueprintUtils.addComponentsToBlueprint(masterBlueprint, components)).to.deep.equal({
        blueprint: {
          host_groups: [
            {
              name: "host-group-1",
              components: [
                { name: "ZOOKEEPER_SERVER" },
                { name: "NAMENODE" },
                { name: "HBASE_MASTER" },
                { name: "FLUME_HANDLER" },
                { name: "HCAT" }
              ]
            },
            {
              name: "host-group-2",
              components: [
                { name: "SECONDARY_NAMENODE" },
                { name: "FLUME_HANDLER" },
                { name: "HCAT" }
              ]
            }
          ]
        },
        blueprint_cluster_binding: {
          host_groups: [
            {
              name: "host-group-1",
              hosts: [
                { fqdn: "host1" },
                { fqdn: "host2" }
              ]
            },
            {
              name: "host-group-2",
              hosts: [
                { fqdn: "host3" }
              ]
            }
          ]
        }
      });
    });
  });

  describe('#mergeBlueprints', function() {
    it('should merge components', function() {
      expect(blueprintUtils.mergeBlueprints(masterBlueprint, slaveBlueprint)).to.deep.equal(
        {
          blueprint: {
            host_groups: [
              {
                name: "host-group-1",
                components: [
                  { name: "ZOOKEEPER_SERVER" },
                  { name: "NAMENODE" },
                  { name: "HBASE_MASTER" }
                ]
              },
              {
                name: "host-group-2",
                components: [
                  { name: "SECONDARY_NAMENODE" },
                  { name: "DATANODE" }
                ]
              },
              {
                name: "host-group-3",
                components: [
                  { name: "DATANODE" },
                  { name: "HDFS_CLIENT" },
                  { name: "ZOOKEEPER_CLIENT" }
                ]
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                name: "host-group-1",
                hosts: [
                  { fqdn: "host1" },
                  { fqdn: "host2" }
                ]
              },
              {
                name: "host-group-2",
                hosts: [
                  { fqdn: "host3" }
                ]
              },
              {
                name: "host-group-3",
                hosts: [
                  { fqdn: "host4" },
                  { fqdn: "host5" }
                ]
              }
            ]
          }
        }
      );
    });
  });

  describe('#buildConfigsJSON', function () {
    var tests = [
      {
        "stepConfigs": [
          Em.Object.create({
            serviceName: "YARN",
            configs: [
              Em.Object.create({
                name: "p1",
                value: "v1",
                filename: "yarn-site.xml",
                isRequiredByAgent: true
              }),
              Em.Object.create({
                name: "p2",
                value: "v2",
                filename: "yarn-site.xml",
                isRequiredByAgent: true
              }),
              Em.Object.create({
                name: "p3",
                value: "v3",
                filename: "yarn-env.xml",
                isRequiredByAgent: true
              })
            ]
          }),
          Em.Object.create({
            serviceName: "MISC",
            configs: [
              Em.Object.create({
                name: "user",
                value: "yarn",
                filename: "yarn-env.xml",
                isRequiredByAgent: true
              })
            ]
          })
        ],
        "configurations": {
          "yarn-site": {
            "properties": {
              "p1": "v1",
              "p2": "v2"
            }
          },
          "yarn-env": {
            "properties": {
              "p3": "v3",
              "user": "yarn"
            }
          }
        }
      }
    ];
    tests.forEach(function (test) {
      it("generate configs for request (use in validation)", function () {
        expect(blueprintUtils.buildConfigsJSON(test.stepConfigs)).to.eql(test.configurations);
      });
    });
  });

  describe('#generateHostGroups()', function () {
    beforeEach(function() {
      sinon.stub(blueprintUtils, 'getComponentForHosts').returns({
        "host1": ["C1", "C2"],
        "host2": ["C1", "C3"]
      });
    });
    afterEach(function() {
      blueprintUtils.getComponentForHosts.restore();
    });

    var tests = [
      {
        "hostNames": ["host1", "host2"],
        "hostComponents": [
          Em.Object.create({
            componentName: "C1",
            hostName: "host1"
          }),
          Em.Object.create({
            componentName: "C2",
            hostName: "host1"
          }),
          Em.Object.create({
            componentName: "C1",
            hostName: "host2"
          }),
          Em.Object.create({
            componentName: "C3",
            hostName: "host2"
          })
        ],
        result: {
          blueprint: {
            host_groups: [
              {
                name: "host-group-1",
                "components": [
                  {
                    "name": "C1"
                  },
                  {
                    "name": "C2"
                  }
                ]
              },
              {
                name: "host-group-2",
                "components": [
                  {
                    "name": "C1"
                  },
                  {
                    "name": "C3"
                  }
                ]
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                "name": "host-group-1",
                "hosts": [
                  {
                    "fqdn": "host1"
                  }
                ]
              },
              {
                "name": "host-group-2",
                "hosts": [
                  {
                    "fqdn": "host2"
                  }
                ]
              }
            ]
          }
        }
      }
    ];
    tests.forEach(function (test) {
      it("generate host groups", function () {
        expect(blueprintUtils.generateHostGroups(test.hostNames)).to.eql(test.result);
      });
    });
  });

  describe("#getComponentForHosts()", function() {
    var res;
    beforeEach(function() {
      sinon.stub(App.ClientComponent, 'find').returns([
        Em.Object.create({
          componentName: "C1",
          hostNames: ["host1", "host2"]
        })
      ]);
      sinon.stub(App.SlaveComponent, 'find').returns([
        Em.Object.create({
          componentName: "C2",
          hostNames: ["host2", "host3"]
        })
      ]);
      sinon.stub(App.MasterComponent, 'find').returns([
        Em.Object.create({
          componentName: "C3",
          hostNames: ["host3"]
        })
      ]);
      res = blueprintUtils.getComponentForHosts();
    });
    afterEach(function() {
      App.ClientComponent.find.restore();
      App.SlaveComponent.find.restore();
      App.MasterComponent.find.restore();
    });

    it('map for 3 items is created', function () {
      expect(Object.keys(res)).to.have.property('length').equal(3);
    });

    it("host1 map is valid", function() {
      expect(res.host1.toArray()).to.eql(['C1']);
    });
    it("host2 map is valid", function() {
      expect(res.host2.toArray()).to.eql(['C1', 'C2']);
    });
    it("host3 map is valid", function() {
      expect(res.host3.toArray()).to.eql(['C2', 'C3']);
    });
  });

  describe('#_generateHostMap', function() {
    it('generate map', function() {
      var map = blueprintUtils._generateHostMap({}, ['h1','h2', 'h1'],'c1');
      expect(map.h1[0]).to.be.equal('c1');
      expect(map.h2[0]).to.be.equal('c1');
    });

    it('skip generations as hosts is empty', function() {
      expect(blueprintUtils._generateHostMap({}, [],'c1')).to.eql({});
    });

    it('skip throws error when data is wrong (should assert error if no data returned from server)', function() {
      expect(function () {
        blueprintUtils._generateHostMap();
      }).to.throw(Error);
    });
  });

  describe('#getHostGroupByFqdn', function() {
    it('should return `null` if blueprint undefined', function() {
      expect(blueprintUtils.getHostGroupByFqdn(undefined, 'host1')).to.be.null;
    });

    it('should return `null` if blueprint not valid', function() {
      expect(blueprintUtils.getHostGroupByFqdn({not_valid_object: {}}, 'host1')).to.be.null;
    });

    it('should find host1-group by host1.name', function() {
      var bp = {
        blueprint_cluster_binding: {
          host_groups: [
            {
              hosts: [
                {fqdn: 'host2.name'}
              ],
              name: 'host2-group'
            },
            {
              hosts: [
                {fqdn: 'host1.name'}
              ],
              name: 'host1-group'
            }
          ]
        }
      };
      expect(blueprintUtils.getHostGroupByFqdn(bp, 'host1.name')).to.be.equal('host1-group');
    });
  });

  describe('#addComponentToHostGroup', function() {
    it('should add new component to host1-group', function() {
      var bp = {
        blueprint: {
          host_groups: [
            {
              components: [
                { name: 'COMPONENT1'}
              ],
              name: 'host1-group'
            }
          ]
        }
      };
      var expected = {
        blueprint: {
          host_groups: [
            {
              components: [
                { name: 'COMPONENT1'},
                { name: 'COMPONENT2'}
              ],
              name: 'host1-group'
            }
          ]
        }
      };
      expect(blueprintUtils.addComponentToHostGroup(bp, 'COMPONENT2', 'host1-group').toString()).to.eql(expected.toString());
    });

    it('should skip adding component since it already in host1-group', function() {
      var bp = {
        blueprint: {
          host_groups: [
            {
              components: [
                { name: 'COMPONENT1'}
              ],
              name: 'host1-group'
            }
          ]
        }
      };
      var expected = {
        blueprint: {
          host_groups: [
            {
              components: [
                { name: 'COMPONENT1'}
              ],
              name: 'host1-group'
            }
          ]
        }
      };
      expect(blueprintUtils.addComponentToHostGroup(bp, 'COMPONENT1', 'host1-group').toString()).to.eql(expected.toString());
    });

    it('should create components attribute and add component to host1-group', function() {
      var bp = {
        blueprint: {
          host_groups: [
            {
              name: 'host1-group'
            }
          ]
        }
      };
      var expected = {
        blueprint: {
          host_groups: [
            {
              components: [
                { name: 'COMPONENT1'}
              ],
              name: 'host1-group'
            }
          ]
        }
      };
      expect(blueprintUtils.addComponentToHostGroup(bp, 'COMPONENT1', 'host1-group').toString()).to.eql(expected.toString());
    });
  });
});

});

require.register("test/utils/config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('config');
require('utils/configs_collection');
require('utils/config');
require('models/service/hdfs');
var setups = require('test/init_model_test');

describe('App.config', function () {

  describe('#trimProperty',function() {
    var testMessage = 'displayType `{0}`, value `{1}`{3} should return `{2}`';
    var tests = [
      {
        config: {
          displayType: 'directory',
          value: ' /a /b /c'
        },
        e: '/a,/b,/c'
      },
      {
        config: {
          displayType: 'directories',
          value: ' /a /b '
        },
        e: '/a,/b'
      },
      {
        config: {
          displayType: 'directories',
          name: 'dfs.datanode.data.dir',
          value: ' [DISK]/a [SSD]/b '
        },
        e: '[DISK]/a,[SSD]/b'
      },
      {
        config: {
          displayType: 'directories',
          name: 'dfs.datanode.data.dir',
          value: '/a,/b, /c\n/d,\n/e  /f'
        },
        e: '/a,/b,/c,/d,/e,/f'
      },
      {
        config: {
          displayType: 'host',
          value: ' localhost '
        },
        e: 'localhost'
      },
      {
        config: {
          displayType: 'password',
          value: ' passw ord '
        },
        e: ' passw ord '
      },
      {
        config: {
          displayType: 'string',
          value: ' value'
        },
        e: ' value'
      },
      {
        config: {
          displayType: 'string',
          value: ' value'
        },
        e: ' value'
      },
      {
        config: {
          displayType: 'string',
          value: 'http://localhost ',
          name: 'javax.jdo.option.ConnectionURL'
        },
        e: 'http://localhost'
      },
      {
        config: {
          displayType: 'string',
          value: 'http://localhost    ',
          name: 'oozie.service.JPAService.jdbc.url'
        },
        e: 'http://localhost'
      },
      {
        config: {
          displayType: 'custom',
          value: ' custom value '
        },
        e: ' custom value'
      },
      {
        config: {
          displayType: 'componentHosts',
          value: ['host1.com', 'host2.com']
        },
        e: ['host1.com', 'host2.com']
      }
    ];

    tests.forEach(function(test) {
      it(testMessage.format(test.config.displayType, test.config.value, test.e, !!test.config.name ? ', name `' + test.config.name + '`' : ''), function() {
        expect(App.config.trimProperty(test.config)).to.eql(test.e);
        expect(App.config.trimProperty(Em.Object.create(test.config), true)).to.eql(test.e);
      });
    });
  });

  describe('#mapCustomStack', function() {
    before(function() {
      setups.setupStackVersion(this, 'HDF-2.2');
    });

    it('versions of HDF > 2.0 should map with HDP 2.3 stack based property definitions', function() {
      var baseStackFolder = App.config.mapCustomStack();
      expect(baseStackFolder).to.equal("HDP2.3");
    });

    it('versions of HDF = 2.0 should map with HDP 2.3 stack based property definitions', function() {
      App.set('currentStackVersion', 'HDF-2.0');
      var baseStackFolder = App.config.mapCustomStack();
      expect(baseStackFolder).to.equal("HDP2.3");
    });


    after(function() {
      setups.restoreStackVersion(this);
    });
  });

  describe('#preDefinedConfigFile', function() {
    before(function() {
      setups.setupStackVersion(this, 'BIGTOP-0.8');
    });

    it('bigtop site properties should be ok.', function() {
      var bigtopSiteProperties = App.config.preDefinedConfigFile('BIGTOP', 'site_properties');
      expect(bigtopSiteProperties).to.be.ok;
    });

    it('a non-existing file should not be ok.', function () {
      var notExistingSiteProperty = App.config.preDefinedConfigFile('notExisting');
      expect(notExistingSiteProperty).to.not.be.ok;
    });

    after(function() {
      setups.restoreStackVersion(this);
    });
  });

  describe('#preDefinedSiteProperties-bigtop', function () {
    before(function() {
      setups.setupStackVersion(this, 'BIGTOP-0.8');
    });

    it('bigtop should use New PostgreSQL Database as its default hive metastore database', function () {
      App.StackService.createRecord({serviceName: 'HIVE'});
      expect(App.config.get('preDefinedSiteProperties').findProperty('recommendedValue', 'New PostgreSQL Database')).to.be.ok;
    });

    after(function() {
      setups.restoreStackVersion(this);
    });
  });

  describe('#generateConfigPropertiesByName', function() {
    var tests = [
      {
        names: ['property_1', 'property_2'],
        properties: undefined,
        e: {
          keys: ['name']
        },
        m: 'Should generate base property object without additional fields'
      },
      {
        names: ['property_1', 'property_2'],
        properties: { category: 'SomeCat', serviceName: 'SERVICE_NAME' },
        e: {
          keys: ['name', 'category', 'serviceName']
        },
        m: 'Should generate base property object without additional fields'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.config.generateConfigPropertiesByName(test.names, test.properties).length).to.eql(test.names.length);
        expect(App.config.generateConfigPropertiesByName(test.names, test.properties).map(function(property) {
          return Em.keys(property);
        }).reduce(function(p, c) {
          return p.concat(c);
        }).uniq()).to.eql(test.e.keys);
      });
    });

  });

  describe('#setPreDefinedServiceConfigs', function() {
    beforeEach(function() {
      sinon.stub(App.StackService, 'find', function() {
        return [
          Em.Object.create({
            id: 'HDFS',
            serviceName: 'HDFS',
            configTypes: {
              'hadoop-env': {},
              'hdfs-site': {}
            }
          }),
          Em.Object.create({
            id: 'OOZIE',
            serviceName: 'OOZIE',
            configTypes: {
              'oozie-env': {},
              'oozie-site': {}
            }
          })
        ];
      });
      App.config.setPreDefinedServiceConfigs(true);
    });
    afterEach(function() {
      App.StackService.find.restore();
    });

    it('should include service MISC', function() {
      expect(App.config.get('preDefinedServiceConfigs').findProperty('serviceName', 'MISC')).to.be.ok;
    });

    it('should include -env config types according to stack services', function() {
      var miscCategory = App.config.get('preDefinedServiceConfigs').findProperty('serviceName', 'MISC');
      expect(Em.keys(miscCategory.get('configTypes'))).to.eql(['cluster-env', 'hadoop-env', 'oozie-env']);
    });
  });
  
  describe('#isManagedMySQLForHiveAllowed', function () {

    var cases = [
      {
        osFamily: 'redhat5',
        expected: false
      },
      {
        osFamily: 'redhat6',
        expected: true
      },
      {
        osFamily: 'suse11',
        expected: false
      }
    ],
      title = 'should be {0} for {1}';

    cases.forEach(function (item) {
      it(title.format(item.expected, item.osFamily), function () {
        expect(App.config.isManagedMySQLForHiveAllowed(item.osFamily)).to.equal(item.expected);
      });
    });

  });

  describe('#shouldSupportFinal', function () {

    var cases = [
      {
        shouldSupportFinal: false,
        title: 'no service name specified'
      },
      {
        serviceName: 's0',
        shouldSupportFinal: false,
        title: 'no filename specified'
      },
      {
        serviceName: 'MISC',
        shouldSupportFinal: false,
        title: 'MISC'
      },
      {
        serviceName: 's0',
        filename: 's0-site',
        shouldSupportFinal: true,
        title: 'final attribute supported'
      },
      {
        serviceName: 's0',
        filename: 's0-env',
        shouldSupportFinal: false,
        title: 'final attribute not supported'
      },
      {
        serviceName: 'Cluster',
        filename: 'krb5-conf.xml',
        shouldSupportFinal: false,
        title: 'kerberos descriptor identities don\'t support final'
      }
    ];

    beforeEach(function () {
      sinon.stub(App.StackService, 'find').returns([
        {
          serviceName: 's0'
        }
      ]);
      sinon.stub(App.config, 'getConfigTypesInfoFromService').returns({
        supportsFinal: ['s0-site']
      });
    });

    afterEach(function () {
      App.StackService.find.restore();
      App.config.getConfigTypesInfoFromService.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(App.config.shouldSupportFinal(item.serviceName, item.filename)).to.equal(item.shouldSupportFinal);
      });
    });

  });

  describe('#shouldSupportAddingForbidden', function () {

    var cases = [
      {
        shouldSupportAddingForbidden: false,
        title: 'no service name specified'
      },
      {
        serviceName: 's0',
        shouldSupportAddingForbidden: false,
        title: 'no filename specified'
      },
      {
        serviceName: 'MISC',
        shouldSupportAddingForbidden: false,
        title: 'MISC'
      },
      {
        serviceName: 's0',
        filename: 's0-site',
        shouldSupportAddingForbidden: true,
        title: 'adding forbidden supported'
      },
      {
        serviceName: 's0',
        filename: 's0-properties',
        shouldSupportAddingForbidden: false,
        title: 'adding forbidden not supported'
      }
    ];

    beforeEach(function () {
      sinon.stub(App.StackService, 'find').returns([
        Em.Object.create({
          serviceName: 's0',
          configTypes: {
            's0-size': {},
            's0-properties': {}
          }
        })
      ]);
      sinon.stub(App.config, 'getConfigTypesInfoFromService').returns({
        supportsAddingForbidden: ['s0-site']
      });
    });

    afterEach(function () {
      App.StackService.find.restore();
      App.config.getConfigTypesInfoFromService.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(App.config.shouldSupportAddingForbidden(item.serviceName, item.filename)).to.equal(item.shouldSupportAddingForbidden);
      });
    });

  });

  describe('#removeRangerConfigs', function () {

    it('should remove ranger configs and categories', function () {
      var configs = [
        Em.Object.create({
          configs: [
            Em.Object.create({filename: 'filename'}),
            Em.Object.create({filename: 'ranger-filename'})
          ],
          configCategories: [
            Em.Object.create({name: 'ranger-name'}),
            Em.Object.create({name: 'name'}),
            Em.Object.create({name: 'also-ranger-name'})
          ]
        })
      ];
      App.config.removeRangerConfigs(configs);
      expect(configs).eql(
          [
            Em.Object.create({
              configs: [
                Em.Object.create({filename: 'filename'})
              ],
              configCategories: [
                Em.Object.create({name: 'name'})
              ]
            })
          ]
      );
    });

  });

  describe("#createOverride", function() {
    var template = {
      name: "p1",
      filename: "f1",
      value: "v1",
      recommendedValue: "rv1",
      savedValue: "sv1",
      isFinal: true,
      recommendedIsFinal: false,
      savedIsFinal: true
    };

    var configProperty = App.ServiceConfigProperty.create(template);

    var group = Em.Object.create({name: "group1", properties: []});

    Object.keys(template).forEach(function (key) {
      it(key, function () {
        var override = App.config.createOverride(configProperty, {}, group);
        if (['savedValue', 'savedIsFinal'].contains(key)) {
          expect(override.get(key)).to.equal(null);
        } else {
          expect(override.get(key)).to.equal(template[key]);
        }
      });
    });

    describe('overrides some values that should be different for override', function() {
      var override;
      beforeEach(function () {
        override = App.config.createOverride(configProperty, {}, group);
      });
      it('isOriginalSCP is false', function () {
        expect(override.get('isOriginalSCP')).to.be.false;
      });
      it('overrides is null', function () {
        expect(override.get('overrides')).to.be.null;
      });
      it('group is valid', function () {
        expect(override.get('group')).to.eql(group);
      });
      it('parentSCP is valid', function () {
        expect(override.get('parentSCP')).to.eql(configProperty);
      });
    });

    var overriddenTemplate = {
      value: "v2",
      recommendedValue: "rv2",
      savedValue: "sv2",
      isFinal: true,
      recommendedIsFinal: false,
      savedIsFinal: true
    };

    Object.keys(overriddenTemplate).forEach(function (key) {
      it('overrides some specific values `' + key + '`', function () {
        var override = App.config.createOverride(configProperty, overriddenTemplate, group);
        expect(override.get(key)).to.equal(overriddenTemplate[key]);
      });
    });

    it('throws error due to undefined configGroup', function() {
      expect(App.config.createOverride.bind(App.config, configProperty, {}, null)).to.throw(App.EmberObjectTypeError);
    });

    it('throws error due to undefined originalSCP', function() {
      expect(App.config.createOverride.bind(App.config, null, {}, group)).to.throw(App.ObjectTypeError);
    });

    describe('updates originalSCP object ', function() {

      var overridenTemplate2;
      var override;

      beforeEach(function () {
        configProperty.set('overrides', null);
        configProperty.set('overrideValues', []);
        configProperty.set('overrideIsFinalValues', []);
        overridenTemplate2 = {
          value: "v12",
          recommendedValue: "rv12",
          savedValue: "sv12",
          isFinal: true,
          recommendedIsFinal: false,
          savedIsFinal: false
        };
        override = App.config.createOverride(configProperty, overridenTemplate2, group);
      });

      it('overrides.0 is valid', function () {
        expect(configProperty.get('overrides')[0]).to.be.eql(override);
      });
      it('overrideValues is valid', function () {
        expect(configProperty.get('overrideValues')).to.be.eql([overridenTemplate2.savedValue]);
      });
      it('overrideIsFinalValues is valid', function () {
        expect(configProperty.get('overrideIsFinalValues')).to.be.eql([overridenTemplate2.savedIsFinal]);
      });

    });

    describe('overrides with empty string values', function () {

      beforeEach(function () {
        configProperty.set('overrides', [
          {
            savedValue: null,
            savedIsFinal: true
          },
          {
            savedValue: '',
            savedIsFinal: false
          },
          {
            savedValue: '1',
            savedIsFinal: false
          }
        ]);
        App.config.createOverride(configProperty, null, group);
      });

      it('values', function () {
        expect(configProperty.get('overrideValues')).to.eql(['', '1']);
      });

      it('isFinal', function () {
        expect(configProperty.get('overrideIsFinalValues')).to.eql([false, false]);
      });

    });
  });

  describe('#getIsSecure', function() {
    var secureConfigs = App.config.get('secureConfigs');
    before(function() {
      App.config.set('secureConfigs', [{name: 'secureConfig'}]);
    });
    after(function() {
      App.config.set('secureConfigs', secureConfigs);
    });

    it('config is secure', function() {
      expect(App.config.getIsSecure('secureConfig')).to.equal(true);
    });
    it('config is not secure', function() {
      expect(App.config.getIsSecure('NotSecureConfig')).to.equal(false);
    });
  });

  describe('#getDefaultCategory', function() {
    it('returns custom category', function() {
      expect(App.config.getDefaultCategory(null, 'filename.xml')).to.equal('Custom filename');
    });
    it('returns advanced category', function() {
      expect(App.config.getDefaultCategory(Em.Object.create, 'filename.xml')).to.equal('Advanced filename');
    });
  });

  describe('#getDefaultDisplayType', function() {
    it('returns singleLine displayType', function() {
      expect(App.config.getDefaultDisplayType('v1')).to.equal('string');
    });
    it('returns multiLine displayType', function() {
      expect(App.config.getDefaultDisplayType('v1\nv2')).to.equal('multiLine');
    });
  });

  describe('#formatValue', function() {
    it('formatValue for componentHosts', function () {
      var serviceConfigProperty = Em.Object.create({'displayType': 'componentHosts', value: "['h1','h2']"});
      expect(App.config.formatPropertyValue(serviceConfigProperty)).to.eql(['h1','h2']);
    });

    it('formatValue for int', function () {
      var serviceConfigProperty = Em.Object.create({'displayType': 'int', value: '4.0'});
      expect(App.config.formatPropertyValue(serviceConfigProperty)).to.equal('4');
    });

    it('formatValue for int with m', function () {
      var serviceConfigProperty = Em.Object.create({'displayType': 'int', value: '4m'});
      expect(App.config.formatPropertyValue(serviceConfigProperty)).to.equal('4');
    });

    it('formatValue for float', function () {
      var serviceConfigProperty = Em.Object.create({'displayType': 'float', value: '0.40'});
      expect(App.config.formatPropertyValue(serviceConfigProperty)).to.equal('0.4');
    });

    it('formatValue for kdc_type', function () {
      var serviceConfigProperty = Em.Object.create({'name': 'kdc_type', value: 'mit-kdc'});
      expect(App.config.formatPropertyValue(serviceConfigProperty)).to.equal(Em.I18n.t('admin.kerberos.wizard.step1.option.kdc'));
    });

    it('don\'t format value', function () {
      var serviceConfigProperty = Em.Object.create({'name': 'any', displayType: 'any', value: 'any'});
      expect(App.config.formatPropertyValue(serviceConfigProperty)).to.equal('any');
    });
  });

  describe('#getPropertyIfExists', function() {
    [
      {
        propertyName: 'someProperty',
        defaultValue: 'default',
        firstObject: { someProperty: '1' },
        secondObject: { someProperty: '2' },
        res: '1',
        m: 'use value from first object'
      },
      {
        propertyName: 'someProperty',
        defaultValue: 'default',
        firstObject: { someOtherProperty: '1' },
        secondObject: { someProperty: '2' },
        res: '2',
        m: 'use value from second object'
      },
      {
        propertyName: 'someProperty',
        defaultValue: 'default',
        firstObject: { someOtherProperty: '1' },
        secondObject: { someOtherProperty: '2' },
        res: 'default',
        m: 'use default value'
      },
      {
        propertyName: 'someProperty',
        defaultValue: 'default',
        res: 'default',
        m: 'use default value'
      },
      {
        propertyName: 'someProperty',
        defaultValue: true,
        firstObject: { someProperty: false },
        secondObject: { someProperty: true },
        res: false,
        m: 'use value from first object, check booleans'
      },
      {
        propertyName: 'someProperty',
        defaultValue: true,
        firstObject: { someProperty: 0 },
        secondObject: { someProperty: 1 },
        res: 0,
        m: 'use value from first object, check 0'
      },
      {
        propertyName: 'someProperty',
        defaultValue: true,
        firstObject: { someProperty: '' },
        secondObject: { someProperty: '1' },
        res: '',
        m: 'use value from first object, check empty string'
      }
    ].forEach(function (t) {
        it(t.m, function () {
          expect(App.config.getPropertyIfExists(t.propertyName, t.defaultValue, t.firstObject, t.secondObject)).to.equal(t.res);
        })
      });
  });

  describe('#createDefaultConfig', function() {
    before(function() {
      sinon.stub(App.config, 'getDefaultDisplayType', function() {
        return 'pDisplayType';
      });
      sinon.stub(App.config, 'getDefaultCategory', function() {
        return 'pCategory';
      });
      sinon.stub(App.config, 'getIsSecure', function() {
        return false;
      });
      sinon.stub(App.config, 'shouldSupportFinal', function() {
        return true;
      });
      sinon.stub(App.config, 'get', function(param) {
        if (param === 'serviceByConfigTypeMap') {
          return { 'pFileName': Em.Object.create({serviceName: 'pServiceName' }) };
        }
        return Em.get(App.config, param);
      });
    });

    after(function() {
      App.config.getDefaultDisplayType.restore();
      App.config.getDefaultCategory.restore();
      App.config.getIsSecure.restore();
      App.config.shouldSupportFinal.restore();
      App.config.get.restore();
    });

    var res = {
      /** core properties **/
      id: 'pName__pFileName',
      name: 'pName',
      filename: 'pFileName.xml',
      value: '',
      savedValue: null,
      isFinal: false,
      savedIsFinal: null,
      /** UI and Stack properties **/
      recommendedValue: null,
      recommendedIsFinal: null,
      supportsFinal: true,
      supportsAddingForbidden: false,
      serviceName: 'pServiceName',
      displayName: 'pName',
      displayType: 'pDisplayType',
      description: '',
      category: 'pCategory',
      isSecureConfig: false,
      showLabel: true,
      isVisible: true,
      isUserProperty: false,
      isRequired: true,
      group: null,
      isRequiredByAgent:  true,
      isReconfigurable: true,
      unit: null,
      hasInitialValue: false,
      isOverridable: true,
      index: Infinity,
      dependentConfigPattern: null,
      options: null,
      radioName: null,
      widgetType: null,
      errorMessage: '',
      warnMessage: ''
    };
    it('create default config object', function () {
      expect(App.config.createDefaultConfig('pName', 'pFileName', true)).to.eql(res);
    });
    it('getDefaultDisplayType is called', function() {
      expect(App.config.getDefaultDisplayType.called).to.be.true;
    });
    it('getDefaultCategory is called with correct arguments', function() {
      expect(App.config.getDefaultCategory.calledWith(true, 'pFileName')).to.be.true;
    });
    it('getIsSecure is called with correct arguments', function() {
      expect(App.config.getIsSecure.calledWith('pName')).to.be.true;
    });
    it('shouldSupportFinal is called with correct arguments', function() {
      expect(App.config.shouldSupportFinal.calledWith('pServiceName', 'pFileName')).to.be.true;
    });
  });

  describe('#mergeStackConfigsWithUI', function() {
    beforeEach(function() {
      sinon.stub(App.config, 'getPropertyIfExists', function(key, value) {return 'res_' + value});
    });

    afterEach(function() {
      App.config.getPropertyIfExists.restore();
    });

    var template = {
      name: 'pName',
      filename: 'pFileName',
      value: 'pValue',
      savedValue: 'pValue',
      isFinal: true,
      savedIsFinal: true,

      serviceName: 'pServiceName',
      displayName: 'pDisplayName',
      displayType: 'pDisplayType',
      category: 'pCategory'
    };

    var result = {
      name: 'pName',
      filename: 'pFileName',
      value: 'pValue',
      savedValue: 'pValue',
      isFinal: true,
      savedIsFinal: true,

      serviceName: 'res_pServiceName',
      displayName: 'res_pDisplayName',
      displayType: 'res_pDisplayType',
      category: 'res_pCategory'
    };

    it('called generate property object', function () {
      expect(App.config.mergeStaticProperties(template, {}, {})).to.eql(result);
    });
  });

  describe('#updateHostsListValue', function() {
    var tests = [
      {
        siteConfigs: {
          'hadoop.registry.zk.quorum': 'host1,host2'
        },
        propertyName: 'hadoop.registry.zk.quorum',
        propertyType: 'yarn-site',
        hostsList: 'host1',
        e: 'host1'
      },
      {
        siteConfigs: {
          'hadoop.registry.zk.quorum': 'host1:10,host2:10'
        },
        propertyName: 'hadoop.registry.zk.quorum',
        propertyType: 'yarn-site',
        hostsList: 'host2:10,host1:10',
        e: 'host1:10,host2:10'
      },
      {
        siteConfigs: {
          'hadoop.registry.zk.quorum': 'host1:10,host2:10,host3:10'
        },
        propertyName: 'hadoop.registry.zk.quorum',
        propertyType: 'yarn-site',
        hostsList: 'host2:10,host1:10',
        e: 'host2:10,host1:10'
      },
      {
        siteConfigs: {
          'hadoop.registry.zk.quorum': 'host1:10,host2:10,host3:10'
        },
        propertyName: 'hadoop.registry.zk.quorum',
        propertyType: 'yarn-site',
        hostsList: 'host2:10,host1:10,host3:10,host4:11',
        e: 'host2:10,host1:10,host3:10,host4:11'
      },
      {
        siteConfigs: {
          'hive.zookeeper.quorum': 'host1'
        },
        propertyName: 'some.new.property',
        propertyType: 'hive-site',
        hostsList: 'host2,host1:10',
        e: 'host2,host1:10'
      },
      {
        siteConfigs: {
          'some.new.property': '[\'host1\',\'host2\']'
        },
        propertyName: 'some.new.property',
        propertyType: 'property-type',
        hostsList: '[\'host1\',\'host2\']',
        isArray: true,
        e: '[\'host1\',\'host2\']',
        message: 'array-formatted property value with no changes'
      },
      {
        siteConfigs: {
          'some.new.property': '[\'host2\',\'host1\']'
        },
        propertyName: 'some.new.property',
        propertyType: 'property-type',
        hostsList: '[\'host1\',\'host2\']',
        isArray: true,
        e: '[\'host2\',\'host1\']',
        message: 'array-formatted property value with different hosts order'
      },
      {
        siteConfigs: {
          'some.new.property': '[\'host1\',\'host2\']'
        },
        propertyName: 'some.new.property',
        propertyType: 'property-type',
        hostsList: '[\'host3\',\'host4\']',
        isArray: true,
        e: '[\'host3\',\'host4\']',
        message: 'array-formatted property value with changes'
      },
      {
        siteConfigs: {
          'templeton.hive.properties': 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9083\\,thrift://host2:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true'
        },
        propertyName: 'templeton.hive.properties',
        propertyType: 'webhcat-site',
        hostsList: 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9083\\,thrift://host2:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true',
        e: 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9083\\,thrift://host2:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true',
        message: 'templeton.hive.properties, no changes'
      },
      {
        siteConfigs: {
          'templeton.hive.properties': 'hive.metastore.local=false,hive.metastore.uris=thrift://host2:9083\\,thrift://host1:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true'
        },
        propertyName: 'templeton.hive.properties',
        propertyType: 'webhcat-site',
        hostsList: 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9083\\,thrift://host2:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true',
        e: 'hive.metastore.local=false,hive.metastore.uris=thrift://host2:9083\\,thrift://host1:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true',
        message: 'templeton.hive.properties, different hosts order'
      },
      {
        siteConfigs: {
          'templeton.hive.properties': 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9082\\,thrift://host2:9082,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true'
        },
        propertyName: 'templeton.hive.properties',
        propertyType: 'webhcat-site',
        hostsList: 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9083\\,thrift://host2:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true',
        e: 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9083\\,thrift://host2:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true',
        message: 'templeton.hive.properties, different ports'
      },
      {
        siteConfigs: {
          'templeton.hive.properties': 'hive.metastore.local=false,hive.metastore.uris=thrift://host1:9083\\,thrift://host2:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true'
        },
        propertyName: 'templeton.hive.properties',
        propertyType: 'webhcat-site',
        hostsList: 'hive.metastore.local=false,hive.metastore.uris=thrift://host3:9083\\,thrift://host4:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true',
        e: 'hive.metastore.local=false,hive.metastore.uris=thrift://host3:9083\\,thrift://host4:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true',
        message: 'templeton.hive.properties, different hosts'
      },
      {
        siteConfigs: {
          'templeton.hive.properties': 'hive.metastore.local=false'
        },
        propertyName: 'templeton.hive.properties',
        propertyType: 'hive-site',
        hostsList: 'hive.metastore.local=true',
        e: 'hive.metastore.local=true',
        message: 'custom templeton.hive.properties'
      }
    ];

    tests.forEach(function(test) {
      var message = test.message
        || 'ZK located on {0}, current prop value is "{1}" "{2}" value should be "{3}"'
          .format(test.hostsList, ''+test.siteConfigs[test.propertyName], test.propertyName, test.e);

      describe(message, function () {
        var result;

        beforeEach(function () {
          result = App.config.updateHostsListValue(test.siteConfigs, test.propertyType, test.propertyName, test.hostsList, test.isArray);
        });

        it('returned value', function() {
          expect(result).to.be.eql(test.e);
        });

        it('value in configs object', function() {
          expect(test.siteConfigs[test.propertyName]).to.be.eql(test.e);
        });
      });
    });
  });

  describe('#createHostNameProperty', function () {
    it('create host property', function () {
      expect(App.config.createHostNameProperty('service1', 'component1', ['host1'], Em.Object.create({
        isMultipleAllowed: false,
        displayName: 'display name'
      }))).to.eql({
            "id": 'component1_host__service1-site',
            "name": 'component1_host',
            "displayName": 'display name host',
            "value": ['host1'],
            "recommendedValue": ['host1'],
            "description": "The host that has been assigned to run display name",
            "displayType": "componentHost",
            "isOverridable": false,
            "isRequiredByAgent": false,
            "serviceName": 'service1',
            "filename": "service1-site.xml",
            "category": 'component1',
            "index": 0
          })
    });

    it('create hosts property', function () {
      expect(App.config.createHostNameProperty('service1', 'component1', ['host1'], Em.Object.create({
        isMultipleAllowed: true,
        displayName: 'display name'
      }))).to.eql({
            "id": 'component1_hosts__service1-site',
            "name": 'component1_hosts',
            "displayName": 'display name host',
            "value": ['host1'],
            "recommendedValue": ['host1'],
            "description": "The hosts that has been assigned to run display name",
            "displayType": "componentHosts",
            "isOverridable": false,
            "isRequiredByAgent": false,
            "serviceName": 'service1',
            "filename": "service1-site.xml",
            "category": 'component1',
            "index": 0
          })
    });
  });

  describe("#truncateGroupName()", function() {

    it("name is empty", function() {
      expect(App.config.truncateGroupName('')).to.be.empty;
    });

    it("name has less than max chars", function() {
      expect(App.config.truncateGroupName('group1')).to.equal('group1');
    });

    it("name has more than max chars", function() {
      expect(App.config.truncateGroupName('group_has_more_than_max_characters')).to.equal('group_has...haracters');
    });
  });

  describe('#getComponentName', function () {
    [
      { configName: 'somename_host', componentName: 'SOMENAME' },
      { configName: 'somename_hosts', componentName: 'SOMENAME' },
      { configName: 'somenamehost', componentName: '' },
      { configName: 'somenamehosts', componentName: '' }
    ].forEach(function (t) {
      it('format config name ' + t.configName + ' to component ', function() {
        expect(App.config.getComponentName(t.configName)).to.equal(t.componentName);
      });
    });
  });

  describe('#getDescription', function () {

    it('should add extra-message to the description for `password`-configs', function () {
      var extraMessage = Em.I18n.t('services.service.config.password.additionalDescription');
      expect(App.config.getDescription('', 'password')).to.contain(extraMessage);
    });

    it('should not add extra-message to the description if it already contains it', function () {

      var extraMessage = Em.I18n.t('services.service.config.password.additionalDescription');
      var res = App.config.getDescription(extraMessage, 'password');
      expect(res).to.contain(extraMessage);
      expect(res).to.contain(extraMessage);
      var subd = res.replace(extraMessage, '');
      expect(subd).to.not.contain(extraMessage);
    });

    it('should add extra-message to the description if description is not defined', function () {

      var extraMessage = Em.I18n.t('services.service.config.password.additionalDescription');
      expect(App.config.getDescription(undefined, 'password')).to.contain(extraMessage);
    });

  });

  describe('#parseIdentities', function() {
    var testObject = {
      identities: [
        {
          name: "/spnego"
        },
        {
          principal: {
            configuration: "hbase-env/hbase_principal_name",
            type: "user",
            local_username: "${hbase-env/hbase_user}",
            value: "${hbase-env/hbase_user}-${cluster_name|toLower()}@${realm}"
          },
          name: "hbase",
          keytab: {
            owner: {
              access: "r",
              name: "${hbase-env/hbase_user}"
            },
            file: "${keytab_dir}/hbase.headless.keytab",
            configuration: "hbase-env/hbase_user_keytab",
            group: {
              access: "r",
              name: "${cluster-env/user_group}"
            }
          }
        },
        {
          name: "/smokeuser"
        }
      ]
    };
    var result = {
      "hbase_principal_name__hbase-env": true,
      "hbase_user_keytab__hbase-env": true
    };

    it('generates map with identities', function() {
      expect(App.config.parseIdentities(testObject, {})).to.eql(result);
    });
  });

  describe('#kerberosIdentitiesDescription', function () {
    it('update empty description', function() {
      expect(App.config.kerberosIdentitiesDescription()).to.eql(Em.I18n.t('services.service.config.secure.additionalDescription'));
    });

    it('update description for identities (without dot)', function() {
      expect(App.config.kerberosIdentitiesDescription('some text')).to.eql('some text. '
        + Em.I18n.t('services.service.config.secure.additionalDescription'));
    });

    it('update description for identities (with dot)', function() {
      expect(App.config.kerberosIdentitiesDescription('some text.')).to.eql('some text. '
        + Em.I18n.t('services.service.config.secure.additionalDescription'));
    });

    it('update description for identities (with dot and spaces at the end)', function() {
      expect(App.config.kerberosIdentitiesDescription('some text. ')).to.eql('some text. '
        + Em.I18n.t('services.service.config.secure.additionalDescription'));
    });
  });

  describe('#getTempletonHiveHosts', function () {
    var testCases = [
      {
        value: 'hive.metastore.local=false,hive.metastore.uris=thrift://host0:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true',
        result: ['thrift://host0:9083'],
        message: 'one host'
      },
      {
        value: 'hive.metastore.local=false,hive.metastore.uris=thrift://host0:9083\\,thrift://host1:9083\\,thrift://host2:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true',
        result: ['thrift://host0:9083', 'thrift://host1:9083', 'thrift://host2:9083'],
        message: 'several hosts'
      },
      {
        value: 'thrift://host0:9083\\,thrift://host1:9083\\,thrift://host2:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true',
        result: ['thrift://host0:9083', 'thrift://host1:9083', 'thrift://host2:9083'],
        message: 'no leading text'
      },
      {
        value: 'hive.metastore.local=false,hive.metastore.uris=thrift://host0:9083\\,thrift://host1:9083\\,thrift://host2:9083',
        result: ['thrift://host0:9083', 'thrift://host1:9083', 'thrift://host2:9083'],
        message: 'no trailing text'
      },
      {
        value: 'hive.metastore.local=false',
        result: 'hive.metastore.local=false',
        message: 'no hosts list'
      }
    ];

    testCases.forEach(function (test) {
      it(test.message, function () {
        expect(App.config.getTempletonHiveHosts(test.value)).to.eql(test.result);
      });
    });
  });
});

});

require.register("test/utils/configs/config_initializer_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/configs/objects/service_config_property');
require('utils/configs/config_initializer');

var serviceConfigProperty;

describe('App.ConfigInitializer', function () {

  beforeEach(function () {
    serviceConfigProperty = App.ServiceConfigProperty.create();
  });

  describe('#setRecommendedValue', function () {
    it('should change the recommended value', function () {
      serviceConfigProperty.set('recommendedValue', 'value0');
      App.ConfigInitializer.setRecommendedValue(serviceConfigProperty, /\d/, '1');
      expect(serviceConfigProperty.get('recommendedValue')).to.equal('value1');
    });
  });

  describe('#initialValue', function () {

    var cases = {
      'kafka.ganglia.metrics.host': [
        {
          message: 'kafka.ganglia.metrics.host property should have the value of ganglia hostname when ganglia is selected',
          localDB: {
            masterComponentHosts: [
              {
                component: 'GANGLIA_SERVER',
                hostName: 'c6401'
              }
            ]
          },
          expected: 'c6401'
        },
        {
          message: 'kafka.ganglia.metrics.host property should have the value "localhost" when ganglia is not selected',
          localDB: {
            masterComponentHosts: [
              {
                component: 'NAMENODE',
                hostName: 'c6401'
              }
            ]
          },
          expected: 'localhost'
        }
      ],
      'hive_database': [
        {
          alwaysEnableManagedMySQLForHive: true,
          currentStateName: '',
          isManagedMySQLForHiveEnabled: false,
          receivedValue: 'New MySQL Database',
          value: 'New MySQL Database',
          options: [
            {
              displayName: 'New MySQL Database'
            }
          ],
          hidden: false
        },
        {
          alwaysEnableManagedMySQLForHive: false,
          currentStateName: 'configs',
          isManagedMySQLForHiveEnabled: false,
          receivedValue: 'New MySQL Database',
          value: 'New MySQL Database',
          options: [
            {
              displayName: 'New MySQL Database'
            }
          ],
          hidden: false
        },
        {
          alwaysEnableManagedMySQLForHive: false,
          currentStateName: '',
          isManagedMySQLForHiveEnabled: true,
          receivedValue: 'New MySQL Database',
          value: 'New MySQL Database',
          options: [
            {
              displayName: 'New MySQL Database'
            }
          ],
          hidden: false
        },
        {
          alwaysEnableManagedMySQLForHive: false,
          currentStateName: '',
          isManagedMySQLForHiveEnabled: false,
          receivedValue: 'New MySQL Database',
          value: 'Existing MySQL Database',
          options: [
            {
              displayName: 'New MySQL Database'
            }
          ],
          hidden: true
        },
        {
          alwaysEnableManagedMySQLForHive: false,
          currentStateName: '',
          isManagedMySQLForHiveEnabled: false,
          receivedValue: 'New PostgreSQL Database',
          value: 'New PostgreSQL Database',
          options: [
            {
              displayName: 'New MySQL Database'
            }
          ],
          hidden: true
        }
      ],
      'hbase.zookeeper.quorum': [
        {
          filename: 'hbase-site.xml',
          value: 'host0,host1',
          recommendedValue: 'host0,host1',
          title: 'should set ZooKeeper Server hostnames'
        },
        {
          filename: 'ams-hbase-site.xml',
          value: 'localhost',
          recommendedValue: null,
          title: 'should ignore ZooKeeper Server hostnames'
        }
      ],
      'hivemetastore_host': {
        localDB: {
          masterComponentHosts: [
            {
              component: 'HIVE_METASTORE',
              hostName: 'h0'
            },
            {
              component: 'HIVE_METASTORE',
              hostName: 'h1'
            }
          ]
        },
        value: ['h0', 'h1'],
        title: 'array that contains names of hosts with Hive Metastore'
      },
      'hive_master_hosts': {
        localDB: {
          masterComponentHosts: [
            {
              component: 'HIVE_SERVER',
              hostName: 'h0'
            },
            {
              component: 'HIVE_METASTORE',
              hostName: 'h0'
            },
            {
              component: 'HIVE_METASTORE',
              hostName: 'h1'
            },
            {
              component: 'WEBHCAT_SERVER',
              hostName: 'h2'
            }
          ]
        },
        value: 'h0,h1',
        title: 'comma separated list of hosts with Hive Server and Metastore'
      },
      'hive.metastore.uris': {
        localDB: {
          masterComponentHosts: [
            {
              component: 'HIVE_METASTORE',
              hostName: 'h0'
            },
            {
              component: 'HIVE_METASTORE',
              hostName: 'h1'
            }
          ]
        },
        dependencies: {
          'hive.metastore.uris': 'thrift://localhost:9083'
        },
        filename: 'hive-site.xml',
        recommendedValue: 'thrift://localhost:9083',
        value: 'thrift://h0:9083,thrift://h1:9083',
        title: 'comma separated list of Metastore hosts with thrift prefix and port'
      },
      'templeton.hive.properties': {
        localDB: {
          masterComponentHosts: [
            {
              component: 'HIVE_METASTORE',
              hostName: 'h0'
            },
            {
              component: 'HIVE_METASTORE',
              hostName: 'h1'
            }
          ]
        },
        dependencies: {
          'hive.metastore.uris': 'thrift://localhost:9083'
        },
        recommendedValue: 'hive.metastore.local=false,hive.metastore.uris=thrift://localhost:9083,hive.metastore.sasl.enabled=false',
        value: 'hive.metastore.local=false,hive.metastore.uris=thrift://h0:9083\\,thrift://h1:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true',
        title: 'should add relevant hive.metastore.uris value'
      },
      'yarn.resourcemanager.zk-address': {
        localDB: {
          masterComponentHosts: [
            {
              component: 'ZOOKEEPER_SERVER',
              hostName: 'h0'
            },
            {
              component: 'ZOOKEEPER_SERVER',
              hostName: 'h1'
            }
          ]
        },
        dependencies: {
          clientPort: '2182'
        },
        recommendedValue: 'localhost:2181',
        value: 'h0:2182,h1:2182',
        title: 'should add ZK host and port dynamically'
      },
      'knox_gateway_host': {
        localDB: {
          masterComponentHosts: [
            {
              component: 'KNOX_GATEWAY',
              hostName: 'h0'
            },
            {
              component: 'KNOX_GATEWAY',
              hostName: 'h1'
            }
          ]
        },
        value: ['h0', 'h1'],
        title: 'array that contains names of hosts with Knox Gateway'
      },
      'atlas.rest.address': [
        {
          localDB: {
            masterComponentHosts: [
              {
                component: 'ZOOKEEPER_SERVER',
                hostName: 'h0'
              },
              {
                component: 'ZOOKEEPER_SERVER',
                hostName: 'h1'
              }
            ]
          },
          dependencies: {
            'atlas.enableTLS': false,
            'atlas.server.http.port': 21000,
            'atlas.server.https.port': 21443
          },
          value: 'http://h0:21000,http://h1:21000',
          title: 'TLS is not enabled'
        },
        {
          localDB: {
            masterComponentHosts: [
              {
                component: 'ZOOKEEPER_SERVER',
                hostName: 'h0'
              },
              {
                component: 'ZOOKEEPER_SERVER',
                hostName: 'h1'
              }
            ]
          },
          dependencies: {
            'atlas.enableTLS': true,
            'atlas.server.http.port': 21000,
            'atlas.server.https.port': 21443
          },
          value: 'https://h0:21443,https://h1:21443',
          title: 'TLS is enabled'
        }
      ]
    };

    cases['atlas.rest.address'].forEach(function (test) {
      it(test.title, function () {
        serviceConfigProperty.setProperties({
          name: 'atlas.rest.address',
          value: ''
        });
        App.ConfigInitializer.initialValue(serviceConfigProperty, test.localDB, test.dependencies);
        expect(serviceConfigProperty.get('value')).to.equal(test.value);
        expect(serviceConfigProperty.get('recommendedValue')).to.equal(test.value);
      });
    });

    cases['kafka.ganglia.metrics.host'].forEach(function (item) {
      it(item.message, function () {
        serviceConfigProperty.setProperties({
          name: 'kafka.ganglia.metrics.host',
          value: 'localhost'
        });
        App.ConfigInitializer.initialValue(serviceConfigProperty, item.localDB, []);
        expect(serviceConfigProperty.get('value')).to.equal(item.expected);
      });
    });

    describe('hive_database', function () {

      beforeEach(function () {
        this.stub = sinon.stub(App, 'get');
      });

      afterEach(function () {
        App.get.restore();
      });

      cases.hive_database.forEach(function (item) {
        var title = 'hive_database value should be set to {0}';
        describe(title.format(item.value), function () {

          beforeEach(function () {
            this.stub
              .withArgs('supports.alwaysEnableManagedMySQLForHive').returns(item.alwaysEnableManagedMySQLForHive)
              .withArgs('router.currentState.name').returns(item.currentStateName)
              .withArgs('isManagedMySQLForHiveEnabled').returns(item.isManagedMySQLForHiveEnabled);
            serviceConfigProperty.setProperties({
              name: 'hive_database',
              value: item.receivedValue,
              options: item.options
            });
            App.ConfigInitializer.initialValue(serviceConfigProperty, {}, []);
          });

          it('value is ' + item.value, function () {
            expect(serviceConfigProperty.get('value')).to.equal(item.value);
          });

          it('`New MySQL Database` is ' + (item.hidden ? '' : 'not') + ' hidden', function () {
            expect(serviceConfigProperty.get('options').findProperty('displayName', 'New MySQL Database').hidden).to.equal(item.hidden);
          });

        });
      });

    });

    cases['hbase.zookeeper.quorum'].forEach(function (item) {
      it(item.title, function () {
        serviceConfigProperty.setProperties({
          name: 'hbase.zookeeper.quorum',
          value: 'localhost',
          'filename': item.filename
        });
        App.ConfigInitializer.initialValue(serviceConfigProperty, {
          masterComponentHosts: {
            filterProperty: function () {
              return {
                mapProperty: function () {
                  return ['host0', 'host1'];
                }
              };
            }
          }
        }, []);
        expect(serviceConfigProperty.get('value')).to.equal(item.value);
        expect(serviceConfigProperty.get('recommendedValue')).to.equal(item.recommendedValue);
      });
    });

    it(cases.hive_master_hosts.title, function () {
      serviceConfigProperty.set('name', 'hive_master_hosts');
      App.ConfigInitializer.initialValue(serviceConfigProperty, cases.hive_master_hosts.localDB, []);
      expect(serviceConfigProperty.get('value')).to.equal(cases.hive_master_hosts.value);
    });

    it(cases['hive.metastore.uris'].title, function () {
      serviceConfigProperty.setProperties({
        name: 'hive.metastore.uris',
        recommendedValue: cases['hive.metastore.uris'].recommendedValue,
        filename: 'hive-site.xml'
      });
      App.ConfigInitializer.initialValue(serviceConfigProperty, cases['hive.metastore.uris'].localDB, {'hive.metastore.uris': cases['hive.metastore.uris'].recommendedValue});
      expect(serviceConfigProperty.get('value')).to.equal(cases['hive.metastore.uris'].value);
      expect(serviceConfigProperty.get('recommendedValue')).to.equal(cases['hive.metastore.uris'].value);
    });

    it(cases['templeton.hive.properties'].title, function () {
      serviceConfigProperty.setProperties({
        name: 'templeton.hive.properties',
        recommendedValue: cases['templeton.hive.properties'].recommendedValue,
        value: cases['templeton.hive.properties'].recommendedValue
      });
      App.ConfigInitializer.initialValue(serviceConfigProperty, cases['templeton.hive.properties'].localDB, {'hive.metastore.uris': cases['templeton.hive.properties'].recommendedValue});
      expect(serviceConfigProperty.get('value')).to.equal(cases['templeton.hive.properties'].value);
      expect(serviceConfigProperty.get('recommendedValue')).to.equal(cases['templeton.hive.properties'].value);
    });

    it(cases['yarn.resourcemanager.zk-address'].title, function () {
      serviceConfigProperty.setProperties({
        name: 'yarn.resourcemanager.zk-address',
        recommendedValue: cases['yarn.resourcemanager.zk-address'].recommendedValue
      });
      App.ConfigInitializer.initialValue(serviceConfigProperty, cases['yarn.resourcemanager.zk-address'].localDB, cases['yarn.resourcemanager.zk-address'].dependencies);
      expect(serviceConfigProperty.get('value')).to.equal(cases['yarn.resourcemanager.zk-address'].value);
      expect(serviceConfigProperty.get('recommendedValue')).to.equal(cases['yarn.resourcemanager.zk-address'].value);
    });

    function getLocalDBForSingleComponent(component) {
      return {
        masterComponentHosts: [
          {
            component: component,
            hostName: 'h1'
          },
          {
            component: 'FAKE_COMPONENT',
            hostName: 'FAKE_HOST'
          }
        ]
      };
    }

    function getLocalDBForMultipleComponents(component, count) {
      var ret = {
        masterComponentHosts: [{
          component: 'FAKE_COMPONENT',
          hostName: 'FAKE_HOST'
        }]
      };
      for (var i = 1; i <= count; i++) {
        ret.masterComponentHosts.push({
          component: component,
          hostName: 'h' + i
        })
      }
      return ret;
    }

    Em.A([
      {
        config: 'dfs.namenode.rpc-address',
        localDB: getLocalDBForSingleComponent('NAMENODE'),
        rValue: 'c6401.ambari.apache.org:8020',
        expectedValue: 'h1:8020'
      },
      {
        config: 'dfs.http.address',
        localDB: getLocalDBForSingleComponent('NAMENODE'),
        rValue: 'c6401.ambari.apache.org:8020',
        expectedValue: 'h1:8020'
      },
      {
        config: 'dfs.namenode.http-address',
        localDB: getLocalDBForSingleComponent('NAMENODE'),
        rValue: 'c6401.ambari.apache.org:8020',
        expectedValue: 'h1:8020'
      },
      {
        config: 'dfs.https.address',
        localDB: getLocalDBForSingleComponent('NAMENODE'),
        rValue: 'c6401.ambari.apache.org:8020',
        expectedValue: 'h1:8020'
      },
      {
        config: 'dfs.namenode.https-address',
        localDB: getLocalDBForSingleComponent('NAMENODE'),
        rValue: 'c6401.ambari.apache.org:8020',
        expectedValue: 'h1:8020'
      },
      {
        config: 'fs.default.name',
        localDB: getLocalDBForSingleComponent('NAMENODE'),
        rValue: 'hdfs://c6401.ambari.apache.org:8020',
        expectedValue: 'hdfs://h1:8020'
      },
      {
        config: 'fs.defaultFS',
        localDB: getLocalDBForSingleComponent('NAMENODE'),
        rValue: 'hdfs://c6401.ambari.apache.org:8020',
        expectedValue: 'hdfs://h1:8020'
      },
      {
        config: 'hbase.rootdir',
        localDB: getLocalDBForSingleComponent('NAMENODE'),
        rValue: 'hdfs://c6401.ambari.apache.org:8020',
        expectedValue: 'hdfs://h1:8020'
      },
      {
        config: 'instance.volumes',
        localDB: getLocalDBForSingleComponent('NAMENODE'),
        rValue: 'hdfs://c6401.ambari.apache.org:8020',
        expectedValue: 'hdfs://h1:8020'
      },
      {
        config: 'dfs.secondary.http.address',
        localDB: getLocalDBForSingleComponent('SECONDARY_NAMENODE'),
        rValue: 'c6401.ambari.apache.org:50090',
        expectedValue: 'h1:50090'
      },
      {
        config: 'dfs.namenode.secondary.http-address',
        localDB: getLocalDBForSingleComponent('SECONDARY_NAMENODE'),
        rValue: 'c6401.ambari.apache.org:50090',
        expectedValue: 'h1:50090'
      },
      {
        config: 'yarn.log.server.url',
        localDB: getLocalDBForSingleComponent('HISTORYSERVER'),
        rValue: 'http://localhost:19888/jobhistory/logs',
        expectedValue: 'http://h1:19888/jobhistory/logs'
      },
      {
        config: 'mapreduce.jobhistory.webapp.address',
        localDB: getLocalDBForSingleComponent('HISTORYSERVER'),
        rValue: 'c6407.ambari.apache.org:19888',
        expectedValue: 'h1:19888'
      },
      {
        config: 'mapreduce.jobhistory.address',
        localDB: getLocalDBForSingleComponent('HISTORYSERVER'),
        rValue: 'c6407.ambari.apache.org:19888',
        expectedValue: 'h1:19888'
      },
      {
        config: 'yarn.resourcemanager.hostname',
        localDB: getLocalDBForSingleComponent('RESOURCEMANAGER'),
        rValue: 'c6407.ambari.apache.org',
        expectedValue: 'h1'
      },
      {
        config: 'yarn.resourcemanager.resource-tracker.address',
        localDB: getLocalDBForSingleComponent('RESOURCEMANAGER'),
        rValue: 'c6407.ambari.apache.org:123',
        expectedValue: 'h1:123'
      },
      {
        config: 'yarn.resourcemanager.webapp.https.address',
        localDB: getLocalDBForSingleComponent('RESOURCEMANAGER'),
        rValue: 'c6407.ambari.apache.org:123',
        expectedValue: 'h1:123'
      },
      {
        config: 'yarn.resourcemanager.webapp.address',
        localDB: getLocalDBForSingleComponent('RESOURCEMANAGER'),
        rValue: 'c6407.ambari.apache.org:123',
        expectedValue: 'h1:123'
      },
      {
        config: 'yarn.resourcemanager.scheduler.address',
        localDB: getLocalDBForSingleComponent('RESOURCEMANAGER'),
        rValue: 'c6407.ambari.apache.org:123',
        expectedValue: 'h1:123'
      },
      {
        config: 'yarn.resourcemanager.address',
        localDB: getLocalDBForSingleComponent('RESOURCEMANAGER'),
        rValue: 'c6407.ambari.apache.org:123',
        expectedValue: 'h1:123'
      },
      {
        config: 'yarn.resourcemanager.admin.address',
        localDB: getLocalDBForSingleComponent('RESOURCEMANAGER'),
        rValue: 'c6407.ambari.apache.org:123',
        expectedValue: 'h1:123'
      },
      {
        config: 'yarn.timeline-service.webapp.address',
        localDB: getLocalDBForSingleComponent('APP_TIMELINE_SERVER'),
        rValue: 'c6407.ambari.apache.org:432',
        expectedValue: 'h1:432'
      },
      {
        config: 'yarn.timeline-service.address',
        localDB: getLocalDBForSingleComponent('APP_TIMELINE_SERVER'),
        rValue: 'c6407.ambari.apache.org:432',
        expectedValue: 'h1:432'
      },
      {
        config: 'yarn.timeline-service.webapp.https.address',
        localDB: getLocalDBForSingleComponent('APP_TIMELINE_SERVER'),
        rValue: 'c6407.ambari.apache.org:432',
        expectedValue: 'h1:432'
      },
      {
        config: 'mapred.job.tracker',
        localDB: getLocalDBForSingleComponent('JOBTRACKER'),
        rValue: 'c6407.ambari.apache.org:111',
        expectedValue: 'h1:111'
      },
      {
        config: 'mapred.job.tracker.http.address',
        localDB: getLocalDBForSingleComponent('JOBTRACKER'),
        rValue: 'c6407.ambari.apache.org:111',
        expectedValue: 'h1:111'
      },
      {
        config: 'mapreduce.history.server.http.address',
        localDB: getLocalDBForSingleComponent('HISTORYSERVER'),
        rValue: 'c6407.ambari.apache.org:555',
        expectedValue: 'h1:555'
      },
      {
        config: 'oozie.base.url',
        localDB: getLocalDBForSingleComponent('OOZIE_SERVER'),
        rValue: 'http://localhost:11000/oozie',
        expectedValue: 'http://h1:11000/oozie'
      },
      {
        config: 'nimbus.host',
        localDB: getLocalDBForSingleComponent('NIMBUS'),
        rValue: 'localhost',
        expectedValue: 'h1'
      },
      {
        config: '*.broker.url',
        localDB: getLocalDBForSingleComponent('FALCON_SERVER'),
        rValue: 'tcp://localhost:61616',
        expectedValue: 'tcp://h1:61616'
      },
      {
        config: 'storm.zookeeper.servers',
        localDB: getLocalDBForMultipleComponents('ZOOKEEPER_SERVER', 3),
        rValue: "['c6401.ambari.apache.org','c6402.ambari.apache.org']",
        expectedValue: ['h1', 'h2', 'h3']
      },
      {
        config: 'nimbus.seeds',
        localDB: getLocalDBForMultipleComponents('NIMBUS', 3),
        rValue: "['c6401.ambari.apache.org','c6402.ambari.apache.org']",
        expectedValue: ['h1', 'h2', 'h3']
      },
      {
        config: 'hawq_master_address_host',
        localDB: getLocalDBForSingleComponent('HAWQMASTER'),
        rValue: 'localhost',
        expectedValue: 'h1'
      },
      {
        config: 'hawq_standby_address_host',
        localDB: getLocalDBForSingleComponent('HAWQSTANDBY'),
        rValue: 'localhost',
        expectedValue: 'h1'
      },
      {
        config: 'hawq_dfs_url',
        localDB: getLocalDBForSingleComponent('NAMENODE'),
        rValue: 'localhost:8020/hawq_data',
        expectedValue: 'h1:8020/hawq_data'
      },
      {
        config: 'hawq_rm_yarn_address',
        localDB: getLocalDBForSingleComponent('RESOURCEMANAGER'),
        rValue: 'localhost:8032',
        expectedValue: 'h1:8032'
      },
      {
        config: 'hawq_rm_yarn_scheduler_address',
        localDB: getLocalDBForSingleComponent('RESOURCEMANAGER'),
        rValue: 'localhost:8030',
        expectedValue: 'h1:8030'
      },
      {
        config: 'hadoop_host',
        localDB: getLocalDBForSingleComponent('NAMENODE'),
        rValue: 'localhost',
        expectedValue: 'h1'
      },
      {
        config: 'hive_master_hosts',
        localDB: getLocalDBForMultipleComponents('HIVE_METASTORE', 3),
        rValue: '',
        expectedValue: 'h1,h2,h3'
      },
      {
        config: 'hive_master_hosts',
        localDB: getLocalDBForMultipleComponents('HIVE_SERVER', 3),
        rValue: '',
        expectedValue: 'h1,h2,h3'
      },
      {
        config: 'zookeeper.connect',
        localDB: getLocalDBForMultipleComponents('ZOOKEEPER_SERVER', 3),
        rValue: 'localhost:2181',
        expectedValue: 'h1:2181,h2:2181,h3:2181'
      },
      {
        config: 'hive.zookeeper.quorum',
        localDB: getLocalDBForMultipleComponents('ZOOKEEPER_SERVER', 3),
        rValue: 'localhost:2181',
        expectedValue: 'h1:2181,h2:2181,h3:2181'
      },
      {
        config: 'templeton.zookeeper.hosts',
        localDB: getLocalDBForMultipleComponents('ZOOKEEPER_SERVER', 3),
        rValue: 'localhost:2181',
        expectedValue: 'h1:2181,h2:2181,h3:2181'
      },
      {
        config: 'hadoop.registry.zk.quorum',
        localDB: getLocalDBForMultipleComponents('ZOOKEEPER_SERVER', 3),
        rValue: 'localhost:2181',
        expectedValue: 'h1:2181,h2:2181,h3:2181'
      },
      {
        config: 'hive.cluster.delegation.token.store.zookeeper.connectString',
        localDB: getLocalDBForMultipleComponents('ZOOKEEPER_SERVER', 3),
        rValue: 'localhost:2181',
        expectedValue: 'h1:2181,h2:2181,h3:2181'
      },
      {
        config: 'instance.zookeeper.host',
        localDB: getLocalDBForMultipleComponents('ZOOKEEPER_SERVER', 3),
        rValue: 'localhost:2181',
        expectedValue: 'h1:2181,h2:2181,h3:2181'
      },
      {
        config: 'templeton.hive.properties',
        localDB: getLocalDBForMultipleComponents('HIVE_METASTORE', 2),
        rValue: 'hive.metastore.local=false,hive.metastore.uris=thrift://localhost:9933,hive.metastore.sasl.enabled=false',
        dependencies: {
          'hive.metastore.uris': 'thrift://localhost:9083'
        },
        expectedValue: 'hive.metastore.local=false,hive.metastore.uris=thrift://h1:9083\\,thrift://h2:9083,hive.metastore.sasl.enabled=false'
      },
      {
        config: 'hbase.zookeeper.quorum',
        m: 'hbase.zookeeper.quorum hbase-site.xml',
        localDB: getLocalDBForMultipleComponents('ZOOKEEPER_SERVER', 3),
        rValue: 'c6401.ambari.apache.org,c6402.ambari.apache.org',
        expectedValue: 'h1,h2,h3',
        filename: 'hbase-site.xml'
      },
      {
        config: 'hbase.zookeeper.quorum',
        m: 'hbase.zookeeper.quorum not-hbase-site.xml',
        localDB: getLocalDBForMultipleComponents('ZOOKEEPER_SERVER', 3),
        rValue: 'localhost',
        expectedValue: '',
        expectedRValue: 'localhost',
        filename: 'not-hbase-site.xml'
      },
      {
        config: 'yarn.resourcemanager.zk-address',
        localDB: getLocalDBForMultipleComponents('ZOOKEEPER_SERVER', 3),
        rValue: 'localhost:2181',
        dependencies: {
          'clientPort': '3333'
        },
        expectedValue: 'h1:3333,h2:3333,h3:3333'
      },
      {
        config: 'RANGER_HOST',
        localDB: getLocalDBForSingleComponent('RANGER_ADMIN'),
        rValue: 'locahost',
        expectedValue: 'h1'
      },
      {
        config: 'hive.metastore.uris',
        filename: 'hive-site.xml',
        localDB: getLocalDBForMultipleComponents('HIVE_METASTORE', 2),
        dependencies: {
          'hive.metastore.uris': 'thrift://localhost:9083'
        },
        rValue: 'thrift://localhost:9083',
        expectedValue: 'thrift://h1:9083,thrift://h2:9083'
      }
    ]).forEach(function (test) {
      describe(test.m || test.config, function () {

        beforeEach(function () {
          serviceConfigProperty.setProperties({
            name: test.config,
            recommendedValue: test.rValue,
            filename: test.filename
          });
          App.ConfigInitializer.initialValue(serviceConfigProperty, test.localDB, test.dependencies);
        });

        it('value is ' + test.expectedValue, function () {
          expect(serviceConfigProperty.get('value')).to.eql(test.expectedValue);
        });

        if (Em.isNone(test.expectedRValue)) {
          it('recommendedValue is ' + test.expectedValue, function () {
            expect(serviceConfigProperty.get('recommendedValue')).to.eql(test.expectedValue);
          });
        }
        else {
          it('recommendedValue is ' + test.expectedRValue, function () {
            expect(serviceConfigProperty.get('recommendedValue')).to.eql(test.expectedRValue);
          });
        }

      });
    });

  });

  describe('#getHiveMetastoreUris', function () {

    var cases = [
      {
        hosts: [
          {
            hostName: 'h0',
            component: 'HIVE_SERVER'
          },
          {
            hostName: 'h1',
            component: 'HIVE_METASTORE'
          },
          {
            hostName: 'h2',
            component: 'HIVE_METASTORE'
          }
        ],
        recommendedValue: 'thrift://localhost:9083',
        expected: 'thrift://h1:9083,thrift://h2:9083',
        title: 'typical case'
      },
      {
        hosts: [
          {
            hostName: 'h0',
            component: 'HIVE_SERVER'
          }
        ],
        recommendedValue: 'thrift://localhost:9083',
        expected: '',
        title: 'no Metastore hosts in DB'
      },
      {
        hosts: [
          {
            hostName: 'h0',
            component: 'HIVE_SERVER'
          },
          {
            hostName: 'h1',
            component: 'HIVE_METASTORE'
          },
          {
            hostName: 'h2',
            component: 'HIVE_METASTORE'
          }
        ],
        recommendedValue: '',
        expected: '',
        title: 'default value without port'
      },
      {
        hosts: [
          {
            hostName: 'h0',
            component: 'HIVE_SERVER'
          },
          {
            hostName: 'h1',
            component: 'HIVE_METASTORE'
          },
          {
            hostName: 'h2',
            component: 'HIVE_METASTORE'
          }
        ],
        expected: '',
        title: 'no default value specified'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(App.ConfigInitializer.getHiveMetastoreUris(item.hosts, item.recommendedValue)).to.equal(item.expected);
      });
    });

  });

  describe('initializerTypes', function () {
    var types = App.ConfigInitializer.get('initializerTypes');
    Em.keys(types).forEach(function(type) {
      it(type, function() {
        var methodName = types[type].method;
        expect(methodName).to.be.a.string;
        expect(methodName).to.have.length.above(0);
        expect(App.ConfigInitializer[methodName]).to.be.a.function;
      });
    });
  });

  describe('initializers', function () {

    var initializers = App.ConfigInitializer.get('initializers');
    var types = App.ConfigInitializer.get('initializerTypes');
    var typeNames = types.mapProperty('name');

    Em.keys(initializers).forEach(function (configName) {
      it(configName, function () {
        var type = initializers[configName].type;
        expect(typeNames).to.contain(type);
      });
    });

  });

  describe('uniqueInitializers', function () {

    var uniqueInitializers = App.ConfigInitializer.get('uniqueInitializers');
    var uniqueInitializersNames = Em.keys(uniqueInitializers).map(function (key) {
      return uniqueInitializers[key];
    });

    it('should contains only unique methods', function () {
      expect(uniqueInitializersNames.length).to.equal(uniqueInitializersNames.uniq().length);
    });

    uniqueInitializersNames.forEach(function (name) {
      it(name, function () {
        expect(App.ConfigInitializer[name]).to.be.a.function;
      });
    });

  });
});

});

require.register("test/utils/configs/database_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var dbUtils = require('utils/configs/database');

describe('Database Utils', function() {
  describe('#getDBLocationFromJDBC', function() {
    [
      {
        jdbcUrl: 'jdbc:mysql://localhost/somedb',
        e: 'localhost'
      },
      {
        jdbcUrl: 'jdbc:postgresql://some.hostname.com:5432/somedb',
        e: 'some.hostname.com'
      },
      {
        jdbcUrl: 'jdbc:derby:/some/dir/another_dir/somedb',
        e: '/some/dir/another_dir'
      },
      {
        jdbcUrl: 'jdbc:derby:${oozie-env/data-dir}/${oozie-env/database_name}-db',
        e: '${oozie-env/data-dir}'
      },
      {
        jdbcUrl: 'jdbc:sqlserver://127.0.0.1;databaseName=some-db;integratedSecurity=true',
        e: '127.0.0.1'
      },
      {
        jdbcUrl: 'jdbc:sqlserver://127.0.0.1:3030;databaseName=some-db;integratedSecurity=true',
        e: '127.0.0.1'
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@//localhost.com:1521/someDb',
        e: 'localhost.com'
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@ec2-52-5-27-33.compute-1.amazonaws.com:1521:ORCL',
        e: 'ec2-52-5-27-33.compute-1.amazonaws.com'
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@ec2-52-5-27-33.compute-1.amazonaws.com:3301:ORCL',
        e: 'ec2-52-5-27-33.compute-1.amazonaws.com'
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@//{0}:1521/{1}',
        e: ""
      },
      {
        jdbcUrl: 'jdbc:oracl:thin:@//some.com:1521/some-db',
        e: ""
      }
    ].forEach(function(test) {
      it('when jdbc url is ' + test.jdbcUrl + ' host name is ' + test.e, function() {
        expect(dbUtils.getDBLocationFromJDBC(test.jdbcUrl)).to.eql(test.e);
      });
    });
  });

  describe('#parseJdbcUrl', function() {
    [
      {
        jdbcUrl: 'jdbc:mysql://localhost/somedb',
        e: {
          dbType: 'mysql',
          location: 'localhost'
        }
      },
      {
        jdbcUrl: 'jdbc:postgresql://some.hostname.com:5432/somedb',
        e: {
          dbType: 'postgres',
          location: 'some.hostname.com'
        }
      },
      {
        jdbcUrl: 'jdbc:postgresql://some.hostname.com:1111/somedb',
        e: {
          dbType: 'postgres',
          location: 'some.hostname.com'
        }
      },
      {
        jdbcUrl: 'jdbc:derby:/some/dir/another_dir/somedb',
        e: {
          dbType: 'derby',
          location: '/some/dir/another_dir'
        }
      },
      {
        jdbcUrl: 'jdbc:derby:${oozie-env/data-dir}/${oozie-env/database_name}-db',
        e: {
          dbType: 'derby',
          location: '${oozie-env/data-dir}'
        }
      },
      {
        jdbcUrl: 'jdbc:derby:${oozie.data.dir}/${oozie.db.schema.name}-db;create=true',
        e: {
          dbType: 'derby',
          location: '${oozie.data.dir}'
        }
      },
      {
        jdbcUrl: 'jdbc:sqlserver://127.0.0.1;databaseName=some-db;integratedSecurity=true',
        e: {
          dbType: 'mssql',
          location: '127.0.0.1'
        }
      },
      {
        jdbcUrl: 'jdbc:sqlserver://127.0.0.1:3011;databaseName=some-db;integratedSecurity=true',
        e: {
          dbType: 'mssql',
          location: '127.0.0.1'
        }
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@//localhost.com:1521/someDb',
        e: {
          dbType: 'oracle',
          location: 'localhost.com'
        }
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@localhost.com:1521:someDb',
        e: {
          dbType: 'oracle',
          location: 'localhost.com'
        }
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@//{0}:1521/{1}',
        e: {
          dbType: 'oracle',
          location: ""
        }
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@//localhost:3301/somedb',
        e: {
          dbType: 'oracle',
          location: 'localhost'
        }
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@localhost:3302/somedb',
        e: {
          dbType: 'oracle',
          location: 'localhost'
        }
      },
      {
        jdbcUrl: 'jdbc:sqlanywhere:host=some.com;database=somedb',
        e: {
          dbType: 'sqla',
          location: 'some.com'
        }
      },
      {
        jdbcUrl: 'jdbc:sqlanywhere:host=some.com:333;database=somedb',
        e: {
          dbType: 'sqla',
          location: 'some.com'
        }
      },
      {
        jdbcUrl: 'jdbc:sqlanywhere:database=somedb;host=some.com:333',
        e: {
          dbType: 'sqla',
          location: 'some.com'
        }
      },
      {
        jdbcUrl: 'jdbc:sqlanywhere:database=somedb;host=some2.com:333;someadditional=some_param',
        e: {
          dbType: 'sqla',
          location: 'some2.com'
        }
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:scott/tiger@myhost:1521:orcl',
        e: {
          dbType: 'oracle',
          location: 'myhost'
        }
      },
      {
        jdbcUrl: 'jdbc:custom:custom/@@@',
        e: {
          dbType: null,
          location: ''
        }
      }
    ].forEach(function(test) {
      it('when jdbc url is ' + test.jdbcUrl + ' result is ' + JSON.stringify(test.e), function() {
        expect(dbUtils.parseJdbcUrl(test.jdbcUrl)).to.be.deep.eql(test.e);
      });
    });
  });
});

});

require.register("test/utils/configs/modification_handlers/misc_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */


require('utils/configs/modification_handlers/modification_handler');

var App = require('app');

describe('#App.ServiceConfigModificationHandler MISC', function() {
  var genStepConfig = function(serviceName, properties) {
    return Em.Object.create({
      serviceName: serviceName,
      configs: properties
    });
  };
  var genProperty = function(propName, value, initialValue, filename) {
    return Em.Object.create({
      name: propName,
      value: value,
      initialValue: initialValue,
      filename: filename
    });
  };
  var genProperties = function(properties) {
    return properties.map(function(item) {
      return genProperty.apply(undefined, item);
    });
  };
  var handler = require('utils/configs/modification_handlers/misc');

  describe('#getDependentConfigChanges', function() {

    describe('YARN dependent configs', function() {
      var tests = [
        {
          miscHandlerParams: {
            changedConfig: genProperty('yarn_user', 'new-user', 'initial-user', 'yarn-env.xml'),
            selectedServices: ['HDFS', 'YARN', 'MAPREDUCE2', 'ZOOKEEPER'],
            allConfigs: [
              genStepConfig('YARN', genProperties([
                ['yarn.admin.acl', 'some-user2 some-group2', '', 'yarn-site.xml']
              ])),
              genStepConfig('MISC', genProperties([
                ['user_group', 'some-group', 'initial-group', 'cluster-env.xml'],
                ['yarn_user', 'new-user', 'initial-user', 'yarn-env.xml']
              ]))
            ]
          },
          m: 'yarn_user changed, yarn.admin.acl new user name should be appended to users joined joined comma',
          e: { propertyName: 'yarn.admin.acl', curValue: 'some-user2 some-group2', newValue: 'some-user2,new-user some-group2'}
        },
        {
          miscHandlerParams: {
            changedConfig: genProperty('yarn_user', 'new-user', 'initial-user', 'yarn-env.xml'),
            selectedServices: ['HDFS', 'YARN', 'MAPREDUCE2', 'ZOOKEEPER'],
            allConfigs: [
              genStepConfig('YARN', genProperties([
                ['yarn.admin.acl', 'initial-user some-group2', '', 'yarn-site.xml']
              ])),
              genStepConfig('MISC', genProperties([
                ['user_group', 'some-group', 'initial-group', 'cluster-env.xml'],
                ['yarn_user', 'some-user', 'initial-user', 'yarn-env.xml']
              ]))
            ]
          },
          m: 'yarn_user changed, yarn.admin.acl initial user name should be update with new one',
          e: { propertyName: 'yarn.admin.acl', curValue: 'initial-user some-group2', newValue: 'new-user some-group2'}
        },
        {
          miscHandlerParams: {
            changedConfig: genProperty('yarn_user', 'new-user', 'initial-user', 'yarn-env.xml'),
            selectedServices: ['HDFS', 'YARN', 'MAPREDUCE2', 'ZOOKEEPER'],
            allConfigs: [
              genStepConfig('YARN', genProperties([
                ['yarn.admin.acl', '', '', 'yarn-site.xml']
              ])),
              genStepConfig('MISC', genProperties([
                ['user_group', 'some-group', 'initial-group', 'cluster-env.xml'],
                ['yarn_user', 'new-user', 'initial-user', 'yarn-env.xml']
              ]))
            ]
          },
          m: 'yarn_user changed, yarn.admin.acl initial value is not in valid format its value should be set with yarn_user and user_group',
          e: { propertyName: 'yarn.admin.acl', curValue: '', newValue: 'new-user'}
        }
      ];

      tests.forEach(function(test) {
        it(test.m, function() {
          var handlerParams = test.miscHandlerParams;
          var result = handler.getDependentConfigChanges(handlerParams.changedConfig, handlerParams.selectedServices, handlerParams.allConfigs, false).toArray();
          // check the key => value according test.e from result
          expect(App.permit(result.findProperty('propertyName', test.e.propertyName), Em.keys(test.e))).to.eql(test.e);
        });
      });
    });
  });
});

});

require.register("test/utils/configs/modification_handlers/modification_handler_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/configs/modification_handlers/modification_handler');

describe('App.ServiceConfigModificationHandler', function () {

  var handler = App.ServiceConfigModificationHandler.create();

  describe('#getConfig', function () {

    var allConfigs = [
        Em.Object.create({
          serviceName: 's',
          configs: [
            Em.Object.create({
              name: 'c1',
              filename: 'f1'
            })
          ]
        })
      ],
      cases = [
        {
          configName: 'c0',
          result: undefined,
          title: 'property isn\'t defined'
        },
        {
          configName: 'c1',
          result: Em.Object.create({
            name: 'c1',
            filename: 'f1'
          }),
          title: 'property is defined, filename isn\'t passed'
        },
        {
          configName: 'c1',
          configFilename: 'f1',
          result: Em.Object.create({
            name: 'c1',
            filename: 'f1'
          }),
          title: 'property is defined, filename is passed'
        },
        {
          configName: 'c1',
          configFilename: 'f2',
          result: undefined,
          title: 'property is defined, filenames don\'t match'
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(handler.getConfig(allConfigs, item.configName, item.configFilename, 's')).to.eql(item.result);
      });
    });

  });

});

});

require.register("test/utils/configs/theme/theme_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('utils/configs/theme/theme');

describe('App.configTheme', function() {

  describe("#resolveConfigThemeConditions()", function () {

    beforeEach(function() {
      this.mockThemeCondition = sinon.stub(App.ThemeCondition, 'find');
      sinon.stub(App.configTheme, 'calculateConfigCondition').returns(true);
      this.mockId = sinon.stub(App.config, 'configId');
      sinon.stub(App.configTheme, 'getThemeResource').returns(Em.Object.create({
        configProperties: ['conf1']
      }));
    });

    afterEach(function() {
      this.mockId.restore();
      this.mockThemeCondition.restore();
      App.configTheme.calculateConfigCondition.restore();
      App.configTheme.getThemeResource.restore();
    });

    it("theme configs empty", function() {
      var configs = [Em.Object.create({
        name: 'conf1',
        filename: 'file1',
        hiddenBySection: false
      })];
      this.mockThemeCondition.returns([
        Em.Object.create({
          configs: []
        })
      ]);
      App.configTheme.resolveConfigThemeConditions(configs);
      expect(App.configTheme.calculateConfigCondition.called).to.be.false;
      expect(configs[0].get('hiddenBySection')).to.be.false;
    });

    it("theme resource is not 'config'", function() {
      var configs = [Em.Object.create({
        name: 'conf1',
        filename: 'file1',
        hiddenBySection: false
      })];
      this.mockThemeCondition.returns([
        Em.Object.create({
          configs: [{}],
          resource: ''
        })
      ]);
      App.configTheme.resolveConfigThemeConditions(configs);
      expect(App.configTheme.calculateConfigCondition.called).to.be.false;
      expect(configs[0].get('hiddenBySection')).to.be.false;
    });

    it("property_value_attributes is null", function() {
      var configs = [Em.Object.create({
        name: 'conf1',
        filename: 'file1',
        hiddenBySection: false
      })];
      this.mockThemeCondition.returns([
        Em.Object.create({
          configs: [{}],
          resource: 'config',
          then: {
            property_value_attributes: null
          },
          id: 'c1'
        })
      ]);
      App.configTheme.resolveConfigThemeConditions(configs);
      expect(App.configTheme.calculateConfigCondition.calledOnce).to.be.true;
      expect(App.configTheme.getThemeResource.called).to.be.false;
      expect(configs[0].get('hiddenBySection')).to.be.false;
    });

    it("property_value_attributes.visible is null", function() {
      var configs = [Em.Object.create({
        name: 'conf1',
        filename: 'file1',
        hiddenBySection: false
      })];
      this.mockThemeCondition.returns([
        Em.Object.create({
          configs: [{}],
          resource: 'config',
          then: {
            property_value_attributes: {
              visible: null
            }
          },
          id: 'c1'
        })
      ]);
      App.configTheme.resolveConfigThemeConditions(configs);
      expect(App.configTheme.calculateConfigCondition.calledOnce).to.be.true;
      expect(App.configTheme.getThemeResource.called).to.be.false;
      expect(configs[0].get('hiddenBySection')).to.be.false;
    });

    it("config not in the theme", function() {
      var configs = [Em.Object.create({
        name: 'conf1',
        filename: 'file1',
        hiddenBySection: false
      })];
      this.mockThemeCondition.returns([
        Em.Object.create({
          configs: [{}],
          resource: 'config',
          then: {
            property_value_attributes: {
              visible: true
            }
          },
          id: 'c1'
        })
      ]);
      this.mockId.returns('conf2');
      App.configTheme.resolveConfigThemeConditions(configs);
      expect(App.configTheme.calculateConfigCondition.calledOnce).to.be.true;
      expect(App.configTheme.getThemeResource.calledOnce).to.be.true;
      expect(configs[0].get('hiddenBySection')).to.be.false;
    });

    it("configCondition type is 'config' and hiddenBySection is true", function() {
      var configs = [Em.Object.create({
        name: 'conf1',
        filename: 'file1',
        hiddenBySection: true
      })];
      this.mockThemeCondition.returns([
        Em.Object.create({
          configs: [{}],
          resource: 'config',
          then: {
            property_value_attributes: {
              visible: true
            }
          },
          id: 'c1',
          type: 'config'
        })
      ]);
      this.mockId.returns('conf1');
      App.configTheme.resolveConfigThemeConditions(configs);
      expect(App.configTheme.calculateConfigCondition.calledOnce).to.be.true;
      expect(App.configTheme.getThemeResource.calledOnce).to.be.true;
      expect(configs[0].get('hiddenBySection')).to.be.true;
    });

    it("hiddenBySection should be true", function() {
      var configs = [Em.Object.create({
        name: 'conf1',
        filename: 'file1',
        hiddenBySection: false
      })];
      this.mockThemeCondition.returns([
        Em.Object.create({
          configs: [{}],
          resource: 'config',
          then: {
            property_value_attributes: {
              visible: false
            }
          },
          id: 'c1',
          type: 'config'
        })
      ]);
      this.mockId.returns('conf1');
      App.configTheme.resolveConfigThemeConditions(configs);
      expect(App.configTheme.calculateConfigCondition.calledOnce).to.be.true;
      expect(App.configTheme.getThemeResource.calledOnce).to.be.true;
      expect(configs[0].get('hiddenBySection')).to.be.true;
    });

    it("hiddenBySection should be false", function() {
      var configs = [Em.Object.create({
        name: 'conf1',
        filename: 'file1',
        hiddenBySection: true
      })];
      this.mockThemeCondition.returns([
        Em.Object.create({
          configs: [{}],
          resource: 'config',
          then: {
            property_value_attributes: {
              visible: true
            }
          },
          id: 'c1'
        })
      ]);
      this.mockId.returns('conf1');
      App.configTheme.resolveConfigThemeConditions(configs);
      expect(App.configTheme.calculateConfigCondition.calledOnce).to.be.true;
      expect(App.configTheme.getThemeResource.calledOnce).to.be.true;
      expect(configs[0].get('hiddenBySection')).to.be.false;
    });
  });

  describe("#getThemeResource()", function () {

    beforeEach(function() {
      sinon.stub(App.SubSection, 'find').returns([Em.Object.create({name: 'ss1'})]);
      sinon.stub(App.SubSectionTab, 'find').returns([Em.Object.create({name: 'sst1'})]);
    });

    afterEach(function() {
      App.SubSection.find.restore();
      App.SubSectionTab.find.restore();
    });

    it("configCondition with unknown type", function() {
      expect(App.configTheme.getThemeResource(Em.Object.create())).to.be.null;
    });

    it("configCondition with subsection type", function() {
      expect(App.configTheme.getThemeResource(Em.Object.create({
        name: 'ss1',
        type: 'subsection'
      }))).to.be.eql(Em.Object.create({name: 'ss1'}));
    });

    it("configCondition with subsectionTab type", function() {
      expect(App.configTheme.getThemeResource(Em.Object.create({
        name: 'sst1',
        type: 'subsectionTab'
      }))).to.be.eql(Em.Object.create({name: 'sst1'}));
    });

    it("configCondition with config type", function() {
      expect(App.configTheme.getThemeResource(Em.Object.create({
        configName: 'conf1',
        fileName: 'file1',
        type: 'config'
      }))).to.be.eql(Em.Object.create({
          configProperties: ['conf1__file1']
        }));
    });
  });

  describe("#getConfigThemeActions()", function () {

    beforeEach(function() {
      sinon.stub(App.configTheme, 'getConfigActions').returns([
        Em.Object.create({
          if: '',
          then: 'add',
          else: 'delete',
          hostComponent: 'C1'
        })
      ]);
      this.mock = sinon.stub(App.configTheme, 'calculateConfigCondition');
    });

    afterEach(function() {
      this.mock.restore();
      App.configTheme.getConfigActions.restore();
    });

    it("should add component", function() {
      this.mock.returns(true);
      expect(App.configTheme.getConfigThemeActions([], [])).to.be.eql({
        add: ['C1'],
        delete: []
      });
    });

    it("should delete component", function() {
      this.mock.returns(false);
      expect(App.configTheme.getConfigThemeActions([], [])).to.be.eql({
        add: [],
        delete: ['C1']
      });
    });
  });

  describe("#getConfigActions()", function () {

    beforeEach(function() {
      this.mock = sinon.stub(App.ConfigAction, 'find');
    });

    afterEach(function() {
      this.mock.restore();
    });

    it("action has empty configs", function() {
      this.mock.returns([
        Em.Object.create({
          configs: []
        })
      ]);
      expect(App.configTheme.getConfigActions([], [])).to.be.empty;
    });

    it("empty configs", function() {
      this.mock.returns([
        Em.Object.create({
          configs: [{
            fileName: 'file1',
            configName: 'conf1'
          }]
        })
      ]);
      expect(App.configTheme.getConfigActions([], [])).to.be.empty;
    });

    it("empty storedConfig, config not changed", function() {
      this.mock.returns([
        Em.Object.create({
          configs: [{
            fileName: 'file1',
            configName: 'conf1'
          }]
        })
      ]);
      var config = Em.Object.create({
        filename: 'file1',
        name: 'conf1',
        savedValue: 'val1',
        value: 'val1',
        recommendedValue: 'val1'
      });
      expect(App.configTheme.getConfigActions([config], [])).to.be.empty;
    });

    it("empty storedConfig, savedValue changed", function() {
      this.mock.returns([
        Em.Object.create({
          configs: [{
            fileName: 'file1',
            configName: 'conf1'
          }]
        })
      ]);
      var config = Em.Object.create({
        filename: 'file1',
        name: 'conf1',
        savedValue: 'val1',
        value: 'val2',
        recommendedValue: 'val1'
      });
      expect(App.configTheme.getConfigActions([config], [])).to.be.eql([Em.Object.create({
        configs: [{
          fileName: 'file1',
          configName: 'conf1'
        }]
      })]);
    });

    it("empty storedConfig, recommendedValue changed", function() {
      this.mock.returns([
        Em.Object.create({
          configs: [{
            fileName: 'file1',
            configName: 'conf1'
          }]
        })
      ]);
      var config = Em.Object.create({
        filename: 'file1',
        name: 'conf1',
        value: 'val2',
        recommendedValue: 'val1'
      });
      expect(App.configTheme.getConfigActions([config], [])).to.be.eql([Em.Object.create({
        configs: [{
          fileName: 'file1',
          configName: 'conf1'
        }]
      })]);
    });

    it("storedConfig not changed", function() {
      this.mock.returns([
        Em.Object.create({
          configs: [{
            fileName: 'file1',
            configName: 'conf1'
          }]
        })
      ]);
      var config = Em.Object.create({
        filename: 'file1',
        name: 'conf1',
        savedValue: 'val1',
        value: 'val1',
        recommendedValue: 'val1'
      });
      var storedConfig = {
        filename: 'file1',
        name: 'conf1',
        value: 'val1'
      };
      expect(App.configTheme.getConfigActions([config], [storedConfig])).to.be.empty;
    });

    it("storedConfig changed", function() {
      this.mock.returns([
        Em.Object.create({
          configs: [{
            fileName: 'file1',
            configName: 'conf1'
          }]
        })
      ]);
      var config = Em.Object.create({
        filename: 'file1',
        name: 'conf1',
        savedValue: 'val1',
        value: 'val1',
        recommendedValue: 'val1'
      });
      var storedConfig = {
        filename: 'file1',
        name: 'conf1',
        value: 'val2'
      };
      expect(App.configTheme.getConfigActions([config], [storedConfig])).to.be.eql([Em.Object.create({
        configs: [{
          fileName: 'file1',
          configName: 'conf1'
        }]
      })]);
    });
  });

  describe("#calculateConfigCondition()", function () {
    var testCases = [
      {
        ifStatement: "${file1/conf1}",
        serviceConfigs: [],
        expected: false
      },
      {
        ifStatement: "${file1/conf1}",
        serviceConfigs: [Em.Object.create({
          filename: 'file1.xml',
          name: 'conf1',
          value: 'true'
        })],
        expected: true
      },
      {
        ifStatement: "${file1/conf1}&&${file1/conf2}",
        serviceConfigs: [
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf1',
            value: 'true'
          }),
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf2',
            value: 'true'
          })
        ],
        expected: true
      },
      {
        ifStatement: "${file1/conf1}&&${file1/conf2}",
        serviceConfigs: [
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf1',
            value: 'false'
          }),
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf2',
            value: 'false'
          })
        ],
        expected: false
      },
      {
        ifStatement: "${file1/conf1}&&${file1/conf2}===false",
        serviceConfigs: [
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf1',
            value: 'true'
          }),
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf2',
            value: 'false'
          })
        ],
        expected: true
      },
      {
        ifStatement: "${file1/conf1}&&${file1/conf2}",
        serviceConfigs: [
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf1',
            value: 'true'
          }),
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf2',
            value: 'false'
          })
        ],
        expected: false
      },
      {
        ifStatement: "${file1/conf1}===false&&${file1/conf2}===false",
        serviceConfigs: [
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf1',
            value: 'false'
          }),
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf2',
            value: 'false'
          })
        ],
        expected: true
      },
      {
        ifStatement: "${file1/conf1}||${file1/conf2}",
        serviceConfigs: [
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf1',
            value: 'true'
          }),
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf2',
            value: 'true'
          })
        ],
        expected: true
      },
      {
        ifStatement: "${file1/conf1}||${file1/conf2}",
        serviceConfigs: [
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf1',
            value: 'false'
          }),
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf2',
            value: 'true'
          })
        ],
        expected: true
      },
      {
        ifStatement: "${file1/conf1}||${file1/conf2}",
        serviceConfigs: [
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf1',
            value: 'true'
          }),
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf2',
            value: 'false'
          })
        ],
        expected: true
      },
      {
        ifStatement: "${file1/conf1}||${file1/conf2}",
        serviceConfigs: [
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf1',
            value: 'false'
          }),
          Em.Object.create({
            filename: 'file1.xml',
            name: 'conf2',
            value: 'false'
          })
        ],
        expected: false
      }
    ];

    testCases.forEach(function(test) {
      it("ifStatement: " + test.ifStatement +
         "serviceConfigs: " + JSON.stringify(test.serviceConfigs), function() {
        expect(App.configTheme.calculateConfigCondition(test.ifStatement, test.serviceConfigs)).to.be.equal(test.expected);
      });
    });
  });

});

});

require.register("test/utils/configs_collection_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/configs_collection');

describe('App.configsCollection', function () {

  var configsCollection;

  beforeEach(function () {
    configsCollection = Em.Object.create(App.configsCollection);
    sinon.spy(Em, 'assert');
  });

  afterEach(function () {
    Em.assert.restore();
  });

  describe('#add', function () {

    var throwCases = [
      {
        obj: undefined,
        collection: [],
        isError: true,
        title: 'null passed'
      },
      {
        obj: {},
        collection: [],
        isError: true,
        title: 'no id passed'
      },
      {
        obj: undefined,
        collection: [],
        isError: true,
        title: 'no item passed'
      }
    ];

    var cases = [
      {
        collection: [],
        isError: false,
        title: 'initial state'
      },
      {
        obj: {
          id: 1,
          name: 'n10'
        },
        collection: [
          {
            id: 1,
            name: 'n10'
          }
        ],
        mapItem: {
          id: 1,
          name: 'n10'
        },
        isError: false,
        title: 'new item'
      },
      {
        obj: {
          id: 1,
          name: 'n11'
        },
        collection: [
          {
            id: 1,
            name: 'n10'
          }
        ],
        mapItem: {
          id: 1,
          name: 'n11'
        },
        isError: false,
        title: 'duplicate id'
      },
      {
        obj: {
          id: '1',
          name: 'n12'
        },
        collection: [
          {
            id: 1,
            name: 'n10'
          }
        ],
        mapItem: {
          id: '1',
          name: 'n12'
        },
        isError: false,
        title: 'duplicate id, key name conversion'
      }
    ];

    throwCases.forEach(function (item) {

      it(item.title, function () {
        expect(function () {configsCollection.add(item.obj);}).to.throw(Error);
      });

    });

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          if (item.hasOwnProperty('obj')) {
            configsCollection.add(item.obj);
          }
        });

        it('configs array', function () {
          expect(configsCollection.getAll()).to.eql(item.collection);
        });

        if (item.obj && item.obj.id) {
          it('configs map', function () {
            expect(configsCollection.getConfig(item.obj.id)).to.eql(item.mapItem);
          });
        }

      });

    });

  });

  describe('#getConfig', function () {

    var throwCases = [
      {
        result: undefined,
        isError: true,
        title: 'no id passed'
      },
      {
        id: null,
        result: undefined,
        isError: true,
        title: 'invalid id passed'
      }
    ];

    var cases = [
      {
        id: 1,
        result: {
          id: 1
        },
        isError: false,
        title: 'existing item'
      },
      {
        id: 1,
        result: {
          id: 1
        },
        isError: false,
        title: 'existing item, key name conversion'
      },
      {
        id: 2,
        result: undefined,
        isError: false,
        title: 'item doesn\'t exist'
      }
    ];

    throwCases.forEach(function (item) {

      it(item.title, function () {
        configsCollection.add({
          id: 1
        });
        expect(function () {configsCollection.getConfig(item.id);}).to.throw(Error);
      });

    });

    cases.forEach(function (item) {

      describe(item.title, function () {

        var result;

        beforeEach(function () {
          configsCollection.add({
            id: 1
          });
          result = configsCollection.getConfig(item.id);
        });

        it('returned value', function () {
          expect(result).to.eql(item.result);
        });

      });

    });

  });

  describe('#getConfigByName', function () {

    var configIds = ['n0_f0', 'n1_f1'];
    var throwCases = [
      {
        fileName: 'f0',
        result: undefined,
        isError: true,
        title: 'no name passed'
      },
      {
        name: 'n0',
        result: undefined,
        isError: true,
        title: 'no filename passed'
      }
    ];
    var cases = [
        {
          name: 'n0',
          fileName: 'f0',
          result: {
            id: 'n0_f0'
          },
          isError: false,
          title: 'existing item'
        },
        {
          name: 'n0',
          fileName: 'f1',
          result: undefined,
          isError: false,
          title: 'not existing item'
        }
      ];

    beforeEach(function () {
      sinon.stub(App.config, 'configId', function (name, fileName) {
        return name + '_' + fileName;
      });
    });

    afterEach(function () {
      configsCollection.clearAll();
      App.config.configId.restore();
    });

    throwCases.forEach(function (item) {

      it(item.title, function () {
        expect(function () {configsCollection.getConfigByName(item.name, item.fileName);}).to.throw(Error);
      });

    });

    cases.forEach(function (item) {

      describe(item.title, function () {

        var result;

        beforeEach(function () {

          configIds.forEach(function (id) {
            configsCollection.add({
              id: id
            });
          });
          result = configsCollection.getConfigByName(item.name, item.fileName);
        });

        it('returned value', function () {
          expect(result).to.eql(item.result);
        });

      });

    });

  });

  describe('#getAll', function () {

    var configs = [
      {
        id: 'c0'
      },
      {
        id: 'c1'
      }
    ];

    beforeEach(function () {
      configsCollection.clearAll();
    });

    it('should return all configs', function () {
      configs.forEach(function (item) {
        configsCollection.add(item);
      });
      expect(configsCollection.getAll()).to.eql(configs);
    });

  });


  describe('#clearAll', function () {

    beforeEach(function () {
      configsCollection.add({
        id: 'c0'
      });
      configsCollection.clearAll();
    });

    it('should clear configs array', function () {
      expect(configsCollection.getAll()).to.have.length(0);
    });

    it('should clear configs map', function () {
      expect(configsCollection.getConfig('c0')).to.be.undefined;
    });

  });

});

});

require.register("test/utils/credentials_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var credentials = require('utils/credentials');
var testHelpers = require('test/helpers');

describe('credentials utils', function () {

  var storeTypeStatusMock = function (clusterName, key) {
    var result = {};
    result[key] = clusterName;
    return result;
  };

  describe('#createCredentials', function () {

    it('should send AJAX request', function () {
      credentials.createCredentials('c', 'a', {});
      expect(testHelpers.findAjaxRequest('name', 'credentials.create')).to.eql([
        {
          sender: credentials,
          name: 'credentials.create',
          data: {
            clusterName: 'c',
            resource: {},
            alias: 'a'
          },
          error: 'createCredentialsErrorCallback'
        }
      ]);
    });

  });

  describe('#credentialsSuccessCallback', function () {

    var params = {
        callback: Em.K
      },
      cases = [
        {
          items: [],
          callbackArgument: [],
          title: 'no data returned'
        },
        {
          items: [{}, {}],
          callbackArgument: [undefined, undefined],
          title: 'empty data returned'
        },
        {
          items: [
            {
              Credential: {
                id: 0
              }
            },
            {
              Credential: {
                id: 1
              }
            }
          ],
          callbackArgument: [
            {
              id: 0
            },
            {
              id: 1
            }
          ],
          title: 'valid data returned'
        }
      ];

    beforeEach(function () {
      sinon.spy(params, 'callback');
    });

    afterEach(function () {
      params.callback.restore();
    });

    cases.forEach(function (item) {

      it(item.title, function () {
        credentials.credentialsSuccessCallback({
          items: item.items
        }, null, params);
        expect(params.callback.firstCall.args).to.eql([item.callbackArgument]);
      });

    });

  });

  describe('#createOrUpdateCredentials', function () {

    var mock = {
        dfd: {
          getCredential: null,
          updateCredentials: null,
          createCredentials: null
        },
        callback: Em.K,
        getCredential: function () {
          return mock.dfd.getCredential.promise();
        },
        updateCredentials: function () {
          return mock.dfd.updateCredentials.promise();
        },
        createCredentials: function () {
          return mock.dfd.createCredentials.promise();
        }
      },
      cases = [
        {
          getCredentialResolve: true,
          credentialsCallback: 'updateCredentials',
          isCredentialsCallbackResolve: true,
          status: 'success',
          result: {
            status: 200
          },
          callbackArgs: [
            true,
            {
              status: 200
            }
          ],
          title: 'successful credentials update'
        },
        {
          getCredentialResolve: true,
          credentialsCallback: 'updateCredentials',
          isCredentialsCallbackResolve: false,
          status: 'error',
          result: {
            status: 404
          },
          callbackArgs: [
            false,
            {
              status: 404
            }
          ],
          title: 'failed credentials update'
        },
        {
          getCredentialResolve: false,
          credentialsCallback: 'createCredentials',
          isCredentialsCallbackResolve: true,
          status: 'success',
          result: {
            status: 201
          },
          callbackArgs: [
            true,
            {
              status: 201
            }
          ],
          title: 'successful credentials creation'
        },
        {
          getCredentialResolve: false,
          credentialsCallback: 'createCredentials',
          isCredentialsCallbackResolve: false,
          status: 'error',
          result: {
            status: 500
          },
          callbackArgs: [
            false,
            {
              status: 500
            }
          ],
          title: 'failed credentials creation'
        }
      ];

    beforeEach(function () {
      sinon.stub(credentials, 'getCredential', mock.getCredential);
      sinon.stub(credentials, 'updateCredentials', mock.updateCredentials);
      sinon.stub(credentials, 'createCredentials', mock.createCredentials);
      sinon.spy(mock, 'callback');
      mock.dfd.getCredential = $.Deferred();
      mock.dfd.updateCredentials = $.Deferred();
      mock.dfd.createCredentials = $.Deferred();
    });

    afterEach(function () {
      credentials.getCredential.restore();
      credentials.updateCredentials.restore();
      credentials.createCredentials.restore();
      mock.callback.restore();
    });

    cases.forEach(function (item) {

      var getCredentialMethod = item.getCredentialResolve ? 'resolve' : 'reject',
        credentialsCallbackMethod = item.isCredentialsCallbackResolve ? 'resolve' : 'reject';

      it(item.title, function () {
        mock.dfd.getCredential[getCredentialMethod]();
        mock.dfd[item.credentialsCallback][credentialsCallbackMethod](null, item.status, item.result);
        credentials.createOrUpdateCredentials().done(mock.callback);
        expect(mock.callback.firstCall.args).to.eql(item.callbackArgs);
      });

    });

  });

  describe('#getCredential', function () {

    it('should send AJAX request', function () {
      credentials.getCredential('c', 'a', Em.K);
      expect(testHelpers.findAjaxRequest('name', 'credentials.get')).to.eql([
        {
          sender: credentials,
          name: 'credentials.get',
          data: {
            clusterName: 'c',
            alias: 'a',
            callback: Em.K
          },
          success: 'getCredentialSuccessCallback',
          error: 'getCredentialErrorCallback'
        }
      ]);
    });

  });

  describe('#getCredentialSuccessCallback', function () {

    var params = {
        callback: Em.K
      },
      cases = [
        {
          data: null,
          callback: undefined,
          callbackCallCount: 0,
          title: 'no callback passed'
        },
        {
          data: null,
          callback: null,
          callbackCallCount: 0,
          title: 'invalid callback passed'
        },
        {
          data: null,
          callbackCallCount: 1,
          callbackArgument: null,
          title: 'no data passed'
        },
        {
          data: {},
          callbackCallCount: 1,
          callbackArgument: null,
          title: 'no credential info passed'
        },
        {
          data: {
            Credential: 'c'
          },
          callbackCallCount: 1,
          callbackArgument: 'c',
          title: 'credential info passed'
        }
      ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          sinon.spy(params, 'callback');
          credentials.getCredentialSuccessCallback(item.data, null, item.hasOwnProperty('callback') ? {
            callback: item.callback
          } : params);
        });

        afterEach(function () {
          params.callback.restore();
        });

        it('callback call count', function () {
          expect(params.callback.callCount).to.equal(item.callbackCallCount);
        });

        if (item.callbackCallCount) {
          it('callback argument', function () {
            expect(params.callback.firstCall.args).to.eql([item.callbackArgument]);
          });
        }

      });

    });

  });

  describe('#updateCredentials', function () {

    it('should send AJAX request', function () {
      credentials.updateCredentials('c', 'a', {});
      expect(testHelpers.findAjaxRequest('name', 'credentials.update')).to.eql([
        {
          sender: credentials,
          name: 'credentials.update',
          data: {
            clusterName: 'c',
            alias: 'a',
            resource: {}
          }
        }
      ]);
    });

  });

  describe('#credentials', function () {

    it('should send AJAX request', function () {
      credentials.credentials('c', Em.K);
      expect(testHelpers.findAjaxRequest('name', 'credentials.list')).to.eql([
        {
          sender: credentials,
          name: 'credentials.list',
          data: {
            clusterName: 'c',
            callback: Em.K
          },
          success: 'credentialsSuccessCallback'
        }
      ]);
    });

  });

  describe('#removeCredentials', function () {

    it('should send AJAX request', function () {
      credentials.removeCredentials('c', 'a');
      expect(testHelpers.findAjaxRequest('name', 'credentials.delete')).to.eql([
        {
          sender: credentials,
          name: 'credentials.delete',
          data: {
            clusterName: 'c',
            alias: 'a'
          }
        }
      ]);
    });

  });

  describe('#storageInfo', function () {

    it('should send AJAX request', function () {
      credentials.storageInfo('c', Em.K);
      expect(testHelpers.findAjaxRequest('name', 'credentials.store.info')).to.eql([
        {
          sender: credentials,
          name: 'credentials.store.info',
          data: {
            clusterName: 'c',
            callback: Em.K
          },
          success: 'storageInfoSuccessCallback'
        }
      ]);
    });

  });

  describe('#storageInfoSuccessCallback', function () {

    var params = {
        callback: Em.K
      },
      cases = [
        {
          callbackArgument: null,
          title: 'no clusters'
        },
        {
          clusters: null,
          callbackArgument: null,
          title: 'invalid clusters info'
        },
        {
          clusters: {},
          callbackArgument: {
            persistent: false,
            temporary: false
          },
          title: 'empty clusters info'
        },
        {
          clusters: {
            credential_store_properties: {
              'storage.persistent': true,
              'storage.temporary': true
            }
          },
          callbackArgument: {
            persistent: false,
            temporary: false
          },
          title: 'invalid storage properties format'
        },
        {
          clusters: {
            credential_store_properties: {}
          },
          callbackArgument: {
            persistent: false,
            temporary: false
          },
          title: 'no storage properties'
        },
        {
          clusters: {
            credential_store_properties: {
              'storage.persistent': 'true',
              'storage.temporary': 'false'
            }
          },
          callbackArgument: {
            persistent: true,
            temporary: false
          },
          title: 'valid storage properties format - persistent storage'
        },
        {
          clusters: {
            credential_store_properties: {
              'storage.persistent': 'false',
              'storage.temporary': 'true'
            }
          },
          callbackArgument: {
            persistent: false,
            temporary: true
          },
          title: 'valid storage properties format - temporary storage'
        },
        {
          clusters: {
            credential_store_properties: {
              'storage.persistent': 'true',
              'storage.temporary': 'true'
            }
          },
          callbackArgument: {
            persistent: true,
            temporary: true
          },
          title: 'valid storage properties format - both types'
        }
      ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          sinon.spy(params, 'callback');
          credentials.storageInfoSuccessCallback({
            Clusters: item.clusters
          }, null, params);
        });

        afterEach(function () {
          params.callback.restore();
        });

        it('callback execution', function () {
          expect(params.callback.calledOnce).to.be.true;
        });

        it('callback argument', function () {
          expect(params.callback.firstCall.args).to.eql([item.callbackArgument]);
        });

      });

    });

  });

  describe('#isStorePersisted', function () {

    beforeEach(function () {
      sinon.stub(credentials, 'storeTypeStatus', storeTypeStatusMock);
    });

    afterEach(function () {
      credentials.storeTypeStatus.restore();
    });

    it('should return storeTypeStatus result', function () {
      expect(credentials.isStorePersisted('c')).to.eql({
        persistent: 'c'
      });
    });

  });


  describe('#isStoreTemporary', function () {

    beforeEach(function () {
      sinon.stub(credentials, 'storeTypeStatus', storeTypeStatusMock);
    });

    afterEach(function () {
      credentials.storeTypeStatus.restore();
    });

    it('should return storeTypeStatus result', function () {
      expect(credentials.isStoreTemporary('c')).to.eql({
        temporary: 'c'
      });
    });

  });

  describe('#storeTypeStatus', function () {

    var mock = {
        successCallback: Em.K,
        errorCallback: Em.K
      },
      data = {
        clusterName: 'c'
      },
      error = {
        status: 404
      },
      cases = [
        {
          isSuccess: true,
          callbackArgument: data,
          title: 'success'
        },
        {
          isSuccess: false,
          callbackArgument: error,
          title: 'fail'
        }
      ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        var callbackName = item.isSuccess ? 'successCallback' : 'errorCallback';

        beforeEach(function () {
          sinon.spy(mock, 'successCallback');
          sinon.spy(mock, 'errorCallback');
          sinon.stub(credentials, 'storageInfo', function (clusterName, callback) {
            var dfd = $.Deferred();
            if (item.isSuccess) {
              callback({
                temporary: data
              });
            } else {
              dfd.reject(error);
            }
            return dfd.promise();
          });
          credentials.storeTypeStatus(null, 'temporary').then(mock.successCallback, mock.errorCallback);
        });

        afterEach(function () {
          mock.successCallback.restore();
          mock.errorCallback.restore();
          credentials.storageInfo.restore();
        });

        it('success callback', function () {
          expect(mock.successCallback.called).to.equal(item.isSuccess);
        });

        it('error callback', function () {
          expect(mock.errorCallback.called).to.not.equal(item.isSuccess);
        });

        it('callback called once', function () {
          expect(mock[callbackName].calledOnce).to.be.true;
        });

        it('callback arguments', function () {
          expect(mock[callbackName].firstCall.args).to.eql([item.callbackArgument]);
        });

      });

    });

  });

  describe('#createCredentialResource', function () {

    it('should return object with arguments', function () {
      expect(credentials.createCredentialResource('p', 'c', 't')).to.eql({
        principal: 'p',
        key: 'c',
        type: 't'
      });
    });

  });

  describe('#isKDCCredentialsPersisted', function () {

    var cases = [
      {
        credentials: [],
        isKDCCredentialsPersisted: false,
        title: 'empty array passed'
      },
      {
        credentials: [{}, {}],
        isKDCCredentialsPersisted: false,
        title: 'no aliases passed'
      },
      {
        credentials: [
          {
            alias: 'a0'
          },
          {
            alias: 'a1'
          }
        ],
        isKDCCredentialsPersisted: false,
        title: 'no KDC admin credentials passed'
      },
      {
        credentials: [
          {
            alias: 'kdc.admin.credential'
          },
          {
            alias: 'a2'
          }
        ],
        isKDCCredentialsPersisted: false,
        title: 'no KDC admin credentials type passed'
      },
      {
        credentials: [
          {
            alias: 'kdc.admin.credential',
            type: 'temporary'
          },
          {
            alias: 'a3'
          }
        ],
        isKDCCredentialsPersisted: false,
        title: 'temporary storage'
      },
      {
        credentials: [
          {
            alias: 'kdc.admin.credential',
            type: 'persisted'
          },
          {
            alias: 'kdc.admin.credential'
          },
          {
            alias: 'a4'
          }
        ],
        isKDCCredentialsPersisted: true,
        title: 'persistent storage'
      }
    ];

    cases.forEach(function (item) {

      it(item.title, function () {
        expect(credentials.isKDCCredentialsPersisted(item.credentials)).to.equal(item.isKDCCredentialsPersisted);
      });

    });

  });

});

});

require.register("test/utils/data_manipulation_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var dataManipulation = require('utils/data_manipulation');

describe('dataManipulation', function () {

  describe('#rejectPropertyValues', function () {

    it('Basic test', function () {
      var collection = [
          {n: 'v1'},
          {n: 'v2'},
          {n: 'v3'},
          {n: 'v4'}
        ],
        key = 'n',
        valuesToReject = ['v2', 'v3'];
      var result = dataManipulation.rejectPropertyValues(collection, key, valuesToReject);
      expect(result).to.eql([
        {n: 'v1'},
        {n: 'v4'}
      ]);
    });

  });

  describe('#filterPropertyValues', function () {

    it('Basic test', function () {
      var collection = [
          {n: 'v1'},
          {n: 'v2'},
          {n: 'v3'},
          {n: 'v4'}
        ],
        key = 'n',
        valuesToFilter = ['v2', 'v3'];
      var result = dataManipulation.filterPropertyValues(collection, key, valuesToFilter);
      expect(result).to.eql([
        {n: 'v2'},
        {n: 'v3'}
      ]);
    });

  });

  describe('#groupPropertyValues', function () {

    it('Basic test', function () {
      var collection = [
          {n: 'v1'},
          {n: 'v2'},
          {n: 'v2'},
          {n: 'v4'}
        ],
        key = 'n';
      var result = dataManipulation.groupPropertyValues(collection, key);
      expect(JSON.stringify(result)).to.equal(JSON.stringify({
        v1: [
          {n: 'v1'}
        ],
        v2: [
          {n: 'v2'},
          {n: 'v2'}
        ],
        v4: [
          {n: 'v4'}
        ]}));
    });

  });

});
});

require.register("test/utils/date/date_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var date = require('utils/date/date');

describe('date', function () {

  var incorrectTests = Em.A([
    {m: 'null', t: null},
    {m: 'empty', t: ''},
    {m: 'false', t: false},
    {m:'[]' , t: []},
    {m: '{}', t: {}},
    {m: 'undefined', t: undefined},
    {m: 'empty function', t: function(){}}
  ]);

  describe('#dateFormatZeroFirst()', function() {
    var tests = [
      {
        t: 2,
        e: '02',
        m: 'should convert to `02`'
      },
      {
        t: 10,
        e: '10',
        m: 'should convert to `10`'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(date.dateFormatZeroFirst(test.t)).to.eql(test.e);
      });
    });
  });

  describe('#startTime()', function() {
    var today = new Date();
    var testDate = new Date(1349752195000);
    var tests = [
      { t: 1349752195000, e: testDate.toDateString() + ' {0}:{1}'.format(date.dateFormatZeroFirst(testDate.getHours()), date.dateFormatZeroFirst(testDate.getMinutes())) },
      { t: -10000000, e: 'Not started' },
      { t: today.getTime(), e: 'Today {0}:{1}'.format(date.dateFormatZeroFirst(today.getHours()), date.dateFormatZeroFirst(today.getMinutes())) },
      { t: today, e: ''}
    ];
    tests.forEach(function(test) {
      var testMessage = 'should convert {0} to {1}'.format(test.t, test.e);
      it(testMessage, function() {
        expect(date.startTime(test.t)).to.be.eql(test.e);
      });
    });
  });

  describe('#endTime()', function() {
    var today = new Date();
    var testDate = new Date(1349752195000);
    var tests = [
      { t: 1349752195000, e: testDate.toDateString() + ' {0}:{1}'.format(date.dateFormatZeroFirst(testDate.getHours()), date.dateFormatZeroFirst(testDate.getMinutes())) },
      { t: -10000000, e: 'Not finished' },
      { t: today.getTime(), e: 'Today {0}:{1}'.format(date.dateFormatZeroFirst(today.getHours()), date.dateFormatZeroFirst(today.getMinutes())) },
      { t: today, e: ''}
    ];
    tests.forEach(function(test) {
      var testMessage = 'should convert {0} to {1}'.format(test.t, test.e);
      it(testMessage, function() {
        expect(date.endTime(test.t)).to.be.eql(test.e);
      });
    });
  });

  describe('#timingFormat', function() {
    var tests = Em.A([
      {i: '30', e:'30 ms'},
      {i: '300', e:'300 ms'},
      {i: '999', e:'999 ms'},
      {i: '1000', e:'1.00 secs'},
      {i: '3000', e:'3.00 secs'},
      {i: '35000', e:'35.00 secs'},
      {i: '350000', e:'350.00 secs'},
      {i: '999999', e:'1000.00 secs'},
      {i: '1000000', e:'16.67 mins'},
      {i: '3500000', e:'58.33 mins'},
      {i: '35000000', e:'9.72 hours'},
      {i: '350000000', e:'4.05 days'},
      {i: '3500000000', e:'40.51 days'},
      {i: '35000000000', e:'405.09 days'}
    ]);

    describe('Correct data', function(){
      tests.forEach(function(test) {
        it(test.i, function() {
          expect(date.timingFormat(test.i)).to.equal(test.e);
        });
      });
    });

    describe('Incorrect data', function(){
      incorrectTests.forEach(function(test) {
        it(test.m, function() {
          expect(date.timingFormat(test.t)).to.equal(null);
        });
      });
    });

  });

  describe('#duration', function() {
    var tests = Em.A([
      {startTime: 1, endTime: 2, e: 1},
      {startTime: 0, endTime: 2000, e: 0},
      {startTime: 200, endTime: 0, e: 19800}
    ]);

    beforeEach(function() {
      sinon.stub(App, 'dateTime', function () { return 20000; });
    });

    tests.forEach(function(test) {
      it(test.startTime + ' ' + test.endTime, function() {
        expect(date.duration(test.startTime, test.endTime)).to.equal(test.e);
      });
    });

    afterEach(function() {
      App.dateTime.restore();
    });
  });

  describe('#durationSummary()', function() {
    var tests = [
      {
        startTimestamp: 1349752195000,
        endTimestamp: 1349752199000,
        e: '4.00 secs'
      },
      {
        startTimestamp: 1349752195000,
        endTimestamp: 1367752195000,
        e: '208.33 days'
      },
      {
        startTimestamp: -10000000,
        endTimestamp: 1367752195000,
        e: Em.I18n.t('common.na')
      },
      {
        startTimestamp: 1349752195000,
        endTimestamp: -1,
        stubbed: true,
        e: '0 secs'
      },
      {
        startTimestamp: 100000000,
        endTimestamp: -1,
        stubbed: true,
        e: '19.00 secs'
      }
    ];

    beforeEach(function() {
      sinon.stub(App, 'dateTimeWithTimeZone', function () { return 100019000; });
    });

    tests.forEach(function(test) {
      var testMessage = 'duration between {0} and {1} is {2}'.format(test.startTimestamp, test.endTimestamp, test.e) + (test.stubbed ? " App.dateTime() is stubbed" : "");
      it(testMessage, function() {
        expect(date.durationSummary(test.startTimestamp, test.endTimestamp)).to.be.eql(test.e);
      });
    });

    afterEach(function() {
      App.dateTimeWithTimeZone.restore();
    });
  });

});
});

require.register("test/utils/date/timezone_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var timezoneUtils = require('utils/date/timezone');

describe('timezoneUtils', function () {

  describe('#_groupTimezones', function () {

    var formattedTimezones = [
      {utcOffset: 1, groupByKey: '1', formattedOffset: '+01:00', value: 'a/Aa', region: 'a', city: 'Aa'},
      {utcOffset: 1, groupByKey: '1', formattedOffset: '+01:00', value: 'a/Bb', region: 'a', city: 'Bb'},
      {utcOffset: 2, groupByKey: '2', formattedOffset: '+02:00', value: 'a/Cc', region: 'a', city: 'Cc'},
      {utcOffset: 2, groupByKey: '2', formattedOffset: '+02:00', value: 'a/Dd', region: 'a', city: 'Dd'},
      {utcOffset: 1, groupByKey: '1', formattedOffset: '+01:00', value: 'b/Ee', region: 'b', city: 'Ee'},
      {utcOffset: 1, groupByKey: '1', formattedOffset: '+01:00', value: 'b/Ff', region: 'b', city: 'Ff'},
      {utcOffset: 2, groupByKey: '2', formattedOffset: '+02:00', value: 'b/Gg', region: 'b', city: 'Gg'},
      {utcOffset: 2, groupByKey: '2', formattedOffset: '+02:00', value: 'b/Hh', region: 'b', city: 'Hh'},
      {utcOffset: 2, groupByKey: '2', formattedOffset: '+02:00', value: 'b/II', region: 'b', city: 'II'},
      {utcOffset: 2, groupByKey: '2', formattedOffset: '+02:00', value: 'b', region: 'b', city: ''}
    ];

    before(function () {
      this.result = timezoneUtils._groupTimezones(formattedTimezones);
    });

    it('should group to 4 groups', function () {
      expect(this.result.length).to.equal(4);
    });

    it('UTCOffset should be [1,1,2,2]', function () {
      expect(this.result.mapProperty('utcOffset')).to.eql([1, 1, 2, 2]);
    });

    it('should map regions and cities correctly', function () {
      var expected = [
        '(UTC+01:00 UTC) a / Aa, Bb',
        '(UTC+01:00 UTC) b / Ee, Ff',
        '(UTC+02:00 UTC) a / Cc, Dd',
        '(UTC+02:00 UTC) b / Gg, Hh'
      ];
      var values = this.result.mapProperty('label');
      expect(values).to.eql(expected);
      expect(values.join('')).to.not.contain('II');
      expect(values.join('')).to.not.contain(', ,');
    });

  });

  describe('#_parseTimezones', function () {

    beforeEach(function () {
      sinon.stub(timezoneUtils, 'getAllTimezoneNames').returns([
        'Europe/Helsinki',
        'Asia/Magadan',
        'America/Lima'
      ]);
      sinon.stub(timezoneUtils, '_groupTimezones', function (list) {
        return list;
      });
      this.result = timezoneUtils._parseTimezones();
    });

    afterEach(function () {
      timezoneUtils.getAllTimezoneNames.restore();
      timezoneUtils._groupTimezones.restore();
    });

    it('should sort by offset and name', function () {
      expect(this.result.mapProperty('value')).to.eql(['America/Lima', 'Europe/Helsinki', 'Asia/Magadan']);
    });

    it('should split regions and cities', function () {
      expect(this.result.mapProperty('region')).to.eql(['America', 'Europe', 'Asia']);
      expect(this.result.mapProperty('city')).to.eql(['Lima', 'Helsinki', 'Magadan']);
    });

  });

  describe('#getAllTimezoneNames', function () {

    var result = timezoneUtils.getAllTimezoneNames();

    it('timezone names are parsed', function () {
      expect(result).to.have.length.above(0);
    });

    describe('Etc/* are excluded', function () {
      result.forEach(function (tz) {
        it(tz, function () {
          expect(tz.indexOf('Etc/')).to.equal(-1);
        });
      });
    });

    describe('Abbreviations are excluded', function () {
      result.forEach(function (tz) {
        it(tz, function () {
          expect(tz).to.not.equal(tz.toUpperCase());
        });
      });
    });

  });

  describe('#detectUserTimezone', function () {

    var getTimezoneOffset = Date.prototype.getTimezoneOffset;

    function mockTimezoneOffset(jan, jul) {
      Date.prototype.getTimezoneOffset = function () {
        var month = this.getMonth();
        if (month > 3 && month < 9) {
          return -jul;
        }
        return -jan;
      };
    }

    afterEach(function () {
      Date.prototype.getTimezoneOffset = getTimezoneOffset;
    });

    it('Detect UTC+1', function () {
      mockTimezoneOffset(0, 60);
      var tz = timezoneUtils.detectUserTimezone();
      expect(tz).to.contain('0-60|Atlantic');
    });

    it('Detect UTC+1 for Europe', function () {
      mockTimezoneOffset(0, 60);
      var tz = timezoneUtils.detectUserTimezone('Europe');
      expect(tz).to.contain('0-60|Europe');
    });

    it('Detect UTC-4', function () {
      mockTimezoneOffset(-300, -240);
      var tz = timezoneUtils.detectUserTimezone();
      expect(tz).to.contain('300240|America');
    });

    it('Detect UTC+3 for Asia', function () {
      mockTimezoneOffset(120, 180);
      var tz = timezoneUtils.detectUserTimezone();
      expect(tz).to.contain('-120-180|Asia');
    });

    it('Detect UTC-7', function () {
      mockTimezoneOffset(-480, -420);
      var tz = timezoneUtils.detectUserTimezone();
      expect(tz).to.contain('480420|America');
    });

  });

});
});

require.register("test/utils/db_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.db', function () {

  describe('#App.db.set', function () {

    afterEach(function () {
      App.db.cleanUp();
    });

    it('should create one object', function () {
      App.db.set('a', 'b', 1);
      expect(App.db.data.a.b).to.equal(1);
    });

    it('should create nested objects', function () {
      App.db.set('b.c', 'd', 1);
      expect(App.db.data.b.c.d).to.equal(1);
    });

  });

  describe('#App.db.get', function () {

    after(function () {
      App.db.cleanUp();
    });

    it('should return undefined', function () {
      var ret = App.db.get('a', 'b');
      expect(ret).to.be.undefined;
    });

    it('should return set value', function () {
      App.db.set('a', 'b', 10);
      var ret = App.db.get('a', 'b');
      expect(ret).to.equal(10);
    });

  });

  describe('#App.db.setProperties', function () {

    afterEach(function () {
      App.db.cleanUp();
    });

    it('should create one object', function () {
      App.db.setProperties('a', {b: 1, c: 2});
      expect(App.db.data.a).to.eql({b: 1, c: 2});
    });

    it('should create nested objects', function () {
      App.db.setProperties('b.c', {b: 1, c: 2});
      expect(App.db.data.b.c).to.eql({b: 1, c: 2});
    });

  });

  describe('#App.db.getProperties', function () {

    after(function () {
      App.db.cleanUp();
    });

    it('should return undefined', function () {
      var ret = App.db.getProperties('a', ['b', 'c']);
      expect(ret).to.eql({b: undefined, c: undefined});
    });

    it('should return set value', function () {
      App.db.setProperties('a', {b: 1, c: 2});
      var ret = App.db.getProperties('a', ['b', 'c']);
      expect(ret).to.eql({b: 1, c: 2});
    });

  });

});
});

require.register("test/utils/ember_computed_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('utils/ember_computed');

describe('Ember.computed macros', function () {

  beforeEach(function () {
    App.reopen({
      someRandomTestingKey: function () {
        return this.get('someAnotherKey');
      }.property('someAnotherKey'),
      someAnotherKey: ''
    });
  });

  afterEach(function () {
    delete App.someAnotherKey;
    delete App.someRandomTestingKey;
  });

  describe('#equal', function () {

    beforeEach(function () {
      App.setProperties({
        someAnotherKey: '123'
      });
      this.obj = Em.Object.create({
        prop1: '123',
        prop2: Em.computed.equal('prop1', '123'),
        prop3: Em.computed.equal('App.someRandomTestingKey', '123')
      });
    });

    it('`true` if values are equal', function () {
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('`false` if values are not equal', function () {
      this.obj.set('prop1', '321');
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`prop3` depends on App.* key', function () {
      expect(this.obj.get('prop3')).to.be.true;
      App.set('someAnotherKey', '');
      expect(this.obj.get('prop3')).to.be.false;
    });

    it('prop3 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.eql(['App.someRandomTestingKey']);
    });

  });

  describe('#notEqual', function () {

    beforeEach(function () {
      App.setProperties({
        someAnotherKey: '123'
      });
      this.obj = Em.Object.create({
        prop1: '123',
        prop2: Em.computed.notEqual('prop1', '123'),
        prop3: Em.computed.notEqual('App.someRandomTestingKey', '123')
      });
    });

    it('`false` if values are equal', function () {
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`true` if values are not equal', function () {
      this.obj.set('prop1', '321');
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('`prop3` depends on App.* key', function () {
      expect(this.obj.get('prop3')).to.be.false;
      App.set('someAnotherKey', '');
      expect(this.obj.get('prop3')).to.be.true;
    });

    it('prop3 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.eql(['App.someRandomTestingKey']);
    });

  });

  describe('#equalProperties', function () {

    beforeEach(function () {
      App.set('someAnotherKey', '123');
      this.obj = Em.Object.create({
        prop1: '123',
        prop2: '123',
        prop3: Em.computed.equalProperties('prop1', 'prop2'),
        prop4: Em.computed.equalProperties('App.someRandomTestingKey', 'prop2'),
        prop5: Em.computed.equalProperties('prop1', 'App.someRandomTestingKey')
      });
    });

    it('`true` if values are equal', function () {
      expect(this.obj.get('prop3')).to.be.true;
    });

    it('`false` if values are not equal', function () {
      this.obj.set('prop1', '321');
      expect(this.obj.get('prop3')).to.be.false;
    });

    it('prop4 depends on App.* key', function () {
      expect(this.obj.get('prop4')).to.be.true;
      App.set('someAnotherKey', '');
      expect(this.obj.get('prop4')).to.be.false;
    });

    it('prop5 depends on App.* key', function () {
      expect(this.obj.get('prop5')).to.be.true;
      App.set('someAnotherKey', '');
      expect(this.obj.get('prop5')).to.be.false;
    });

    it('prop4 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop4._dependentKeys).to.eql(['App.someRandomTestingKey', 'prop2']);
    });

    it('prop5 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop5._dependentKeys).to.eql(['prop1', 'App.someRandomTestingKey']);
    });

  });

  describe('#notEqualProperties', function () {

    beforeEach(function () {
      App.set('someAnotherKey', '123');
      this.obj = Em.Object.create({
        prop1: '123',
        prop2: '123',
        prop3: Em.computed.notEqualProperties('prop1', 'prop2'),
        prop4: Em.computed.notEqualProperties('App.someRandomTestingKey', 'prop2'),
        prop5: Em.computed.notEqualProperties('prop1', 'App.someRandomTestingKey')
      });
    });

    it('`false` if values are equal', function () {
      expect(this.obj.get('prop3')).to.be.false;
    });

    it('`true` if values are not equal', function () {
      this.obj.set('prop1', '321');
      expect(this.obj.get('prop3')).to.be.true;
    });

    it('prop4 depends on App.* key', function () {
      expect(this.obj.get('prop4')).to.be.false;
      App.set('someAnotherKey', '');
      expect(this.obj.get('prop4')).to.be.true;
    });

    it('prop5 depends on App.* key', function () {
      expect(this.obj.get('prop5')).to.be.false;
      App.set('someAnotherKey', '');
      expect(this.obj.get('prop5')).to.be.true;
    });

    it('prop4 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop4._dependentKeys).to.eql(['App.someRandomTestingKey', 'prop2']);
    });

    it('prop5 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop5._dependentKeys).to.eql(['prop1', 'App.someRandomTestingKey']);
    });

  });

  describe('#ifThenElse', function () {

    beforeEach(function () {
      App.set('someAnotherKey', true);
      this.obj = Em.Object.create({
        prop1: true,
        prop2: Em.computed.ifThenElse('prop1', '1', '0'),
        prop3: Em.computed.ifThenElse('App.someRandomTestingKey', '1', '0')
      });
    });

    it('`1` if `prop1` is true', function () {
      expect(this.obj.get('prop2')).to.equal('1');
    });

    it('`0` if `prop1` is false', function () {
      this.obj.set('prop1', false);
      expect(this.obj.get('prop2')).to.equal('0');
    });

    it('prop3 depends on App.* key', function () {
      expect(this.obj.get('prop3')).to.equal('1');
      App.set('someAnotherKey', false);
      expect(this.obj.get('prop3')).to.equal('0');
    });

    it('prop3 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.eql(['App.someRandomTestingKey']);
    });

  });

  describe('#and', function () {

    beforeEach(function () {
      App.setProperties({
        someAnotherKey: true
      });
      this.obj = Em.Object.create({
        prop1: true,
        prop2: true,
        prop3: true,
        prop4: Em.computed.and('prop1', 'prop2', 'prop3'),
        prop5: Em.computed.and('prop1', '!prop2', '!prop3'),
        prop6: Em.computed.and('App.someRandomTestingKey', 'prop1'),
        prop7: Em.computed.and('!App.someRandomTestingKey', 'prop1')
      });
    });

    it('prop4 `true` if all dependent properties are true', function () {
      expect(this.obj.get('prop4')).to.be.true;
    });

    it('prop4 `false` if at elast one dependent property is false', function () {
      this.obj.set('prop2', false);
      expect(this.obj.get('prop4')).to.be.false;
    });

    it('prop5 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop5._dependentKeys).to.eql(['prop1', 'prop2', 'prop3']);
    });

    it('prop5 `false` if some inverted dependent properties is true', function () {
      expect(this.obj.get('prop5')).to.be.false;
    });

    it('prop5 `false` if some inverted dependent properties is true (2)', function () {
      this.obj.set('prop1', true);
      expect(this.obj.get('prop5')).to.be.false;
    });

    it('prop5 `true` ', function () {
      this.obj.set('prop2', false);
      this.obj.set('prop3', false);
      expect(this.obj.get('prop5')).to.be.true;
    });

    it('`prop6` depends on App.* key', function () {
      expect(this.obj.get('prop6')).to.be.true;
      App.set('someAnotherKey', false);
      expect(this.obj.get('prop6')).to.be.false;
      App.set('someAnotherKey', true);
      expect(this.obj.get('prop6')).to.be.true;
    });

    it('prop6 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop6._dependentKeys).to.eql(['App.someRandomTestingKey', 'prop1']);
    });

    it('`prop7` depends on inverted App.* key', function () {
      expect(this.obj.get('prop7')).to.be.false;
      App.set('someAnotherKey', false);
      expect(this.obj.get('prop7')).to.be.true;
      App.set('someAnotherKey', true);
      expect(this.obj.get('prop7')).to.be.false;
    });

    it('prop7 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop7._dependentKeys).to.eql(['App.someRandomTestingKey', 'prop1']);
    });

  });

  describe('#or', function () {
    beforeEach(function () {
      App.setProperties({
        someAnotherKey: true
      });
      this.obj = Em.Object.create({
        prop1: false,
        prop2: false,
        prop3: false,
        prop4: Em.computed.or('prop1', 'prop2', 'prop3'),
        prop5: Em.computed.or('!prop1', '!prop2', '!prop3'),
        prop6: Em.computed.or('App.someRandomTestingKey', 'prop1'),
        prop7: Em.computed.or('!App.someRandomTestingKey', 'prop1')
      });
    });

    it('`false` if all dependent properties are false', function () {
      expect(this.obj.get('prop4')).to.be.false;
    });

    it('`true` if at elast one dependent property is true', function () {
      this.obj.set('prop2', true);
      expect(this.obj.get('prop4')).to.be.true;
    });

    it('prop5 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop5._dependentKeys).to.eql(['prop1', 'prop2', 'prop3']);
    });

    it('prop5 `true` if some inverted dependent properties is true', function () {
      expect(this.obj.get('prop5')).to.be.true;
    });

    it('prop5 `true` if some inverted dependent properties is true (2)', function () {
      this.obj.set('prop1', true);
      expect(this.obj.get('prop5')).to.be.true;
    });

    it('prop5 `false` ', function () {
      this.obj.set('prop1', true);
      this.obj.set('prop2', true);
      this.obj.set('prop3', true);
      expect(this.obj.get('prop5')).to.be.false;
    });

    it('`prop6` depends on App.* key', function () {
      expect(this.obj.get('prop6')).to.be.true;
      App.set('someAnotherKey', false);
      expect(this.obj.get('prop6')).to.be.false;
      App.set('someAnotherKey', true);
      expect(this.obj.get('prop6')).to.be.true;
    });

    it('prop6 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop6._dependentKeys).to.eql(['App.someRandomTestingKey', 'prop1']);
    });

    it('`prop7` depends on inverted App.* key', function () {
      expect(this.obj.get('prop7')).to.be.false;
      App.set('someAnotherKey', false);
      expect(this.obj.get('prop7')).to.be.true;
      App.set('someAnotherKey', true);
      expect(this.obj.get('prop7')).to.be.false;
    });

    it('prop7 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop7._dependentKeys).to.eql(['App.someRandomTestingKey', 'prop1']);
    });

  });

  describe('#sumProperties', function () {

    beforeEach(function () {
      App.setProperties({
        someAnotherKey: 5
      });
      this.obj = Em.Object.create({
        prop1: 1,
        prop2: 2,
        prop3: 3,
        prop4: Em.computed.sumProperties('prop1', 'prop2', 'prop3'),
        prop5: Em.computed.sumProperties('prop1', 'prop2', 'App.someRandomTestingKey')
      });
    });

    it('should be sum of dependent values', function () {
      expect(this.obj.get('prop4')).to.equal(6);
    });

    it('should be updated if some dependent value is changed', function () {
      this.obj.set('prop1', 4);
      expect(this.obj.get('prop4')).to.equal(9);
    });

    it('should be updated if some dependent value is string', function () {
      this.obj.set('prop1', '4');
      expect(this.obj.get('prop4')).to.equal(9);
    });

    it('should be updated if some dependent value is string (2)', function () {
      this.obj.set('prop1', '4.5');
      expect(this.obj.get('prop4')).to.equal(9.5);
    });

    it('should be updated if some dependent value is null', function () {
      this.obj.set('prop1', null);
      expect(this.obj.get('prop4')).to.equal(5);
    });

    it('`prop5` depends on App.* key', function () {
      expect(this.obj.get('prop5')).to.equal(8);
      App.set('someAnotherKey', 6);
      expect(this.obj.get('prop5')).to.equal(9);
    });

    it('prop5 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop5._dependentKeys).to.eql(['prop1', 'prop2', 'App.someRandomTestingKey']);
    });

  });

  describe('#gte', function () {

    beforeEach(function () {
      App.set('someAnotherKey', 4);
      this.obj = Em.Object.create({
        prop1: 2,
        prop2: Em.computed.gte('prop1', 3),
        prop3: Em.computed.gte('App.someRandomTestingKey', 3)
      });
    });

    it('`false` if value is less than needed', function () {
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`true` if value is equal to the needed', function () {
      this.obj.set('prop1', 3);
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('`true` if value is greater than needed', function () {
      this.obj.set('prop1', 4);
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('prop3 depends on App.* key', function () {
      expect(this.obj.get('prop3')).to.be.true;
      App.set('someAnotherKey', 3);
      expect(this.obj.get('prop3')).to.be.true;
      App.set('someAnotherKey', 2);
      expect(this.obj.get('prop3')).to.be.false;
    });

    it('prop3 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.eql(['App.someRandomTestingKey']);
    });

  });

  describe('#gteProperties', function () {

    beforeEach(function () {
      App.set('someAnotherKey', 4);
      this.obj = Em.Object.create({
        prop1: 2,
        prop2: 3,
        prop3: Em.computed.gteProperties('prop1', 'prop2'),
        prop4: Em.computed.gteProperties('App.someRandomTestingKey', 'prop2'),
        prop5: Em.computed.gteProperties('prop1', 'App.someRandomTestingKey')
      });
    });

    it('`false` if value is less than needed', function () {
      expect(this.obj.get('prop3')).to.be.false;
    });

    it('`true` if value is equal to the needed', function () {
      this.obj.set('prop1', 3);
      expect(this.obj.get('prop3')).to.be.true;
    });

    it('`true` if value is greater than needed', function () {
      this.obj.set('prop1', 4);
      expect(this.obj.get('prop3')).to.be.true;
    });

    it('prop4 depends on App.* key', function () {
      expect(this.obj.get('prop4')).to.be.true;
      App.set('someAnotherKey', 3);
      expect(this.obj.get('prop4')).to.be.true;
      App.set('someAnotherKey', 2);
      expect(this.obj.get('prop4')).to.be.false;
    });

    it('prop5 depends on App.* key', function () {
      expect(this.obj.get('prop5')).to.be.false;
      App.set('someAnotherKey', 2);
      expect(this.obj.get('prop5')).to.be.true;
      App.set('someAnotherKey', 1);
      expect(this.obj.get('prop5')).to.be.true;
    });

    it('prop4 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop4._dependentKeys).to.eql(['App.someRandomTestingKey', 'prop2']);
    });

    it('prop5 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop5._dependentKeys).to.eql(['prop1', 'App.someRandomTestingKey']);
    });

  });

  describe('#lte', function () {

    beforeEach(function () {
      App.set('someAnotherKey', 0);
      this.obj = Em.Object.create({
        prop1: 2,
        prop2: Em.computed.lte('prop1', 1),
        prop3: Em.computed.lte('App.someRandomTestingKey', 1)
      });
    });

    it('`false` if value is greater  than needed', function () {
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`true` if value is equal to the needed', function () {
      this.obj.set('prop1', 1);
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('`true` if value is less than needed', function () {
      this.obj.set('prop1', 0);
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('prop3 depends on App.* key', function () {
      expect(this.obj.get('prop3')).to.be.true;
      App.set('someAnotherKey', 1);
      expect(this.obj.get('prop3')).to.be.true;
      App.set('someAnotherKey', 2);
      expect(this.obj.get('prop3')).to.be.false;
    });

    it('prop3 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.eql(['App.someRandomTestingKey']);
    });

  });

  describe('#lteProperties', function () {

    beforeEach(function () {
      App.set('someAnotherKey', 1);
      this.obj = Em.Object.create({
        prop1: 2,
        prop2: 1,
        prop3: Em.computed.lteProperties('prop1', 'prop2'),
        prop4: Em.computed.lteProperties('App.someRandomTestingKey', 'prop2'),
        prop5: Em.computed.lteProperties('prop1', 'App.someRandomTestingKey')
      });
    });

    it('`false` if d1 is greater than d2', function () {
      expect(this.obj.get('prop3')).to.be.false;
    });

    it('`true` if d1 is equal to the d2', function () {
      this.obj.set('prop1', 1);
      expect(this.obj.get('prop3')).to.be.true;
    });

    it('`true` if d1 is less than d2', function () {
      this.obj.set('prop1', 0);
      expect(this.obj.get('prop3')).to.be.true;
    });

    it('prop4 depends on App.* key', function () {
      expect(this.obj.get('prop4')).to.be.true;
      App.set('someAnotherKey', 0);
      expect(this.obj.get('prop4')).to.be.true;
      App.set('someAnotherKey', 2);
      expect(this.obj.get('prop4')).to.be.false;
    });

    it('prop5 depends on App.* key', function () {
      expect(this.obj.get('prop5')).to.be.false;
      App.set('someAnotherKey', 2);
      expect(this.obj.get('prop5')).to.be.true;
      App.set('someAnotherKey', 3);
      expect(this.obj.get('prop5')).to.be.true;
    });

    it('prop4 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop4._dependentKeys).to.eql(['App.someRandomTestingKey', 'prop2']);
    });

    it('prop5 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop5._dependentKeys).to.eql(['prop1', 'App.someRandomTestingKey']);
    });

  });

  describe('#gt', function () {

    beforeEach(function () {
      App.set('someAnotherKey', 4);
      this.obj = Em.Object.create({
        prop1: 2,
        prop2: Em.computed.gt('prop1', 3),
        prop3: Em.computed.gt('App.someRandomTestingKey', 3)
      });
    });

    it('`false` if value is less than needed', function () {
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`false` if value is equal to the needed', function () {
      this.obj.set('prop1', 3);
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`true` if value is greater than needed', function () {
      this.obj.set('prop1', 4);
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('prop3 depends on App.* key', function () {
      expect(this.obj.get('prop3')).to.be.true;
      App.set('someAnotherKey', 3);
      expect(this.obj.get('prop3')).to.be.false;
      App.set('someAnotherKey', 2);
      expect(this.obj.get('prop3')).to.be.false;
    });

    it('prop3 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.eql(['App.someRandomTestingKey']);
    });

  });

  describe('#gtProperties', function () {

    beforeEach(function () {
      App.set('someAnotherKey', 4);
      this.obj = Em.Object.create({
        prop1: 2,
        prop2: 3,
        prop3: Em.computed.gtProperties('prop1', 'prop2'),
        prop4: Em.computed.gtProperties('App.someRandomTestingKey', 'prop2'),
        prop5: Em.computed.gtProperties('prop1', 'App.someRandomTestingKey')
      });
    });

    it('`false` if value is less than needed', function () {
      expect(this.obj.get('prop3')).to.be.false;
    });

    it('`false` if value is equal to the needed', function () {
      this.obj.set('prop1', 3);
      expect(this.obj.get('prop3')).to.be.false;
    });

    it('`true` if value is greater than needed', function () {
      this.obj.set('prop1', 4);
      expect(this.obj.get('prop3')).to.be.true;
    });

    it('prop4 depends on App.* key', function () {
      expect(this.obj.get('prop4')).to.be.true;
      App.set('someAnotherKey', 3);
      expect(this.obj.get('prop4')).to.be.false;
      App.set('someAnotherKey', 2);
      expect(this.obj.get('prop4')).to.be.false;
    });

    it('prop5 depends on App.* key', function () {
      expect(this.obj.get('prop5')).to.be.false;
      App.set('someAnotherKey', 2);
      expect(this.obj.get('prop5')).to.be.false;
      App.set('someAnotherKey', 1);
      expect(this.obj.get('prop5')).to.be.true;
    });

    it('prop4 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop4._dependentKeys).to.eql(['App.someRandomTestingKey', 'prop2']);
    });

    it('prop5 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop5._dependentKeys).to.eql(['prop1', 'App.someRandomTestingKey']);
    });

  });

  describe('#lt', function () {

    beforeEach(function () {
      App.set('someAnotherKey', 0);
      this.obj = Em.Object.create({
        prop1: 2,
        prop2: Em.computed.lt('prop1', 1),
        prop3: Em.computed.lt('App.someRandomTestingKey', 1)
      });
    });

    it('`false` if value is greater  than needed', function () {
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`false` if value is equal to the needed', function () {
      this.obj.set('prop1', 1);
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`true` if value is less than needed', function () {
      this.obj.set('prop1', 0);
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('prop3 depends on App.* key', function () {
      expect(this.obj.get('prop3')).to.be.true;
      App.set('someAnotherKey', 1);
      expect(this.obj.get('prop3')).to.be.false;
      App.set('someAnotherKey', 2);
      expect(this.obj.get('prop3')).to.be.false;
    });

    it('prop3 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.eql(['App.someRandomTestingKey']);
    });

  });

  describe('#ltProperties', function () {

    beforeEach(function () {
      App.set('someAnotherKey', 1);
      this.obj = Em.Object.create({
        prop1: 2,
        prop2: 1,
        prop3: Em.computed.ltProperties('prop1', 'prop2'),
        prop4: Em.computed.ltProperties('App.someRandomTestingKey', 'prop2'),
        prop5: Em.computed.ltProperties('prop1', 'App.someRandomTestingKey')
      });
    });

    it('`false` if d1 is greater than d2', function () {
      expect(this.obj.get('prop3')).to.be.false;
    });

    it('`false` if d1 is equal to the d2', function () {
      this.obj.set('prop1', 1);
      expect(this.obj.get('prop3')).to.be.false;
    });

    it('`true` if d1 is less than d2', function () {
      this.obj.set('prop1', 0);
      expect(this.obj.get('prop3')).to.be.true;
    });

    it('prop4 depends on App.* key', function () {
      expect(this.obj.get('prop4')).to.be.false;
      App.set('someAnotherKey', 0);
      expect(this.obj.get('prop4')).to.be.true;
      App.set('someAnotherKey', 2);
      expect(this.obj.get('prop4')).to.be.false;
    });

    it('prop5 depends on App.* key', function () {
      expect(this.obj.get('prop5')).to.be.false;
      App.set('someAnotherKey', 2);
      expect(this.obj.get('prop5')).to.be.false;
      App.set('someAnotherKey', 3);
      expect(this.obj.get('prop5')).to.be.true;
    });

    it('prop4 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop4._dependentKeys).to.eql(['App.someRandomTestingKey', 'prop2']);
    });

    it('prop5 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop5._dependentKeys).to.eql(['prop1', 'App.someRandomTestingKey']);
    });

  });

  describe('#match', function () {

    beforeEach(function () {
      this.obj = Em.Object.create({
        prop1: 'abc',
        prop2: Em.computed.match('prop1', /^ab/)
      })
    });

    it('`true` if value match regexp', function () {
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('`true` if value match regexp (2)', function () {
      this.obj.set('prop1', 'abaaa');
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('`false` if value doesn\'t match regexp', function () {
      this.obj.set('prop1', '!!!!');
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`prop2` has valid dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop2._dependentKeys).to.eql(['prop1']);
    });

  });

  describe('#someBy', function () {

    beforeEach(function () {
      this.obj = Em.Object.create({
        prop1: [{a: 1}, {a: 2}, {a: 3}],
        prop2: Em.computed.someBy('prop1', 'a', 2)
      });
    });

    it('`true` if some collection item has needed property value', function () {
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('`false` if on one collection item doesn\'t have needed property value', function () {
      this.obj.set('prop1.1.a', 3);
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`false` for null/undefined collection', function () {
      this.obj.set('prop1', null);
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`prop2` has valid dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop2._dependentKeys).to.eql(['prop1.@each.a']);
    });

  });

  describe('#someByKey', function () {

    beforeEach(function () {
      App.setProperties({
        someAnotherKey: 2
      });
      this.obj = Em.Object.create({
        prop1: [{a: 1}, {a: 2}, {a: 3}],
        prop2: Em.computed.someByKey('prop1', 'a', 'value1'),
        prop3: Em.computed.someByKey('prop1', 'a', 'App.someRandomTestingKey'),
        value1: 2
      });
    });

    it('`true` if some collection item has needed property value', function () {
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('`false` if on one collection item doesn\'t have needed property value', function () {
      this.obj.set('prop1.1.a', 3);
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`false` for null/undefined collection', function () {
      this.obj.set('prop1', null);
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`prop2` has valid dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop2._dependentKeys).to.eql(['prop1.@each.a', 'value1']);
    });

    it('`prop3` has valid dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.eql(['prop1.@each.a', 'App.someRandomTestingKey']);
    });

    it('`prop3` depends on App.* key', function () {
      expect(this.obj.get('prop3')).to.be.true;
      this.obj.set('prop1.1.a', 3);
      expect(this.obj.get('prop3')).to.be.false;
    });

  });

  describe('#everyBy', function () {

    beforeEach(function () {
      this.obj = Em.Object.create({
        prop1: [{a: 2}, {a: 2}, {a: 2}],
        prop2: Em.computed.everyBy('prop1', 'a', 2)
      });
    });

    it('`true` if all collection items have needed property value', function () {
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('`false` if at least one collection item doesn\'t have needed property value', function () {
      this.obj.set('prop1.1.a', 3);
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`false` for null/undefined collection', function () {
      this.obj.set('prop1', null);
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`prop2` has valid dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop2._dependentKeys).to.eql(['prop1.@each.a']);
    });

  });

  describe('#everyByKey', function () {
    beforeEach(function () {
      App.setProperties({
        someAnotherKey: 2
      });
      this.obj = Em.Object.create({
        prop1: [{a: 2}, {a: 2}, {a: 2}],
        prop2: Em.computed.everyByKey('prop1', 'a', 'value1'),
        prop3: Em.computed.everyByKey('prop1', 'a', 'App.someRandomTestingKey'),
        value1: 2
      });
    });

    it('`true` if all collection items have needed property value', function () {
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('`false` if at least one collection item doesn\'t have needed property value', function () {
      this.obj.set('prop1.1.a', 3);
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`false` for null/undefined collection', function () {
      this.obj.set('prop1', null);
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`prop2` has valid dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop2._dependentKeys).to.eql(['prop1.@each.a', 'value1']);
    });

    it('`prop3` has valid dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.eql(['prop1.@each.a', 'App.someRandomTestingKey']);
    });

    it('`prop3` depends on App.* key', function () {
      expect(this.obj.get('prop3')).to.be.true;
      this.obj.set('prop1.1.a', 3);
      expect(this.obj.get('prop3')).to.be.false;
    });

  });

  describe('#mapBy', function () {

    beforeEach(function () {
      this.obj = Em.Object.create({
        prop1: [{a: 1}, {a: 2}, {a: 3}],
        prop2: Em.computed.mapBy('prop1', 'a')
      });
    });

    it('should map dependent property', function () {
      expect(this.obj.get('prop2')).to.eql([1, 2, 3]);
    });

    it('should map dependent property (2)', function () {
      this.obj.get('prop1').push({a: 4});
      expect(this.obj.get('prop2')).to.eql([1, 2, 3, 4]);
    });

    it('`[]` for null/undefined collection', function () {
      this.obj.set('prop1', null);
      expect(this.obj.get('prop2')).to.eql([]);
    });

    it('`prop2` has valid dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop2._dependentKeys).to.eql(['prop1.@each.a']);
    });

  });

  describe('#filterBy', function () {

    beforeEach(function () {
      this.obj = Em.Object.create({
        prop1: [{a: 2}, {a: 2}, {a: 3}],
        prop2: Em.computed.filterBy('prop1', 'a', 2)
      });
    });

    it('should filter dependent property', function () {
      expect(this.obj.get('prop2')).to.eql([{a: 2}, {a: 2}]);
    });

    it('should filter dependent property (2)', function () {
      this.obj.get('prop1').pushObject({a: 2});
      expect(this.obj.get('prop2')).to.eql([{a: 2}, {a: 2}, {a: 2}]);
    });

    it('`[]` for null/undefined collection', function () {
      this.obj.set('prop1', null);
      expect(this.obj.get('prop2')).to.eql([]);
    });

    it('`prop2` has valid dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop2._dependentKeys).to.eql(['prop1.@each.a']);
    });

  });

  describe('#filterByKey', function () {

    beforeEach(function () {
      App.setProperties({
        someAnotherKey: 2
      });
      this.obj = Em.Object.create({
        prop1: [{a: 2}, {a: 2}, {a: 3}],
        prop2: Em.computed.filterByKey('prop1', 'a', 'value1'),
        prop3: Em.computed.filterByKey('prop1', 'a', 'App.someRandomTestingKey'),
        value1: 2
      });
    });

    it('should filter dependent property', function () {
      expect(this.obj.get('prop2')).to.eql([{a: 2}, {a: 2}]);
    });

    it('should filter dependent property (2)', function () {
      this.obj.get('prop1').pushObject({a: 2});
      expect(this.obj.get('prop2')).to.eql([{a: 2}, {a: 2}, {a: 2}]);
    });

    it('`[]` for null/undefined collection', function () {
      this.obj.set('prop1', null);
      expect(this.obj.get('prop2')).to.eql([]);
    });

    it('`prop2` has valid dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop2._dependentKeys).to.eql(['prop1.@each.a', 'value1']);
    });

    it('`prop3` has valid dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.eql(['prop1.@each.a', 'App.someRandomTestingKey']);
    });

    it('`prop3` depends on App.* key', function () {
      expect(this.obj.get('prop3')).to.eql([{a: 2}, {a: 2}]);
      this.obj.set('prop1.1.a', 3);
      expect(this.obj.get('prop3')).to.eql([{a: 2}]);
    });

  });

  describe('#findBy', function () {

    beforeEach(function () {
      this.obj = Em.Object.create({
        prop1: [{b: 1, a: 2}, {b: 2, a: 2}, {a: 3}],
        prop2: Em.computed.findBy('prop1', 'a', 2)
      });
    });

    it('should filter dependent property', function () {
      expect(this.obj.get('prop2')).to.eql({b:1, a: 2});
    });

    it('should filter dependent property (2)', function () {
      this.obj.get('prop1').pushObject({b: 3, a: 2});
      expect(this.obj.get('prop2')).to.eql({b: 1, a: 2});
    });

    it('`null` for null/undefined collection', function () {
      this.obj.set('prop1', null);
      expect(this.obj.get('prop2')).to.be.null;
    });

    it('`prop2` has valid dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop2._dependentKeys).to.eql(['prop1.@each.a']);
    });

  });

  describe('#findByKey', function () {

    beforeEach(function () {
      App.setProperties({
        someAnotherKey: 2
      });
      this.obj = Em.Object.create({
        prop1: [{b: 1, a: 2}, {b: 2, a: 2}, {a: 3}],
        prop2: Em.computed.findByKey('prop1', 'a', 'value1'),
        prop3: Em.computed.findByKey('prop1', 'a', 'App.someRandomTestingKey'),
        value1: 2
      });
    });

    it('should filter dependent property', function () {
      expect(this.obj.get('prop2')).to.eql({b:1, a: 2});
    });

    it('should filter dependent property (2)', function () {
      this.obj.get('prop1').pushObject({b: 3, a: 2});
      expect(this.obj.get('prop2')).to.eql({b: 1, a: 2});
    });

    it('`null` for null/undefined collection', function () {
      this.obj.set('prop1', null);
      expect(this.obj.get('prop2')).to.be.null;
    });

    it('`prop2` has valid dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop2._dependentKeys).to.eql(['prop1.@each.a', 'value1']);
    });

    it('`prop3` has valid dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.eql(['prop1.@each.a', 'App.someRandomTestingKey']);
    });

    it('`prop3` depends on App.* key', function () {
      expect(this.obj.get('prop3')).to.eql({b: 1, a: 2});
      this.obj.get('prop1').pushObject({b: 3, a: 2});
      expect(this.obj.get('prop3')).to.eql({b: 1, a: 2});
    });

  });

  describe('#alias', function() {

    beforeEach(function () {
      App.set('someAnotherKey', {a: {b: 1}});
      this.obj = Em.Object.create({
        prop1: {
          a: {
            b: {
              c: 1
            }
          }
        },
        prop2: Em.computed.alias('prop1.a.b.c'),
        prop3: Em.computed.alias('App.someAnotherKey.a.b')
      })
    });

    it('should be equal to dependent property', function () {
      expect(this.obj.get('prop2')).to.equal(1);
    });

    it('should be equal to dependent property (2)', function () {
      this.obj.set('prop1.a.b.c', 2);
      expect(this.obj.get('prop2')).to.equal(2);
    });

    it('prop3 depends on App.* key', function () {
      expect(this.obj.get('prop3')).to.equal(1);
      App.set('someAnotherKey.a.b', 4);
      expect(this.obj.get('prop3')).to.equal(4);
    });

    it('prop3 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.eql(['App.someAnotherKey.a.b']);
    });

  });

  describe('#existsIn', function () {

    beforeEach(function () {
      this.obj = Em.Object.create({
        prop1: 'v1',
        prop2: Em.computed.existsIn('prop1', ['v1', 'v2'])
      });
    });

    it('`true` if dependent value is in the array', function () {
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('`true` if dependent value is in the array (2)', function () {
      this.obj.set('prop1', 'v2');
      expect(this.obj.get('prop2')).to.be.true;
    });

    it('`false` if dependent value is not in the array', function () {
      this.obj.set('prop1', 'v3');
      expect(this.obj.get('prop2')).to.be.false;
    });

  });

  describe('#percents', function () {

    beforeEach(function () {
      App.setProperties({
        p1: 25,
        p2: 100
      });
      this.obj = Em.Object.create({
        prop1: 10,
        prop2: 25,
        prop3: Em.computed.percents('prop1', 'prop2'),
        prop4: Em.computed.percents('prop1', 'prop2', 2),
        prop5: Em.computed.percents('App.p1', 'App.p2', 1)
      });
    });

    afterEach(function () {
      delete App.p1;
      delete App.p2;
    });

    it('should calculate percents', function () {
      expect(this.obj.get('prop3')).to.equal(40);
      expect(this.obj.get('prop4')).to.equal(40.00);
    });

    it('should calculate percents (2)', function () {
      this.obj.set('prop2', 35);
      expect(this.obj.get('prop3')).to.equal(29);
      expect(this.obj.get('prop4')).to.equal(28.57);
    });

    it('should calculate percents (3)', function () {
      this.obj.set('prop2', '35');
      expect(this.obj.get('prop3')).to.equal(29);
      expect(this.obj.get('prop4')).to.equal(28.57);
    });

    it('should calculate percents (4)', function () {
      this.obj.set('prop1', 10.6);
      this.obj.set('prop2', 100);
      expect(this.obj.get('prop3')).to.equal(11);
      expect(this.obj.get('prop4')).to.equal(10.60);
    });

    it('should calculate percents (5)', function () {
      this.obj.set('prop1', '10.6');
      this.obj.set('prop2', 100);
      expect(this.obj.get('prop3')).to.equal(11);
      expect(this.obj.get('prop4')).to.equal(10.60);
    });

    it('prop5 depends on App.* keys', function () {
      expect(this.obj.get('prop5')).to.equal(25.0);
      App.set('p2', 50);
      expect(this.obj.get('prop5')).to.equal(50.0);
      App.set('p1', 10);
      expect(this.obj.get('prop5')).to.equal(20.0);
    });

    it('prop4 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop5._dependentKeys).to.eql(['App.p1', 'App.p2']);
    });

  });

  describe('#formatRole', function () {

    beforeEach(function () {
      this.obj = Em.Object.create({
        prop1: 'NAMENODE',
        prop2: false,
        prop3: Em.computed.formatRole('prop1', 'prop2')
      });
      sinon.stub(App.StackServiceComponent, 'find', function () {
        return [
          Em.Object.create({id: 'NAMENODE', displayName: 'NameNode'}),
          Em.Object.create({id: 'SECONDARY_NAMENODE', displayName: 'Secondary NameNode'})
        ];
      });
      sinon.stub(App.StackService, 'find', function () {
        return [
          Em.Object.create({id: 'MAPREDUCE2', displayName: 'MapReduce2'}),
          Em.Object.create({id: 'HIVE', displayName: 'Hive'})
        ];
      });
    });

    afterEach(function () {
      App.StackService.find.restore();
      App.StackServiceComponent.find.restore();
    });

    it('should format as role', function () {
      expect(this.obj.get('prop3')).to.equal('NameNode');
    });

    it('should format as role (2)', function () {
      this.obj.set('prop1', 'HIVE');
      this.obj.set('prop2', true);
      expect(this.obj.get('prop3')).to.equal('Hive');
    });

  });

  describe('#sumBy', function () {

    beforeEach(function () {
      this.obj = Em.Object.create({
        prop1: [
          {a: 1}, {a: 2}, {a: 3}
        ],
        prop2: Em.computed.sumBy('prop1', 'a')
      });
    });

    it('should calculate sum', function () {
      expect(this.obj.get('prop2')).to.equal(6);
    });

    it('should calculate sum (2)', function () {
      this.obj.get('prop1').pushObject({a: 4});
      expect(this.obj.get('prop2')).to.equal(10);
    });

    it('0 for empty collection', function () {
      this.obj.set('prop1', []);
      expect(this.obj.get('prop2')).to.equal(0);
    });

  });

  describe('#i18nFormat', function () {

    beforeEach(function () {

      App.setProperties({
        someAnotherKey: 'some value'
      });

      sinon.stub(Em.I18n, 't', function (key) {
        var msgs = {
          key1: '{0} {1} {2}'
        };
        return msgs[key];
      });
      this.obj = Em.Object.create({
        prop1: 'abc',
        prop2: 'cba',
        prop3: 'aaa',
        prop4: Em.computed.i18nFormat('key1', 'prop1', 'prop2', 'prop3'),
        prop5: Em.computed.i18nFormat('not_existing_key', 'prop1', 'prop2', 'prop3'),
        prop6: Em.computed.i18nFormat('key1', 'App.someRandomTestingKey', 'prop2', 'prop3')
      });
    });

    afterEach(function () {
      Em.I18n.t.restore();
    });

    it('`prop4` check dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop4._dependentKeys).to.eql(['prop1', 'prop2', 'prop3']);
    });

    it('should format message', function () {
      expect(this.obj.get('prop4')).to.equal('abc cba aaa');
    });

    it('should format message (2)', function () {
      this.obj.set('prop1', 'aaa');
      expect(this.obj.get('prop4')).to.equal('aaa cba aaa');
    });

    it('empty string for not existing i18-key', function () {
      expect(this.obj.get('prop5')).to.equal('');
    });

    it('`prop6` depends on App.* key', function () {
      expect(this.obj.get('prop6')).to.equal('some value cba aaa');
      App.set('someAnotherKey', '');
      expect(this.obj.get('prop6')).to.equal(' cba aaa');
    });

    it('prop6 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop6._dependentKeys).to.eql(['App.someRandomTestingKey', 'prop2', 'prop3']);
    });

  });

  describe('#concat', function () {

    beforeEach(function () {

      App.setProperties({
        someAnotherKey: 'some value'
      });

      this.obj = Em.Object.create({
        prop1: 'abc',
        prop2: 'cba',
        prop3: 'aaa',
        prop4: Em.computed.concat(' ', 'prop1', 'prop2', 'prop3'),
        prop5: Em.computed.concat(' ', 'App.someRandomTestingKey', 'prop2', 'prop3'),
        prop6: Em.computed.concat(' ')
      });
    });

    it('should concat dependent values', function () {
      expect(this.obj.get('prop4')).to.equal('abc cba aaa');
    });

    it('should concat dependent values (2)', function () {
      this.obj.set('prop1', 'aaa');
      expect(this.obj.get('prop4')).to.equal('aaa cba aaa');
    });

    it('`prop5` depends on App.* key', function () {
      expect(this.obj.get('prop5')).to.equal('some value cba aaa');
      App.set('someAnotherKey', '');
      expect(this.obj.get('prop5')).to.equal(' cba aaa');
    });

    it('prop5 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop5._dependentKeys).to.eql(['App.someRandomTestingKey', 'prop2', 'prop3']);
    });

    it('prop6 without dependent keys', function () {
      expect(this.obj.get('prop6')).to.equal('');
    });

  });

  describe('#notExistsIn', function () {

    beforeEach(function () {
      this.obj = Em.Object.create({
        prop1: 'v1',
        prop2: Em.computed.notExistsIn('prop1', ['v1', 'v2'])
      });
    });

    it('`false` if dependent value is in the array', function () {
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`false` if dependent value is in the array (2)', function () {
      this.obj.set('prop1', 'v2');
      expect(this.obj.get('prop2')).to.be.false;
    });

    it('`true` if dependent value is not in the array', function () {
      this.obj.set('prop1', 'v3');
      expect(this.obj.get('prop2')).to.be.true;
    });

  });

  describe('#firstNotBlank', function () {

    beforeEach(function () {

      App.setProperties({
        someAnotherKey: 'NOT-EMPTY-STRING'
      });

      this.obj = Em.Object.create({
        prop1: '',
        prop2: null,
        prop3: '1234',
        prop4: Em.computed.firstNotBlank('prop1', 'prop2', 'prop3'),
        prop5: Em.computed.firstNotBlank('prop1', 'App.someRandomTestingKey', 'prop3'),
        prop6: Em.computed.firstNotBlank('prop1', 'prop2')
      })
    });

    it('`prop4` check dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop4._dependentKeys).to.eql(['prop1', 'prop2', 'prop3']);
    });

    it('should returns prop3', function () {
      expect(this.obj.get('prop4')).to.equal('1234');
    });

    it('should returns prop2', function () {
      this.obj.set('prop2', 'not empty string');
      expect(this.obj.get('prop4')).to.equal('not empty string');
    });

    it('should returns prop1', function () {
      this.obj.set('prop2', 'not empty string');
      this.obj.set('prop1', 'prop1 is used');
      expect(this.obj.get('prop4')).to.equal('prop1 is used');
    });

    it('`prop5` depends on App.* key', function () {
      expect(this.obj.get('prop5')).to.equal('NOT-EMPTY-STRING');
      App.set('someAnotherKey', '!!!!!!!');
      expect(this.obj.get('prop5')).to.equal('!!!!!!!');
      App.set('someAnotherKey', null);
      expect(this.obj.get('prop5')).to.equal('1234');
    });

    it('prop5 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop5._dependentKeys).to.eql(['prop1', 'App.someRandomTestingKey', 'prop3']);
    });

    it('prop6 depends on blank values', function () {
      expect(this.obj.get('prop6')).to.be.null;
    });

  });

  describe('#format', function () {

    beforeEach(function () {

      App.setProperties({
        someAnotherKey: 'some value'
      });

      this.obj = Em.Object.create({
        prop1: 'abc',
        prop2: 'cba',
        prop3: 'aaa',
        prop4: Em.computed.format('{0} {1} {2}', 'prop1', 'prop2', 'prop3'),
        prop5: Em.computed.format(null, 'prop1', 'prop2', 'prop3'),
        prop6: Em.computed.format('{0} {1} {2}', 'App.someRandomTestingKey', 'prop2', 'prop3')
      });
    });

    it('`prop4` check dependent keys', function () {
      expect(Em.meta(this.obj).descs.prop4._dependentKeys).to.eql(['prop1', 'prop2', 'prop3']);
    });

    it('should format message', function () {
      expect(this.obj.get('prop4')).to.equal('abc cba aaa');
    });

    it('should format message (2)', function () {
      this.obj.set('prop1', 'aaa');
      expect(this.obj.get('prop4')).to.equal('aaa cba aaa');
    });

    it('empty string for not existing i18-key', function () {
      expect(this.obj.get('prop5')).to.equal('');
    });

    it('`prop6` depends on App.* key', function () {
      expect(this.obj.get('prop6')).to.equal('some value cba aaa');
      App.set('someAnotherKey', '');
      expect(this.obj.get('prop6')).to.equal(' cba aaa');
    });

    it('prop6 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop6._dependentKeys).to.eql(['App.someRandomTestingKey', 'prop2', 'prop3']);
    });

  });

  describe('#formatUnavailable', function () {

    beforeEach(function () {
      App.setProperties({
        someAnotherKey: 1
      });

      this.obj = Em.Object.create({
        prop1: 1,
        prop2: Em.computed.formatUnavailable('prop1'),
        prop3: Em.computed.formatUnavailable('App.someRandomTestingKey')
      });
    });

    it('`value` is 1', function () {
      expect(this.obj.get('prop2')).to.equal(1);
      expect(this.obj.get('prop3')).to.equal(1);
    });

    it('`value` is 0', function () {
      App.set('someAnotherKey', 0);
      this.obj.set('prop1', 0);
      expect(this.obj.get('prop2')).to.equal(0);
      expect(this.obj.get('prop3')).to.equal(0);
    });

    it('`value` is `0`', function () {
      App.set('someAnotherKey', '0');
      this.obj.set('prop1', '0');
      expect(this.obj.get('prop2')).to.equal('0');
      expect(this.obj.get('prop3')).to.equal('0');
    });

    it('`value` is not numeric', function () {
      App.set('someAnotherKey', null);
      this.obj.set('prop1', null);
      expect(this.obj.get('prop2')).to.equal('n/a');
      expect(this.obj.get('prop3')).to.equal('n/a');
    });

    it('prop3 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.eql(['App.someRandomTestingKey']);
    });

  });

  describe('#countBasedMessage', function () {

    var msg0 = 'msg0';
    var msg1 = 'msg1';
    var msgM = 'msgM';

    beforeEach(function () {
      App.setProperties({
        someAnotherKey: 1
      });

      this.obj = Em.Object.create({
        prop1: 1,
        prop2: Em.computed.countBasedMessage('prop1', msg0, msg1, msgM),
        prop3: Em.computed.countBasedMessage('App.someRandomTestingKey', msg0, msg1, msgM)
      });
    });

    it('`value` is 1', function () {
      expect(this.obj.get('prop2')).to.equal(msg1);
      expect(this.obj.get('prop3')).to.equal(msg1);
    });

    it('`value` is 0', function () {
      App.set('someAnotherKey', 0);
      this.obj.set('prop1', 0);
      expect(this.obj.get('prop2')).to.equal(msg0);
      expect(this.obj.get('prop3')).to.equal(msg0);
    });

    it('`value` is greater than 1', function () {
      App.set('someAnotherKey', 3);
      this.obj.set('prop1', 3);
      expect(this.obj.get('prop2')).to.equal(msgM);
      expect(this.obj.get('prop3')).to.equal(msgM);
    });

    it('prop3 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.eql(['App.someRandomTestingKey']);
    });

  });

  describe('#getByKey', function () {

    beforeEach(function () {
      this.obj = Em.Object.create({
        prop1: {a: 1, b: 2, c: 3},
        prop2: 'a',
        prop3: Em.computed.getByKey('prop1', 'prop2'),
        prop4: Em.computed.getByKey('prop1', 'App.someRandomTestingKey'),
        prop5: Em.computed.getByKey('prop1', 'prop2', 100500) // with default value
      });
      App.set('someAnotherKey', 'a');
    });

    it('prop3 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.eql(['prop1', 'prop2']);
    });

    it('prop4 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop4._dependentKeys).to.eql(['prop1', 'App.someRandomTestingKey']);
    });

    it('prop5 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop5._dependentKeys).to.eql(['prop1', 'prop2']);
    });

    it('prop3 value is 1', function () {
      expect(this.obj.get('prop3')).to.be.equal(1);
    });

    it('prop3 value is 2', function () {
      this.obj.set('prop2', 'b');
      expect(this.obj.get('prop3')).to.be.equal(2);
    });

    it('prop3 value is 3', function () {
      this.obj.set('prop2', 'c');
      expect(this.obj.get('prop3')).to.be.equal(3);
    });

    it('prop3 value is 4', function () {
      this.obj.set('prop1.c', 4);
      this.obj.set('prop2', 'c');
      expect(this.obj.get('prop3')).to.be.equal(4);
    });

    it('prop4 values is 1', function () {
      expect(this.obj.get('prop4')).to.be.equal(1);
    });

    it('prop4 values is 2', function () {
      App.set('someAnotherKey', 'b');
      expect(this.obj.get('prop4')).to.be.equal(2);
    });

    it('prop4 values is 3', function () {
      App.set('someAnotherKey', 'c');
      expect(this.obj.get('prop4')).to.be.equal(3);
    });

    it('prop5 value is set to the default value', function () {
      this.obj.set('prop2', 'd');
      expect(this.obj.get('prop5')).to.be.equal(100500);
    });

  });

  describe('#truncate', function () {

    beforeEach(function () {
      this.obj = Em.Object.create({
        prop1: '123456789',
        prop2: Em.computed.truncate('prop1', 8, 5),
        prop3: Em.computed.truncate('App.someRandomTestingKey', 8, 5),
        prop4: Em.computed.truncate('prop1', 8, 5, '###')
      });
      App.set('someAnotherKey', 'abcdefghi');
    });

    it('prop2 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop2._dependentKeys).to.be.eql(['prop1']);
    });

    it('prop3 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop3._dependentKeys).to.be.eql(['App.someRandomTestingKey']);
    });

    it('prop4 dependent keys are valid', function () {
      expect(Em.meta(this.obj).descs.prop4._dependentKeys).to.be.eql(['prop1']);
    });

    it('prop2 value is 12345...', function () {
      expect(this.obj.get('prop2')).to.be.equal('12345...');
    });

    it('prop2 value is 54321...', function () {
      this.obj.set('prop1', '543216789');
      expect(this.obj.get('prop2')).to.be.equal('54321...');
    });

    it('prop2 value is 1234', function () {
      this.obj.set('prop1', '1234');
      expect(this.obj.get('prop2')).to.be.equal('1234');
    });

    it('prop2 value is ""', function () {
      this.obj.set('prop1', null);
      expect(this.obj.get('prop2')).to.be.equal('');
    });

    it('prop3 value is abcde...', function () {
      expect(this.obj.get('prop3')).to.be.equal('abcde...');
    });

    it('prop3 value is edcba...', function () {
      App.set('someAnotherKey', 'edcbafghi');
      expect(this.obj.get('prop3')).to.be.equal('edcba...');
    });

    it('prop3 value is abcd', function () {
      App.set('someAnotherKey', 'abcd');
      expect(this.obj.get('prop3')).to.be.equal('abcd');
    });

    it('prop4 value is 12345###', function () {
      expect(this.obj.get('prop4')).to.be.equal('12345###');
    });

    it('prop4 value is 54321###', function () {
      this.obj.set('prop1', '543216789');
      expect(this.obj.get('prop4')).to.be.equal('54321###');
    });

    it('prop4 value is 12345', function () {
      this.obj.set('prop1', '12345');
      expect(this.obj.get('prop4')).to.be.equal('12345');
    });

  });

});
});

require.register("test/utils/ember_reopen_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('utils/ember_reopen');

describe('Ember functionality extension', function () {

  describe('#Em.View', function () {

    var view,
      cases = [
        {
          result: {
            p0: 'v3',
            p1: 'v4',
            p2: 'v5'
          },
          title: 'active view'
        },
        {
          result: {
            p0: 'v0',
            p1: 'v1',
            p2: 'v2'
          },
          propertyToSet: 'isDestroyed',
          title: 'destroyed view'
        },
        {
          result: {
            p0: 'v0',
            p1: 'v1',
            p2: 'v2'
          },
          propertyToSet: 'isDestroying',
          title: 'view being destroyed'
        }
      ];

    beforeEach(function () {
      view = Em.View.create({
        isDestroyed: false,
        isDestroying: false,
        p0: 'v0',
        p1: 'v1',
        p2: 'v2'
      });
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        if (item.propertyToSet) {
          view.set(item.propertyToSet, true);
        }
        view.set('p0', 'v3');
        view.setProperties({
          p1: 'v4',
          p2: 'v5'
        });
        expect(view.getProperties(['p0', 'p1', 'p2'])).to.eql(item.result);
      });
    });

  });

  describe('#Em.Route', function() {
    describe('#serializeQueryParams', function() {
      var route,
          cases = [
        {
          m: 'No query params',
          params: undefined,
          e: {
            result: {query: ''},
            serializedQuery: {}
          }
        },
        {
          m: 'Query params ?param1=value1&param2=value2',
          params: { query: '?param1=value1&param2=value2'},
          e: {
            result: {query: '?param1=value1&param2=value2'},
            serializedQuery: {param1: 'value1', param2: 'value2'}
          }
        },
        {
          m: 'Query params with encodedComponent ?param1=value1%30&param2=value2',
          params: { query: '?param1=value1%30&param2=value2'},
          e: {
            result: {query: '?param1=value1%30&param2=value2'},
            serializedQuery: {param1: 'value10', param2: 'value2'}
          }
        }
      ];

      beforeEach(function() {
        route = Ember.Route.create({
          route: 'demo:query',
          serialize: function(router, params) {
            return this.serializeQueryParams(router, params, 'testController');
          }
        });
      });

      afterEach(function() {
        route.destroy();
        route = null;
      });

      cases.forEach(function(test) {
        it(test.m, function() {
          var ctrl = Em.Object.create({});
          var router = Em.Object.create({
            testController: ctrl
          });
          var ret = route.serialize(router, test.params);
          expect(ret).to.be.eql(test.e.result);
          expect(ctrl.get('serializedQuery')).to.be.eql(test.e.serializedQuery);
        });
      });
    });
  });
});

});

require.register("test/utils/file_utils_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var fileUtils = require('utils/file_utils');

describe('file_utils', function () {

  describe('#openInfoInNewTab', function () {

    var mock = {
      document: {
        write: Em.K
      },
      focus: Em.K
    };

    beforeEach(function () {
      sinon.stub(window, 'open').returns(mock);
      sinon.spy(mock.document, 'write');
      sinon.spy(mock, 'focus');
      fileUtils.openInfoInNewTab('data');
    });

    afterEach(function () {
      window.open.restore();
      mock.document.write.restore();
      mock.focus.restore();
    });

    it('opening new window', function () {
      expect(window.open.calledOnce).to.be.true;
    });

    it('no URL for new window', function () {
      expect(window.open.firstCall.args).to.eql(['']);
    });

    it('writing document contents', function () {
      expect(mock.document.write.calledOnce).to.be.true;
    });

    it('document contents', function () {
      expect(mock.document.write.firstCall.args).to.eql(['data']);
    });

    it('focusing on new window', function () {
      expect(mock.focus.calledOnce).to.be.true;
    });

  });

  describe('#safariDownload', function () {

    var linkEl = {
      click: Em.K
    };

    beforeEach(function () {
      sinon.stub(document, 'createElement').returns(linkEl);
      sinon.stub(document.body, 'appendChild', Em.K);
      sinon.stub(document.body, 'removeChild', Em.K);
      sinon.spy(linkEl, 'click');
      fileUtils.safariDownload('file data', 'csv', 'file.csv');
    });

    afterEach(function () {
      document.createElement.restore();
      document.body.appendChild.restore();
      document.body.removeChild.restore();
      linkEl.click.restore();
    });

    it('creating new element', function () {
      expect(document.createElement.calledOnce).to.be.true;
    });

    it('new element is a link', function () {
      expect(document.createElement.firstCall.args).to.eql(['a']);
    });

    it('link URL', function () {
      expect(linkEl.href).to.equal('data:attachment/csv;charset=utf-8,file%20data');
    });

    it('file name', function () {
      expect(linkEl.download).to.equal('file.csv');
    });

    it('appending element to document', function () {
      expect(document.body.appendChild.calledOnce).to.be.true;
    });

    it('link is appended', function () {
      expect(document.body.appendChild.firstCall.args).to.eql([linkEl]);
    });

    it('link is clicked', function () {
      expect(linkEl.click.calledOnce).to.be.true;
    });

    it('removing element from document', function () {
      expect(document.body.removeChild.calledOnce).to.be.true;
    });

    it('link is removed', function () {
      expect(document.body.removeChild.firstCall.args).to.eql([linkEl]);
    });

  });

});

});

require.register("test/utils/form_field_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/form');


/*
 * formField.isValid property doesn't update correctly, so I have to work with errorMessage property
 */
describe('App.FormField', function () {

  describe('#validate()', function () {
    /*NUMBER TYPE END*/
    /*REQUIRE*/
    it('Required field shouldn\'t be empty', function () {
      var formField = App.FormField.create();
      formField.set('displayType', 'string');
      formField.set('value', '');
      formField.set('isRequired', true);
      formField.validate();
      expect(formField.get('errorMessage')).to.be.not.equal('');
    });
    /*REQUIRE END*/

  });
});
});

require.register("test/utils/handlebars_helpers_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/handlebars_helpers');

describe('handlebars_helpers', function () {

  describe('#registerBoundHelper', function () {

    var options = {
      hash: {}
    };

    beforeEach(function () {
      sinon.stub(Em.Handlebars, 'registerHelper', function (name, callback) {
        callback('prop', options);
      });
      sinon.stub(Em.Handlebars.helpers, 'view', Em.K);
      App.registerBoundHelper('helper', {});
    });

    afterEach(function () {
      Em.Handlebars.registerHelper.restore();
      Em.Handlebars.helpers.view.restore();
    });

    it('contentBinding', function () {
      expect(options.hash.contentBinding).to.equal('prop');
    });

    it('view', function () {
      expect(Em.Handlebars.helpers.view.calledOnce).to.be.true;
    });

    it('view arguments', function () {
      expect(Em.Handlebars.helpers.view.firstCall.args).to.eql([{}, options]);
    });

  });

});

});

require.register("test/utils/heatmap_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var heatmap = require('utils/heatmap');

describe('heatmap utils', function () {

  describe('mappers', function () {

    var mappers;

    beforeEach(function () {
      mappers = Em.Object.create(heatmap.mappers);
    });

    describe('#metricMapperWithTransform', function () {

      var cases = [
        {
          hostComponents: null,
          hostToValueMap: {},
          title: 'no host components data'
        },
        {
          hostComponents: [null, null],
          metricName: 'm0',
          hostToValueMap: {},
          title: 'host components data is absent'
        },
        {
          hostComponents: [{}, {}],
          metricName: 'm1',
          hostToValueMap: {},
          title: 'provided metric data is absent'
        },
        {
          hostComponents: [{}, {}],
          metricName: 'm2.m3',
          hostToValueMap: {},
          title: 'provided metrics data is absent'
        },
        {
          hostComponents: [
            null,
            {},
            {
              m4: 1,
              HostRoles: {
                host_name: 'h0'
              }
            },
            {
              m4: 1.5,
              HostRoles: {
                host_name: 'h1'
              }
            },
            {
              m4: 1.60,
              HostRoles: {
                host_name: 'h2'
              }
            },
            {
              m4: 1.72,
              HostRoles: {
                host_name: 'h3'
              }
            },
            {
              m4: 1.85,
              HostRoles: {
                host_name: 'h4'
              }
            },
            {
              m4: 1.97,
              HostRoles: {
                host_name: 'h5'
              }
            }
          ],
          metricName: 'm4',
          hostToValueMap: {
            h0: '1.0',
            h1: '1.5',
            h2: '1.6',
            h3: '1.7',
            h4: '1.9',
            h5: '2.0'
          },
          title: 'no transform function'
        },
        {
          hostComponents: [
            {
              m5: 100,
              HostRoles: {
                host_name: 'h6'
              }
            }
          ],
          metricName: 'm5',
          transformValueFunction: Math.sqrt,
          hostToValueMap: {
            h6: '10.0'
          },
          title: 'transform function provided'
        }
      ];

      cases.forEach(function (item) {

        it(item.title, function () {
          expect(mappers.metricMapperWithTransform({
            host_components: item.hostComponents
          }, item.metricName, item.transformValueFunction)).to.eql(item.hostToValueMap);
        });

      });

    });

  });

});

});

require.register("test/utils/helper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var App = require('app');
require('utils/helper');
var O = Em.Object;

describe('utils/helper', function() {

  describe('String helpers', function() {
    describe('#trim()', function(){
      it('should replace first space', function() {
        expect(' as d f'.trim()).to.be.equal('as d f');
      });
    });
    describe('#endsWith()', function() {
      it('`abcd` ends with `d`', function(){
        expect('abcd'.endsWith('d')).to.be.true;
      });
      it('`abcd` doesn\'t end with `f`', function(){
        expect('abcd'.endsWith('f')).to.be.false;
      });
    });
    describe('#contains()', function() {
      it('`abc` contains b', function(){
        expect('abc'.contains('b')).to.be.true;
      });
      it('`abc` doesn\'t contain d', function() {
        expect('abc'.contains('d')).to.be.false;
      });
    });
    describe('#capitalize()',function() {
      it('`abc d` should start with `A`', function() {
        expect('abc d'.capitalize()).to.be.equal('Abc d');
      });
    });
    describe('#findIn()', function(){
      var obj = {
        a: {
          a1: 'AVal1'
        },
        b: 'BVal',
        c: {
          c1: {
            c2: 'Cval2'
          },
          b: 'BVal'
        }
      };
      var testValue = function(key, value) {
        it('key `' + key + '` should have `' + JSON.stringify(value) + '` value', function() {
          expect(key.findIn(obj)).to.eql(value);
        });
      };
      it('expect return `null` on non-object input', function(){
        expect('a'.findIn('b')).to.null;
      });
      testValue('a', obj.a);
      testValue('c2', obj.c.c1.c2);
      testValue('b', obj.b);
      testValue('d', null);
    });
    describe('#format()', function(){
      it('should replace string correctly', function(){
        expect("{0} world{1}".format("Hello","!")).to.be.equal("Hello world!");
      });
    });
    describe('#highlight()', function() {
      var str = "Hello world! I want to highlight this word!";
      it('should highlight `word` with default template', function() {
        var result = str.highlight(['word']);
        expect(result).to.be.equal("Hello world! I want to highlight this <b>word</b>!");
      });
      it('should highlight `world` and `word` with template `<span class="yellow">{0}</span>`', function() {
        var result = str.highlight(["world", "word"], '<span class="yellow">{0}</span>');
        expect(result).to.be.equal('Hello <span class="yellow">world</span>! I want to highlight this <span class="yellow">word</span>!')
      });
      var str2 = "First word, second word";
      it('should highlight `word` multiply times with default template', function() {
        var result = str2.highlight(["word"]);
        expect(result).to.be.equal("First <b>word</b>, second <b>word</b>");
      });
    });
  });

  describe('Number helpers', function(){
    describe('#toDaysHoursMinutes()', function(){
      var time = 1000000000;
      var minute = 1000*60;
      var hour = 60*minute;
      var day = 24*hour;
      var result = time.toDaysHoursMinutes();
      var testDays = Math.floor(time/day);
      it('should correct convert days', function(){
        expect(testDays).to.eql(result.d);
      });
      it('should correct convert hours', function(){
        expect(Math.floor((time - testDays * day)/hour)).to.eql(result.h);
      });
      it('should correct convert minutes', function(){
        expect(((time - Math.floor((time - testDays*day)/hour)*hour - testDays*day)/minute).toFixed(2)).to.eql(result.m);
      });
    });
  });

  describe('Array helpers', function(){

    var tests = Em.A([
      {
        m: 'plain objects, no nesting',
        array: [{a: 1}, {a: 2}, {a: 3}],
        property: 'a',
        callback3: function (item) {
          return Em.get(item, 'a');
        },
        e1: {1: {a: 1}, 2: {a: 2}, 3: {a: 3}},
        e2: {1: true, 2: true, 3: true},
        e3: {1: 1, 2: 2, 3: 3}
      },
      {
        m: 'plain objects, nesting',
        array: [{a: {a: 1}}, {a: {a: 2}}, {a:{a: 3}}],
        property: 'a.a',
        callback3: function (item) {
          return Em.get(item, 'a.a');
        },
        e1: {1: {a: {a: 1}}, 2: {a: {a: 2}}, 3: {a: {a: 3}}},
        e2: {1: true, 2: true, 3: true},
        e3: {1: 1, 2: 2, 3: 3}
      },
      {
        m: 'Ember objects, no nesting',
        array: [O.create({a: 1}), O.create({a: 2}), O.create({a: 3})],
        property: 'a',
        callback3: function (item) {
          return Em.get(item, 'a');
        },
        e1: {1: O.create({a: 1}), 2: O.create({a: 2}), 3: O.create({a: 3})},
        e2: {1: true, 2: true, 3: true},
        e3: {1: 1, 2: 2, 3: 3}
      },
      {
        m: 'Ember objects, nesting',
        array: [O.create({a: {a: 1}}), O.create({a: {a: 2}}), O.create({a: {a: 3}})],
        property: 'a.a',
        callback3: function (item) {
          return Em.get(item, 'a.a');
        },
        e1: {1: O.create({a: {a: 1}}), 2: O.create({a: {a: 2}}), 3: O.create({a: {a: 3}})},
        e2: {1: true, 2: true, 3: true},
        e3: {1: 1, 2: 2, 3: 3}
      }
    ]);

    describe('#sortPropertyLight()', function(){
      var testable = [
        { a: 2 },
        { a: 1 },
        { a: 6},
        { a: 64},
        { a: 3},
        { a: 3}
      ];
      var result = testable.sortPropertyLight('a');
      it('should return array with same length', function(){
        expect(testable.length).to.eql(result.length);
      });
      it('should sort array', function() {
        expect(result.mapProperty('a')).to.be.eql([1, 2, 3, 3, 6, 64]);
      });
      it('should try to sort without throwing exception', function(){
        expect(testable.sortPropertyLight(['a'])).to.ok;
      });
    });

    describe('#toMapByProperty', function () {
      tests.forEach(function (test) {
        it(test.m, function () {
          expect(test.array.toMapByProperty(test.property)).to.eql(test.e1);
        });
      });
    });

    describe('#toWickMapByProperty', function () {
      tests.forEach(function (test) {
        it(test.m, function () {
          expect(test.array.toWickMapByProperty(test.property)).to.eql(test.e2);
        });
      });
    });

    describe('#toMapByCallback', function () {
      tests.forEach(function (test) {
        it(test.m, function () {
          expect(test.array.toMapByCallback(test.property, test.callback3)).to.eql(test.e3);
        });
      });
    });

    describe('#toWickMap', function () {

      it('should convert to wick map', function () {
        expect([1,2,3].toWickMap()).to.eql({1: true, 2: true, 3: true});
      });

    });

  });

  describe('App helpers', function(){
    var appendDiv = function() {
      $('body').append('<div id="tooltip-test"></div>');
    };
    var removeDiv = function() {
      $('body').remove('#tooltip-test');
    };
    describe('#isEmptyObject', function(){
      it('should return true on empty object', function() {
        expect(App.isEmptyObject({})).to.be.true;
      });
      it('should return false on non-empty object', function() {
        expect(App.isEmptyObject({ a: 1 })).to.be.false;
      });
    });

    describe('#tooltip()', function() {
      beforeEach(appendDiv);
      afterEach(removeDiv);
      it('should add tooltip', function() {
        App.tooltip($('#tooltip-test'));
        expect($('#tooltip-test').data('tooltip').enabled).to.be.true;
      });
    });
    describe('#popover()', function() {
      beforeEach(appendDiv);
      afterEach(removeDiv);
      it('should add popover', function() {
        App.popover($('#tooltip-test'));
        expect($('#tooltip-test').data('popover').enabled).to.be.true;
      });
    });
    describe('#App.format', function(){
      describe('#commandDetail()', function() {
        var command = "GANGLIA_MONITOR STOP";
        var ignored = "DECOMMISSION, NAMENODE";
        var removeString = "SERVICE/HDFS STOP";
        var nagiosState = "nagios_update_ignore ACTIONEXECUTE";
        var installRepo = "install_packages ACTIONEXECUTE";
        it('should convert command to readable info', function() {
          expect(App.format.commandDetail(command)).to.be.equal(' Ganglia Monitor Stop');
        });
        it('should ignore decommission command', function(){
          expect(App.format.commandDetail(ignored)).to.be.equal('  NameNode');
        });
        it('should remove SERVICE string from command', function(){
          expect(App.format.commandDetail(removeString)).to.be.equal(' HDFS Stop');
        });
        it('should return maintenance message', function() {
          expect(App.format.commandDetail(nagiosState)).to.be.equal(' Toggle Maintenance Mode');
        });
        it('should return install repo message', function() {
          expect(App.format.commandDetail(installRepo)).to.be.equal(Em.I18n.t('common.installRepo.task'));
        });
      });
      describe('#taskStatus()', function(){
        var testable = [
          { status: 'PENDING', expectable: 'pending'},
          { status: 'QUEUED', expectable: 'queued'},
          { status: 'COMPLETED', expectable: 'completed'}
        ];
        testable.forEach(function(testObj){
          it('should convert `' + testObj.status + '` to `' + testObj.expectable + '`', function(){
            expect(App.format.taskStatus(testObj.status)).to.eql(testObj.expectable);
          });
        });
      });

      describe('#normalizeNameBySeparators()', function() {
        var testMessage = '`{0}` should be converted to `{1}`';
        var tests = {
          'APP_TIMELINE_SERVER': 'App Timeline Server',
          'app_timeline_server': 'App Timeline Server',
          'APP-TIMELINE-SERVER': 'App Timeline Server',
          'app-timeline-server': 'App Timeline Server',
          'APP TIMELINE SERVER': 'App Timeline Server',
          'app timeline server': 'App Timeline Server',
          'FALCON': 'Falcon',
          'falcon': 'Falcon'
        };
        Object.keys(tests).forEach(function (inputName) {
          it(testMessage.format(inputName, tests[inputName]), function() {
            expect(App.format.normalizeNameBySeparators(inputName, ["-", "_", " "])).to.eql(tests[inputName]);
          });
        });
      });

      describe('#normalizeName()', function() {
        var testMessage = '`{0}` should be converted to `{1}`';
        var tests = {
          'APP_TIMELINE_SERVER': 'App Timeline Server',
          'DATANODE': 'DataNode',
          'DECOMMISSION_DATANODE': 'Update Exclude File',
          'DRPC_SERVER': 'DRPC Server',
          'FALCON': 'Falcon',
          'FALCON_CLIENT': 'Falcon Client',
          'FALCON_SERVER': 'Falcon Server',
          'FALCON_SERVICE_CHECK': 'Falcon Service Check',
          'FLUME_HANDLER': 'Flume',
          'FLUME_SERVICE_CHECK': 'Flume Service Check',
          'GANGLIA_MONITOR': 'Ganglia Monitor',
          'GANGLIA_SERVER': 'Ganglia Server',
          'GLUSTERFS_CLIENT': 'GLUSTERFS Client',
          'GLUSTERFS_SERVICE_CHECK': 'GLUSTERFS Service Check',
          'GMETAD_SERVICE_CHECK': 'Gmetad Service Check',
          'GMOND_SERVICE_CHECK': 'Gmond Service Check',
          'HADOOP_CLIENT': 'Hadoop Client',
          'HBASE_CLIENT': 'HBase Client',
          'HBASE_MASTER': 'HBase Master',
          'HBASE_REGIONSERVER': 'RegionServer',
          'HBASE_SERVICE_CHECK': 'HBase Service Check',
          'HCAT': 'HCat Client',
          'HDFS': 'HDFS',
          'HDFS_CLIENT': 'HDFS Client',
          'HDFS_SERVICE_CHECK': 'HDFS Service Check',
          'HISTORYSERVER': 'History Server',
          'HIVE_CLIENT': 'Hive Client',
          'HIVE_METASTORE': 'Hive Metastore',
          'HIVE_SERVER': 'HiveServer2',
          'HIVE_SERVICE_CHECK': 'Hive Service Check',
          'HUE_SERVER': 'Hue Server',
          'JAVA_JCE': 'Java JCE',
          'JOBTRACKER': 'JobTracker',
          'JOBTRACKER_SERVICE_CHECK': 'JobTracker Service Check',
          'JOURNALNODE': 'JournalNode',
          'KERBEROS_ADMIN_CLIENT': 'Kerberos Admin Client',
          'KERBEROS_CLIENT': 'Kerberos Client',
          'KERBEROS_SERVER': 'Kerberos Server',
          'MAPREDUCE2_CLIENT': 'MapReduce2 Client',
          'MAPREDUCE2_SERVICE_CHECK': 'MapReduce2 Service Check',
          'MYSQL_SERVER': 'MySQL Server',
          'NAMENODE': 'NameNode',
          'NAMENODE_SERVICE_CHECK': 'NameNode Service Check',
          'NIMBUS': 'Nimbus',
          'NODEMANAGER': 'NodeManager',
          'OOZIE_CLIENT': 'Oozie Client',
          'OOZIE_SERVER': 'Oozie Server',
          'OOZIE_SERVICE_CHECK': 'Oozie Service Check',
          'PIG': 'Pig',
          'PIG_SERVICE_CHECK': 'Pig Service Check',
          'RESOURCEMANAGER': 'ResourceManager',
          'SECONDARY_NAMENODE': 'SNameNode',
          'SQOOP': 'Sqoop',
          'SQOOP_SERVICE_CHECK': 'Sqoop Service Check',
          'STORM_REST_API': 'Storm REST API Server',
          'STORM_SERVICE_CHECK': 'Storm Service Check',
          'STORM_UI_SERVER': 'Storm UI Server',
          'SUPERVISOR': 'Supervisor',
          'TASKTRACKER': 'TaskTracker',
          'TEZ_CLIENT': 'Tez Client',
          'WEBHCAT_SERVER': 'WebHCat Server',
          'YARN_CLIENT': 'YARN Client',
          'YARN_SERVICE_CHECK': 'YARN Service Check',
          'ZKFC': 'ZKFailoverController',
          'ZOOKEEPER_CLIENT': 'ZooKeeper Client',
          'ZOOKEEPER_QUORUM_SERVICE_CHECK': 'ZK Quorum Service Check',
          'ZOOKEEPER_SERVER': 'ZooKeeper Server',
          'ZOOKEEPER_SERVICE_CHECK': 'ZooKeeper Service Check',
          'CLIENT': 'Client'
        };
        Object.keys(tests).forEach(function (inputName) {
          it(testMessage.format(inputName, tests[inputName]), function() {
            expect(App.format.normalizeName(inputName)).to.eql(tests[inputName]);
          });
        });
      });
      describe('#kdcErrorMsg()', function() {
        var tests = [
          {
            r: "1 Missing KDC administrator credentials. and some text",
            f: "Missing KDC administrator credentials."
          },
          {
            r: "2 Invalid KDC administrator credentials. and some text",
            f: "Invalid KDC administrator credentials."
          },
          {
            r: "3 Failed to find a KDC for the specified realm - kadmin and some text",
            f: "Failed to find a KDC for the specified realm - kadmin"
          },
          {
            r: "4 some text",
            f: null,
            s: true
          },
          {
            r: "4 some text",
            f: "4 some text",
            s: false
          }
        ];

        tests.forEach(function(t) {
          it("kdcErrorMsg for " + t.f + " with strict " + t.s, function() {
            expect(App.format.kdcErrorMsg(t.r, t.s)).to.be.equal(t.f);
          })
        });

      });

      describe("#role()", function() {
        before(function () {
          App.format.stackServiceRolesMap = {};
          App.format.stackComponentRolesMap = {};
        });
        beforeEach(function () {
          sinon.stub(App.StackService, 'find').returns([Em.Object.create({
            id: 'S1',
            displayName: 's1'
          })]);
          sinon.stub(App.StackServiceComponent, 'find').returns([Em.Object.create({
            id: 'C1',
            displayName: 'c1'
          })]);
        });
        afterEach(function () {
          App.StackService.find.restore();
          App.StackServiceComponent.find.restore();
        });
        it("S1 -> s1", function() {
          expect(App.format.role('S1', true)).to.equal('s1');
        });
        it("C1 -> c1", function() {
          expect(App.format.role('C1', false)).to.equal('c1');
        });
        it("stackRolesMap is not empty", function() {
          expect(App.format.stackServiceRolesMap).to.not.be.empty;
          expect(App.format.stackComponentRolesMap).to.not.be.empty;
        });
      });
    });
  });

  describe('#App.permit()', function() {
    var obj = {
      a1: 'v1',
      a2: 'v2',
      a3: 'v3'
    };

    var tests = [
      {
        keys: 'a1',
        e: {
          a1: 'v1'
        }
      },
      {
        keys: ['a2','a3','a4'],
        e: {
          a2: 'v2',
          a3: 'v3'
        }
      }
    ];

    tests.forEach(function(test) {
      it('should return object `{0}` permitted keys `{1}`'.format(JSON.stringify(test.e), JSON.stringify(test.keys)), function() {
        expect(App.permit(obj, test.keys)).to.deep.eql(test.e);
      });
    });
  });

  describe('#App.keysUnderscoreToCamelCase()', function() {
    var tests = [
      {
        object: {
          'key_upper': '2'
        },
        expected: {
          keyUpper: '2'
        },
        m: 'One level object, key should be camelCased'
      },
      {
        object: {
          'key_upper': '2',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          key: '1'
        },
        m: 'One level object, one key should be camelCased.'
      },
      {
        object: {
          'key_upper': '2',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          key: '1'
        },
        m: 'One level object, one key should be camelCased.'
      },
      {
        object: {
          'key_upper': '2',
          'key_upone_uptwo_upthree': '4',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          keyUponeUptwoUpthree: '4',
          key: '1'
        },
        m: 'One level object, two keys should be camelCased, few dots notation.'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.keysUnderscoreToCamelCase(test.object)).to.deep.equal(test.expected);
      });
    });
  });

  describe('#App.keysDottedToCamelCase()', function() {
    var tests = [
      {
        object: {
          'key.upper': '2'
        },
        expected: {
          keyUpper: '2'
        },
        m: 'One level object, key should be camelCased'
      },
      {
        object: {
          'key.upper': '2',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          key: '1'
        },
        m: 'One level object, one key should be camelCased.'
      },
      {
        object: {
          'key.upper': '2',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          key: '1'
        },
        m: 'One level object, one key should be camelCased.'
      },
      {
        object: {
          'key.upper': '2',
          'key.upone.uptwo.upthree': '4',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          keyUponeUptwoUpthree: '4',
          key: '1'
        },
        m: 'One level object, two keys should be camelCased, few dots notation.'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.keysDottedToCamelCase(test.object)).to.deep.equal(test.expected);
      });
    });
  });

  describe('#App.formatDateTimeWithTimeZone()', function () {

    beforeEach(function () {
      sinon.stub(App.router, 'get').withArgs('userSettingsController.userSettings.timezone').returns({
        zones: [{
          value: 'Europe/Amsterdam'
        }]
      });
    });

    afterEach(function () {
      App.router.get.restore();
    });

    it('should format date according to customized timezone', function () {
      expect(App.formatDateTimeWithTimeZone(1000000, 'YYYY-MM-DD HH:mm:ss (hh:mm A)')).to.equal('1970-01-01 01:16:40 (01:16 AM)');
    });

  });

});

});

require.register("test/utils/host_progress_popup_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('controllers/global/background_operations_controller');
require('views/common/modal_popup');
require('utils/helper');
require('utils/host_progress_popup');

describe('App.HostPopup', function () {

  var testTasks = [
    {
      t: [
        {
          Tasks: {
            status: 'COMPLETED',
            id: 2
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 3
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 1
          }
        }
      ],
      m: 'All COMPLETED',
      r: 'SUCCESS',
      p: 100,
      ids: [1,2,3]
    },
    {
      t: [
        {
          Tasks: {
            status: 'FAILED',
            id: 2
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 1
          }
        }
        ,
        {
          Tasks: {
            status: 'COMPLETED',
            id: 3
          }
        }
      ],
      m: 'One FAILED',
      r: 'FAILED',
      p: 100,
      ids: [1,2,3]
    },
    {
      t: [
        {
          Tasks: {
            status: 'ABORTED',
            id: 1
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 2
          }
        }
      ],
      m: 'One ABORTED',
      r: 'ABORTED',
      p: 100,
      ids: [1,2]
    },
    {
      t: [
        {
          Tasks: {
            status: 'TIMEDOUT',
            id: 3
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 1
          }
        }
      ],
      m: 'One TIMEDOUT',
      r: 'TIMEDOUT',
      p: 100,
      ids: [1,3]
    },
    {
      t: [
        {
          Tasks: {
            status: 'IN_PROGRESS',
            id: 1
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 2
          }
        }
      ],
      m: 'One IN_PROGRESS',
      r: 'IN_PROGRESS',
      p: 68,
      ids: [1,2]
    },
    {
      t: [
        {
          Tasks: {
            status: 'QUEUED',
            id: 2
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 3
          }
        }
      ],
      m: 'Something else',
      r: 'PENDING',
      p: 55,
      ids: [2,3]
    }
  ];

  var statusCases = [
    {
      status: 'FAILED',
      result: false
    },
    {
      status: 'ABORTED',
      result: false
    },
    {
      status: 'TIMEDOUT',
      result: false
    },
    {
      status: 'IN_PROGRESS',
      result: true
    },
    {
      status: 'COMPLETED',
      result: false
    },
    {
      status: 'PENDING',
      result: true
    }
  ];

  describe('#setSelectCount', function () {
    var itemsForStatusTest = [
      {
        title: 'Empty',
        data: [],
        result: [0, 0, 0, 0, 0, 0, 0]
      },
      {
        title: 'All Pending',
        data: [
          {status: 'pending'},
          {status: 'queued'}
        ],
        result: [2, 2, 0, 0, 0, 0, 0]
      },
      {
        title: 'All Completed',
        data: [
          {status: 'success'},
          {status: 'completed'}
        ],
        result: [2, 0, 0, 0, 2, 0, 0]
      },
      {
        title: 'All Failed',
        data: [
          {status: 'failed'},
          {status: 'failed'}
        ],
        result: [2, 0, 0, 2, 0, 0, 0]
      },
      {
        title: 'All InProgress',
        data: [
          {status: 'in_progress'},
          {status: 'in_progress'}
        ],
        result: [2, 0, 2, 0, 0, 0, 0]
      },
      {
        title: 'All Aborted',
        data: [
          {status: 'aborted'},
          {status: 'aborted'}
        ],
        result: [2, 0, 0, 0, 0, 2, 0]
      },
      {
        title: 'All Timedout',
        data: [
          {status: 'timedout'},
          {status: 'timedout'}
        ],
        result: [2, 0, 0, 0, 0, 0, 2]
      },
      {
        title: 'Every Category',
        data: [
          {status: 'pending'},
          {status: 'queued'},
          {status: 'success'},
          {status: 'completed'},
          {status: 'failed'},
          {status: 'in_progress'},
          {status: 'aborted'},
          {status: 'timedout'}
        ],
        result: [8, 2, 1, 1, 2, 1, 1]
      }
    ];
    var categories = [
      Ember.Object.create({value: 'all'}),
      Ember.Object.create({value: 'pending'}),
      Ember.Object.create({value: 'in_progress'}),
      Ember.Object.create({value: 'failed'}),
      Ember.Object.create({value: 'completed'}),
      Ember.Object.create({value: 'aborted'}),
      Ember.Object.create({value: 'timedout'})
    ];
    itemsForStatusTest.forEach(function(statusTest) {
      it(statusTest.title, function() {
        App.HostPopup.setSelectCount(statusTest.data, categories);
        expect(categories.mapProperty('count')).to.deep.equal(statusTest.result);
      });
    });
  });

  describe('#getStatus', function() {
    testTasks.forEach(function(testTask) {
      it(testTask.m, function() {
        expect(App.HostPopup.getStatus(testTask.t)[0]).to.equal(testTask.r);
      });
    });
  });

  describe('#getProgress', function() {
    testTasks.forEach(function(testTask) {
      it(testTask.m, function() {
        expect(App.HostPopup.getProgress(testTask.t)).to.equal(testTask.p);
      });
    });
  });

  describe('#isAbortableByStatus', function () {
    statusCases.forEach(function (item) {
      it('should return ' + item.result + ' for ' + item.status, function () {
        expect(App.HostPopup.isAbortableByStatus(item.status)).to.equal(item.result);
      });
    });
  });

  describe('#abortRequest', function () {
    beforeEach(function () {
      sinon.spy(App, 'showConfirmationPopup');
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });
    it('should show confirmation popup', function () {
      App.HostPopup.abortRequest(Em.Object.create({
        name: 'name'
      }));
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
    });
  });

  describe('#abortRequestSuccessCallback', function () {
    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
    });
    it('should open popup', function () {
      App.HostPopup.abortRequestSuccessCallback(null, null, {
        requestName: 'name',
        serviceInfo: Em.Object.create()
      });
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe('#abortRequestErrorCallback', function () {
    var popup = App.HostPopup;
    beforeEach(function () {
      sinon.stub(App.ajax, 'get', function(k) {
        if (k === 'modalPopup') return null;
        return Em.get(App, k);
      });
      sinon.spy(App.ModalPopup, 'show');
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
      App.ajax.get.restore();
    });
    it('should open popup', function () {
      popup.abortRequestErrorCallback({
        responseText: {
          message: 'message'
        },
        status: 404
      }, 'status', 'error', {
        url: 'url'
      }, {
        requestId: 0,
        serviceInfo: Em.Object.create()
      });
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
    statusCases.forEach(function (item) {
      it('should set serviceInfo.isAbortable to' + item.result + ' if status is ' + item.status, function () {
        popup.abortRequestErrorCallback({
          responseText: {
            message: 'message'
          },
          status: 404
        }, 'status', 'error', {
          url: 'url'
        }, {
          requestId: 0,
          serviceInfo: Em.Object.create({
            status: item.status
          })
        });
        expect(App.HostPopup.isAbortableByStatus(item.status)).to.equal(item.result);
      });
    });
  });

  describe('#setBackgroundOperationHeader', function(){
    beforeEach(function (){
      sinon.stub(App.HostPopup, "get").returns(true);
      sinon.spy(App.HostPopup, "set");
      this.stub = sinon.stub(App.router, "get");
    });

    afterEach(function (){
      App.HostPopup.get.restore();
      App.HostPopup.set.restore();
      App.router.get.restore();
    });

    it("should display '2 Background Operations Running' when there are 2 background operations running", function(){
      this.stub.returns(2);
      App.HostPopup.setBackgroundOperationHeader(false);

      expect(App.HostPopup.set.calledWith("popupHeaderName", "2 Background Operations Running")).to.be.true;
    });

    it("should display '1 Background Operation Running' when there is 1 background operation running", function(){
      this.stub.returns(1);
      App.HostPopup.setBackgroundOperationHeader(false);

      expect(App.HostPopup.set.calledWith("popupHeaderName", "1 Background Operation Running")).to.be.true;
    });
  });

  describe('#_getHostsMap', function () {

    Em.A([
      {
        inputData: [
          {name: 's1', hostsMap: {h1: {}, h2: {}}},
          {name: 's2'}
        ],
        isBackgroundOperations: true,
        currentServiceId: null,
        serviceName: 's1',
        m: '`currentServiceId` is null, `serviceName` exists, `isBackgroundOperations` true, `hostsMap` exists',
        e: {h1: {}, h2: {}}
      },
      {
        inputData: [
          {name: 's1', hosts: [
            {name: 'h1'},
            {name: 'h2'}
          ]},
          {name: 's2'}
        ],
        isBackgroundOperations: true,
        currentServiceId: null,
        serviceName: 's1',
        m: '`currentServiceId` is null, `serviceName` exists, `isBackgroundOperations` true, `hosts` exists',
        e: {h1: {name: 'h1'}, h2: {name: 'h2'}}
      },
      {
        inputData: [
          {id: 1, hostsMap: {h1: {}, h2: {}}},
          {id: 2}
        ],
        isBackgroundOperations: true,
        currentServiceId: 1,
        serviceName: 's1',
        m: '`currentServiceId` is 1, `serviceName` exists, `isBackgroundOperations` true, `hostsMap` exists',
        e: {h1: {}, h2: {}}
      },
      {
        inputData: [
          {id: 1, hosts: [
            {name: 'h1'},
            {name: 'h2'}
          ]},
          {id: 2}
        ],
        isBackgroundOperations: true,
        currentServiceId: 1,
        serviceName: 's1',
        m: '`currentServiceId` is 1, `serviceName` exists, `isBackgroundOperations` true, `hosts` exists',
        e: {h1: {name: 'h1'}, h2: {name: 'h2'}}
      },

      {
        inputData: [
          {name: 's1', hostsMap: {h1: {}, h2: {}}},
          {name: 's2'}
        ],
        isBackgroundOperations: false,
        currentServiceId: null,
        serviceName: 's1',
        m: '`currentServiceId` is null, `serviceName` exists, `isBackgroundOperations` false, `hostsMap` exists',
        e: {h1: {}, h2: {}}
      },
      {
        inputData: [
          {name: 's1', hosts: [
            {name: 'h1'},
            {name: 'h2'}
          ]},
          {name: 's2'}
        ],
        isBackgroundOperations: false,
        currentServiceId: null,
        serviceName: 's1',
        m: '`currentServiceId` is null, `serviceName` exists, `isBackgroundOperations` false, `hosts` exists',
        e: {h1: {name: 'h1'}, h2: {name: 'h2'}}
      },
      {
        inputData: [
          {name: 's1', hostsMap: {h1: {}, h2: {}}}
        ],
        isBackgroundOperations: false,
        currentServiceId: 1,
        serviceName: 's1',
        m: '`currentServiceId` is 1, `serviceName` exists, `isBackgroundOperations` false, `hostsMap` exists',
        e: {h1: {}, h2: {}}
      },
      {
        inputData: [
          {name: 's1', hostsMap: {h1: {}, h2: {}}}
        ],
        isBackgroundOperations: false,
        currentServiceId: 1,
        serviceName: 's1',
        m: '`currentServiceId` is 1, `serviceName` exists, `isBackgroundOperations` false, `hosts` exists',
        e: {h1: {}, h2: {}}
      }
    ]).forEach(function (test) {

      it(test.m, function () {
        App.HostPopup.setProperties(test);
        expect(App.HostPopup._getHostsMap()).to.eql(test.e);
      });

    });

  });



});

});

require.register("test/utils/hosts_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var hostsUtils = require('utils/hosts');
var validator = require('utils/validator');
var testHelpers = require('test/helpers');

describe('hosts utils', function () {

  describe('#launchHostsSelectionDialog', function () {

    var popup,
      mock = {
        callback: Em.K
      };

    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show', Em.K);
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    describe('popup header and message', function () {

      var cases = [
        {
          popupDescription: {},
          header: Em.I18n.t('hosts.selectHostsDialog.title'),
          dialogMessage: Em.I18n.t('hosts.selectHostsDialog.message'),
          title: 'default header and message'
        },
        {
          popupDescription: {
            dialogMessage: 'Message 0'
          },
          header: Em.I18n.t('hosts.selectHostsDialog.title'),
          dialogMessage: 'Message 0',
          title: 'default header, custom message'
        },
        {
          popupDescription: {
            header: 'Header 0'
          },
          header: 'Header 0',
          dialogMessage: Em.I18n.t('hosts.selectHostsDialog.message'),
          title: 'custom header, default message'
        },
        {
          popupDescription: {
            header: 'Header 1',
            dialogMessage: 'Message 1'
          },
          header: 'Header 1',
          dialogMessage: 'Message 1',
          title: 'custom header and message'
        }
      ];

      cases.forEach(function (item) {

        describe(item.title, function () {

          beforeEach(function () {
            hostsUtils.launchHostsSelectionDialog(null, null, null, null, null, item.popupDescription);
            popup = Em.Object.create(App.ModalPopup.show.firstCall.args[0]);
          });

          it('header', function () {
            expect(popup.get('header')).to.equal(item.header);
          });

          it('message', function () {
            expect(popup.get('dialogMessage')).to.equal(item.dialogMessage);
          });

        });

      });

    });

    describe('#onPrimary', function () {

      var cases = [
        {
          selectAtleastOneHost: true,
          availableHosts: [],
          warningMessage: Em.I18n.t('hosts.selectHostsDialog.message.warning'),
          callbackCallCount: 0,
          hideCallCount: 0,
          title: 'no hosts available'
        },
        {
          selectAtleastOneHost: false,
          availableHosts: [],
          warningMessage: null,
          callbackCallCount: 1,
          arrayOfSelectedHosts: [],
          hideCallCount: 1,
          title: 'no hosts available, no selection requirement'
        },
        {
          selectAtleastOneHost: true,
          availableHosts: [
            {},
            {
              selected: 1
            },
            {
              selected: 'true'
            }
          ],
          warningMessage: Em.I18n.t('hosts.selectHostsDialog.message.warning'),
          callbackCallCount: 0,
          hideCallCount: 0,
          title: 'no selection state info'
        },
        {
          selectAtleastOneHost: false,
          availableHosts: [
            {},
            {
              selected: 1
            },
            {
              selected: 'true'
            }
          ],
          warningMessage: null,
          callbackCallCount: 1,
          arrayOfSelectedHosts: [],
          hideCallCount: 1,
          title: 'no selection state info, no selection requirement'
        },
        {
          selectAtleastOneHost: true,
          availableHosts: [
            {
              selected: false
            },
            {
              selected: false
            },
            {},
            {
              selected: 1
            },
            {
              selected: 'true'
            }
          ],
          warningMessage: Em.I18n.t('hosts.selectHostsDialog.message.warning'),
          callbackCallCount: 0,
          hideCallCount: 0,
          title: 'no hosts selected'
        },
        {
          selectAtleastOneHost: false,
          availableHosts: [
            {
              selected: false
            },
            {
              selected: false
            },
            {},
            {
              selected: 1
            },
            {
              selected: 'true'
            }
          ],
          warningMessage: null,
          callbackCallCount: 1,
          arrayOfSelectedHosts: [],
          hideCallCount: 1,
          title: 'no hosts selected, no selection requirement'
        },
        {
          selectAtleastOneHost: true,
          availableHosts: [
            {
              selected: true
            },
            {
              selected: false
            },
            {},
            {
              selected: 1
            },
            {
              selected: 'true'
            }
          ],
          warningMessage: null,
          callbackCallCount: 1,
          arrayOfSelectedHosts: [undefined],
          hideCallCount: 1,
          title: '1 host selected, no host info'
        },
        {
          selectAtleastOneHost: false,
          availableHosts: [
            {
              selected: true
            },
            {
              selected: false
            },
            {},
            {
              selected: 1
            },
            {
              selected: 'true'
            }
          ],
          warningMessage: null,
          callbackCallCount: 1,
          arrayOfSelectedHosts: [undefined],
          hideCallCount: 1,
          title: '1 host selected, no host info, no selection requirement'
        },
        {
          selectAtleastOneHost: true,
          availableHosts: [
            {
              selected: true,
              host: {}
            },
            {
              selected: false
            },
            {},
            {
              selected: 1
            },
            {
              selected: 'true'
            }
          ],
          warningMessage: null,
          callbackCallCount: 1,
          arrayOfSelectedHosts: [undefined],
          hideCallCount: 1,
          title: '1 host selected, no host id'
        },
        {
          selectAtleastOneHost: false,
          availableHosts: [
            {
              selected: true,
              host: {}
            },
            {
              selected: false
            },
            {},
            {
              selected: 1
            },
            {
              selected: 'true'
            }
          ],
          warningMessage: null,
          callbackCallCount: 1,
          arrayOfSelectedHosts: [undefined],
          hideCallCount: 1,
          title: '1 host selected, no host id, no selection requirement'
        },
        {
          selectAtleastOneHost: true,
          availableHosts: [
            {
              selected: true,
              host: {
                id: 'h0'
              }
            },
            {
              selected: false,
              host: {
                id: 'h1'
              }
            },
            {
              host: {
                id: 'h2'
              }
            },
            {
              selected: 1,
              host: {
                id: 'h3'
              }
            },
            {
              selected: 'true',
              host: {
                id: 'h4'
              }
            }
          ],
          warningMessage: null,
          callbackCallCount: 1,
          arrayOfSelectedHosts: ['h0'],
          hideCallCount: 1,
          title: '1 host selected, host id available'
        },
        {
          selectAtleastOneHost: false,
          availableHosts: [
            {
              selected: true,
              host: {
                id: 'h5'
              }
            },
            {
              selected: false,
              host: {
                id: 'h6'
              }
            },
            {
              host: {
                id: 'h7'
              }
            },
            {
              selected: 1,
              host: {
                id: 'h8'
              }
            },
            {
              selected: 'true',
              host: {
                id: 'h9'
              }
            }
          ],
          warningMessage: null,
          callbackCallCount: 1,
          arrayOfSelectedHosts: ['h5'],
          hideCallCount: 1,
          title: '1 host selected, host id available, no selection requirement'
        },
        {
          selectAtleastOneHost: true,
          availableHosts: [
            {
              selected: true
            },
            {
              selected: true
            },
            {
              selected: false
            },
            {},
            {
              selected: 1
            },
            {
              selected: 'true'
            }
          ],
          warningMessage: null,
          callbackCallCount: 1,
          arrayOfSelectedHosts: [undefined, undefined],
          hideCallCount: 1,
          title: 'more than 1 host selected, no host info'
        },
        {
          selectAtleastOneHost: false,
          availableHosts: [
            {
              selected: true
            },
            {
              selected: true
            },
            {
              selected: false
            },
            {},
            {
              selected: 1
            },
            {
              selected: 'true'
            }
          ],
          warningMessage: null,
          callbackCallCount: 1,
          arrayOfSelectedHosts: [undefined, undefined],
          hideCallCount: 1,
          title: 'more than 1 host selected, no host info, no selection requirement'
        },
        {
          selectAtleastOneHost: true,
          availableHosts: [
            {
              selected: true,
              host: {}
            },
            {
              selected: true,
              host: {}
            },
            {
              selected: false
            },
            {},
            {
              selected: 1
            },
            {
              selected: 'true'
            }
          ],
          warningMessage: null,
          callbackCallCount: 1,
          arrayOfSelectedHosts: [undefined, undefined],
          hideCallCount: 1,
          title: 'more than 1 host selected, no host id'
        },
        {
          selectAtleastOneHost: false,
          availableHosts: [
            {
              selected: true,
              host: {}
            },
            {
              selected: true,
              host: {}
            },
            {
              selected: false
            },
            {},
            {
              selected: 1
            },
            {
              selected: 'true'
            }
          ],
          warningMessage: null,
          callbackCallCount: 1,
          arrayOfSelectedHosts: [undefined, undefined],
          hideCallCount: 1,
          title: 'more than 1 host selected, no host id, no selection requirement'
        },
        {
          selectAtleastOneHost: true,
          availableHosts: [
            {
              selected: true,
              host: {
                id: 'h10'
              }
            },
            {
              selected: true,
              host: {
                id: 'h11'
              }
            },
            {
              selected: false,
              host: {
                id: 'h12'
              }
            },
            {
              host: {
                id: 'h13'
              }
            },
            {
              selected: 1,
              host: {
                id: 'h14'
              }
            },
            {
              selected: 'true',
              host: {
                id: 'h15'
              }
            }
          ],
          warningMessage: null,
          callbackCallCount: 1,
          arrayOfSelectedHosts: ['h10', 'h11'],
          hideCallCount: 1,
          title: 'more than 1 host selected, host ids available'
        },
        {
          selectAtleastOneHost: false,
          availableHosts: [
            {
              selected: true,
              host: {
                id: 'h16'
              }
            },
            {
              selected: true,
              host: {
                id: 'h17'
              }
            },
            {
              selected: false,
              host: {
                id: 'h18'
              }
            },
            {
              host: {
                id: 'h19'
              }
            },
            {
              selected: 1,
              host: {
                id: 'h20'
              }
            },
            {
              selected: 'true',
              host: {
                id: 'h21'
              }
            }
          ],
          warningMessage: null,
          callbackCallCount: 1,
          arrayOfSelectedHosts: ['h16', 'h17'],
          hideCallCount: 1,
          title: 'more than 1 host selected, host ids available, no selection requirement'
        }
      ];

      cases.forEach(function (item) {

        describe(item.title, function () {

          beforeEach(function () {
            sinon.spy(mock, 'callback');
            hostsUtils.launchHostsSelectionDialog(null, null, item.selectAtleastOneHost, null, mock.callback, {});
            popup = Em.Object.create(App.ModalPopup.show.firstCall.args[0], {
              warningMessage: '',
              availableHosts: item.availableHosts,
              hide: Em.K
            });
            sinon.spy(popup, 'hide');
            popup.onPrimary();
          });

          afterEach(function () {
            mock.callback.restore();
            popup.hide.restore();
          });

          it('warning message', function () {
            expect(popup.get('warningMessage')).to.equal(item.warningMessage);
          });

          it('callback', function () {
            expect(mock.callback.callCount).to.equal(item.callbackCallCount);
          });

          if (item.callbackCallCount) {
            it('callback argument', function () {
              expect(mock.callback.firstCall.args).to.eql([item.arrayOfSelectedHosts]);
            });
          }

          it('hide popup', function () {
            expect(popup.hide.callCount).to.equal(item.hideCallCount);
          });

        });

      });

    });

    describe('#disablePrimary', function () {

      var cases = [
        {
          isLoaded: true,
          disablePrimary: false,
          title: 'enable button'
        },
        {
          isLoaded: false,
          disablePrimary: true,
          title: 'disable button'
        }
      ];

      cases.forEach(function (item) {

        it(item.title, function () {
          hostsUtils.launchHostsSelectionDialog(null, null, null, null, null, item.popupDescription);
          popup = Em.Object.create(App.ModalPopup.show.firstCall.args[0], {
            isLoaded: item.isLoaded
          });
          expect(popup.get('disablePrimary')).to.equal(item.disablePrimary);
        });

      });

    });

    describe('#onSecondary', function () {

      beforeEach(function () {
        sinon.spy(mock, 'callback');
        hostsUtils.launchHostsSelectionDialog(null, null, null, null, mock.callback, {});
        popup = Em.Object.create(App.ModalPopup.show.firstCall.args[0], {
          hide: Em.K
        });
        sinon.spy(popup, 'hide');
        popup.onSecondary();
      });

      afterEach(function () {
        mock.callback.restore();
        popup.hide.restore();
      });

      it('callback', function () {
        expect(mock.callback.calledOnce).to.be.true;
      });

      it('callback argument', function () {
        expect(mock.callback.firstCall.args).to.eql([null]);
      });

      it('hide popup', function () {
        expect(popup.hide.calledOnce).to.be.true;
      });

    });

    describe('#bodyClass', function () {

      var view,
        validComponents = [
          {
            componentName: 'c0'
          },
          {
            componentName: 'c1'
          }
        ];

      beforeEach(function () {
        hostsUtils.launchHostsSelectionDialog([
          {
            host: {
              id: 'h0'
            },
            filtered: false
          },
          {
            host: {
              id: 'h1'
            }
          }
        ], null, null, validComponents, null, {});
        popup = Em.Object.create(App.ModalPopup.show.firstCall.args[0]);
        view = popup.get('bodyClass').create({
          parentView: popup
        });
      });

      describe('#filteredContentObs', function () {

        beforeEach(function () {
          sinon.stub(view, 'filteredContentObsOnce', Em.K);
          sinon.stub(view, 'filterHosts', Em.K);
          sinon.stub(Em.run, 'once', function (context, callback) {
            callback.call(context);
          });
        });

        afterEach(function () {
          view.filteredContentObsOnce.restore();
          view.filterHosts.restore();
          Em.run.once.restore();
        });

        it('should run filteredContentObsOnce', function () {
          popup.set('availableHosts', [
            {
              filtered: true
            }
          ]);
          expect(view.filteredContentObsOnce.calledOnce).to.be.true;
        });

      });

      describe('#filteredContentObsOnce', function () {

        var cases = [
          {
            availableHosts: [],
            filteredContent: [],
            title: 'no hosts available'
          },
          {
            availableHosts: [
              {},
              {
                filtered: false
              },
              {
                filtered: null
              },
              {
                filtered: 0
              }
            ],
            filteredContent: [],
            title: 'no hosts filtered'
          },
          {
            availableHosts: [
              {},
              {
                filtered: false
              },
              {
                filtered: null
              },
              {
                filtered: 0
              },
              {
                filtered: true
              },
              {
                filtered: 'true'
              },
              {
                filtered: 1
              }
            ],
            filteredContent: [
              {
                filtered: true
              },
              {
                filtered: 'true'
              },
              {
                filtered: 1
              }
            ],
            title: 'filtered hosts present'
          }
        ];

        beforeEach(function () {
          sinon.stub(view, 'filteredContentObs', Em.K);
          sinon.stub(view, 'filterHosts', Em.K);
        });

        afterEach(function () {
          view.filteredContentObs.restore();
          view.filterHosts.restore();
        });

        cases.forEach(function (item) {

          it(item.title, function () {
            popup.set('availableHosts', item.availableHosts);
            view.filteredContentObsOnce();
            expect(view.get('filteredContent')).to.eql(item.filteredContent);
          });

        });

      });

      describe('#filterComponents', function () {

        it('should be set from validComponents', function () {
          expect(view.get('filterComponents')).to.eql(validComponents);
        });

      });

      describe('#isDisabled', function () {

        var cases = [
          {
            isLoaded: true,
            isDisabled: false,
            title: 'enabled'
          },
          {
            isLoaded: false,
            isDisabled: true,
            title: 'disabled'
          }
        ];

        cases.forEach(function (item) {

          it(item.title, function () {
            popup.set('isLoaded', item.isLoaded);
            expect(view.get('isDisabled')).to.equal(item.isDisabled);
          });

        });

      });

      describe('#didInsertElement', function () {

        beforeEach(function () {
          sinon.stub(view, 'filterHosts', Em.K);
          sinon.stub(view, 'filteredContentObs', Em.K);
          sinon.stub(view, 'filteredContentObsOnce', Em.K);
          view.get('filterColumns').setEach('selected', false);
          view.get('filterColumns').findProperty('id', 'cpu').set('selected', true);
          view.didInsertElement();
        });

        afterEach(function () {
          view.filterHosts.restore();
          view.filteredContentObs.restore();
          view.filteredContentObsOnce.restore();
        });

        it('column for filter', function () {
          expect(view.get('filterColumn')).to.eql(Em.Object.create({
            id: 'cpu',
            name: 'CPU',
            selected: true
          }));
        });

        it('available hosts', function () {
          expect(view.get('parentView.availableHosts').toArray()).to.eql([
            {
              host: {
                id: 'h0'
              },
              filtered: true
            },
            {
              host: {
                id: 'h1'
              },
              filtered: true
            }
          ]);
        });

        it('isLoaded', function () {
          expect(view.get('parentView.isLoaded')).to.be.true;
        });

        it('observer called', function () {
          expect(view.filteredContentObsOnce.calledOnce).to.be.true;
        });

      });

      describe('#filterHosts', function () {

        var cases = [
          {
            filterText: '',
            filterComponent: null,
            showOnlySelectedHosts: true,
            availableHosts: [
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                selected: false
              })
            ],
            result: [
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                selected: false,
                filterColumnValue: 'centos7',
                filtered: false
              })
            ],
            title: 'no filter text, no component for filter, show selected hosts only'
          },
          {
            filterText: '',
            filterComponent: null,
            showOnlySelectedHosts: false,
            availableHosts: [
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                selected: false
              })
            ],
            result: [
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                selected: false,
                filterColumnValue: 'centos7',
                filtered: true
              })
            ],
            title: 'no filter text, no component for filter, show all hosts'
          },
          {
            filterText: 'n',
            filterComponent: null,
            showOnlySelectedHosts: true,
            availableHosts: [
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h0'
                }),
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h1'
                }),
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn2'
                }),
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn3'
                }),
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h4',
                  osType: 'centos6'
                }),
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h5',
                  osType: 'centos6'
                }),
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn6',
                  osType: 'centos6'
                }),
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn7',
                  osType: 'centos6'
                }),
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h8',
                  osType: 'suse11'
                }),
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h9',
                  osType: 'suse11'
                }),
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn10',
                  osType: 'suse11'
                }),
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn11',
                  osType: 'suse11'
                }),
                selected: false
              })
            ],
            result: [
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h0'
                }),
                selected: true,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h1'
                }),
                selected: false,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn2'
                }),
                selected: true,
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn3'
                }),
                selected: false,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h4',
                  osType: 'centos6'
                }),
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h5',
                  osType: 'centos6'
                }),
                selected: false,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn6',
                  osType: 'centos6'
                }),
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn7',
                  osType: 'centos6'
                }),
                selected: false,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h8',
                  osType: 'suse11'
                }),
                selected: true,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h9',
                  osType: 'suse11'
                }),
                selected: false,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn10',
                  osType: 'suse11'
                }),
                selected: true,
                filterColumnValue: 'suse11',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn11',
                  osType: 'suse11'
                }),
                selected: false,
                filterColumnValue: 'suse11',
                filtered: false
              })
            ],
            title: 'filter text set, no component for filter, show selected hosts only'
          },
          {
            filterText: 'n',
            filterComponent: null,
            showOnlySelectedHosts: false,
            availableHosts: [
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h0'
                }),
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h1'
                }),
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn2'
                }),
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn3'
                }),
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h4',
                  osType: 'centos6'
                }),
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h5',
                  osType: 'centos6'
                }),
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn6',
                  osType: 'centos6'
                }),
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn7',
                  osType: 'centos6'
                }),
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h8',
                  osType: 'suse11'
                }),
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h9',
                  osType: 'suse11'
                }),
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn10',
                  osType: 'suse11'
                }),
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn11',
                  osType: 'suse11'
                }),
                selected: false
              })
            ],
            result: [
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h0'
                }),
                selected: true,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h1'
                }),
                selected: false,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn2'
                }),
                selected: true,
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn3'
                }),
                selected: false,
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h4',
                  osType: 'centos6'
                }),
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h5',
                  osType: 'centos6'
                }),
                selected: false,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn6',
                  osType: 'centos6'
                }),
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn7',
                  osType: 'centos6'
                }),
                selected: false,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h8',
                  osType: 'suse11'
                }),
                selected: true,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h9',
                  osType: 'suse11'
                }),
                selected: false,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn10',
                  osType: 'suse11'
                }),
                selected: true,
                filterColumnValue: 'suse11',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn11',
                  osType: 'suse11'
                }),
                selected: false,
                filterColumnValue: 'suse11',
                filtered: true
              })
            ],
            title: 'filter text set, no component for filter, show all hosts'
          },
          {
            filterText: '',
            filterComponent: Em.Object.create({
              componentName: 'c0'
            }),
            showOnlySelectedHosts: true,
            availableHosts: [
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                hostComponentNames: [],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                hostComponentNames: ['c1', 'c2'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                hostComponentNames: ['c1', 'c2'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false
              })
            ],
            result: [
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                hostComponentNames: [],
                selected: false,
                filterColumnValue: 'centos7',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                hostComponentNames: ['c1', 'c2'],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                hostComponentNames: ['c1', 'c2'],
                selected: false,
                filterColumnValue: 'centos7',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false,
                filterColumnValue: 'centos7',
                filtered: false
              })
            ],
            title: 'no filter text, component filter set, show selected hosts only'
          },
          {
            filterText: '',
            filterComponent: Em.Object.create({
              componentName: 'c1'
            }),
            showOnlySelectedHosts: false,
            availableHosts: [
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                hostComponentNames: [],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                hostComponentNames: ['c1', 'c2'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                hostComponentNames: ['c1', 'c2'],
                selected: false
              })
            ],
            result: [
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                hostComponentNames: [],
                selected: false,
                filterColumnValue: 'centos7',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false,
                filterColumnValue: 'centos7',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos6'
                }),
                hostComponentNames: ['c1', 'c2'],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  osType: 'centos7'
                }),
                hostComponentNames: ['c1', 'c2'],
                selected: false,
                filterColumnValue: 'centos7',
                filtered: true
              })
            ],
            title: 'no filter text, component filter set, show all hosts'
          },
          {
            filterText: 'n',
            filterComponent: Em.Object.create({
              componentName: 'c2'
            }),
            showOnlySelectedHosts: true,
            availableHosts: [
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h0'
                }),
                hostComponentNames: [],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h1'
                }),
                hostComponentNames: [],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn2'
                }),
                hostComponentNames: [],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn3'
                }),
                hostComponentNames: [],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h4',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h5',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn6',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn7',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h8',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h9',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn10',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn11',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h12'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h13'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn14'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn15'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h16',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h17',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn18',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn19',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h20',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h21',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn22',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn23',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h24'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h25'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn26'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn27'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h28',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h29',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn30',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn31',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h32',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h33',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn34',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn35',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false
              })
            ],
            result: [
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h0'
                }),
                hostComponentNames: [],
                selected: true,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h1'
                }),
                hostComponentNames: [],
                selected: false,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn2'
                }),
                hostComponentNames: [],
                selected: true,
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn3'
                }),
                hostComponentNames: [],
                selected: false,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h4',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h5',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: false,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn6',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn7',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: false,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h8',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: true,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h9',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: false,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn10',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: true,
                filterColumnValue: 'suse11',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn11',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: false,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h12'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h13'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn14'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn15'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h16',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h17',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn18',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn19',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h20',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h21',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn22',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn23',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h24'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h25'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn26'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true,
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn27'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h28',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h29',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn30',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn31',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h32',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h33',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn34',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: true,
                filterColumnValue: 'suse11',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn35',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c2'],
                selected: false,
                filterColumnValue: 'suse11',
                filtered: false
              })
            ],
            title: 'filter text set, component filter set, show selected hosts only'
          },
          {
            filterText: 'n',
            filterComponent: Em.Object.create({
              componentName: 'c3'
            }),
            showOnlySelectedHosts: false,
            availableHosts: [
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h0'
                }),
                hostComponentNames: [],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h1'
                }),
                hostComponentNames: [],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn2'
                }),
                hostComponentNames: [],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn3'
                }),
                hostComponentNames: [],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h4',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h5',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn6',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn7',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h8',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h9',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn10',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn11',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h12'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h13'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn14'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn15'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h16',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h17',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn18',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn19',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h20',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h21',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn22',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn23',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h24'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h25'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn26'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn27'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h28',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h29',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn30',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn31',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h32',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h33',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn34',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn35',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: false
              })
            ],
            result: [
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h0'
                }),
                hostComponentNames: [],
                selected: true,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h1'
                }),
                hostComponentNames: [],
                selected: false,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn2'
                }),
                hostComponentNames: [],
                selected: true,
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn3'
                }),
                hostComponentNames: [],
                selected: false,
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h4',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h5',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: false,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn6',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn7',
                  osType: 'centos6'
                }),
                hostComponentNames: [],
                selected: false,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h8',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: true,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h9',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: false,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn10',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: true,
                filterColumnValue: 'suse11',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn11',
                  osType: 'suse11'
                }),
                hostComponentNames: [],
                selected: false,
                filterColumnValue: 'suse11',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h12'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h13'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn14'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn15'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h16',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h17',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn18',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn19',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false,
                filterColumnValue: 'centos6',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h20',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h21',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn22',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: true,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn23',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c1'],
                selected: false,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h24'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: true,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h25'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: false,
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn26'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: true,
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn27'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: false,
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h28',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h29',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: false,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn30',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: true,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn31',
                  osType: 'centos6'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: false,
                filterColumnValue: 'centos6',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h32',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: true,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'h33',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: false,
                filterColumnValue: 'suse11',
                filtered: false
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn34',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: true,
                filterColumnValue: 'suse11',
                filtered: true
              }),
              Em.Object.create({
                host: Em.Object.create({
                  publicHostName: 'hn35',
                  osType: 'suse11'
                }),
                hostComponentNames: ['c0', 'c3'],
                selected: false,
                filterColumnValue: 'suse11',
                filtered: true
              })
            ],
            title: 'filter text set, component filter set, show all hosts'
          }
        ];

        cases.forEach(function (item) {

          var arrayForCheck;

          it(item.title, function () {
            view.setProperties({
              'showOnlySelectedHosts': item.showOnlySelectedHosts,
              'filterText': item.filterText,
              'filterComponent': item.filterComponent,
              'filterColumn': {
                id: 'osType'
              },
              'parentView.availableHosts': item.availableHosts
            });
            item.result.forEach(function (host) {
              if (!host.hasOwnProperty('filterColumnValue')) {
                host.set('filterColumnValue', undefined);
              }
            });
            arrayForCheck = view.get('parentView.availableHosts').toArray();
            arrayForCheck.forEach(function (host) {
              var hostComponentNames = host.get('hostComponentNames');
              if (host.get('hostComponentNames')) {
                host.set('hostComponentNames', hostComponentNames.toArray());
              }
            });
            expect(arrayForCheck).to.eql(item.result);
          });

        });

        it('start index', function () {
          view.set('startIndex', 0);
          view.propertyDidChange('filterColumn');
          expect(view.get('startIndex')).to.equal(1);
        });

      });

      describe('#hostSelectMessage', function () {

        beforeEach(function () {
          sinon.stub(view, 'filterHosts', Em.K);
          sinon.stub(view, 'filteredContentObs', Em.K);
          sinon.stub(view, 'filteredContentObsOnce', Em.K);
        });

        afterEach(function () {
          view.filterHosts.restore();
          view.filteredContentObs.restore();
          view.filteredContentObsOnce.restore();
        });

        it('correct message formatting', function () {
          view.set('parentView.availableHosts', [
            {
              selected: true
            },
            {
              selected: false
            },
            {
              selected: true
            }
          ]);
          expect(view.get('hostSelectMessage')).to.equal(Em.I18n.t('hosts.selectHostsDialog.selectedHostsLink').format(2, 3));
        });

      });

      describe('#selectFilterColumn', function () {

        var columnObject = {
            selected: true
          },
          cases = [
            {
              event: null,
              filterColumn: Em.Object.create(columnObject),
              isPreviousColumnSelected: true,
              title: 'no event data'
            },
            {
              event: {},
              filterColumn: Em.Object.create(columnObject),
              isPreviousColumnSelected: true,
              title: 'no context'
            },
            {
              event: {
                context: null
              },
              filterColumn: Em.Object.create(columnObject),
              isPreviousColumnSelected: true,
              title: 'empty context'
            },
            {
              event: {
                context: Em.Object.create()
              },
              filterColumn: Em.Object.create(columnObject),
              isPreviousColumnSelected: true,
              title: 'no id'
            },
            {
              event: {
                context: Em.Object.create({
                  id: null
                })
              },
              filterColumn: Em.Object.create(columnObject),
              isPreviousColumnSelected: true,
              title: 'invalid id'
            },
            {
              event: {
                context: Em.Object.create({
                  id: 0
                })
              },
              filterColumn: Em.Object.create({
                id: 0,
                selected: true
              }),
              isPreviousColumnSelected: false,
              title: 'valid id'
            }
          ];

        cases.forEach(function (item) {

          describe(item.title, function () {

            var column = Em.Object.create(columnObject);

            beforeEach(function () {
              view.set('filterColumn', column);
              view.selectFilterColumn(item.event);
            });

            it('new column', function () {
              expect(view.get('filterColumn')).to.eql(item.filterColumn);
            });

            it('should deselect previous column', function () {
              expect(column.get('selected')).to.equal(item.isPreviousColumnSelected);
            });

          });

        });

      });

      describe('#selectFilterComponent', function () {

        var componentObject = {
            selected: true
          },
          cases = [
            {
              event: null,
              filterComponent: Em.Object.create(componentObject),
              title: 'no event data'
            },
            {
              event: {},
              filterComponent: Em.Object.create(componentObject),
              title: 'no context'
            },
            {
              event: {
                context: null
              },
              filterComponent: Em.Object.create(componentObject),
              title: 'empty context'
            },
            {
              event: {
                context: Em.Object.create()
              },
              filterComponent: Em.Object.create(componentObject),
              title: 'no component name'
            },
            {
              event: {
                context: Em.Object.create({
                  componentName: null
                })
              },
              filterComponent: Em.Object.create(componentObject),
              title: 'invalid component name'
            },
            {
              event: {
                context: Em.Object.create({
                  componentName: 'c0'
                })
              },
              filterComponent: Em.Object.create({
                componentName: 'c0',
                selected: true
              }),
              title: 'valid component name'
            },
            {
              event: {
                context: Em.Object.create({
                  componentName: 'c0'
                })
              },
              previousFilterComponent: Em.Object.create({
                componentName: 'c0',
                selected: true
              }),
              filterComponent: null,
              title: 'manual deselection'
            },
            {
              event: {
                context: Em.Object.create({
                  componentName: 'c0'
                })
              },
              previousFilterComponent: Em.Object.create({
                componentName: 'c1',
                selected: true
              }),
              filterComponent: Em.Object.create({
                componentName: 'c0',
                selected: true
              }),
              title: 'no manual deselection'
            }
          ];

        cases.forEach(function (item) {

          it(item.title, function () {
            var component = item.previousFilterComponent || Em.Object.create(componentObject);
            view.set('filterComponent', component);
            view.selectFilterComponent(item.event);
            expect(view.get('filterComponent')).to.eql(item.filterComponent);
          });

        });

      });

      describe('#toggleSelectAllHosts', function () {

        var cases = [
          {
            allHostsSelected: true,
            availableHosts: [
              {
                host: {
                  id: 'h0'
                },
                filtered: true,
                selected: true
              },
              {
                host: {
                  id: 'h1'
                },
                filtered: false
              },
              {
                host: {
                  id: 'h2'
                },
                filtered: 'true',
                selected: true
              },
              {
                host: {
                  id: 'h3'
                },
                filtered: 1,
                selected: true
              },
              {
                host: {
                  id: 'h4'
                }
              }
            ],
            title: 'select all hosts'
          },
          {
            allHostsSelected: false,
            availableHosts: [
              {
                host: {
                  id: 'h0'
                },
                filtered: true,
                selected: false
              },
              {
                host: {
                  id: 'h1'
                },
                filtered: false
              },
              {
                host: {
                  id: 'h2'
                },
                filtered: 'true',
                selected: false
              },
              {
                host: {
                  id: 'h3'
                },
                filtered: 1,
                selected: false
              },
              {
                host: {
                  id: 'h4'
                }
              }
            ],
            title: 'deselect all hosts'
          }
        ];

        beforeEach(function () {
          sinon.stub(view, 'filterHosts', Em.K);
          sinon.stub(view, 'filteredContentObs', Em.K);
          sinon.stub(view, 'filteredContentObsOnce', Em.K);
        });

        afterEach(function () {
          view.filterHosts.restore();
          view.filteredContentObs.restore();
          view.filteredContentObsOnce.restore();
        });

        cases.forEach(function (item) {

          it(item.title, function () {
            view.setProperties({
              'allHostsSelected': !item.allHostsSelected,
              'parentView.availableHosts': [
                {
                  host: {
                    id: 'h0'
                  },
                  filtered: true
                },
                {
                  host: {
                    id: 'h1'
                  },
                  filtered: false
                },
                {
                  host: {
                    id: 'h2'
                  },
                  filtered: 'true'
                },
                {
                  host: {
                    id: 'h3'
                  },
                  filtered: 1
                },
                {
                  host: {
                    id: 'h4'
                  }
                }
              ]
            });
            view.toggleProperty('allHostsSelected');
            expect(view.get('parentView.availableHosts').toArray()).to.eql(item.availableHosts);
          });

        });

      });

      describe('#toggleShowSelectedHosts', function () {

        var cases = [
          {
            showOnlySelectedHosts: true,
            title: 'no component for filter'
          },
          {
            showOnlySelectedHosts: false,
            filterComponent: null,
            title: 'empty component for filter'
          },
          {
            showOnlySelectedHosts: true,
            filterComponent: Em.Object.create(),
            title: 'component for filter set'
          }
        ];

        cases.forEach(function (item) {

          describe(item.title, function () {

            beforeEach(function () {
              view.setProperties({
                showOnlySelectedHosts: item.showOnlySelectedHosts,
                filterComponent: item.filterComponent,
                filterText: ''
              });
              view.toggleShowSelectedHosts();
            });

            it('clear component filter', function () {
              expect(view.get('filterComponent')).to.be.null;
            });

            it('clear text filter', function () {
              expect(view.get('filterText')).to.be.null;
            });

            it('toggle hosts display mode', function () {
              expect(view.get('showOnlySelectedHosts')).to.equal(!item.showOnlySelectedHosts);
            });

          });

        });

      });

    });

  });

  describe('#setRackInfo', function () {

    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show', function (obj) {
        return Em.Object.create(obj);
      });
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    describe('#bodyClass', function () {

      describe('#validation', function () {

        var popup,
          view,
          cases = [
            {
              isValidRackId: false,
              errorMessage: Em.I18n.t('hostPopup.setRackId.invalid'),
              disablePrimary: true,
              title: 'invalid rack id'
            },
            {
              isValidRackId: true,
              errorMessage: '',
              disablePrimary: false,
              title: 'valid rack id'
            }
          ];

        cases.forEach(function (item) {

          describe(item.title, function () {

            beforeEach(function () {
              sinon.stub(validator, 'isValidRackId').returns(item.isValidRackId);
              popup = hostsUtils.setRackInfo(null, [], '');
              view = popup.get('bodyClass').create({
                parentView: popup
              });
              view.propertyDidChange('parentView.rackId');
            });

            afterEach(function () {
              validator.isValidRackId.restore();
            });

            it('isValid', function () {
              expect(view.get('isValid')).to.equal(item.isValidRackId);
            });

            it('errorMessage', function () {
              expect(view.get('errorMessage')).to.equal(item.errorMessage);
            });

            it('disablePrimary', function () {
              expect(view.get('parentView.disablePrimary')).to.equal(item.disablePrimary);
            });

          });

        });

      });

    });

    describe('#onPrimary', function () {

      var popup,
        cases = [
          {
            hosts: [],
            ajaxCallArguments: undefined,
            title: 'no hosts'
          },
          {
            hosts: [
              {
                hostName: 'h0'
              },
              {
                hostName: 'h1'
              }
            ],
            ajaxCallArguments: [{
              name: 'bulk_request.hosts.update_rack_id',
              sender: hostsUtils,
              data: {
                hostNames: 'h0,h1',
                requestInfo: 'msg',
                rackId: '/default-rack',
                hostNamesArray: ['h0', 'h1']
              },
              success: 'successRackId',
              error: 'errorRackId'
            }],
            title: 'hosts passed'
          }
        ];

      cases.forEach(function (item) {

        describe(item.title, function () {

          beforeEach(function () {
            popup = hostsUtils.setRackInfo({
              message: 'msg'
            }, item.hosts, '/default-rack');
            popup.set('hide', Em.K);
            sinon.spy(popup, 'hide');
            popup.onPrimary();
          });

          afterEach(function () {
            popup.hide.restore();
          });

          it('AJAX call', function () {
            expect(testHelpers.findAjaxRequest('name', 'bulk_request.hosts.update_rack_id')).to.eql(item.ajaxCallArguments);
          });

          it('hide popup', function () {
            expect(popup.hide.calledOnce).to.be.true;
          });

        });

      });

    });

  });

  describe('#successRackId', function () {

    var hosts = [
      Em.Object.create({
        hostName: 'h0'
      }),
      Em.Object.create({
        hostName: 'h1'
      }),
      Em.Object.create({
        hostName: 'h2'
      })
    ];

    beforeEach(function () {
      sinon.stub(App.Host, 'find').returns(hosts);
    });

    afterEach(function () {
      App.Host.find.restore();
    });

    it('should set rack ids for the proper hosts', function () {
      hostsUtils.successRackId(null, null, {
        hostNamesArray: ['h0', 'h2'],
        rackId: '/default-rack'
      });
      expect(hosts).to.eql([
        Em.Object.create({
          hostName: 'h0',
          rack: '/default-rack'
        }),
        Em.Object.create({
          hostName: 'h1'
        }),
        Em.Object.create({
          hostName: 'h2',
          rack: '/default-rack'
        })
      ]);
    });

  });

  describe('#errorRackId', function () {

    beforeEach(function () {
      sinon.stub(App, 'showAlertPopup', Em.K);
    });

    afterEach(function () {
      App.showAlertPopup.restore();
    });

    it('should show alert popup', function () {
      hostsUtils.errorRackId();
      expect(App.showAlertPopup.calledOnce).to.be.true;
    });

  });

});

});

require.register("test/utils/http_client_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/http_client');

describe('App.HttpClient', function () {

  describe('#defaultErrorHandler', function () {

    var cases = [
      {
        isAsserted: false,
        title: 'no response text'
      },
      {
        responseText: null,
        title: 'empty response text'
      },
      {
        responseText: 404,
        title: 'invalid response text (number)'
      },
      {
        responseText: 'error',
        title: 'invalid response text (string)'
      },
      {
        responseText: '{error}',
        title: 'malformed response text (incorrect literal)'
      },
      {
        responseText: '{error: 404}',
        title: 'malformed response text (no parentheses)'
      },
      {
        responseText: '{\'error\': 404}',
        title: 'malformed response text (incorrect parentheses)'
      },
      {
        responseText: '{"error": 404}',
        title: 'valid response text'
      }
    ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        var jqXHR = {
          responseText: item.responseText
        };

        beforeEach(function () {
          sinon.stub(App.ajax, 'defaultErrorHandler', Em.K);
          sinon.spy(Em, 'assert');
          try {
            App.HttpClient.defaultErrorHandler(jqXHR, '', '', 'http://localhost');
          } catch (e) {}
        });

        afterEach(function () {
          App.ajax.defaultErrorHandler.restore();
          Em.assert.restore();
        });

        it('default error handler call', function () {
          expect(App.ajax.defaultErrorHandler.calledOnce).to.be.true;
        });

        it('default error handler arguments', function () {
          expect(App.ajax.defaultErrorHandler.firstCall.args).to.eql([jqXHR, 'http://localhost']);
        });

        it('no console error assertion', function () {
          expect(Em.assert.threw()).to.be.false;
        });

      });

    });

  });

  describe('#request', function () {

    var errorHandler = Em.K,
      ajaxOptions = {
        params: 'property=value'
      },
      mapper = {},
      cases = [
        {
          url: 'url',
          generatedUrl: 'url?_=1000',
          errorHandler: null,
          passedErrorHandler: App.HttpClient.defaultErrorHandler,
          isGetAsPost: false,
          method: 'GET',
          setRequestHeaderCallCount: 0,
          params: null,
          title: 'no request parameters, default error handler'
        },
        {
          url: 'url?property0=value0&property1=value1',
          generatedUrl: 'url?property0=value0&property1=value1&_=1000',
          errorHandler: errorHandler,
          passedErrorHandler: errorHandler,
          isGetAsPost: true,
          method: 'POST',
          setRequestHeaderCallCount: 2,
          params: '{"RequestInfo":{"query":"property=value"}}',
          title: 'request parameters passed, POST request'
        }
      ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(XMLHttpRequest.prototype, 'open', Em.K);
          sinon.stub(XMLHttpRequest.prototype, 'setRequestHeader', Em.K);
          sinon.stub(XMLHttpRequest.prototype, 'send', Em.K);
          sinon.stub(App, 'dateTime').returns(1000);
          sinon.stub(App.HttpClient, 'onReady', Em.K);
          App.HttpClient.request(item.url, ajaxOptions, mapper, item.errorHandler, item.isGetAsPost);
        });

        afterEach(function () {
          XMLHttpRequest.prototype.open.restore();
          XMLHttpRequest.prototype.setRequestHeader.restore();
          XMLHttpRequest.prototype.send.restore();
          App.dateTime.restore();
          App.HttpClient.onReady.restore();
        });

        it('request method', function () {
          expect(XMLHttpRequest.prototype.open.firstCall.args[0]).to.equal(item.method);
        });

        it('request URL', function () {
          expect(XMLHttpRequest.prototype.open.firstCall.args[1]).to.equal(item.generatedUrl);
        });

        it('setting request headers', function () {
          expect(XMLHttpRequest.prototype.setRequestHeader.callCount).to.equal(item.setRequestHeaderCallCount);
        });

        it('request params', function () {
          expect(XMLHttpRequest.prototype.send.firstCall.args[0]).to.equal(item.params);
        });

        it('onReady callback: ajaxOptions', function () {
          expect(App.HttpClient.onReady.firstCall.args[2]).to.eql(ajaxOptions);
        });

        it('onReady callback: mapper', function () {
          expect(App.HttpClient.onReady.firstCall.args[3]).to.eql(mapper);
        });

        it('onReady callback: errorHandler', function () {
          expect(App.HttpClient.onReady.firstCall.args[4]).to.eql(item.passedErrorHandler);
        });

        it('onReady callback: url', function () {
          expect(App.HttpClient.onReady.firstCall.args[5]).to.equal(item.url);
        });

      });

    });

  });

  describe('#onReady', function () {

    var clock,
      xhr = {
        responseText: '{"property": "value"}',
        statusText: 'status',
        abort: Em.K
      },
      ajaxOptions = {
        complete: Em.K
      },
      mapper = {
        map: Em.K
      },
      mock = {
        errorHandler: Em.K
      },
      cases = [
        {
          readyState: 4,
          status: 200,
          isCommitError: false,
          commitCallCount: 1,
          mapCallCount: 1,
          completeCallCount: 1,
          abortCallCount: 1,
          errorHandlerCallCount: 0,
          onReadyCallCount: 1,
          title: 'successful request'
        },
        {
          readyState: 4,
          status: 200,
          isCommitError: true,
          commitCallCount: 1,
          mapCallCount: 1,
          completeCallCount: 1,
          abortCallCount: 1,
          errorHandlerCallCount: 0,
          onReadyCallCount: 1,
          title: 'successful request, App.store.commit error'
        },
        {
          readyState: 4,
          status: 404,
          isCommitError: false,
          commitCallCount: 0,
          mapCallCount: 0,
          completeCallCount: 0,
          abortCallCount: 0,
          errorHandlerCallCount: 1,
          onReadyCallCount: 1,
          title: 'failed request'
        },
        {
          readyState: 3,
          status: 200,
          isCommitError: false,
          commitCallCount: 1,
          mapCallCount: 1,
          completeCallCount: 1,
          abortCallCount: 1,
          errorHandlerCallCount: 0,
          onReadyCallCount: 2,
          title: 'incomplete request, later successful'
        },
        {
          readyState: 3,
          status: 404,
          isCommitError: false,
          commitCallCount: 0,
          mapCallCount: 0,
          completeCallCount: 0,
          abortCallCount: 0,
          errorHandlerCallCount: 1,
          onReadyCallCount: 2,
          title: 'incomplete request, later failed'
        }
      ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          clock = sinon.useFakeTimers();
          sinon.spy(xhr, 'abort');
          sinon.spy(mapper, 'map');
          sinon.spy(mock, 'errorHandler');
          sinon.spy(ajaxOptions, 'complete');
          sinon.spy(App.HttpClient, 'onReady');
          xhr.readyState = item.readyState;
          xhr.status = item.status;
          App.HttpClient.onReady(xhr, null, ajaxOptions, mapper, mock.errorHandler, 'url');
          clock.tick(10);
          xhr.readyState = 4;
          clock.tick(10);
        });

        afterEach(function () {
          clock.restore();
          xhr.abort.restore();
          mapper.map.restore();
          mock.errorHandler.restore();
          ajaxOptions.complete.restore();
          App.HttpClient.onReady.restore();
        });

        it('mapping data', function () {
          expect(mapper.map.callCount).to.equal(item.mapCallCount);
        });

        if (item.mapCallCount) {
          it('mapped data', function () {
            expect(mapper.map.alwaysCalledWith({
              property: 'value'
            })).to.be.true;
          });
        }

        it('complete callback call', function () {
          expect(ajaxOptions.complete.callCount).to.equal(item.completeCallCount);
        });

        if (item.completeCallCount) {
          it('complete callback context', function () {
            expect(ajaxOptions.complete.alwaysCalledOn(App.HttpClient)).to.be.true;
          });
        }

        it('abort request', function () {
          expect(xhr.abort.callCount).to.equal(item.abortCallCount);
        });

        it('error handler call', function () {
          expect(mock.errorHandler.callCount).to.equal(item.errorHandlerCallCount);
        });

        if (item.errorHandlerCallCount) {
          it('error handler arguments', function () {
            expect(mock.errorHandler.alwaysCalledWith(xhr, 'error', 'status', 'url')).to.be.true;
          });
        }

        it('onReady iterations number', function () {
          expect(App.HttpClient.onReady.callCount).to.equal(item.onReadyCallCount);
        });

      });

    });

  });

  describe('#get', function () {

    var mapper = {},
      cases = [
        {
          data: {
            error: Em.clb
          },
          errorHandler: Em.K,
          passedErrorHandler: Em.K,
          isGetAsPost: false,
          title: 'custom error handler'
        },
        {
          data: {
            error: Em.clb,
            doGetAsPost: true
          },
          interval: 1,
          passedErrorHandler: Em.clb,
          isGetAsPost: true,
          title: 'error handler from data, interval provided, POST request'
        }
      ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(App.HttpClient, 'request', Em.K);
          sinon.stub($, 'periodic', function (options, callback) {
            callback();
          });
          App.HttpClient.get('url', mapper, item.data, item.errorHandler, item.interval);
        });

        afterEach(function () {
          App.HttpClient.request.restore();
          $.periodic.restore();
        });

        it('request call', function () {
          expect(App.HttpClient.request.calledOnce).to.be.true;
        });

        it('request arguments', function () {
          expect(App.HttpClient.request.firstCall.args).to.eql(['url', item.data, mapper, item.passedErrorHandler, item.isGetAsPost]);
        });

      });

    });

  });

  describe('#post', function () {

    var args = ['url', {}, {}, Em.K, 1];

    beforeEach(function () {
      sinon.stub(App.HttpClient, 'get', Em.K);
      App.HttpClient.post.apply(App.HttpClient, args);
    });

    afterEach(function () {
      App.HttpClient.get.restore();
    });

    it('should call get method', function () {
      expect(App.HttpClient.get.calledOnce).to.be.true;
    });

    it('get method arguments', function () {
      expect(App.HttpClient.get.firstCall.args).to.eql(args);
    });

  });

});
});

require.register("test/utils/lazy_loading_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var lazyLoading = require('utils/lazy_loading');

describe('lazy_loading', function () {

  describe('#run()', function () {
    var context = Em.Object.create({isLoaded: false});
    var options = {
      destination: [],
      source: [{'test':'test'}],
      context: context
    };
    it('load one item', function () {
      lazyLoading.run(options);
      expect(options.destination[0]).to.eql(options.source[0]);
      expect(context.get('isLoaded')).to.equal(true);
    });

    var testsInfo = [
      {
        title: 'load 11 item with initSize - 11',
        result: true,
        initSize: 11,
        destinationLength: 11,
        destination: [],
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        context: Em.Object.create()
      },
      {
        title: 'load 11 item with initSize - 12',
        result: true,
        initSize: 12,
        destinationLength: 11,
        destination: [],
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        context: Em.Object.create()
      },
      {//items will be completely loaded on next iteration of pushing chunk
        title: 'load 11 item with initSize - 10',
        result: false,
        initSize: 10,
        destinationLength: 10,
        destination: [],
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        context: Em.Object.create({isLoaded: false})
      }
    ];
    testsInfo.forEach(function(test){
      it(test.title, function () {
        lazyLoading.run(test);
        expect(test.destinationLength).to.equal(test.destination.length);
        expect(test.context.get('isLoaded')).to.equal(test.result);
      });
    });
  });

  describe('#divideIntoChunks()', function () {
    var testsInfo = [
      {
        title: 'load 11 item with chunkSize - 3',
        chunkSize: 3,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}, {i:2}, {i:3}], [{i:4}, {i:5}, {i:6}], [{i:7}, {i:8}, {i:9}], [{i:10},{i:11}]]
      },
      {
        title: 'load 11 item with chunkSize - 0',
        chunkSize: 0,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}]]
      },
      {
        title: 'load 11 item with chunkSize - 1',
        chunkSize: 1,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}], [{i:2}], [{i:3}], [{i:4}], [{i:5}], [{i:6}], [{i:7}], [{i:8}], [{i:9}], [{i:10}], [{i:11}]]
      },
      {
        title: 'load 11 item with chunkSize - 11',
        chunkSize: 0,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}]]
      }
    ];
    testsInfo.forEach(function(test){
      it(test.title, function () {
        var chunks = lazyLoading.divideIntoChunks(test.source, test.chunkSize);
        expect(chunks).to.eql(test.chunks);
      });
    });
  });

  describe("#pushChunk()", function() {
    beforeEach(function () {
      this.clock = sinon.useFakeTimers();
      sinon.spy(lazyLoading, 'pushChunk');
    });
    afterEach(function () {
      this.clock.restore();
      lazyLoading.pushChunk.restore();
    });
    it("last chunk", function() {
      this.clock = sinon.useFakeTimers();

      var destination = [],
          chunks = [[1]],
          context = Em.Object.create(),
          instance = {
            context: context,
            timeoutRef: null,
            terminate: Em.K
          };
      lazyLoading.pushChunk(chunks, 0, 10, destination, instance);
      this.clock.tick(10);
      expect(destination[0]).to.equal(1);
      expect(context.get('isLoaded')).to.be.true;
      expect(lazyLoading.pushChunk.calledTwice).to.be.false;
    });
    it("two chunks", function() {
      this.clock = sinon.useFakeTimers();
      var destination = [],
        chunks = [[1], [2]],
        context = Em.Object.create(),
        instance = {
          context: context,
          timeoutRef: null,
          terminate: Em.K
        };
      lazyLoading.pushChunk(chunks, 0, 10, destination, instance);
      this.clock.tick(20);
      expect(destination.length).to.equal(2);
      expect(context.get('isLoaded')).to.be.true;
      expect(lazyLoading.pushChunk.calledTwice).to.be.true;
    });
    it("terminated chunks", function() {
      this.clock = sinon.useFakeTimers();
      var destination = [],
        chunks = [[1]],
        context = Em.Object.create({isLoaded: false}),
        instance = {
          context: context,
          timeoutRef: null,
          terminate: Em.K
        };
      lazyLoading.pushChunk(chunks, 0, 10, destination, instance);
      clearTimeout(instance.timeoutRef);
      this.clock.tick(10);
      expect(destination.length).to.empty;
      expect(context.get('isLoaded')).to.be.false;
      expect(lazyLoading.pushChunk.calledTwice).to.be.false;
    });
  });

  describe("#terminate()", function() {
    before(function () {
      sinon.spy(lazyLoading, 'pushChunk');
      this.clock = sinon.useFakeTimers();
    });
    after(function () {
      lazyLoading.pushChunk.restore();
      this.clock.restore();
    });
    it("loading terminated", function() {
      var context = Em.Object.create({isLoaded: false});
      var options = {
        destination: [],
        source: [1, 2],
        delay: 10,
        chunkSize: 1,
        initSize: 1,
        context: context
      };

      var ll = lazyLoading.run(options);
      lazyLoading.terminate(ll);
      this.clock.tick(10);
      expect(options.destination.length).to.equal(1);
      expect(context.get('isLoaded')).to.be.false;
      expect(lazyLoading.pushChunk.calledTwice).to.be.false;
    });
  });
});

});

require.register("test/utils/load_timer_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

describe('App.loadTimer', function () {

  window.performance = {
    now: function() {
      return 1;
    }
  };

  beforeEach(function() {
    App.set('supports.showPageLoadTime', true);
  });

  afterEach(function () {
    App.set('supports.showPageLoadTime', false);
    App.loadTimer.set('timeStampCache', {});
  });

  describe("#start()", function() {
    it("time should be cached", function() {
      App.loadTimer.start('test');
      expect(App.loadTimer.get('timeStampCache.test')).to.be.an('number');
    });
  });

  describe("#finish()", function() {
    it("timeStampCache is empty", function() {
      App.loadTimer.start('test');
      expect(App.loadTimer.finish('test')).to.be.not.empty;
      expect(App.loadTimer.get('timeStampCache')).to.be.empty;
    });
  });
});

});

require.register("test/utils/misc_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var misc = require('utils/misc');

describe('misc', function () {

  describe('#formatBandwidth', function () {
    var tests = Em.A([
      {m:'undefined to undefined',i:undefined,e:undefined},
      {m:'0 to <1KB',i:'0',e:'<1KB'},
      {m:'1000 to <1KB',i:'1000',e:'<1KB'},
      {m:'1024 to 1.0KB',i:'1024',e:'1.0KB'},
      {m:'2048 to 2.0KB',i:'2048',e:'2.0KB'},
      {m:'1048576 to 1.0MB',i:'1048576',e:'1.0MB'},
      {m:'1782579 to 1.7MB',i:'1782579',e:'1.7MB'},
      {m:'1546188226 to 1.44GB',i:'1546188226',e:'1.44GB'}
    ]);
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(misc.formatBandwidth(test.i)).to.equal(test.e);
      });
    });
    it('NaN to NaN', function () {
      expect(isNaN(misc.formatBandwidth(NaN))).to.equal(true);
    });
  });

  describe('#ipToInt', function () {
    var tests = Em.A([
      {m:'0.0.0.0 to 0',i:'0.0.0.0',e:0},
      {m:'255.255.255.255 to 4294967295',i:'255.255.255.255',e:4294967295},
      {m:'"" to false',i:'',e:false},
      {m:'255.255.255.256 to false',i:'255.255.255.256',e:false},
      {m:'255.255.255 to false',i:'255.255.255',e:false}
    ]);
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(misc.ipToInt(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#sortByOrder', function() {
    var tests = Em.A([
      {
        sortOrder: ['b', 'c', 'a'],
        array: [{id:'a'}, {id:'b'}, Em.Object.create({id:'c'})],
        e: [{id:'b'}, Em.Object.create({id:'c'}), {id:'a'}],
        m: 'Array with Ember and native objects'
      },
      {
        sortOrder: ['b', 'c', 'a'],
        array: [{id:'a'}, {id:'b'}, {id:'c'}],
        e: [{id:'b'}, {id:'c'}, {id:'a'}],
        m: 'Array with native objects'
      },
      {
        sortOrder: ['b', 'c', 'a'],
        array: [Em.Object.create({id:'a'}), Em.Object.create({id:'b'}), Em.Object.create({id:'c'})],
        e: [Em.Object.create({id:'b'}), Em.Object.create({id:'c'}), Em.Object.create({id:'a'})],
        m: 'Array with Ember objects'
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(misc.sortByOrder(test.sortOrder, test.array)).to.eql(test.e);
      });
    });
  });
});

});

require.register("test/utils/number_utils_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var numberUtils = require('utils/number_utils');

describe('utils/number_utils', function() {

  describe('#bytesToSize', function() {

    describe('check bytes', function() {
      var tests = Em.A([
        {
          bytes: null,
          precision: null,
          parseType: null,
          multiplyBy: null,
          e: 'n/a',
          m: '"n/a" if bytes is null'
        },
        {
          bytes: undefined,
          precision: null,
          parseType: null,
          multiplyBy: null,
          e: 'n/a',
          m: '"n/a" if bytes is undefined'
        },
        {
          bytes: 200,
          precision: null,
          parseType: undefined,
          multiplyBy: null,
          e: '0 Bytes',
          m: '0 if multiply is `null`'
        },
        {
          bytes: 200,
          precision: null,
          parseType: undefined,
          multiplyBy: undefined,
          e: '200 Bytes',
          m: '"200 Bytes" if `multiplyBy` and `parseType` are `undefined`'
        },
        {
          bytes: 200,
          precision: null,
          parseType: undefined,
          multiplyBy: 1,
          e: '200 Bytes',
          m: '`200 Bytes` if `parsetype` is `undefined`'
        }
      ]);

      tests.forEach(function(test) {
        it(test.m, function() {
          expect(numberUtils.bytesToSize(test.bytes, test.precision, test.parseType, test.multiplyBy)).to.equal(test.e);
        });
      });
    });

    describe('check sizes', function() {
      var tests = Em.A([
        {
          bytes: 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'Bytes',
          m: 'Bytes'
        },
        {
          bytes: 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'KB',
          m: 'KB'
        },
        {
          bytes: 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'MB',
          m: 'MB'
        },
        {
          bytes: 1024 * 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'GB',
          m: 'GB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'TB',
          m: 'TB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'PB',
          m: 'PB'
        }
      ]);

      tests.forEach(function(test) {
        it(test.m, function() {
          expect(numberUtils.bytesToSize(test.bytes, test.precision, test.parseType, test.multiplyBy).endsWith(test.e)).to.equal(true);
        });
      });
    });

    describe('check calculated result', function() {
      var tests = Em.A([
        {
          bytes: 42,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '42',
          m: 'Bytes'
        },
        {
          bytes: 1024 * 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '12',
          m: 'KB'
        },
        {
          bytes: 1024 * 1024 * 23,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '23',
          m: 'MB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 34,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '34',
          m: 'GB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 * 45,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '45',
          m: 'TB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 * 1024 * 56,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '56',
          m: 'PB'
        }
      ]);

      tests.forEach(function(test) {
        it(test.m, function() {
          expect(numberUtils.bytesToSize(test.bytes, test.precision, test.parseType, test.multiplyBy).startsWith(test.e)).to.equal(true);
        });
      });
    });

  });
  describe('#validateInteger()', function() {
    var tests = [
      {
        str: null,
        min: null,
        max: null,
        m: 'all params null to' + Em.I18n.t('number.validate.empty'),
        e: Em.I18n.t('number.validate.empty')
      },
      {
        str: "string",
        min: null,
        max: null,
        m: 'try to validate `string` should return ' + Em.I18n.t('number.validate.empty'),
        e: Em.I18n.t('number.validate.notValidNumber')
      },
      {
        str: "string",
        min: null,
        max: null,
        m: 'try to validate `string` should return ' + Em.I18n.t('number.validate.notValidNumber'),
        e: Em.I18n.t('number.validate.notValidNumber')
      },
      {
        str: "1abc",
        min: null,
        max: null,
        m: 'try to validate `1abc` should return ' + Em.I18n.t('number.validate.notValidNumber'),
        e: Em.I18n.t('number.validate.notValidNumber')
      },
      {
        str: "1",
        min: null,
        max: null,
        m: 'try to validate `1` should return ' + Em.I18n.t('number.validate.moreThanMaximum').format(null),
        e: Em.I18n.t('number.validate.moreThanMaximum').format(null)
      },
      {
        str: "1",
        min: 2,
        max: 0,
        m: 'try to validate `1` with max = 0 and min = 2 should return ' + Em.I18n.t('number.validate.lessThanMinimum').format(2),
        e: Em.I18n.t('number.validate.lessThanMinimum').format(2)
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function(){
        expect(numberUtils.validateInteger(test.str, test.min, test.max)).to.eql(test.e);
      });
    });
  });

  describe('#getCardinalityValue()', function() {
    var generateTestObject = function(cardinality, isMax, expected) {
      return {
        cardinality: cardinality,
        isMax: isMax,
        e: expected
      }
    };
    var tests = [
      generateTestObject(null, true, 0),
      generateTestObject(undefined, true, 0),
      generateTestObject('1', true, 1),
      generateTestObject('1', false, 1),
      generateTestObject('0+', true, Infinity),
      generateTestObject('0+', false, 0),
      generateTestObject('1+', true, Infinity),
      generateTestObject('1-2', false, 1),
      generateTestObject('1-2', true, 2),
      generateTestObject('ALL', true, Infinity),
      generateTestObject('ALL', false, Infinity)
    ];
    var message = 'cardinality `{0}`. {1} value should be {2}';
    tests.forEach(function(test) {
      it(message.format('' + test.cardinality, test.isMax ? 'maximum' : 'minimum', test.e), function() {
        expect(numberUtils.getCardinalityValue(test.cardinality, test.isMax)).to.be.eql(test.e);
      });
    })
  });
});
});

require.register("test/utils/object_utils_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var objectUtils = require('utils/object_utils');

describe('utils/object_utils', function() {
  describe('#recursiveTree()', function() {
    var testObj = {
      a1: {
        a2: 'v1',
        a3: {
          a4: {
            a5: {
              a6: 'v2',
              a7: 'v3'
            }
          }
        }
      }
    };
    it('should return correct tree of childs', function(){
      var result = objectUtils.recursiveTree(testObj);
      expect(result).to.be.equal('a2 (/a1)<br/>a5 (/a1/a3/a4)<br/>');
    });

    it('should return `null` if type missed', function() {
      var result = objectUtils.recursiveTree('{ a1: "v1"}');
      expect(result).to.be.null;
    });
  });
  describe('#recursiveKeysCount()', function() {
    var tests = [
      {
        m: 'should return 1 child',
        e: 3,
        obj: {
          a1: {
            a2: 'v1',
            a3: 'v2',
            a4: {
              a5: 'v3'
            }
          }
        }
      },
      {
        m: 'should return 1 childs',
        e: 1,
        obj: {
          a1: 'c1'
        }
      },
      {
        m: 'should return `null`',
        e: null,
        obj: 'a1'
      }
    ];
    tests.forEach(function(test){
      it(test.m, function() {
        expect(objectUtils.recursiveKeysCount(test.obj)).to.be.eql(test.e);
      });
    });
  });

  describe('#deepEqual', function() {
    it('simple values', function() {
      expect(objectUtils.deepEqual(true, true)).to.true;
    });
    it('simple values strict', function() {
      expect(objectUtils.deepEqual(true, 1)).to.false;
    });
    it('simple with complex', function() {
      expect(objectUtils.deepEqual(true, {})).to.false;
    });
    it('complex with simple', function() {
      expect(objectUtils.deepEqual({}, 2)).to.false;
    });
    it('simple objects', function() {
      var a = {
        value: 1
      };
      var b = {
        value: 1
      };
      expect(objectUtils.deepEqual(a, b)).to.true;
    });
    it('simple objects failed', function() {
      var a = {
        value: 1,
        c: 1
      };
      var b = {
        value: 1
      };
      expect(objectUtils.deepEqual(a, b)).to.false;
    });
    it('complex objects', function() {
      var a = {
        value: 1,
        c: {
          d: {
            x: {
              val: 1
            }
          }
        }
      };
      var b = {
        value: 1,
        c: {
          d: {
            x: {
              val: 1
            }
          }
        }
      };
      expect(objectUtils.deepEqual(a, b)).to.true;
    });
    it('complex objects failed', function() {
      var a = {
        value: 1,
        c: {
          d: {
            x: {
              val: 1
            }
          }
        }
      };
      var b = {
        value: 1,
        c: {
          d: {
            x: {
              val: 2
            }
          }
        }
      };
      expect(objectUtils.deepEqual(a, b)).to.false;
    });
    it('complex array', function() {
      var a = [1,2,{a: 2}, 4, {b:{}}];
      var b = [1,2,{a: 2}, 4, {b:{}}];
      expect(objectUtils.deepEqual(a, b)).to.true;
    });
    it('complex array failed', function() {
      var a = [1,3,{a: 2}, 4, {b:{}}];
      var b = [1,2,{a: 2}, 4, {b:{}}];
      expect(objectUtils.deepEqual(a, b)).to.false;
    });
    it('simple array', function() {
      var a = [1,3];
      var b = [1,3];
      expect(objectUtils.deepEqual(a, b)).to.true;
    });
    it('simple array failed', function() {
      var a = [3,1];
      var b = [1,3];
      expect(objectUtils.deepEqual(a, b)).to.false;
    });
  });

  describe('#deepMerge', function() {
    var tests = [
      {
        target: {
          a: [
            {
              c: 3
            }
          ]
        },
        source: {
          a: [
            {
              b: 2
            }
          ]
        },
        e: {
          a: [
            {
              c: 3
            },
            {
              b: 2
            }
          ]
        }
      },
      {
        target: {
          a: {}
        },
        source: {
          a: {
            b: 2,
            c: [1,2,3]
          }
        },
        e: {
          a: {
            b: 2,
            c: [1,2,3]
          }
        }
      },
      {
        target: {
          artifact_data: {
            services: [
              {
                name: "HIVE",
                configurations: [
                  {
                    "hive-site": {
                      hive_prop1: "hive_val1"
                    }
                  }
                ]
              }
            ]
          }
        },
        source: {
          artifact_data: {
            services: [
              {
                name: "HDFS",
                configurations: [
                  {
                    "hdfs-site": {
                      hdfs_prop1: "hdfs_val1"
                    }
                  }
                ]
              }
            ]
          }
        },
        e: {
          artifact_data: {
            services: [
              {
                name: "HIVE",
                configurations: [
                  {
                    "hive-site": {
                      hive_prop1: "hive_val1"
                    }
                  }
                ]
              },
              {
                name: "HDFS",
                configurations: [
                  {
                    "hdfs-site": {
                      hdfs_prop1: "hdfs_val1"
                    }
                  }
                ]
              }
            ]
          }
        }
      },
      {
        source: {
          "artifact_data" : {
            "identities" : [
              {
                "principal" : {
                  "value" : "HTTP/_HOST@${realm}",
                  "type" : "service"
                },
                "name" : "spnego",
                "keytab" : {
                  "file" : "${keytab_dir}/spnego.service.keytab",
                  "owner" : {
                    "name" : "root",
                    "access" : "r"
                  },
                  "group" : {
                    "name" : "${cluster-env/user_group}",
                    "access" : "r"
                  }
                }
              },
              {
                "principal" : {
                  "value" : "${cluster-env/smokeuser}-----@${realm}",
                  "local_username" : "${cluster-env/smokeuser}",
                  "configuration" : "cluster-env/smokeuser_principal_name",
                  "type" : "user"
                },
                "name" : "smokeuser",
                "keytab" : {
                  "file" : "${keytab_dir}/smokeuser.headless.keytab",
                  "owner" : {
                    "name" : "${cluster-env/smokeuser}",
                    "access" : "r"
                  },
                  "configuration" : "cluster-env/smokeuser_keytab",
                  "group" : {
                    "name" : "${cluster-env/user_group}",
                    "access" : "r"
                  }
                }
              }
            ]
          }
        },
        target: {
          "artifact_data" : {
            "identities" : [
              {
                "principal" : {
                  "value" : "${cluster-env/smokeuser}@${realm}",
                  "local_username" : "${cluster-env/smokeuser}",
                  "configuration" : "cluster-env/smokeuser_principal_name",
                  "type" : "user"
                },
                "name" : "smokeuser",
                "keytab" : {
                  "file" : "${keytab_dir}/smokeuser.headless.keytab",
                  "owner" : {
                    "name" : "${cluster-env/smokeuser}",
                    "access" : "r"
                  },
                  "configuration" : "cluster-env/smokeuser_keytab",
                  "group" : {
                    "name" : "${cluster-env/user_group}",
                    "access" : "r"
                  }
                }
              },
              {
                "principal" : {
                  "value" : "HTTP/_HOST@${realm}",
                  "local_username" : null,
                  "configuration" : null,
                  "type" : "service"
                },
                "name" : "spnego",
                "keytab" : {
                  "file" : "${keytab_dir}/spnego.service.keytab",
                  "owner" : {
                    "name" : "root",
                    "access" : "r"
                  },
                  "configuration" : null,
                  "group" : {
                    "name" : "${cluster-env/user_group}",
                    "access" : "d"
                  }
                }
              },
              {
                "name": "anotherOne"
              }
            ]
          }
        },
        e: {
          "artifact_data" : {
            "identities" : [
              {
                "principal" : {
                  "value" : "${cluster-env/smokeuser}-----@${realm}",
                  "local_username" : "${cluster-env/smokeuser}",
                  "configuration" : "cluster-env/smokeuser_principal_name",
                  "type" : "user"
                },
                "name" : "smokeuser",
                "keytab" : {
                  "file" : "${keytab_dir}/smokeuser.headless.keytab",
                  "owner" : {
                    "name" : "${cluster-env/smokeuser}",
                    "access" : "r"
                  },
                  "configuration" : "cluster-env/smokeuser_keytab",
                  "group" : {
                    "name" : "${cluster-env/user_group}",
                    "access" : "r"
                  }
                }
              },
              {
                "principal" : {
                  "value" : "HTTP/_HOST@${realm}",
                  "local_username" : null,
                  "configuration" : null,
                  "type" : "service"
                },
                "name" : "spnego",
                "keytab" : {
                  "file" : "${keytab_dir}/spnego.service.keytab",
                  "owner" : {
                    "name" : "root",
                    "access" : "r"
                  },
                  "configuration" : null,
                  "group" : {
                    "name" : "${cluster-env/user_group}",
                    "access" : "r"
                  }
                }
              },
              {
                "name": "anotherOne"
              }
            ]
          }
        }
      }
    ];

    tests.forEach(function(test) {
      it("Should merge objects `{0}`, `{1}`".format(JSON.stringify(test.target), JSON.stringify(test.source)), function() {
        expect(objectUtils.deepMerge(test.target, test.source, test.handler)).to.be.eql(test.e);
      });
    });
  });

  describe('#detectIndexedKey', function() {
    var tests = [
      {
        target: [
          {
            a: 1,
            b: []
          },
          {
            a: 3,
            b: 2
          },
          {
            a: 2,
            b: {}
          }
        ],
        e: 'a',
        m: 'should detect uniq key as `a`'
      },
      {
        target: [
          {
            "principal" : {
              "value" : "HTTP/_HOST@${realm}",
              "local_username" : null,
              "configuration" : null,
              "type" : "service"
            },
            "name" : "spnego",
            "keytab" : {
              "file" : "${keytab_dir}/spnego.service.keytab",
              "owner" : {
                "name" : "root",
                "access" : "r"
              },
              "configuration" : null,
              "group" : {
                "name" : "${cluster-env/user_group}",
                "access" : "r"
              }
            }
          },
          {
            "principal" : {
              "value" : "${cluster-env/smokeuser}-${cluster_name|toLower()}@${realm}",
              "local_username" : "${cluster-env/smokeuser}",
              "configuration" : "cluster-env/smokeuser_principal_name",
              "type" : "user"
            },
            "name" : "smokeuser",
            "keytab" : {
              "file" : "${keytab_dir}/smokeuser.headless.keytab",
              "owner" : {
                "name" : "${cluster-env/smokeuser}",
                "access" : "r"
              },
              "configuration" : "cluster-env/smokeuser_keytab",
              "group" : {
                "name" : "${cluster-env/user_group}",
                "access" : "r"
              }
            }
          }
        ],
        e: 'name',
        m: 'should detect uniq key as `name`'
      },
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        expect(objectUtils.detectIndexedKey(test.target)).to.eql(test.e);
      });
    });
  });

  describe('#smartArrayObjectMerge', function() {
    var tests = [
      {
        target: [
          {
            a: 2,
            B: 2
          }
        ],
        source: [
          {
            a: 3,
            c: 4
          },
        ],
        m: 'should merge {0} {1}, into {2}',
        e: [
          {
            a: 2,
            B: 2
          },
          {
            a: 3,
            c: 4
          }
        ]
      },
      {
        target: [
          {
            a: 2,
            B: 2
          }
        ],
        source: [
          {
            a: 2,
            B: 3,
            b: 4
          },
          {
            a: 3,
            c: 4
          }
        ],
        m: 'should merge {0} {1}, into {2}',
        e: [
          {
            a: 2,
            B: 3,
            b: 4
          },
          {
            a: 3,
            c: 4
          }
        ]
      },
      {
        target: [
          {
            "spark-defaults" : {
              "spark.history.kerberos.enabled" : "true",
              "spark.history.enabled" : "no"
            }
          }
        ],
        source: [
          {
            "spark-defaults" : {
              "spark.history.kerberos.enabled" : "false"
            }
          },
          {
            "spark-site" : {
              "spark.property" : "false"
            }
          }
        ],
        m: 'should merge {0} {1}, into {2}',
        e: [
          {
            "spark-defaults" : {
              "spark.history.kerberos.enabled" : "true",
              "spark.history.enabled" : "no"
            }
          },
          {
            "spark-site" : {
              "spark.property" : "false"
            }
          }
        ]
      }
    ];

    tests.forEach(function(test) {
      it(test.m.format(JSON.stringify(test.target), JSON.stringify(test.source), JSON.stringify(test.e)), function() {
        expect(objectUtils.smartArrayObjectMerge(test.target, test.source).toArray()).to.be.eql(test.e);
      });
    });
  });
});

});

require.register("test/utils/polling_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');
require('utils/polling');

describe('App.Poll', function () {

  var poll;

  beforeEach(function () {
    poll = App.Poll.create();
  });

  describe('#isCompleted', function () {

    var cases = [
      {
        isError: true,
        isSuccess: false,
        isCompleted: true,
        title: 'error'
      },
      {
        isError: false,
        isSuccess: true,
        isCompleted: true,
        title: 'success'
      },
      {
        isError: false,
        isSuccess: false,
        isCompleted: false,
        title: 'incomplete'
      }
    ];

    cases.forEach(function (item) {

      it(item.title, function () {
        poll.setProperties({
          isError: item.isError,
          isSuccess: item.isSuccess
        });
        expect(poll.get('isCompleted')).to.equal(item.isCompleted);
      });

    });

  });

  describe('#showLink', function () {

    var cases = [
      {
        isPolling: true,
        isStarted: false,
        showLink: true,
        title: 'polling'
      },
      {
        isPolling: false,
        isStarted: true,
        showLink: true,
        title: 'started'
      },
      {
        isPolling: false,
        isStarted: false,
        showLink: false,
        title: 'not polling, not started'
      }
    ];

    cases.forEach(function (item) {

      it(item.title, function () {
        poll.setProperties({
          isPolling: item.isPolling,
          isStarted: item.isStarted
        });
        expect(poll.get('showLink')).to.equal(item.showLink);
      });

    });

  });

  describe('#start', function () {

    var cases = [
      {
        setRequestIdCallCount: 1,
        startPollingCallCount: 0,
        title: 'request id not defined'
      },
      {
        requestId: null,
        setRequestIdCallCount: 1,
        startPollingCallCount: 0,
        title: 'request id is null'
      },
      {
        requestId: 0,
        setRequestIdCallCount: 0,
        startPollingCallCount: 1,
        title: 'request id is zero'
      },
      {
        requestId: 1,
        setRequestIdCallCount: 0,
        startPollingCallCount: 1,
        title: 'request id is non-zero'
      }
    ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(poll, 'setRequestId', Em.K);
          sinon.stub(poll, 'startPolling', Em.K);
          poll.set('requestId', item.requestId);
          poll.start();
        });

        afterEach(function () {
          poll.setRequestId.restore();
          poll.startPolling.restore();
        });

        it('set request id', function () {
          expect(poll.setRequestId.callCount).to.equal(item.setRequestIdCallCount);
        });

        it('start polling', function () {
          expect(poll.startPolling.callCount).to.equal(item.startPollingCallCount);
        });

      });

    });

  });

  describe('#setRequestId', function () {

    var ajaxObj;

    beforeEach(function () {
      $.ajax.restore();
      sinon.stub($, 'ajax', function (obj) {
        return obj;
      });
    });

    it('AJAX request parameters', function () {
      var ajaxProps = {
        url: '/default',
        data: {}
      };
      poll.setProperties(ajaxProps);
      poll.setRequestId();
      ajaxObj = $.ajax.firstCall.args[0];
      expect(Em.Object.create(ajaxObj).getProperties(['url', 'data'])).to.eql(ajaxProps);
    });

    describe('#success', function () {

      var cases = [
        {
          data: undefined,
          isSuccess: true,
          isError: false,
          requestId: 1,
          doPollingCallCount: 0,
          title: 'data not defined'
        },
        {
          data: 'null',
          isSuccess: true,
          isError: false,
          requestId: 1,
          doPollingCallCount: 0,
          title: 'null data'
        },
        {
          data: '',
          isSuccess: true,
          isError: false,
          requestId: 1,
          doPollingCallCount: 0,
          title: 'empty data'
        },
        {
          data: '{}',
          isSuccess: false,
          isError: true,
          requestId: undefined,
          doPollingCallCount: 1,
          title: 'empty object'
        },
        {
          data: '{"Requests":null}',
          isSuccess: false,
          isError: true,
          requestId: null,
          doPollingCallCount: 1,
          title: 'no requests info'
        },
        {
          data: '{"Requests":{}}',
          isSuccess: false,
          isError: true,
          requestId: undefined,
          doPollingCallCount: 1,
          title: 'empty requests info'
        },
        {
          data: '{"Requests":{"name":"r0"}}',
          isSuccess: false,
          isError: true,
          requestId: undefined,
          doPollingCallCount: 1,
          title: 'no request id'
        },
        {
          data: '{"Requests":{"id":0}}',
          isSuccess: false,
          isError: true,
          requestId: 0,
          doPollingCallCount: 1,
          title: 'request id available'
        }
      ];

      cases.forEach(function (item) {

        describe(item.title, function () {

          var ajaxObject;

          beforeEach(function () {
            sinon.stub(poll, 'doPolling', Em.K);
            poll.setProperties({
              isSuccess: false,
              isError: true,
              requestId: 1
            });
            poll.setRequestId();
            ajaxObject = $.ajax.firstCall.args[0];
            ajaxObject.success(item.data);
          });

          afterEach(function () {
            poll.doPolling.restore();
          });

          it('isSuccess', function () {
            expect(poll.get('isSuccess')).to.equal(item.isSuccess);
          });

          it('isError', function () {
            expect(poll.get('isError')).to.equal(item.isError);
          });

          it('requestId', function () {
            expect(poll.get('requestId')).to.equal(item.requestId);
          });

          it('doPolling call', function () {
            expect(poll.doPolling.callCount).to.equal(item.doPollingCallCount);
          });

        });

      });

    });

    describe('#error', function () {

      beforeEach(function () {
        poll.setProperties({
          isSuccess: true,
          isError: false
        });
        poll.setRequestId();
        ajaxObj = $.ajax.firstCall.args[0];
        ajaxObj.error();
      });

      it('isSuccess', function () {
        expect(poll.get('isSuccess')).to.be.false;
      });

      it('isError', function () {
        expect(poll.get('isError')).to.be.true;
      });

    });

  });

  describe('#updateTaskLog', function () {

    beforeEach(function () {
      sinon.stub(poll, 'pollTaskLog', Em.K);
      poll.set('currentTaskId', 0);
      poll.updateTaskLog(1);
    });

    afterEach(function () {
      poll.pollTaskLog.restore();
    });

    it('should change task id', function () {
      expect(poll.get('currentTaskId')).to.equal(1);
    });

    it('should poll task log', function () {
      expect(poll.pollTaskLog.calledOnce).to.be.true;
    });

  });

  describe('#doPolling', function () {

    var cases = [
      {
        requestId: undefined,
        startPollingCallCount: 0,
        title: 'request id is undefined'
      },
      {
        requestId: null,
        startPollingCallCount: 0,
        title: 'request id is null'
      },
      {
        requestId: 0,
        startPollingCallCount: 1,
        title: 'request id is 0'
      },
      {
        requestId: 1,
        startPollingCallCount: 1,
        title: 'request id is gra than 0'
      }
    ];

    beforeEach(function () {
      sinon.stub(poll, 'startPolling', Em.K);
    });

    afterEach(function () {
      poll.startPolling.restore();
    });

    cases.forEach(function (item) {

      it(item.title, function () {
        poll.set('requestId', item.requestId);
        poll.doPolling();
        expect(poll.startPolling.callCount).to.equal(item.startPollingCallCount);
      });

    });

  });

  describe('#pollTaskLog', function () {

    var cases = [
      {
        currentTaskId: undefined,
        ajaxCallArguments: undefined,
        title: 'current task id is undefined'
      },
      {
        currentTaskId: null,
        ajaxCallArguments: undefined,
        title: 'current task id is null'
      },
      {
        currentTaskId: 0,
        ajaxCallArguments: [{
          name: 'background_operations.get_by_task',
          data: {
            requestId: 0,
            taskId: 0
          },
          success: 'pollTaskLogSuccessCallback'
        }],
        title: 'current task id is 0'
      },
      {
        currentTaskId: 1,
        ajaxCallArguments: [{
          name: 'background_operations.get_by_task',
          data: {
            requestId: 0,
            taskId: 1
          },
          success: 'pollTaskLogSuccessCallback'
        }],
        title: 'current task id is more than 0'
      }
    ];

    cases.forEach(function (item) {

      it(item.title, function () {
        poll.setProperties({
          requestId: 0,
          currentTaskId: item.currentTaskId
        });
        poll.pollTaskLog();
        if (item.ajaxCallArguments) {
          item.ajaxCallArguments[0].sender = poll;
        }
        expect(testHelpers.findAjaxRequest('name', 'background_operations.get_by_task')).to.eql(item.ajaxCallArguments);
      });

    });

  });

  describe('#pollTaskLogSuccessCallback', function () {

    it('polled data', function () {
      poll.set('polledData', [
        {
          Tasks: {
            id: 0
          }
        },
        {
          Tasks: {
            id: 1
          }
        },
        {
          Tasks: {
            id: 2
          }
        }
      ]);
      poll.pollTaskLogSuccessCallback({
        Tasks: {
          id: 1,
          stdout: 'stdout',
          stderr: 'stderr'
        }
      });
      expect(poll.get('polledData').toArray()).to.eql([
        {
          Tasks: {
            id: 0
          }
        },
        {
          Tasks: {
            id: 1,
            stdout: 'stdout',
            stderr: 'stderr'
          }
        },
        {
          Tasks: {
            id: 2
          }
        }
      ]);
    });

  });

  describe('#startPolling', function () {

    var cases = [
      {
        requestId: undefined,
        ajaxCallArguments: undefined,
        result: false,
        pollTaskLogCallCount: 0,
        title: 'request id is undefined'
      },
      {
        requestId: null,
        ajaxCallArguments: undefined,
        result: false,
        pollTaskLogCallCount: 0,
        title: 'request id is null'
      },
      {
        requestId: 0,
        ajaxCallArguments: [{
          name: 'background_operations.get_by_request',
          data: {
            requestId: 0
          },
          success: 'reloadSuccessCallback',
          error: 'reloadErrorCallback'
        }],
        result: true,
        pollTaskLogCallCount: 1,
        title: 'request id is 0'
      },
      {
        requestId: 1,
        ajaxCallArguments: [{
          name: 'background_operations.get_by_request',
          data: {
            requestId: 1
          },
          success: 'reloadSuccessCallback',
          error: 'reloadErrorCallback'
        }],
        result: true,
        pollTaskLogCallCount: 1,
        title: 'request id is more than 0'
      }
    ];

    cases.forEach(function (item) {

      var result;

      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(poll, 'pollTaskLog', Em.K);
          poll.set('requestId', item.requestId);
          result = poll.startPolling();
          if (item.ajaxCallArguments) {
            item.ajaxCallArguments[0].sender = poll;
            item.ajaxCallArguments[0].data.callback = poll.startPolling;
          }
        });

        afterEach(function () {
          poll.pollTaskLog.restore();
        });

        it('AJAX request', function () {
          expect(testHelpers.findAjaxRequest('name', 'background_operations.get_by_request')).to.eql(item.ajaxCallArguments);
        });

        it('result', function () {
          expect(result).to.equal(item.result);
        });

        it('pollTaskLog', function () {
          expect(poll.pollTaskLog.callCount).to.equal(item.pollTaskLogCallCount);
        });

      });

    });

  });

  describe('#reloadErrorCallback', function () {

    var cases = [
      {
        status: undefined,
        isSuccess: false,
        isError: false,
        title: 'status is undefined'
      },
      {
        status: null,
        isSuccess: false,
        isError: false,
        title: 'status is null'
      },
      {
        status: 0,
        isSuccess: false,
        isError: false,
        title: 'status is 0'
      },
      {
        status: 200,
        isSuccess: true,
        isError: false,
        title: 'success'
      },
      {
        status: 404,
        isSuccess: false,
        isError: true,
        title: 'error'
      }
    ];

    cases.forEach(function (item) {

      it(item.title, function () {
        poll.setProperties({
          isSuccess: item.isSuccess,
          isError: false
        });
        poll.reloadErrorCallback({
          status: item.status
        }, null, null, null, {});
        expect(poll.get('isError')).to.equal(item.isError);
      });

    });

  });

  describe('#replacePolledData', function () {

    var cases = [
      {
        currentTaskId: undefined,
        data: [],
        result: [],
        title: 'current task id is undefined'
      },
      {
        currentTaskId: null,
        data: [],
        result: [],
        title: 'current task id is null'
      },
      {
        currentTaskId: 0,
        polledData: [
          {
            Tasks: {
              id: 0
            }
          },
          {
            Tasks: {
              id: 1
            }
          }
        ],
        data: [
          {
            Tasks: {
              id: 1
            }
          }
        ],
        result: [
          {
            Tasks: {
              id: 1
            }
          }
        ],
        title: 'current task id is 0, no corresponding task passed'
      },
      {
        currentTaskId: 1,
        polledData: [
          {
            Tasks: {
              id: 0
            }
          }
        ],
        data: [
          {
            Tasks: {
              id: 0
            }
          },
          {
            Tasks: {
              id: 1
            }
          }
        ],
        result: [
          {
            Tasks: {
              id: 0
            }
          },
          {
            Tasks: {
              id: 1
            }
          }
        ],
        title: 'current task id is more than 0, no corresponding task set'
      },
      {
        currentTaskId: 2,
        polledData: [
          {
            Tasks: {
              id: 0
            }
          },
          {
            Tasks: {
              id: 2,
              stdout: 'stdout',
              stderr: 'stderr'
            }
          }
        ],
        data: [
          {
            Tasks: {
              id: 0
            }
          },
          {
            Tasks: {
              id: 2
            }
          },
          {
            Tasks: {
              id: 3
            }
          }
        ],
        result: [
          {
            Tasks: {
              id: 0
            }
          },
          {
            Tasks: {
              id: 2,
              stdout: 'stdout',
              stderr: 'stderr'
            }
          },
          {
            Tasks: {
              id: 3
            }
          }
        ],
        title: 'current task id is more than 0, corresponding task set and passed'
      },
      {
        currentTaskId: 3,
        polledData: [
          {
            Tasks: {
              id: 0
            }
          }
        ],
        data: [
          {
            Tasks: {
              id: 1
            }
          }
        ],
        result: [
          {
            Tasks: {
              id: 1
            }
          }
        ],
        title: 'current task id is more than 0, corresponding task neither set nor passed'
      }
    ];

    cases.forEach(function (item) {

      it(item.title, function () {
        poll.setProperties({
          currentTaskId: item.currentTaskId,
          polledData: item.polledData || null
        });
        poll.replacePolledData(item.data);
        expect(poll.get('polledData').toArray()).to.eql(item.result);
      });

    });

  });

  describe('#calculateProgressByTasks', function () {

    var cases = [
      {
        tasksData: [
          {
            Tasks: {
              status: 'QUEUED'
            }
          },
          {
            Tasks: {
              status: 'QUEUED'
            }
          }
        ],
        result: 9,
        title: 'all tasks pending'
      },
      {
        tasksData: [
          {
            Tasks: {
              status: 'IN_PROGRESS'
            }
          },
          {
            Tasks: {
              status: 'IN_PROGRESS'
            }
          }
        ],
        result: 35,
        title: 'all tasks in progress'
      },
      {
        tasksData: [
          {
            Tasks: {
              status: 'COMPLETED'
            }
          },
          {
            Tasks: {
              status: 'COMPLETED'
            }
          }
        ],
        result: 100,
        title: 'all tasks completed'
      },
      {
        tasksData: [
          {
            Tasks: {
              status: 'FAILED'
            }
          },
          {
            Tasks: {
              status: 'FAILED'
            }
          }
        ],
        result: 100,
        title: 'all tasks failed'
      },
      {
        tasksData: [
          {
            Tasks: {
              status: 'ABORTED'
            }
          },
          {
            Tasks: {
              status: 'ABORTED'
            }
          }
        ],
        result: 100,
        title: 'all tasks aborted'
      },
      {
        tasksData: [
          {
            Tasks: {
              status: 'TIMEDOUT'
            }
          },
          {
            Tasks: {
              status: 'TIMEDOUT'
            }
          }
        ],
        result: 100,
        title: 'all tasks timed out'
      },
      {
        tasksData: [
          {
            Tasks: {
              status: 'QUEUED'
            }
          },
          {
            Tasks: {
              status: 'COMPLETED'
            }
          }
        ],
        result: 55,
        title: 'pending and finished tasks'
      },
      {
        tasksData: [
          {
            Tasks: {
              status: 'IN_PROGRESS'
            }
          },
          {
            Tasks: {
              status: 'FAILED'
            }
          }
        ],
        result: 68,
        title: 'running and finished tasks'
      },
      {
        tasksData: [
          {
            Tasks: {
              status: 'IN_PROGRESS'
            }
          },
          {
            Tasks: {
              status: 'QUEUED'
            }
          }
        ],
        result: 22,
        title: 'running and pending tasks'
      },
      {
        tasksData: [
          {
            Tasks: {
              status: 'IN_PROGRESS'
            }
          },
          {
            Tasks: {
              status: 'QUEUED'
            }
          },
          {
            Tasks: {
              status: 'ABORTED'
            }
          }
        ],
        result: 48,
        title: 'running, pending and finished tasks'
      }
    ];

    cases.forEach(function (item) {

      it(item.title, function () {
        expect(poll.calculateProgressByTasks(item.tasksData)).to.equal(item.result);
      });

    });

  });

  describe('#isPollingFinished', function () {

    var cases = [
      {
        polledData: [
          {
            Tasks: {
              status: 'QUEUED'
            }
          },
          {
            Tasks: {
              status: 'COMPLETED'
            }
          }
        ],
        isPollingFinished: false,
        isSuccess: false,
        isError: false,
        title: 'some queued tasks'
      },
      {
        polledData: [
          {
            Tasks: {
              status: 'IN_PROGRESS'
            }
          },
          {
            Tasks: {
              status: 'COMPLETED'
            }
          }
        ],
        isPollingFinished: false,
        isSuccess: false,
        isError: false,
        title: 'some running tasks'
      },
      {
        polledData: [
          {
            Tasks: {
              status: 'PENDING'
            }
          },
          {
            Tasks: {
              status: 'COMPLETED'
            }
          }
        ],
        isPollingFinished: false,
        isSuccess: false,
        isError: false,
        title: 'some pending tasks'
      },
      {
        polledData: [
          {
            Tasks: {
              status: 'FAILED'
            }
          },
          {
            Tasks: {
              status: 'COMPLETED'
            }
          }
        ],
        isPollingFinished: true,
        isSuccess: false,
        isError: true,
        title: 'all tasks finished, some failed'
      },
      {
        polledData: [
          {
            Tasks: {
              status: 'ABORTED'
            }
          },
          {
            Tasks: {
              status: 'COMPLETED'
            }
          }
        ],
        isPollingFinished: true,
        isSuccess: false,
        isError: true,
        title: 'all tasks finished, some aborted'
      },
      {
        polledData: [
          {
            Tasks: {
              status: 'ABORTED'
            }
          },
          {
            Tasks: {
              status: 'COMPLETED'
            }
          }
        ],
        isPollingFinished: true,
        isSuccess: false,
        isError: true,
        title: 'all tasks finished, some timed out'
      },
      {
        polledData: [
          {
            Tasks: {
              status: 'COMPLETED'
            }
          },
          {
            Tasks: {
              status: 'COMPLETED'
            }
          }
        ],
        isPollingFinished: true,
        isSuccess: true,
        isError: false,
        title: 'all tasks finished successfully'
      }
    ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        var result;

        beforeEach(function () {
          poll.setProperties({
            isSuccess: false,
            isError: false
          });
          result = poll.isPollingFinished(item.polledData);
        });

        it('isPollingFinished', function () {
          expect(result).to.equal(item.isPollingFinished);
        });

        it('isSuccess', function () {
          expect(poll.get('isSuccess')).to.equal(item.isSuccess);
        });

        it('isError', function () {
          expect(poll.get('isError')).to.equal(item.isError);
        });

      });

    });

  });

  describe('#parseInfo', function () {

    var cases = [
      {
        polledData: {
          Requests: {
            id: 1
          }
        },
        replacePolledDataCallCount: 0,
        progress: '0',
        result: false,
        title: 'no corresponding request data'
      },
      {
        polledData: {
          tasks: []
        },
        replacePolledDataCallCount: 1,
        progress: '100',
        result: false,
        title: 'no request id info'
      },
      {
        polledData: {
          Requests: {
            id: 0
          },
          tasks: []
        },
        replacePolledDataCallCount: 1,
        progress: '100',
        result: false,
        title: 'no tasks'
      },
      {
        polledData: {
          Requests: {
            id: 0
          },
          tasks: [
            {
              Tasks: {
                status: 'PENDING'
              }
            },
            {
              Tasks: {
                status: 'COMPLETED'
              }
            }
          ]
        },
        replacePolledDataCallCount: 1,
        progress: '100',
        result: false,
        title: 'not all tasks finished'
      },
      {
        polledData: {
          Requests: {
            id: 0
          },
          tasks: [
            {
              Tasks: {
                status: 'FAILED'
              }
            },
            {
              Tasks: {
                status: 'COMPLETED'
              }
            }
          ]
        },
        replacePolledDataCallCount: 1,
        progress: '100',
        result: true,
        title: 'all tasks finished'
      }
    ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        var result;

        beforeEach(function () {
          sinon.stub(poll, 'replacePolledData', Em.K);
          sinon.stub(poll, 'calculateProgressByTasks').returns(100);
          sinon.stub(poll, 'isPollingFinished', function (data) {
            return data.length > 0 && !(data.someProperty('Tasks.status', 'QUEUED') || data.someProperty('Tasks.status', 'IN_PROGRESS')
              || data.someProperty('Tasks.status', 'PENDING'));
          });
          poll.setProperties({
            requestId: 0,
            progress: '0'
          });
          result = poll.parseInfo(item.polledData);
        });

        afterEach(function () {
          poll.replacePolledData.restore();
          poll.calculateProgressByTasks.restore();
          poll.isPollingFinished.restore();
        });

        it('replacePolledData call', function () {
          expect(poll.replacePolledData.callCount).to.equal(item.replacePolledDataCallCount);
        });

        if (item.replacePolledDataCallCount) {
          it('replacePolledData argument', function () {
            expect(poll.replacePolledData.firstCall.args).to.eql([item.polledData.tasks]);
          });
        }

        it('progress', function () {
          expect(poll.get('progress')).to.equal(item.progress);
        });

        it('result', function () {
          expect(result).to.equal(item.result);
        });

      });

    });

  });

});

});

require.register("test/utils/string_utils_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var stringUtils = require('utils/string_utils');
require('utils/helper');

describe('stringUtils', function () {

  describe('#underScoreToCamelCase', function () {
    var tests = [
      {m:'a_b_c to aBC',i:'a_b_c',e:'aBC'},
      {m:'a_bc to aBc',i:'a_bc',e:'aBc'},
      {m:'ab_c to abC',i:'ab_c',e:'abC'},
      {m:'_b_c to BC',i:'_b_c',e:'BC'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(stringUtils.underScoreToCamelCase(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#pad', function () {
    var tests = [
      {m: '"name" to "    name"', i: 'name', l: 8, a: 1, f: ' ', e: '    name'},
      {m: '"name" to "name    "', i: 'name', l: 8, a: 2, f: ' ', e: 'name    '},
      {m: '"name" to "  name  "', i: 'name', l: 8, a: 3, f: ' ', e: '  name  '},
      {m: '"name" to "name    "', i: 'name', l: 8, a: 0, f: ' ', e: 'name    '},
      {m: '"name" to "name    "', i: 'name', l: 8, a:-1, f: ' ', e: 'name    '},
      {m: '"name" to "name"', i: 'name', l: 4, a: 1, f: ' ', e: 'name'},
      {m: '"name" to "||||||||name"', i: 'name', l: 8, a:1, f: '||', e: '||||||||name'},
      {m: '"name" to "||||name||||"', i: 'name', l: 8, a:3, f: '||', e: '||||name||||'},
      {m: '"name" to "name||||||||"', i: 'name', l: 8, a:2, f: '||', e: 'name||||||||'},
      {m: '"name" to "name" `str` param passed only', i: 'name', e: 'name'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(stringUtils.pad(test.i, test.l, test.f, test.a)).to.equal(test.e);
      });
    });
  });

  describe('#compareVersions', function () {
    var tests = [
      {m: '1.2 equal to 1.2', v1:'1.2', v2:'1.2', e: 0},
      {m: '1.2 lower than 1.3', v1:'1.2', v2:'1.3', e: -1},
      {m: '1.3 higher than 1.2', v1:'1.3', v2:'1.2', e: 1},
      {m: '1.2.1 higher than 1.2', v1:'1.2.1', v2:'1.2', e: 1},
      {m: '11.2 higher than 2.2', v1:'11.2', v2:'2.2', e: 1},
      {m: '0.9 higher than 0.8', v1:'0.9', v2:'0.8', e: 1},
      {m: '1.1-2  equal to 1.1-2 ', v1:'1.1-2', v2:'1.1-2', e: 0},
      {m: '1.1-2 higher than 1.1-1', v1:'1.1-2', v2:'1.1-1', e: 1},
      {m: '1.1-4 lower than 1.1-46', v1:'1.1-4', v2:'1.1-46', e: -1},
      {m: 'return false if no string passed', v1: '0.9', e: -1}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(stringUtils.compareVersions(test.v1, test.v2)).to.equal(test.e);
      });
    });
  });

  describe('#isSingleLine', function () {
    var tests = [
      {m: 'is single line text', t: 'a b', e: true},
      {m: 'is single line text', t: 'a b\n', e: true},
      {m: 'is single line text', t: '\na b', e: true},
      {m: 'is not single line text', t: 'a\nb', e: false}
    ];
    tests.forEach(function(test) {
      it(test.t + ' ' + test.m + ' ', function () {
        expect(stringUtils.isSingleLine(test.t)).to.equal(test.e);
      });
    });
  });

  describe('#arrayToCSV', function() {
    var test = [{a: 1, b:2, c:3}, {a: 1, b:2, c:3}, {a: 1, b:2, c:3}];
    it('array of object to csv-string', function () {
      expect(stringUtils.arrayToCSV(test)).to.equal("1,2,3\n1,2,3\n1,2,3\n");
    });
  });

  describe('#getFileFromPath', function() {
    var tests = [
      {t: undefined, e: ''},
      {t: {}, e: ''},
      {t: [], e: ''},
      {t: '', e: ''},
      {t: function(){}, e: ''},
      {t: '/path/to/file.ext', e: 'file.ext'},
      {t: 'file.ext', e: 'file.ext'},
      {t: 'file', e: 'file'},
      {t: '/path/to/file', e: 'file'}
    ];
    tests.forEach(function(test) {
      it('Check ' + typeof test.t, function () {
        expect(stringUtils.getFileFromPath(test.t)).to.equal(test.e);
      });
    });
  });

  describe('#getPath', function() {
      var tests = [
        {t: undefined, e: ''},
        {t: {}, e: ''},
        {t: [], e: ''},
        {t: '', e: ''},
        {t: function(){}, e: ''},
        {t: '/path/to/filename', e: '/path/to'},
        {t: '/path/to/', e: '/path/to'},
        {t: '/filename', e: '/'},
        {t: 'filename', e: ''},
        {t: '/path/', e: '/path'},
        {t: 'filename/', e: ''}
      ];
      tests.forEach(function(test) {
          it('Check ' + typeof test.t, function () {
            expect(stringUtils.getPath(test.t)).to.equal(test.e);
          });
      });
  });

  describe('#getCamelCase', function () {
    var tests = [
      {i:'a',e:'A'},
      {i:'aB',e:'Ab'},
      {i:'a b',e:'A B'},
      {i:'a.b',e:'A.B'},
      {i:'a,b',e:'A,B'},
      {i:'a;b',e:'A;B'},
      {i:'a. b',e:'A. B'},
      {i:'a   b',e:'A   B'},
      {i:'aaa. bbb',e:'Aaa. Bbb'},
      {i:'aAA. bBB',e:'Aaa. Bbb'},
      {i:'STARTING',e:'Starting'},
      {i:'starting',e:'Starting'},
      {i:'starting,ending',e:'Starting,Ending'},
      {i: null, e: null},
      {i: undefined, e: undefined}
    ];
    tests.forEach(function(test) {
      it(test.i + ' to ' + test.e + ' ', function () {
        expect(stringUtils.getCamelCase(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#findIn', function () {
    var tests = [
      {
        obj: {
          a: '1',
          b: '2'
        },
        key: 'a',
        index: 0,
        e: '1'
      }, {
        obj: {
          a: '1',
          b: '2'
        },
        key: 'a',
        index: 1,
        e: null
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: '12'
          }
        },
        key: 'a',
        index: 1,
        e: '11'
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: {
              a: '22'
            }
          }
        },
        key: 'a',
        index: 2,
        e: '22'
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: {
              a: '22'
            }
          }
        },
        key: 'a',
        index: 0,
        e: '1'
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: {
              a: '22'
            }
          }
        },
        key: 'g',
        index: 0,
        e: null
      }
    ];
    tests.forEach(function(test) {
      it(test.key + ' @ ' + test.index + ' = ' + test.e, function () {
        expect(test.key.findIn(test.obj, test.index)).to.equal(test.e);
      });
    });
  });

  describe("#htmlEntities()", function() {
    var tests = [
      {t: undefined, e: ''},
      {t: '', e: ''},
      {t: 'abc', e: 'abc'},
      {t: 'abc<script>abc', e: 'abc&lt;script&gt;abc'}
    ];
    tests.forEach(function(test) {
      it('Check ' + typeof test.t, function () {
        expect(stringUtils.htmlEntities(test.t)).to.equal(test.e);
      });
    });
  });
});

});

require.register("test/utils/ui_effects_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var uiUtils = require('utils/ui_effects');

describe('utils/ui_effects', function(){
  describe('#pulsate()', function(){
    beforeEach(function(){
      $('body').append('<div id="pulsate-test-dom"></div>');
      this.clock = sinon.useFakeTimers();
      this.clb = Em.K;
      sinon.spy(this, 'clb');
    });

    afterEach(function () {
      this.clb.restore();
    });

    it('opacity should be 0.2 on 5-th iteration', function() {
      var domEl = $('#pulsate-test-dom');
      uiUtils.pulsate(domEl, 1000);
      this.clock.tick(300);
      expect(parseFloat(domEl.css('opacity')).toFixed(1)).to.be.equal('0.2');
    });
    it('should call callback at the end', function() {
      var domEl = $('#pulsate-test-dom');
      uiUtils.pulsate(domEl, 1000, this.clb);
      this.clock.tick(2000);
      expect(this.clb.calledOnce).to.be.ok;
    });

    afterEach(function(){
      $('#pulsate-test-dom').remove();
      this.clock.restore();
    });
  });
});

});

require.register("test/utils/updater_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/updater');
describe('utils/updater', function () {
  beforeEach(function () {
    this.clock = sinon.useFakeTimers();
    sinon.stub(App.router, "get").returns('test');
    App.updater.run.restore();
    sinon.spy(App.updater, 'run');
    App.updater.immediateRun.restore();
    sinon.spy(App.updater, 'immediateRun');
  });

  var tests = {
    t1: {
      obj: Em.Object.create({
        method: sinon.spy(),
        isWorking: true
      }),
      m: 'method called once with default interval in 15 000 ms'
    },
    t2: {
      obj: Em.Object.create({
        method: function () {
        }
      }),
      m: 'should return false if key name is invalid or absent'
    },
    t3: {
      obj: Em.Object.create({
        method2: sinon.spy(),
        isWorking: true
      }),
      m: 'method should be called immediately'
    },
    t4: {
      obj: Em.Object.create({
        method3: sinon.spy(),
        isWorking: true
      }),
      m: 'method call should be ignored if `isWorking` set to false'
    },
    t5: {
      obj: Em.Object.create({
        method4: sinon.spy(),
        isWorking: true
      }),
      m: 'method call should be ignored if urlPattern is not matching router location'
    }
  };

  it(tests.t1.m, function () {
    App.updater.run(tests.t1.obj, 'method', 'isWorking');
    this.clock.tick(3600000 * 1.5);
    expect(tests.t1.obj.method.called).to.be.ok;
  });

  it(tests.t2.m, function () {
    var methodCall = App.updater.run(tests.t2.obj, 'method', 'isWorking');
    expect(methodCall).to.be.false;
  });

  it(tests.t3.m, function () {
    App.updater.run(tests.t3.obj, 'method2', 'isWorking');
    App.updater.immediateRun('method2');
    expect(tests.t3.obj.method2.called).to.be.ok;
  });

  it(tests.t4.m, function () {
    App.updater.run(tests.t4.obj, 'method3', 'isWorking');
    this.clock.tick(10000);
    tests.t4.obj.set('isWorking', false);
    this.clock.tick(5000);
    expect(tests.t4.obj.method3.called).to.be.false;
  });

  it(tests.t5.m, function () {
    App.updater.run(tests.t5.obj, 'method4', 'isWorking', 15000, 'pattern');
    this.clock.tick(15000);
    expect(tests.t5.obj.method4.called).to.be.false;
  });

  afterEach(function () {
    this.clock.restore();
    App.router.get.restore();
  });
});
});

require.register("test/utils/validator_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var validator = require('utils/validator');

describe('validator', function () {

  describe('#isValidEmail(value)', function () {
    it('should return false if value is null', function () {
      expect(validator.isValidEmail(null)).to.equal(false);
    });
    it('should return false if value is ""', function () {
      expect(validator.isValidEmail('')).to.equal(false);
    });
    it('should return false if value is "a.com"', function () {
      expect(validator.isValidEmail('a.com')).to.equal(false);
    });
    it('should return false if value is "@a.com"', function () {
      expect(validator.isValidEmail('@a.com')).to.equal(false);
    });
    it('should return false if value is "a@.com"', function () {
      expect(validator.isValidEmail('a@.com')).to.equal(false);
    });
    it('should return true if value is "a@a.com"', function () {
      expect(validator.isValidEmail('a@a.com')).to.equal(true);
    });
    it('should return true if value is "user@a.b.com"', function () {
      expect(validator.isValidEmail('user@a.b.com')).to.equal(true);
    })
  });

  describe('#isValidInt(value)', function () {
    it('should return false if value is null', function () {
      expect(validator.isValidInt(null)).to.equal(false);
    });
    it('should return false if value is ""', function () {
      expect(validator.isValidInt('')).to.equal(false);
    });
    it('should return false if value is "abc"', function () {
      expect(validator.isValidInt('abc')).to.equal(false);
    });
    it('should return false if value is "0xff"', function () {
      expect(validator.isValidInt('0xff')).to.equal(false);
    });
    it('should return false if value is " 1""', function () {
      expect(validator.isValidInt(' 1')).to.equal(false);
    });
    it('should return false if value is "1 "', function () {
      expect(validator.isValidInt('1 ')).to.equal(false);
    });
    it('should return true if value is "10"', function () {
      expect(validator.isValidInt('10')).to.equal(true);
    });
    it('should return true if value is "-123"', function () {
      expect(validator.isValidInt('-123')).to.equal(true);
    });
    it('should return true if value is "0"', function () {
      expect(validator.isValidInt('0')).to.equal(true);
    });
    it('should return true if value is 10', function () {
      expect(validator.isValidInt(10)).to.equal(true);
    });
    it('should return true if value is -123', function () {
      expect(validator.isValidInt(10)).to.equal(true);
    });
    it('should return true if value is 0', function () {
      expect(validator.isValidInt(10)).to.equal(true);
    })
  });

  describe('#isValidFloat(value)', function () {
    it('should return false if value is null', function () {
      expect(validator.isValidFloat(null)).to.equal(false);
    });
    it('should return false if value is ""', function () {
      expect(validator.isValidFloat('')).to.equal(false);
    });
    it('should return false if value is "abc"', function () {
      expect(validator.isValidFloat('abc')).to.equal(false);
    });
    it('should return false if value is "0xff"', function () {
      expect(validator.isValidFloat('0xff')).to.equal(false);
    });
    it('should return false if value is " 1""', function () {
      expect(validator.isValidFloat(' 1')).to.equal(false);
    });
    it('should return false if value is "1 "', function () {
      expect(validator.isValidFloat('1 ')).to.equal(false);
    });
    it('should return true if value is "10"', function () {
      expect(validator.isValidFloat('10')).to.equal(true);
    });
    it('should return true if value is "-123"', function () {
      expect(validator.isValidFloat('-123')).to.equal(true);
    });
    it('should return true if value is "0"', function () {
      expect(validator.isValidFloat('0')).to.equal(true);
    });
    it('should return true if value is 10', function () {
      expect(validator.isValidFloat(10)).to.equal(true);
    });
    it('should return true if value is -123', function () {
      expect(validator.isValidFloat(10)).to.equal(true);
    });
    it('should return true if value is 0', function () {
      expect(validator.isValidFloat(10)).to.equal(true);
    });
    it('should return true if value is "0.0"', function () {
      expect(validator.isValidFloat("0.0")).to.equal(true);
    });
    it('should return true if value is "10.123"', function () {
      expect(validator.isValidFloat("10.123")).to.equal(true);
    });
    it('should return true if value is "-10.123"', function () {
      expect(validator.isValidFloat("-10.123")).to.equal(true);
    });
    it('should return true if value is 10.123', function () {
      expect(validator.isValidFloat(10.123)).to.equal(true);
    });
    it('should return true if value is -10.123', function () {
      expect(validator.isValidFloat(-10.123)).to.equal(true);
    })

  });
  describe('#isIpAddress(value)', function () {
    it('"127.0.0.1" - valid IP', function () {
      expect(validator.isIpAddress('127.0.0.1')).to.equal(true);
    })
    it('"227.3.67.196" - valid IP', function () {
      expect(validator.isIpAddress('227.3.67.196')).to.equal(true);
    })
    it('"327.0.0.0" - invalid IP', function () {
      expect(validator.isIpAddress('327.0.0.0')).to.equal(false);
    })
    it('"127.0.0." - invalid IP', function () {
      expect(validator.isIpAddress('127.0.0.')).to.equal(false);
    })
    it('"127.0." - invalid IP', function () {
      expect(validator.isIpAddress('127.0.')).to.equal(false);
    })
    it('"127" - invalid IP', function () {
      expect(validator.isIpAddress('127')).to.equal(false);
    })
    it('"127.333.0.1" - invalid IP', function () {
      expect(validator.isIpAddress('127.333.0.1')).to.equal(false);
    })
    it('"127.0.333.1" - invalid IP', function () {
      expect(validator.isIpAddress('127.0.333.1')).to.equal(false);
    })
    it('"127.0.1.333" - invalid IP', function () {
      expect(validator.isIpAddress('127.0.1.333')).to.equal(false);
    })
    it('"127.0.0.0:45555" - valid IP', function () {
      expect(validator.isIpAddress('127.0.0.0:45555')).to.equal(true);
    })
    it('"327.0.0.0:45555" - invalid IP', function () {
      expect(validator.isIpAddress('327.0.0.0:45555')).to.equal(false);
    })
  });

  describe('#isDomainName(value)', function () {
    it('"google.com" - valid Domain Name', function () {
      expect(validator.isDomainName('google.com')).to.equal(true);
    });
    it('"google" - invalid Domain Name', function () {
      expect(validator.isDomainName('google')).to.equal(false);
    });
    it('"123.123" - invalid Domain Name', function () {
      expect(validator.isDomainName('123.123')).to.equal(false);
    });
    it('"4goog.le" - valid Domain Name', function () {
      expect(validator.isDomainName('4goog.le')).to.equal(true);
    });
    it('"55454" - invalid Domain Name', function () {
      expect(validator.isDomainName('55454')).to.equal(false);
    })
  });

  describe('#hasSpaces()', function(){
    var testable = [
      { str: ' hello', detect: true },
      { str: 'hello world', detect: true },
      { str: 'hello ', detect: true },
      { str: 'hello', detect: false }
    ];
    testable.forEach(function(value){
      it('should ' + (value.detect ? '' : 'not') + ' detects spaces in `' + value.str + '`', function(){
        expect(validator.hasSpaces(value.str)).to.eql(value.detect);
      });
    });
  });
  describe('#isNotTrimmed', function(){
    var testable = [
      { str: ' hello world', detect: true },
      { str: ' hello world ', detect: true },
      { str: 'hello world ', detect: true },
      { str: 'hello world', detect: false },
      { str: 'hello world !', detect: false }
    ];
    testable.forEach(function(value){
      it('should ' + (value.detect ? '' : 'not') + 'trimmed string', function() {
        expect(validator.isNotTrimmed(value.str)).to.eql(value.detect);
      });
    });
  });
  describe('#empty()', function(){
    var testable = [
      { obj: "", detect: true },
      { obj: 0, detect: true },
      { obj: "0", detect: true },
      { obj: null, detect: true },
      { obj: undefined, detect: true },
      { obj: 'hello', detect: false },
      { obj: {}, detect: false },
      { obj: [], detect: false },
      { obj: ['a'], detect: false },
      { obj: 1, detect: false },
      { obj: true, detect: false }
    ];
    testable.forEach(function(value) {
      var detect = value.detect ? '' : 'not';
      it('should {0} detect empty value in `{1}`'.format(detect, JSON.stringify(value.obj)), function() {
        expect(validator.empty(value.obj)).to.eql(value.detect);
      });
    });
  });
  describe('#isValidUserName(value)', function() {
    var tests = [
      {m:'"" - invalid',i:'',e:false},
      {m:'"abc123" - valid',i:'abc123',e:true},
      {m:'"1abc123" - invalid',i:'1abc123',e:false},
      {m:'"abc123$" - invalid',i:'abc123$',e:false},
      {m:'"~1abc123" - invalid',i: '~1abc123',e:false},
      {m:'"abc12345679abc1234567890abc1234567890$" - invalid',i:'abc12345679abc1234567890abc1234567890$',e:false},
      {m:'"1abc123$$" - invalid',i:'1abc123$$',e:false},
      {m:'"a" - valid',i:'a',e:true},
      {m:'"!" - invalid',i:'!',e:false},
      {m:'"root$" - invalid',i:'root$',e:false},
      {m:'"rootU" - invalid',i:'rootU',e:false},
      {m:'"rUoot" - invalid',i:'rUoot',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidUserName(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isValidUNIXUser(value)', function() {
    var tests = [
      {m:'"" - invalid',i:'',e:false},
      {m:'"abc123" - valid',i:'abc123',e:true},
      {m:'"1abc123" - invalid',i:'1abc123',e:false},
      {m:'"abc123$" - invalid',i:'abc123$',e:false},
      {m:'"~1abc123" - invalid',i: '~1abc123',e:false},
      {m:'"abc12345679abc1234567890abc1234567890$" - invalid',i:'abc12345679abc1234567890abc1234567890$',e:false},
      {m:'"1abc123$$" - invalid',i:'1abc123$$',e:false},
      {m:'"a" - valid',i:'a',e:true},
      {m:'"!" - invalid',i:'!',e:false},
      {m:'"abc_" - valid',i:'abc_',e:true},
      {m:'"_abc" - valid',i:'_abc',e:true},
      {m:'"abc_abc" - valid',i:'_abc',e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidUNIXUser(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isValidDir(value)', function() {
    var tests = [
      {m:'"dir" - invalid',i:'dir',e:false},
      {m:'" /dir" - invalid',i:' /dir',e:false},
      {m:'"/dir" - valid',i:'/dir',e:true},
      {m:'"/dir1,dir2" - invalid',i:'/dir1,dir2',e:false},
      {m:'"/dir1, /dir2" - invalid',i:'/dir1,dir2',e:false},
      {m:'"/dir1,/dir2" - valid',i:'/dir1,/dir2',e:true},
      {m:'"/123" - valid',i:'/111',e:true},
      {m:'"/abc" - valid',i:'/abc',e:true},
      {m:'"/1a2b3c" - valid',i:'/1a2b3c',e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidDir(test.i)).to.equal(test.e);
      })
    });
  });

  describe('#isConfigValueLink', function() {
    var tests = [
      {m:'link valid',i:'${asd}',e:true},
      {m:'empty link ${} -invalid',i:'${}',e:false},
      {m:'${ just wrong',i:'${',e:false},
      {m:'anything  just wrong',i:'anything',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isConfigValueLink(test.i)).to.equal(test.e);
      })
    });
  });

  describe('#isValidDataNodeDir(value)', function() {
    var tests = [
      {m:'"dir" - invalid',i:'dir',e:false},
      {m:'"/dir" - valid',i:'/dir',e:true},
      {m:'"/dir1,dir2" - invalid',i:'/dir1,dir2',e:false},
      {m:'"/dir1,/dir2" - valid',i:'/dir1,/dir2',e:true},
      {m:'" /dir1,/dir2" - valid',i:' /dir1,/dir2',e:false},
      {m:'"/dir1, /dir2" - valid',i:' /dir1,/dir2',e:false},
      {m:'"/123" - valid',i:'/111',e:true},
      {m:'"/abc" - valid',i:'/abc',e:true},
      {m:'"/1a2b3c" - valid',i:'/1a2b3c',e:true},
      {m:'"[ssd]/1a2b3c" - valid',i:'[ssd]/1a2b3c',e:true},
      {m:'"[DISK]/1a2b3c" - valid',i:'[DISK]/1a2b3c',e:true},
      {m:'"[DISK]file:///1a2b3c" - valid',i:'[DISK]file:///1a2b3c',e:true},
      {m:'"[] /1a2b3c" - invalid',i:'[] /1a2b3c',e:false},
      {m:'"[ssd] /1a2b3c" - invalid',i:'[ssd] /1a2b3c',e:false},
      {m:'"[/1a2b3c]" - invalid',i:'[/1a2b3c]',e:false},
      {m:'"[s]ss /sd" - invalid',i:'[s]ss /sd',e:false},
      {m:'" [s]ss/sd" - invalid',i:' [s]ss/sd',e:false},
      {m:'"[RAM_DISK]/1a2b3c" - valid',i:'[RAM_DISK]/1a2b3c',e:true},
      {m:'"[RAMDISK_]/1a2b3c" - invalid',i:'[RAMDISK_]/1a2b3c',e:false},
      {m:'"[_RAMDISK]/1a2b3c" - invalid',i:'[_RAMDISK]/1a2b3c',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidDataNodeDir(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isAllowedDir(value)', function() {
    var tests = [
      {m:'"/home" - not allowed',i:'/home',e:false},
      {m:'"/homes" - not allowed',i:'/homes',e:false},
      {m:'"/home/" - not allowed',i:'/home/',e:false},
      {m:'"/homes/" - not allowed',i:'/homes/',e:false},
      {m:'"/dir" - allowed',i:'/dir',e:true},
      {m:'"/dir/home" - allowed',i:'/dir/home',e:true},
      {m:'"/dir/homes" - allowed',i:'/dir/homes',e:true},
      {m:'"/dir/home/" - allowed',i:'/dir/home/',e:true},
      {m:'"/dir/homes/" - allowed',i:'/dir/homes/',e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isAllowedDir(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isValidConfigKey(value)', function() {
    var tests = [
      {m:'"123" - valid',i:'123',e:true},
      {m:'"abc" - valid',i:'abc',e:true},
      {m:'"abc123" - valid',i:'abc123',e:true},
      {m:'".abc." - valid',i:'.abc.',e:true},
      {m:'"_abc_" - valid',i:'_abc_',e:true},
      {m:'"-abc-" - valid',i:'-abc-',e:true},
      {m:'"abc 123" - invalid',i:'abc 123',e:false},
      {m:'"a"b" - invalid',i:'a"b',e:false},
      {m:'"a\'b" - invalid',i:'a\'b',e:false},
      {m:'" a " - valid', i: ' a ', e: true},
      {m:'" a" - valid', i: ' a', e: true},
      {m:'"a " - valid', i: 'a ', e: true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidConfigKey(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isValidConfigGroupName(value)', function() {
    var tests = [
      {m:'"123" - valid',i:'123',e:true},
      {m:'"abc" - valid',i:'abc',e:true},
      {m:'"abc123" - valid',i:'abc123',e:true},
      {m:'".abc." - invalid',i:'.abc.',e:false},
      {m:'"_abc_" - valid',i:'_abc_',e:true},
      {m:'"-abc-" - valid',i:'-abc-',e:true},
      {m:'" abc  123 " - valid',i:' abc  123 ',e:true},
      {m:'"a"b" - invalid',i:'a"b',e:false},
      {m:'"a\'b" - invalid',i:'a\'b',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidConfigGroupName(test.i)).to.equal(test.e);
      })
    });
  });

  describe('#isValidMatchesRegexp()', function() {
    var message = '`{0}` should be {1}',
      tests = [
        { value: '.*', expected: true },
        { value: '..', expected: true },
        { value: '.a1', expected: true },
        { value: '.*a1', expected: true },
        { value: '.*a1.*', expected: true },
        { value: '.*a1.a2', expected: true },
        { value: '.*a1.*.a2', expected: true },
        { value: '.*a1.*.a2.*.a3.a4.*.*', expected: true },
        { value: '*', expected: false },
        { value: '1>1', expected: false },
        //{ value: '.*a1,*', expected: false },
        { value: '?a1[1]asd[1]', expected: false },
        { value: 'a1[1]asd[1]', expected: true },
        { value: 'a1[1]asd[1][', expected: false },
        { value: 'a1[1|1]asd[1]', expected: true },
        { value: '/a1[1|1]asd[1]', expected: true },
        { value: 'a1-2!', expected: true },
        { value: '|a1-2', expected: false },
        { value: '[a1', expected: false },
        { value: 'a{1}', expected: true },
        { value: 'a{1,2}', expected: true },
        { value: 'a{1,2}{', expected: false }
      ];
    tests.forEach(function(test) {
      it(message.format(test.value, test.expected ? 'valid' : 'not valid'), function() {
        expect(validator.isValidMatchesRegexp(test.value)).to.equal(test.expected);
      })
    });
  });

  describe('#isValidURL', function() {
    var tests = [
      {m:'"http://apache.org" - valid',i:'http://apache.org',e:true},
      {m:'"http://ambari.apache.org" - valid',i:'http://ambari.apache.org',e:true},
      {m:'"https://ambari.apache.org" - valid',i:'https://ambari.apache.org',e:true},
      {m:'"htp://ambari.apache.org." - invalid',i:'.htp://ambari.apache.org.',e:false},
      {m:'"ambari.apache.org" - invalid',i:'ambari.apache.org',e:false},
      {m:'"www.ambari.apache.org" - invalid',i:'www.ambari.apache.org',e:false},
      {m:'"" - invalid',i:'',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidURL(test.i)).to.equal(test.e);
      })
    });
  });

  describe('#isHostname()', function() {
    var tests = [
      {m:'"localhost" - valid',i:'localhost',e:true},
      {m:'"c6401.apache.ambari.org" - valid',i:'c6401.apache.ambari.org',e:true},
      {m:'"c6401.org" - valid',i:'c6401.org',e:true},
      {m:'"c6401" - invalid',i:'c6401',e:false},
      {m:'"c6401." - invalid',i:'c6401.',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isHostname(test.i)).to.equal(test.e);
      })
    });
  });

  describe('#isValidBaseUrl()', function() {
    var tests = [
      {m: '"" - valid', i: '', e: true},
      {m: '"http://" - valid', i: 'http://', e: true},
      {m: '"https://" - valid', i: 'https://', e: true},
      {m: '"ftp://" - valid', i: 'ftp://', e: true},
      {m: '"file:///" - valid', i: 'file:///', e: true},
      {m: '"file3" - invalid', i: 'file3', e: false},
      {m: '"3" - invalid', i: '3', e: false},
      {m: '"a" - invalid', i: 'a', e: false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidBaseUrl(test.i)).to.equal(test.e);
      })
    });
  });

  describe('#isValidLdapsURL()', function() {
    var tests = [
      {m: '"" - invalid', i: '', e: false},
      {m: '"http://example.com" - invalid', i: 'http://example.com', e: false},
      {m: '"ldap://example.com" - invalid', i: 'ldap://example.com', e: false},
      {m: '"ldaps://example.com" - valid', i: 'ldaps://example.com', e: true},
      {m: '"ldaps://example.com:636" - valid', i: 'ldaps://example.com:636', e: true},
      {m: '"ldaps://example.com:636/path" - valid', i: 'ldaps://example.com:636/path', e: true},
      {m: '"ldaps://example.com:6eeee36/path" - valid', i: 'ldaps://example.com:6eee36/path', e: false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidLdapsURL(test.i)).to.equal(test.e);
      })
    });
  });

  describe('#isValidAlertName', function () {

    [
      {v: '', e: false},
      {v: 'a', e: true},
      {v: 'a b', e: true},
      {v: '/', e: false},
      {v: '/>1', e: false},
      {v: 'a 1%', e: true},
      {v: 'a (b)', e: true}
    ].forEach(function (test) {

      it(test.m || test.v, function () {
        expect(validator.isValidAlertName(test.v)).to.be.equal(test.e);
      })

    });


  });

});

});

require.register("test/views/application_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/application');

var view,
  modals = [],
  removed = false,
  events = [
      {
      event: 'keyup',
      which: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span class="close"></span></div></div>',
      particle: '',
      length: 0
    },
    {
      event: 'keyup',
      keyCode: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span class="close"></span></div></div>',
      particle: '',
      length: 0
    },
    {
      event: 'keydown',
      which: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      keyCode: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keyup',
      which: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keyup',
      keyCode: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      which: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span class="btn-success" disabled="disabled"></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      keyCode: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span class="btn-success" disabled="disabled"></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span class="btn-success"></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keyup',
      key: 'Esc',
      html: '<div id="modal"><div class="modal-footer"><span class="close"></span></div></div>',
      particle: 'not ',
      length: 1
    }
  ];

describe.skip('App.ApplicationView', function () {

  before(function () {
    if($('#modal').length) {
      removed = true;
    }
    while($('#modal').length) {
      modals.push({
        modal: $('#modal'),
        parent: $('modal').parent()
      });
      $('#modal').remove();
    }
  });

  beforeEach(function () {
    view = App.ApplicationView.create({
      template: null
    });
  });

  afterEach(function () {
    $('#modal').remove();
  });

  after(function () {
    if (removed) {
      modals.forEach(function (item) {
        item.parent.append(item.modal);
      });
    }
  });

  describe('#didInsertElement', function () {
    events.forEach(function (item) {
      it('should ' + item.particle + 'close modal window on ' + item.key + ' press', function () {
        $('body').append(item.html);
        $('span').click(function () {
          $('#modal').remove();
        });
        view.didInsertElement();
        var e = $.Event(item.event);
        e.which = item.which;
        e.keyCode = item.keyCode;
        $(document).trigger(e);
        expect($('#modal')).to.have.length(item.length);
      });
    });
  });

});

});

require.register("test/views/common/ajax_default_error_popup_body_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/ajax_default_error_popup_body');

describe('App.AjaxDefaultErrorPopupBodyView', function () {

  describe('#statusCode', function () {

    var view = App.AjaxDefaultErrorPopupBodyView.create();

    it('should format status code', function () {
      view.set('status', 404);
      expect(view.get('statusCode')).to.equal(Em.I18n.t('utils.ajax.defaultErrorPopupBody.statusCode').format(404));
    });

  });

  describe('#showMessage', function () {

    var view = App.AjaxDefaultErrorPopupBodyView.create(),
      title = 'should be {0}',
      cases = [
        {
          message: 'error',
          showMessage: true
        },
        {
          message: '',
          showMessage: false
        },
        {
          message: null,
          showMessage: false
        },
        {
          message: undefined,
          showMessage: false
        },
        {
          message: 0,
          showMessage: false
        }
      ];

    cases.forEach(function (item) {
      it(title.format(item.showMessage), function () {
        view.set('message', item.message);
        expect(view.get('showMessage')).to.equal(item.showMessage);
      });
    });

  });

  describe('#api', function () {

    var view = App.AjaxDefaultErrorPopupBodyView.create();

    it('should format string with request type and URL', function () {
      view.setProperties({
        type: 'GET',
        url: 'api/v1/clusters'
      });
      expect(view.get('api')).to.equal(Em.I18n.t('utils.ajax.defaultErrorPopupBody.message').format('GET', 'api/v1/clusters'));
    });

  });

});

});

require.register("test/views/common/chart/linear_time_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/chart/linear_time');
var testHelpers = require('test/helpers');

describe('App.ChartLinearTimeView', function () {
  var chartLinearTimeView;

  beforeEach(function() {
    chartLinearTimeView = App.ChartLinearTimeView.create();
  });

  describe("#isRequestRunning", function () {

    it("isPopup true, running request", function() {
      chartLinearTimeView.setProperties({
        isPopup: true,
        runningPopupRequests: [{
          ajaxIndex: 'req1'
        }],
        ajaxIndex: 'req1'
      });
      chartLinearTimeView.propertyDidChange('isRequestRunning');
      expect(chartLinearTimeView.get('isRequestRunning')).to.be.true;
    });

    it("isPopup false, running request", function() {
      chartLinearTimeView.setProperties({
        isPopup: false,
        runningRequests: [{
          ajaxIndex: 'req1'
        }],
        ajaxIndex: 'req1'
      });
      chartLinearTimeView.propertyDidChange('isRequestRunning');
      expect(chartLinearTimeView.get('isRequestRunning')).to.be.true;
    });

    it("isPopup false, no running request", function() {
      chartLinearTimeView.setProperties({
        isPopup: false,
        runningRequests: [],
        ajaxIndex: 'req1'
      });
      chartLinearTimeView.propertyDidChange('isRequestRunning');
      expect(chartLinearTimeView.get('isRequestRunning')).to.be.false;
    });

    it("isPopup true, no running request", function() {
      chartLinearTimeView.setProperties({
        isPopup: true,
        runningPopupRequests: [],
        ajaxIndex: 'req1'
      });
      chartLinearTimeView.propertyDidChange('isRequestRunning');
      expect(chartLinearTimeView.get('isRequestRunning')).to.be.false;
    });

  });

  describe('#transformData', function () {

    var result;
    var data = [[1, 1200000000], [2, 1200000000], [3, 1200000000]];
    var name = 'abc';

    beforeEach(function () {
      sinon.stub(App.router, 'get').withArgs('userSettingsController.userSettings.timezone').returns('(UTC+00:00) Greenwich');
      sinon.stub(App, 'dateTimeWithTimeZone').returns(1);
    });

    afterEach(function () {
      App.router.get.restore();
      App.dateTimeWithTimeZone.restore();
    });

    it('"name" should be "abc" ', function () {
      result = chartLinearTimeView.transformData(data, name);
      expect(result.name).to.equal('abc');
    });

    it('data size should be 3 ', function () {
      result = chartLinearTimeView.transformData(data, name);
      expect(result.data.length).to.equal(3);
    });

    it('data[0].y should be 1 ', function () {
      result = chartLinearTimeView.transformData(data, name);
      expect(result.data[0].y).to.equal(1);
    })

  });

  describe('#yAxisFormatter', function() {
    var tests = [
      {m:'undefined to 0',i:undefined,e:0},
      {m:'NaN to 0',i:NaN,e:0},
      {m:'0 to 0',i:'0',e:'0'},
      {m:'1000 to 1K',i:'1000',e:'1K'},
      {m:'1000000 to 1M',i:'1000000',e:'1M'},
      {m:'1000000000 to 1B',i:'1000000000',e:'1B'},
      {m:'1000000000000 to 1T',i:'1000000000000',e:'1T'},
      {m:'1048576 to 1.049M',i:'1048576',e:'1.049M'},
      {m:'1073741824 to 1.074B',i:'1073741824',e:'1.074B'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(chartLinearTimeView.yAxisFormatter(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#checkSeries', function() {
    var tests = [
      {m:'undefined - false',i:undefined,e:false},
      {m:'NaN - false',i:NaN,e:false},
      {m:'object without data property - false',i:[{}],e:false},
      {m:'object with empty data property - false',i:[{data:[]}],e:false},
      {m:'object with invalid data property - false',i:[{data:[1]}],e:false},
      {m:'object with valid data property - true',i:[{data:[{x:1,y:1},{x:2,y:2}]}],e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(chartLinearTimeView.checkSeries(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#BytesFormatter', function() {
    var tests = [
      {m:'undefined to "0 B"',i:undefined,e:'0 B'},
      {m:'NaN to "0 B"',i:NaN,e:'0 B'},
      {m:'0 to "0 B"',i:0,e:'0 B'},
      {m:'124 to "124 B"',i:124,e:'124 B'},
      {m:'1024 to "1 KB"',i:1024,e:'1 KB'},
      {m:'1536 to "1 KB"',i:1536,e:'1.5 KB'},
      {m:'1048576 to "1 MB"',i:1048576,e:'1 MB'},
      {m:'1073741824 to "1 GB"',i:1073741824,e:'1 GB'},
      {m:'1610612736 to "1.5 GB"',i:1610612736,e:'1.5 GB'}
    ];

    tests.forEach(function(test) {
      it(test.m + ' ', function () {

        expect(App.ChartLinearTimeView.BytesFormatter(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#PercentageFormatter', function() {
    var tests = [
      {m:'undefined to "0 %"',i:undefined,e:'0 %'},
      {m:'NaN to "0 %"',i:NaN,e:'0 %'},
      {m:'0 to "0 %"',i:0,e:'0 %'},
      {m:'1 to "1%"',i:1,e:'1%'},
      {m:'1.12341234 to "1.123%"',i:1.12341234,e:'1.123%'},
      {m:'-11 to "-11%"',i:-11,e:'-11%'},
      {m:'-11.12341234 to "-11.123%"',i:-11.12341234,e:'-11.123%'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(App.ChartLinearTimeView.PercentageFormatter(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#TimeElapsedFormatter', function() {
    var tests = [
      {m:'undefined to "0 ms"',i:undefined,e:'0 ms'},
      {m:'NaN to "0 ms"',i:NaN,e:'0 ms'},
      {m:'0 to "0 ms"',i:0,e:'0 ms'},
      {m:'1000 to "1000 ms"',i:1000,e:'1000 ms'},
      {m:'120000 to "2 m"',i:120000,e:'2 m'},
      {m:'3600000 to "60 m"',i:3600000,e:'60 m'},
      {m:'5000000 to "1 hr"',i:5000000,e:'1 hr'},
      {m:'7200000 to "2 hr"',i:7200000,e:'2 hr'},
      {m:'90000000 to "1 d"',i:90000000,e:'1 d'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(App.ChartLinearTimeView.TimeElapsedFormatter(test.i)).to.equal(test.e);
      });
    });
  });

  describe("#getDataForAjaxRequest()", function() {
    var services = {
      yarnService: [],
      hdfsService: []
    };
    var rangeCases = [
      {
        currentTimeIndex: 0,
        customStartTime: 100000,
        customEndTime: 200000,
        fromSeconds: -3599,
        toSeconds: 1,
        title: 'preset time range'
      },
      {
        currentTimeIndex: 8,
        customStartTime: 100000,
        customEndTime: 200000,
        fromSeconds: 100,
        toSeconds: 200,
        title: 'custom time range'
      },
      {
        currentTimeIndex: 8,
        customStartTime: null,
        customEndTime: null,
        fromSeconds: -3599,
        toSeconds: 1,
        title: 'custom time range, no boundaries set'
      }
    ];
    beforeEach(function(){
      sinon.stub(App.HDFSService, 'find', function(){return services.hdfsService});
      sinon.stub(App.YARNService, 'find', function(){return services.yarnService});
      sinon.stub(App, 'dateTime').returns(1000);
      chartLinearTimeView.set('content', null);
    });
    afterEach(function(){
      App.HDFSService.find.restore();
      App.YARNService.find.restore();
      App.dateTime.restore();
    });

    it("content has hostName", function() {
      chartLinearTimeView.set('content', Em.Object.create({
        hostName: 'host1'
      }));
      expect(chartLinearTimeView.getDataForAjaxRequest()).to.be.eql({
        toSeconds: 1,
        fromSeconds: -3599,
        stepSeconds: 15,
        hostName: 'host1',
        nameNodeName: '',
        resourceManager: ''
      });
    });
    it("get Namenode host", function() {
      services.hdfsService = [
        Em.Object.create({
          nameNode: {hostName: 'host1'}
        })
      ];
      expect(chartLinearTimeView.getDataForAjaxRequest()).to.be.eql({
        toSeconds: 1,
        fromSeconds: -3599,
        stepSeconds: 15,
        hostName: '',
        nameNodeName: 'host1',
        resourceManager: ''
      });
      services.hdfsService = [];
    });
    it("get Namenode host HA", function() {
      services.hdfsService = [
        Em.Object.create({
          activeNameNode: {hostName: 'host1'}
        })
      ];
      expect(chartLinearTimeView.getDataForAjaxRequest()).to.be.eql({
        toSeconds: 1,
        fromSeconds: -3599,
        stepSeconds: 15,
        hostName: '',
        nameNodeName: 'host1',
        resourceManager: ''
      });
      services.hdfsService = [];
    });
    it("get resourceManager host", function() {
      services.yarnService = [
        Em.Object.create({
          resourceManager: {hostName: 'host1'}
        })
      ];
      expect(chartLinearTimeView.getDataForAjaxRequest()).to.be.eql({
        toSeconds: 1,
        fromSeconds: -3599,
        stepSeconds: 15,
        hostName: '',
        nameNodeName: '',
        resourceManager: 'host1'
      });
      services.yarnService = [];
    });
    rangeCases.forEach(function (item) {
      it(item.title, function () {
        chartLinearTimeView.setProperties({
          currentTimeIndex: item.currentTimeIndex,
          customStartTime: item.customStartTime,
          customEndTime: item.customEndTime,
          timeUnitSeconds: 3600
        });
        var requestData = Em.Object.create(chartLinearTimeView.getDataForAjaxRequest());
        expect(requestData.getProperties(['fromSeconds', 'toSeconds'])).to.eql({
          fromSeconds: item.fromSeconds,
          toSeconds: item.toSeconds
        });
      });
    });
  });

  describe('#setCurrentTimeIndexFromParent', function () {

    var view,
      cases = [
        {
          parent: 1,
          child: 2,
          result: 2,
          title: 'child and parent have currentTimeRangeIndex'
        },
        {
          parent: undefined,
          child: 2,
          result: 2,
          title: 'only child has currentTimeRangeIndex'
        },
        {
          parent: 1,
          child: undefined,
          result: 1,
          title: 'only parent has currentTimeRangeIndex'
        }
      ],
      isReadyCases = [
        {
          inWidget: true,
          isClusterMetricsWidget: true,
          parentViewIsLoaded: true,
          isReady: false,
          title: 'cluster metrics widget'
        },
        {
          inWidget: true,
          isClusterMetricsWidget: false,
          parentViewIsLoaded: false,
          isReady: true,
          title: 'enhanced service widget'
        },
        {
          inWidget: false,
          isClusterMetricsWidget: false,
          parentViewIsLoaded: true,
          isReady: false,
          title: 'non-widget graph'
        }
      ];

    beforeEach(function () {
      view = App.ChartLinearTimeView.create({
        isReady: true,
        controller: {},
        parentView: Em.Object.create({
          currentTimeRangeIndex: 1,
          isLoaded: true,
          parentView: Em.Object.create({
            currentTimeRangeIndex: 2
          })
        }),
        timeUnitSecondsSetter: Em.K
      });
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.set('parentView.currentTimeRangeIndex', item.child);
        view.set('parentView.parentView.currentTimeRangeIndex', item.parent);
        view.propertyDidChange('parentView.currentTimeRangeIndex');
        expect(view.get('currentTimeIndex')).to.equal(item.result);
      });
    });

    isReadyCases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(App.ajax, 'abortRequests', Em.K);
          view.set('inWidget', item.inWidget);
          view.set('parentView.isClusterMetricsWidget', item.isClusterMetricsWidget);
          view.propertyDidChange('parentView.currentTimeRangeIndex');
        });

        afterEach(function () {
          App.ajax.abortRequests.restore();
        });

        it('parentView.isLoaded', function () {
          expect(view.get('parentView.isLoaded')).to.eql(item.parentViewIsLoaded);
        });

        it('isReady', function () {
          expect(view.get('isReady')).to.eql(item.isReady);
        });

      });

    });

  });

  describe('#loadDataSuccessCallback', function () {

    beforeEach(function () {
      sinon.stub(chartLinearTimeView, '_refreshGraph', Em.K);
    });

    afterEach(function () {
      chartLinearTimeView._refreshGraph.restore();
    });

    it('should refresh graph', function () {
      var response = {
        key: 'value'
      };
      chartLinearTimeView.loadDataSuccessCallback(response);
      expect(chartLinearTimeView._refreshGraph.calledOnce).to.be.true;
      expect(chartLinearTimeView._refreshGraph.calledWith(response)).to.be.true;
    });
  });

  describe('#setYAxisFormatter', function () {

    var view,
      cases = [
        {
          displayUnit: '%',
          formatter: 'PercentageFormatter'
        },
        {
          displayUnit: 'B',
          formatter: 'BytesFormatter'
        },
        {
          displayUnit: 'ms',
          formatter: 'TimeElapsedFormatter'
        },
        {
          displayUnit: 'kg',
          formatter: 'DefaultFormatter',
          title: 'other display unit'
        },
        {
          formatter: 'DefaultFormatter',
          title: 'no display unit'
        }
      ],
      methodNames = ['PercentageFormatter', 'CreateRateFormatter', 'BytesFormatter', 'TimeElapsedFormatter', 'DefaultFormatter'];

    beforeEach(function () {
      view = App.ChartLinearTimeView.create();
      methodNames.forEach(function (name) {
        sinon.stub(App.ChartLinearTimeView, name, Em.K);
      });
    });

    afterEach(function () {
      methodNames.forEach(function (name) {
        App.ChartLinearTimeView[name].restore();
      });
    });

    cases.forEach(function (item) {
      describe(item.title || item.displayUnit, function () {

        beforeEach(function () {
          view.set('displayUnit', item.displayUnit);
          view.setYAxisFormatter();
          view.yAxisFormatter();
        });

        methodNames.forEach(function (name) {
          it(name, function () {
            expect(App.ChartLinearTimeView[name].callCount).to.equal(Number(name === item.formatter));
          });
        });
      });
    });

  });

  describe('#localeTimeUnit', function () {

    var cases = [
      {
        timeUnitSeconds: 240,
        localeTimeUnit: '1 minute'
      },
      {
        timeUnitSeconds: 172788,
        localeTimeUnit: '719.95 minute'
      },
      {
        timeUnitSeconds: 172800,
        localeTimeUnit: 'day'
      },
      {
        timeUnitSeconds: 1209599,
        localeTimeUnit: 'day'
      },
      {
        timeUnitSeconds: 1209600,
        localeTimeUnit: 'week'
      },
      {
        timeUnitSeconds: 5183999,
        localeTimeUnit: 'week'
      },
      {
        timeUnitSeconds: 5184000,
        localeTimeUnit: 'month'
      },
      {
        timeUnitSeconds: 62207999,
        localeTimeUnit: 'month'
      },
      {
        timeUnitSeconds: 622080000,
        localeTimeUnit: 'year'
      },
      {
        timeUnitSeconds: 700000000,
        localeTimeUnit: 'year'
      }
    ];

    beforeEach(function () {
      sinon.stub(Rickshaw.Fixtures, 'Time').returns({
        unit: function (name) {
          return {
            name: name
          };
        }
      });
    });

    afterEach(function () {
      Rickshaw.Fixtures.Time.restore();
    });

    cases.forEach(function (item) {
      it(item.timeUnitSeconds + 's', function () {
        expect(chartLinearTimeView.localeTimeUnit(item.timeUnitSeconds).name).to.equal(item.localeTimeUnit);
      });
    });

  });

});


describe('App.ChartLinearTimeView.LoadAggregator', function () {

  var aggregator = App.ChartLinearTimeView.LoadAggregator;

  describe("#groupRequests()", function () {
    var result;
    beforeEach(function () {
      var requests = [
        {
          name: 'r1',
          context: 'c1',
          fields: ['f1']
        },
        {
          name: 'r2',
          context: 'c2',
          fields: ['f2']
        },
        {
          name: 'r2',
          context: 'c3',
          fields: ['f3', 'f4']
        }
      ];
      result = aggregator.groupRequests(requests);
    });
    it("result['r1'].subRequests.length", function () {
      expect(result.r1.subRequests.length).to.equal(1);
    });
    it("result['r1'].fields.length", function () {
      expect(result.r1.fields.length).to.equal(1);
    });
    it("result['r2'].subRequests.length", function () {
      expect(result.r2.subRequests.length).to.equal(2);
    });
    it("result['r2'].fields.length", function () {
      expect(result.r2.fields.length).to.equal(3);
    });
  });

  describe("#runRequests()", function () {
    beforeEach(function () {
      sinon.stub(aggregator, 'groupRequests', function (requests) {
        return requests;
      });
      sinon.stub(aggregator, 'formatRequestData', function(_request){
        return _request.fields;
      });
      App.ajax.send.restore();
      sinon.stub(App.ajax, 'send', function(){
        return {
          done: Em.K,
          fail: Em.K,
          always: Em.K
        }
      });
    });
    afterEach(function () {
      aggregator.groupRequests.restore();
      aggregator.formatRequestData.restore();
    });
    it("valid request is sent", function () {
      var context = Em.Object.create({
        content: {
          hostName: 'host1'
        },
        runningRequests: []
      });
      var requests = {
        'r1': {
          name: 'r1',
          context: context,
          fields: ['f3', 'f4']
        }
      };
      aggregator.runRequests(requests);
      var args = testHelpers.findAjaxRequest('name', 'r1');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(context);
      expect(args[0].data).to.be.eql({
        fields: ['f3', 'f4'],
        hostName: 'host1'
      });
    });
  });

  describe("#formatRequestData()", function () {
    var cases = [
      {
        currentTimeIndex: 0,
        customStartTime: 100000,
        customEndTime: 200000,
        result: 'f3[400,4000,15],f4[400,4000,15]',
        title: 'preset time range'
      },
      {
        currentTimeIndex: 8,
        customStartTime: 100000,
        customEndTime: 200000,
        result: 'f3[100,200,15],f4[100,200,15]',
        title: 'custom time range'
      },
      {
        currentTimeIndex: 8,
        customStartTime: null,
        customEndTime: null,
        result: 'f3[400,4000,15],f4[400,4000,15]',
        title: 'custom time range, no boundaries set'
      }
    ];
    beforeEach(function () {
      sinon.stub(App, 'dateTime').returns(4000000);
    });
    afterEach(function () {
      App.dateTime.restore();
    });
    cases.forEach(function (item) {
      it(item.title, function () {
        var context = Em.Object.create({
          timeUnitSeconds: 3600,
          currentTimeIndex: item.currentTimeIndex,
          customStartTime: item.customStartTime,
          customEndTime: item.customEndTime
        });
        var request = {
          name: 'r1',
          context: context,
          fields: ['f3', 'f4']
        };
        expect(aggregator.formatRequestData(request)).to.equal(item.result);
      });
    });
  });

});

});

require.register("test/views/common/configs/config_history_flow_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/configs/config_history_flow');
var testHelpers = require('test/helpers');

describe.skip('App.ConfigHistoryFlowView', function () {

  var view = App.ConfigHistoryFlowView.create({
    controller: Em.Object.create({
      loadSelectedVersion: Em.K,
      loadStep: Em.K
    }),
    displayedServiceVersion: Em.Object.create(),
    serviceVersions: []
  });

  App.TestAliases.testAsComputedAlias(view, 'serviceName', 'controller.selectedService.serviceName', 'string');

  App.TestAliases.testAsComputedOr(view, 'isSaveDisabled', ['controller.isSubmitDisabled', '!controller.versionLoaded', '!controller.isPropertiesChanged']);

  App.TestAliases.testAsComputedGt(view, 'displayedServiceVersion.notes.length', 100);

  App.TestAliases.testAsComputedTruncate(view, 'shortNotes', 'displayedServiceVersion.notes', 100, 100);

  describe('#visibleServiceVersion', function () {
    var testCases = [
      {
        params: {
          startIndex: 0,
          serviceVersions: []
        },
        result: []
      },
      {
        params: {
          startIndex: 0,
          serviceVersions: [1, 2, 3]
        },
        result: [1, 2, 3]
      },
      {
        params: {
          startIndex: 0,
          serviceVersions: [1, 2, 3, 4, 5, 6, 7]
        },
        result: [1, 2, 3, 4, 5]
      },
      {
        params: {
          startIndex: 3,
          serviceVersions: [1, 2, 3, 4, 5, 6, 7]
        },
        result: [4, 5, 6, 7]
      }
    ];
    testCases.forEach(function (test) {
      it('start index - ' + test.params.startIndex + ', serviceVersions length - ' + test.params.serviceVersions.length, function () {
        view.set('serviceVersions', test.params.serviceVersions);
        view.set('startIndex', test.params.startIndex);
        view.propertyDidChange('visibleServiceVersion');
        expect(view.get('visibleServiceVersion')).to.eql(test.result);
      });
    });
  });

  describe('#versionActionsDisabled', function () {
    it('versionLoaded is false', function () {
      view.set('controller.versionLoaded', false);
      expect(view.get('versionActionsDisabled')).to.be.true;
    });
    it('versionLoaded is true', function () {
      view.set('controller.versionLoaded', true);
      expect(view.get('versionActionsDisabled')).to.be.false;
    });
  });

  describe('#dropDownList', function () {
    var displayedServiceVersion = {version: 1};

    it('Only one service version is present', function () {
      view.set('serviceVersions', [displayedServiceVersion]);
      view.set('displayedServiceVersion', displayedServiceVersion);
      view.propertyDidChange('dropDownList');
      expect(view.get('dropDownList')).to.be.empty;
    });
    it('Three service version', function () {
      view.set('serviceVersions', [displayedServiceVersion, {version: 2}, {version: 3}]);
      view.set('displayedServiceVersion', displayedServiceVersion);
      view.propertyDidChange('dropDownList');
      expect(view.get('dropDownList')).to.eql([{version: 3}, {version: 2}]);
    });
    it('Seven service version, showFullList is false', function () {
      view.set('serviceVersions', [
        displayedServiceVersion,
        {version: 2},
        {version: 3},
        {version: 4},
        {version: 5},
        {version: 6},
        {version: 7},
        {version: 8}
      ]);
      view.set('displayedServiceVersion', displayedServiceVersion);
      view.set('showFullList', false);
      view.propertyDidChange('dropDownList');
      expect(view.get('dropDownList')).to.eql([
        {version: 8},
        {version: 7},
        {version: 6},
        {version: 5},
        {version: 4},
        {version: 3}
      ]);
    });
    it('Seven service version, showFullList is true', function () {
      view.set('serviceVersions', [
        displayedServiceVersion,
        {version: 2},
        {version: 3},
        {version: 4},
        {version: 5},
        {version: 6},
        {version: 7},
        {version: 8}
      ]);
      view.set('displayedServiceVersion', displayedServiceVersion);
      view.set('showFullList', true);
      view.propertyDidChange('dropDownList');
      expect(view.get('dropDownList')).to.eql([
        {version: 8},
        {version: 7},
        {version: 6},
        {version: 5},
        {version: 4},
        {version: 3},
        {version: 2}
      ]);
    });
  });

  describe('#openFullList()', function () {
    var event;
    beforeEach(function () {
      event = {
        stopPropagation: Em.K
      };
      sinon.spy(event, 'stopPropagation');
      view.openFullList(event);
    });

    afterEach(function () {
      event.stopPropagation.restore();
    });

    it('stopPropagation is called once', function () {
      expect(event.stopPropagation.calledOnce).to.be.true;
    });

    it('stopPropagation is true', function () {
      expect(view.get('stopPropagation')).to.be.true;
    });
  });

  describe('#hideFullList()', function () {
    var testCases = [
      {
        params: {
          serviceVersions: new Array(0)
        },
        result: true
      },
      {
        params: {
          serviceVersions: new Array(6)
        },
        result: true
      },
      {
        params: {
          serviceVersions: new Array(7)
        },
        result: false
      }
    ];
    testCases.forEach(function (test) {
      it('notes length - ' + test.params.count, function () {
        view.set('serviceVersions', test.params.serviceVersions);
        view.hideFullList();
        expect(view.get('showFullList')).to.equal(test.result);
      });
    });
  });

  describe('#didInsertElement()', function () {

    beforeEach(function () {
      sinon.stub(App, 'tooltip');
      view.didInsertElement();
    });

    afterEach(function () {
      App.tooltip.restore();
    });

    it('App.tooltip is called one', function () {
      expect(App.tooltip.calledOnce).to.be.true;
    });
  });

  describe('#willInsertElement()', function () {

    beforeEach(function () {
      sinon.stub(view, 'adjustFlowView', Em.K);
      sinon.stub(view, 'keepInfoBarAtTop', Em.K);
    });

    afterEach(function () {
      view.adjustFlowView.restore();
      view.keepInfoBarAtTop.restore();
    });

    describe('Only current version is present', function () {

      beforeEach(function () {
        view.set('serviceVersions', [Em.Object.create({isCurrent: true})]);
        view.willInsertElement();
      });

      it('adjustFlowView is called once', function () {
        expect(view.adjustFlowView.calledOnce).to.be.true;
      });
      it('keepInfoBarAtTop is called once', function () {
        expect(view.keepInfoBarAtTop.calledOnce).to.be.true;
      });
      it('startIndex = 0', function () {
        expect(view.get('startIndex')).to.equal(0);
      });
      it('serviceVersions.@each.isDisplayed = [true]', function () {
        expect(view.get('serviceVersions').mapProperty('isDisplayed')).to.eql([true]);
      });
    });

    describe('Five service versions are present', function () {

      beforeEach(function () {
        view.set('serviceVersions', [
          Em.Object.create({isCurrent: true}),
          Em.Object.create(),
          Em.Object.create(),
          Em.Object.create(),
          Em.Object.create()
        ]);
        view.willInsertElement();
      });
      it('adjustFlowView is called once', function () {
        expect(view.adjustFlowView.calledOnce).to.be.true;
      });
      it('keepInfoBarAtTop is called once', function () {
        expect(view.keepInfoBarAtTop.calledOnce).to.be.true;
      });
      it('startIndex = 0', function () {
        expect(view.get('startIndex')).to.equal(0);
      });
      it('serviceVersions.@each.isDisplayed = [true, false, false, false, false]', function () {
        expect(view.get('serviceVersions').mapProperty('isDisplayed')).to.eql([true, false, false, false, false]);
      });
    });

    describe('Six service versions are present', function () {
      beforeEach(function () {
        view.set('serviceVersions', [
          Em.Object.create({isCurrent: true}),
          Em.Object.create(),
          Em.Object.create(),
          Em.Object.create(),
          Em.Object.create(),
          Em.Object.create()
        ]);
        view.willInsertElement();
      });

      it('adjustFlowView is called once', function () {
        expect(view.adjustFlowView.calledOnce).to.be.true;
      });
      it('keepInfoBarAtTop is called once', function () {
        expect(view.keepInfoBarAtTop.calledOnce).to.be.true;
      });
      it('startIndex is 1', function () {
        expect(view.get('startIndex')).to.equal(1);
      });
      it('serviceVersions.@each.isDisplayed = [true, false, false, false, false, false]', function () {
        expect(view.get('serviceVersions').mapProperty('isDisplayed')).to.eql([true, false, false, false, false, false]);
      });
    });

  });

  describe('#setInfoBarPosition()', function () {
    var testCases = [
      {
        params: {
          scrollTop: 0,
          defaultTop: 0
        },
        result: 'auto'
      },
      {
        params: {
          scrollTop: 1,
          defaultTop: 11
        },
        result: '10px'
      },
      {
        params: {
          scrollTop: 1,
          defaultTop: 0
        },
        result: '10px'
      }
    ];
    var infoBar = {
      css: Em.K
    };

    beforeEach(function () {
      sinon.spy(infoBar, 'css');
    });

    afterEach(function () {
      infoBar.css.restore();
    });

    testCases.forEach(function (test) {
      it('scroll top - ' + test.params.scrollTop + ', default top - ' + test.params.defaultTop, function () {
        view.setInfoBarPosition(infoBar, test.params.defaultTop, test.params.scrollTop);
        expect(infoBar.css.calledWith('top', test.result)).to.be.true;
      });
    });
  });

  describe('#adjustFlowView()', function () {
    var testCases = [
      {
        params: {
          serviceVersions: [Em.Object.create()],
          startIndex: 0
        },
        result: {
          first: [true],
          showLeftArrow: false,
          showRightArrow: false
        }
      },
      {
        params: {
          serviceVersions: [
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create()
          ],
          startIndex: 0
        },
        result: {
          first: [true, false, false, false, false],
          showLeftArrow: false,
          showRightArrow: false
        }
      },
      {
        params: {
          serviceVersions: [
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create()
          ],
          startIndex: 0
        },
        result: {
          first: [true, false, false, false, false, false],
          showLeftArrow: false,
          showRightArrow: true
        }
      },
      {
        params: {
          serviceVersions: [
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create()
          ],
          startIndex: 1
        },
        result: {
          first: [false, true, false, false, false, false],
          showLeftArrow: true,
          showRightArrow: false
        }
      },
      {
        params: {
          serviceVersions: [
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create()
          ],
          startIndex: 1
        },
        result: {
          first: [false, true, false, false, false, false, false],
          showLeftArrow: true,
          showRightArrow: true
        }
      }
    ];

    testCases.forEach(function (test) {
      it('start index - ' + test.params.startIndex + ', serviceVersions length - ' + test.params.serviceVersions.length, function () {
        view.set('startIndex', test.params.startIndex);
        view.set('serviceVersions', test.params.serviceVersions);

        view.adjustFlowView();
        expect(view.get('serviceVersions').mapProperty('first')).to.eql(test.result.first);
        expect(view.get('showLeftArrow')).to.eql(test.result.showLeftArrow);
        expect(view.get('showRightArrow')).to.eql(test.result.showRightArrow);
      });
    });
  });

  describe('#switchVersion()', function () {
    var event = {
      context: Em.Object.create({
        version: 2
      })
    };
    beforeEach(function(){
      sinon.stub(view, 'shiftFlowOnSwitch', Em.K);
      sinon.spy(view.get('controller'), 'loadSelectedVersion');
    });
    afterEach(function(){
      view.shiftFlowOnSwitch.restore();
      view.get('controller').loadSelectedVersion.restore();
    });
    it('Only one service version is present', function () {
      view.set('serviceVersions', [Em.Object.create({version: 2})]);
      view.switchVersion(event);
      expect(view.get('serviceVersions').mapProperty('isDisplayed')).to.eql([true]);
      expect(view.get('controller').loadSelectedVersion.calledWith(2)).to.be.true;
      expect(view.shiftFlowOnSwitch.calledWith(0)).to.be.true;
    });
    it('Two service versions are present', function () {
      view.set('serviceVersions', [
        Em.Object.create({version: 1}),
        Em.Object.create({version: 2})
      ]);
      view.switchVersion(event);
      expect(view.get('serviceVersions').mapProperty('isDisplayed')).to.eql([false, true]);
      expect(view.get('controller').loadSelectedVersion.calledWith(2)).to.be.true;
      expect(view.shiftFlowOnSwitch.calledWith(1)).to.be.true;
    });
  });

  describe('#compare()', function () {
    it('should set compareServiceVersion', function () {
      view.compare({context: Em.Object.create({version: 1})});

      expect(view.get('controller.compareServiceVersion')).to.eql(Em.Object.create({version: 1}));
    });
  });

  describe('#revert()', function () {
    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show', function (options) {
        options.onPrimary.call(Em.Object.create({
          serviceConfigNote: 'note',
          hide: Em.K
        }));
      });
      sinon.stub(view, 'sendRevertCall', Em.K);
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
      view.sendRevertCall.restore();
    });
    it('context passed', function () {
      view.revert({context: Em.Object.create({
        version: 1,
        serviceName: 'S1'
      })});

      expect(App.ModalPopup.show.calledOnce).to.be.true;
      expect(view.sendRevertCall.calledWith(Em.Object.create({
        version: 1,
        serviceName: 'S1',
        serviceConfigNote: 'note'
      }))).to.be.true;
    });
    it('context is not passed', function () {
      view.set('displayedServiceVersion', Em.Object.create({
        version: 1,
        serviceName: 'S1'
      }));
      view.revert({});

      expect(App.ModalPopup.show.calledOnce).to.be.true;
      expect(view.sendRevertCall.calledWith(Em.Object.create({
        version: 1,
        serviceName: 'S1',
        serviceConfigNote: 'note',
        notes: ''
      }))).to.be.true;
    });
  });

  describe('#sendRevertCall()', function () {

    beforeEach(function () {
      view.sendRevertCall(Em.Object.create());
    });

    it('request is sent', function () {
      var args = testHelpers.findAjaxRequest('name', 'service.serviceConfigVersion.revert');
      expect(args).exists;
    });
  });

  describe('#sendRevertCallSuccess()', function () {
    beforeEach(function () {
      sinon.spy(view.get('controller'), 'loadStep');
      sinon.stub(App.router.get('updateController'), 'updateComponentConfig', Em.K);
      view.sendRevertCallSuccess();
    });
    afterEach(function () {
      view.get('controller').loadStep.restore();
      App.router.get('updateController').updateComponentConfig.restore();
    });

    it('loadStep is called', function () {
      expect(view.get('controller').loadStep.calledOnce).to.be.true;
    });

    it('updateComponentConfig is called', function () {
      expect(App.router.get('updateController').updateComponentConfig.calledOnce).to.be.true;
    });
  });

  describe('#save()', function () {

    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show', Em.K);
      sinon.stub(App.ServiceConfigVersion, 'find').returns([
        { serviceName: 'service'}
      ]);
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
      App.ServiceConfigVersion.find.restore();
    });

    it('modal popup should be displayed', function () {
      view.save();
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });

    it('controller properties should be modified on save', function () {
      view.setProperties({
        'serviceName': 'service',
        'controller.saveConfigsFlag': false,
        'controller.serviceConfigVersionNote': '',
        'controller.serviceConfigNote': '',
        'controller.preSelectedConfigVersion': null,
        'serviceConfigNote': 'note',
        'displayedServiceVersion.serviceName': 'service',
        'controller.selectedConfigGroup.name': 'group'
      });
      var popup = view.save();
      popup.onSave();
      expect(view.get('controller.saveConfigsFlag')).to.be.true;
      expect(view.get('controller').getProperties(['saveConfigsFlag', 'serviceConfigVersionNote', 'serviceConfigNote', 'preSelectedConfigVersion'])).to.eql({
        saveConfigsFlag: true,
        serviceConfigVersionNote: 'note',
        serviceConfigNote: this.get('serviceConfigNote'),
        preSelectedConfigVersion: Em.Object.create({
          version: 2,
          serviceName: 'service',
          groupName: 'group'
        })
      });
    });
  });

  describe('#shiftBack()', function () {

    beforeEach(function () {
      sinon.stub(view, 'decrementProperty', Em.K);
      sinon.stub(view, 'adjustFlowView', Em.K);
      view.shiftBack();
    });

    afterEach(function () {
      view.adjustFlowView.restore();
      view.decrementProperty.restore();
    });

    it('decrementProperty is called with correct data', function () {
      expect(view.decrementProperty.calledWith('startIndex')).to.be.true;
    });

    it('adjustFlowView is called once', function () {
      expect(view.adjustFlowView.calledOnce).to.be.true;
    });
  });

  describe('#shiftForward()', function () {

    beforeEach(function () {
      sinon.stub(view, 'incrementProperty', Em.K);
      sinon.stub(view, 'adjustFlowView', Em.K);
      view.shiftForward();
    });

    afterEach(function () {
      view.adjustFlowView.restore();
      view.incrementProperty.restore();
    });

    it('startIndex++', function () {
      expect(view.incrementProperty.calledWith('startIndex')).to.be.true;
    });

    it('adjustFlowView is called once', function () {
      expect(view.adjustFlowView.calledOnce).to.be.true;
    });
  });

  describe('#adjustFlowView()', function () {
    var testCases = [
      {
        params: {
          serviceVersions: [],
          startIndex: 0,
          versionIndex: 1
        },
        result: {
          startIndex: 0,
          adjustFlowViewCall: false
        }
      },
      {
        params: {
          serviceVersions: new Array(6),
          startIndex: 7,
          versionIndex: 6
        },
        result: {
          startIndex: 1,
          adjustFlowViewCall: true
        }
      },
      {
        params: {
          serviceVersions: new Array(12),
          startIndex: 7,
          versionIndex: 6
        },
        result: {
          startIndex: 6,
          adjustFlowViewCall: true
        }
      },
      {
        params: {
          serviceVersions: new Array(12),
          startIndex: 0,
          versionIndex: 6
        },
        result: {
          startIndex: 6,
          adjustFlowViewCall: true
        }
      },
      {
        params: {
          serviceVersions: new Array(6),
          startIndex: 0,
          versionIndex: 6
        },
        result: {
          startIndex: 1,
          adjustFlowViewCall: true
        }
      }
    ];

    beforeEach(function () {
      sinon.stub(view, 'adjustFlowView', Em.K);
    });

    afterEach(function () {
      view.adjustFlowView.restore();
    });

    testCases.forEach(function (test) {
      it('start index - ' + test.params.startIndex + ', serviceVersions length - ' + test.params.serviceVersions.length + ', versionIndex - ' + test.params.versionIndex, function () {
        view.set('serviceVersions', test.params.serviceVersions);
        view.set('startIndex', test.params.startIndex);
        view.shiftFlowOnSwitch(test.params.versionIndex);

        expect(view.get('startIndex')).to.eql(test.result.startIndex);
        expect(view.adjustFlowView.calledOnce).to.eql(test.result.adjustFlowViewCall);
      });
    });
  });
});

function getView() {
  return App.ConfigsServiceVersionBoxView.create();
}

describe('App.ConfigsServiceVersionBoxView', function () {

  App.TestAliases.testAsComputedAlias(getView(), 'disabledActionAttr', 'serviceVersion.disabledActionAttr', 'object');

  App.TestAliases.testAsComputedAlias(getView(), 'disabledActionMessages', 'serviceVersion.disabledActionMessages', 'object');

});
});

require.register("test/views/common/configs/custom_category_views/notification_configs_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/configs/custom_category_views/notification_configs_view');
var view;

function getView() {
  return App.NotificationsConfigsView.create({
    $: function() {
      return {show: Em.K, hide: Em.K};
    },
    category: {
      name: 'name'
    },
    serviceConfigs: [],
    categoryConfigs: [],
    categoryConfigsAll: [],
    mainView: Em.View.create({
      filter: '',
      columns: []
    })
  });
}

describe('App.NotificationsConfigsView', function () {

  beforeEach(function () {
    view = getView();
  });

  App.TestAliases.testAsComputedFindBy(getView(), 'useAuthConfig', 'categoryConfigs', 'name', 'smtp_use_auth');

  describe('#didInsertElement', function () {

    beforeEach(function () {
      sinon.stub(view, 'updateCategoryConfigs', Em.K);
      sinon.stub(view, 'onTlsOrSslChanged');
    });

    afterEach(function () {
      view.updateCategoryConfigs.restore();
      view.onTlsOrSslChanged.restore();
    });

    it('should not do nothing if no configs', function () {

      view.set('categoryConfigsAll', []);
      view.didInsertElement();
      expect(view.updateCategoryConfigs.called).to.equal(false);

    });

    describe('should update category configs', function () {
      var configs = [
        Em.Object.create({
          name: "create_notification",
          value: 'yes',
          filename: "alert_notification"
        }),
        Em.Object.create({
          name: 'mail.smtp.starttls.enable',
          value: false,
          filename: "alert_notification"
        }),
        Em.Object.create({
          name: 'smtp_use_auth',
          value: 'true',
          filename: "alert_notification"
        })
      ];

      beforeEach(function () {
        view.set('serviceConfigs', configs);
        view.reopen({
          categoryConfigsAll: Em.computed.filterBy('serviceConfigs', 'filename', 'alert_notification')
        });
        view.didInsertElement();
      });

      it('createNotification = yes', function () {
        expect(view.get('createNotification')).to.equal('yes');
      });
      it('tlsOrSsl = ssl', function () {
        expect(view.get('tlsOrSsl')).to.equal('ssl');
      });
      it('updateCategoryConfigs is called once', function () {
        expect(view.updateCategoryConfigs.called).to.be.true;
      });

    });
  });

  describe("#onTlsOrSslChanged()", function () {

    var configs = [
      Em.Object.create({
        name: "mail.smtp.starttls.enable",
        value: 'yes'
      }),
      Em.Object.create({
        name: 'mail.smtp.startssl.enable',
        value: false
      })
    ];

    it("tls", function () {
      view.set('categoryConfigsAll', configs);
      view.set('tlsOrSsl', 'tls');
      view.onTlsOrSslChanged();
      expect(configs.findProperty('name', 'mail.smtp.starttls.enable').get('value')).to.be.true;
      expect(configs.findProperty('name', 'mail.smtp.startssl.enable').get('value')).to.be.false;
    });

    it("ssl", function () {
      view.set('categoryConfigsAll', configs);
      view.set('tlsOrSsl', 'ssl');
      view.onTlsOrSslChanged();
      expect(configs.findProperty('name', 'mail.smtp.starttls.enable').get('value')).to.be.false;
      expect(configs.findProperty('name', 'mail.smtp.startssl.enable').get('value')).to.be.true;
    });
  });

  describe("#onUseAuthConfigChange()", function () {

    beforeEach(function () {
      sinon.stub(view, 'updateConfig');
      view.set('categoryConfigs', [
        Em.Object.create({name: 'ambari.dispatch.credential.username'}),
        Em.Object.create({name: 'smtp_use_auth'})
      ]);
    });

    afterEach(function () {
      view.updateConfig.restore();
    });

    it("auth config is not editable", function () {
      view.get('categoryConfigs').findProperty('name', 'smtp_use_auth').setProperties({
        value: true,
        isEditable: false
      });
      view.onUseAuthConfigChange();
      expect(view.updateConfig.calledWith(
        Em.Object.create({name: 'ambari.dispatch.credential.username'}),
        false
      )).to.be.true;
    });

    it("auth config is editable", function () {
      view.get('categoryConfigs').findProperty('name', 'smtp_use_auth').setProperties({
        value: true,
        isEditable: true
      });
      view.onUseAuthConfigChange();
      expect(view.updateConfig.calledWith(
        Em.Object.create({name: 'ambari.dispatch.credential.username'}),
        true
      )).to.be.true;
    });
  });

  describe("#updateCategoryConfigs()", function () {

    beforeEach(function () {
      sinon.stub(view, 'updateConfig');
      sinon.stub(view, 'onUseAuthConfigChange');
      view.set('categoryConfigs', [
        Em.Object.create({name: 'ambari.dispatch.credential.username'})
      ]);
      view.set('categoryConfigsAll', [
        Em.Object.create({
          name: 'create_notification'
        })
      ]);
    });

    afterEach(function () {
      view.updateConfig.restore();
      view.onUseAuthConfigChange.restore();
    });

    it("createNotification is 'yes'", function () {
      view.set('createNotification', 'yes');
      view.updateCategoryConfigs();
      expect(view.onUseAuthConfigChange.called).to.be.true;
      expect(view.get('categoryConfigsAll').findProperty('name', 'create_notification').get('value')).to.equal('yes');
      expect(view.updateConfig.calledWith(
        Em.Object.create({name: 'ambari.dispatch.credential.username'}),
        true
      )).to.be.true;
    });

    it("createNotification is 'no'", function () {
      view.set('createNotification', 'no');
      view.updateCategoryConfigs();
      expect(view.onUseAuthConfigChange.called).to.be.true;
      expect(view.get('categoryConfigsAll').findProperty('name', 'create_notification').get('value')).to.equal('no');
      expect(view.updateConfig.calledWith(
        Em.Object.create({name: 'ambari.dispatch.credential.username'}),
        false
      )).to.be.true;
    });
  });

  describe("#updateConfig()", function () {

    var config;

    beforeEach(function () {
      config = Em.Object.create();
    });

    describe("flag is true", function () {

      beforeEach(function () {
        view.updateConfig(config, true);
      });
      it('isRequired is true', function () {
        expect(config.get('isRequired')).to.be.true;
      });
      it('isEditable is true', function () {
        expect(config.get('isEditable')).to.be.true;
      });
    });

    describe("flag is false", function () {
      beforeEach(function () {
        view.updateConfig(config, false);
      });
      it('isRequired is false', function () {
        expect(config.get('isRequired')).to.be.false;
      });
      it('isEditable is false', function () {
        expect(config.get('isEditable')).to.be.false;
      });
    });
  });
});

});

require.register("test/views/common/configs/overriddenProperty_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/configs/overriddenProperty_view');

describe('App.ServiceConfigView.SCPOverriddenRowsView', function () {

  var view = App.ServiceConfigView.SCPOverriddenRowsView.create();

  describe('#didInsertElement', function () {

    beforeEach(function () {
      sinon.spy(view, 'setSwitchText');
      sinon.stub(App, 'tooltip', Em.K);
    });

    afterEach(function () {
      view.setSwitchText.restore();
      App.tooltip.restore();
    });

    it('setSwitchLinks method should be executed', function () {
      view.didInsertElement();
      expect(view.setSwitchText.calledOnce).to.be.true;
    });

  });

  describe('#setSwitchText', function () {

    view = App.ServiceConfigView.SCPOverriddenRowsView.create({
      serviceConfigProperty: {
        overrides: [
          Em.Object.create({
            group: Em.Object.create({
              displayName: 'hcg',
              switchGroupTextShort: 'short',
              switchGroupTextFull: 'full'
            })
          })
        ]
      }
    });

    beforeEach(function () {
      sinon.stub(App, 'tooltip', Em.K);
    });

    afterEach(function () {
      App.tooltip.restore();
    });

    it('should not modify overrides', function () {
      view.set('isDefaultGroupSelected', false);
      expect(view.get('serviceConfigProperty.overrides.firstObject.group.switchGroupTextShort')).to.equal('short');
      expect(view.get('serviceConfigProperty.overrides.firstObject.group.switchGroupTextFull')).to.equal('full');
    });

    it('should set switchGroupTextShort and switchGroupTextFull', function () {
      view.set('isDefaultGroupSelected', true);
      expect(view.get('serviceConfigProperty.overrides.firstObject.group.switchGroupTextShort')).to.equal(Em.I18n.t('services.service.config_groups.switchGroupTextShort').format('hcg'));
      expect(view.get('serviceConfigProperty.overrides.firstObject.group.switchGroupTextFull')).to.equal(Em.I18n.t('services.service.config_groups.switchGroupTextFull').format('hcg'));
    });

  });

});

});

require.register("test/views/common/configs/service_config_container_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/chart/pie');
require('views/common/configs/services_config');

describe('App.ServiceConfigContainerView', function () {

  var view;

  beforeEach(function () {
    view = App.ServiceConfigContainerView.create({
      filter: ''
    });
  });

  describe('#pushView', function () {
    it('shouldn\'t be launched before selectedService is set', function () {
      view.set('controller', {});
      view.pushView();
      expect(view.get('childViews')).to.be.empty;
    });
  });

  describe('#selectedServiceObserver', function () {

    it('should add a child view', function () {
      view.set('controller', Em.Object.create({
        selectedService: {
          configCategories: [],
          configs: []
        },
        isRecommendedLoaded: true
      }));
      expect(view.get('childViews')).to.have.length(1);
    });

    it('should set controller for the view', function () {
      view.set('controller', Em.Object.create({
        name: 'controller',
        selectedService: {
          configCategories: [],
          configs: []
        },
        isRecommendedLoaded: true
      }));
      expect(view.get('childViews.firstObject.controller.name')).to.equal('controller');
    });

    it('should add config categories', function () {
      view.set('controller', Em.Object.create({
        selectedService: {
          configCategories: [Em.Object.create(), Em.Object.create()],
          configs: []
        },
        isRecommendedLoaded: true
      }));
      expect(view.get('childViews.firstObject.serviceConfigsByCategoryView.childViews')).to.have.length(2);
    });

  });

});

});

require.register("test/views/common/configs/service_config_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/chart/pie');
require('views/common/configs/services_config');

describe('App.ServiceConfigView', function () {

  var controller = App.WizardStep7Controller.create({
    selectedServiceObserver: Em.K,
    switchConfigGroupConfigs: Em.K
  });

  var view = App.ServiceConfigView.create({
    controller: controller
  });

  var testCases = [
    {
      title: 'selectedConfigGroup is null',
      result: {
        'category1': false,
        'category2': true,
        'category3': false
      },
      selectedConfigGroup: null,
      selectedService: {
        serviceName: 'TEST',
        configCategories: [
          App.ServiceConfigCategory.create({ name: 'category1', canAddProperty: false}),
          App.ServiceConfigCategory.create({ name: 'category2', siteFileName: 'category2.xml', canAddProperty: true}),
          App.ServiceConfigCategory.create({ name: 'category3', siteFileName: 'category3.xml', canAddProperty: false})
        ],
        configs: []
      }
    },
    {
      title: 'selectedConfigGroup is default group',
      result: {
        'category1': true,
        'category2': true,
        'category3': false
      },
      selectedConfigGroup: {isDefault: true},
      selectedService: {
        serviceName: 'TEST',
        configCategories: [
          App.ServiceConfigCategory.create({ name: 'category1', canAddProperty: true}),
          App.ServiceConfigCategory.create({ name: 'category2', siteFileName: 'category2.xml', canAddProperty: true}),
          App.ServiceConfigCategory.create({ name: 'category3', siteFileName: 'category3.xml', canAddProperty: false})
        ],
        configs: []
      }
    }
  ];

  describe('#checkCanEdit', function () {
    before(function () {
      sinon.stub(App.config, 'shouldSupportAddingForbidden').withArgs('TEST', 'category2.xml').returns(true).withArgs('TEST', 'category3.xml').returns(false);
    });

    after(function () {
      App.config.shouldSupportAddingForbidden.restore();
    });

    testCases.forEach(function (test) {
      describe(test.title, function () {

        beforeEach(function () {
          controller.set('selectedService', test.selectedService);
          controller.set('selectedConfigGroup', test.selectedConfigGroup);
          view.checkCanEdit();
        });
        Object.keys(test.result).forEach(function (categoryName) {
          it(categoryName, function () {
            var canAddProperty = controller.get('selectedService.configCategories').findProperty('name', categoryName).get('canAddProperty');
            expect(canAddProperty).to.be.equal(test.result[categoryName]);
          });
        });
      });
    });
  });

  describe('#pickActiveTab', function () {

    Em.A([
        {
          tabs: [
            Em.Object.create({isAdvanced: false, isActive: false, name: 'settings', isHiddenByFilter: false}),
            Em.Object.create({isAdvanced: true, isActive: false, name: 'advanced', isHiddenByFilter: false})
          ],
          m: 'Should make `settings` active (1)',
          e: 'settings'
        },
        {
          tabs: [
            Em.Object.create({isAdvanced: false, isActive: false, name: 'settings', isHiddenByFilter: true}),
            Em.Object.create({isAdvanced: true, isActive: false, name: 'advanced', isHiddenByFilter: false})
          ],
          m: 'Should make `advanced` active (1)',
          e: 'advanced'
        },
        {
          tabs: [
            Em.Object.create({isAdvanced: false, isActive: true, name: 'settings', isHiddenByFilter: false}),
            Em.Object.create({isAdvanced: true, isActive: false, name: 'advanced', isHiddenByFilter: false})
          ],
          m: 'Should make `settings` active (2)',
          e: 'settings'
        },
        {
          tabs: [
            Em.Object.create({isAdvanced: false, isActive: true, name: 'settings', isHiddenByFilter: true}),
            Em.Object.create({isAdvanced: true, isActive: false, name: 'advanced', isHiddenByFilter: false})
          ],
          m: 'Should make `advanced` active (2)',
          e: 'advanced'
        },
        {
          tabs: [
            Em.Object.create({isAdvanced: false, isActive: false, name: 'settings', isHiddenByFilter: false}),
            Em.Object.create({isAdvanced: true, isActive: false, name: 'advanced', isHiddenByFilter: false})
          ],
          m: 'Should make `settings` active (3)',
          e: 'settings'
        },
        {
          tabs: [
            Em.Object.create({isAdvanced: false, isActive: false, name: 'settings', isHiddenByFilter: false}),
            Em.Object.create({isAdvanced: true, isActive: true, name: 'advanced', isHiddenByFilter: false})
          ],
          m: 'Should make `advanced` active (3)',
          e: 'advanced'
        }
    ]).forEach(function (test) {
        it(test.m, function () {
          view.pickActiveTab(test.tabs);
          expect(test.tabs.findProperty('name', test.e).get('isActive')).to.be.true;
        });
      });

  });

});

});

require.register("test/views/common/configs/service_configs_by_category_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/chart/pie');
require('views/common/configs/services_config');

describe('App.ServiceConfigsByCategoryView', function () {

  var view = App.ServiceConfigsByCategoryView.create({
    serviceConfigs: []
  });

  var testData = [
    {
      title: 'four configs in correct order',
      configs: [
        Em.Object.create({index: 1, resultId: 1}),
        Em.Object.create({index: 2, resultId: 2}),
        Em.Object.create({index: 3, resultId: 3}),
        Em.Object.create({index: 4, resultId: 4})
      ]
    },
    {
      title: 'four configs in reverse order',
      configs: [
        Em.Object.create({index: 4, resultId: 4}),
        Em.Object.create({index: 3, resultId: 3}),
        Em.Object.create({index: 2, resultId: 2}),
        Em.Object.create({index: 1, resultId: 1})
      ]
    },
    {
      title: 'four configs in random order',
      configs: [
        Em.Object.create({index: 3, resultId: 3}),
        Em.Object.create({index: 4, resultId: 4}),
        Em.Object.create({index: 1, resultId: 1}),
        Em.Object.create({index: 2, resultId: 2})
      ]
    },
    {
      title: 'four configs with no index',
      configs: [
        Em.Object.create({resultId: 1}),
        Em.Object.create({resultId: 2}),
        Em.Object.create({resultId: 3}),
        Em.Object.create({resultId: 4})
      ]
    },
    {
      title: 'four configs but one with index',
      configs: [
        Em.Object.create({resultId: 2}),
        Em.Object.create({resultId: 3}),
        Em.Object.create({resultId: 4}),
        Em.Object.create({index: 1, resultId: 1})
      ]
    },
    {
      title: 'index is null or not number',
      configs: [
        Em.Object.create({index: null, resultId: 3}),
        Em.Object.create({index: 1, resultId: 1}),
        Em.Object.create({index: 2, resultId: 2}),
        Em.Object.create({index: 'a', resultId: 4})
      ]
    },
    {
      title: 'four configs when indexes skipped',
      configs: [
        Em.Object.create({index: 88, resultId: 3}),
        Em.Object.create({index: 67, resultId: 2}),
        Em.Object.create({index: 111, resultId: 4}),
        Em.Object.create({index: 3, resultId: 1})
      ]
    }
  ];

  App.TestAliases.testAsComputedIfThenElse(view, 'isCategoryBodyVisible', 'category.isCollapsed', 'display: none;', 'display: block;');

  describe('#sortByIndex', function () {
    var result = [1, 2, 3, 4];
    testData.forEach(function(_test){
      it(_test.title, function () {
        expect(view.sortByIndex(_test.configs).mapProperty('resultId')).to.deep.equal(result);
      })
    })
  });

  describe('#isShowBlock', function() {
    var tests = [
      {
        categoryConfigs: Em.A([
          Em.Object.create({ isHiddenByFilter: false })
        ]),
        category: {},
        m: 'no configs with widget, filtered properties are visible. Panel should be shown',
        e: true
      },
      {
        categoryConfigs: Em.A([]),
        category: Em.Object.create({ customCanAddProperty: true}),
        m: 'Category with custom properties. Panel shouldn\'t be shown',
        e: false
      },
      {
        categoryConfigs: Em.A([
          Em.Object.create({ isHiddenByFilter: false })
        ]),
        category: Em.Object.create({ customCanAddProperty: true}),
        m: 'Category with custom properties. Filtered configs are hidden. Panel should be shown',
        e: true
      },
      {
        categoryConfigs: Em.A([
          Em.Object.create({ isHiddenByFilter: true })
        ]),
        category: Em.Object.create({ customCanAddProperty: false }),
        m: 'Filtered configs are hidden. Category not for custom properties. Panel should be hidden',
        e: false
      },
      {
        categoryConfigs: Em.A([]),
        category: Em.Object.create({ customCanAddProperty: false }),
        m: 'Category without properties and not for custom configurations. Panel should be hidden',
        e: false
      },
      {
        categoryConfigs: Em.A([
          Em.Object.create({ widget: {someProp: 'a'}}),
          Em.Object.create({ widget: {someProp: 'b'}})
        ]),
        category: Em.Object.create({ customCanAddProperty: false }),
        m: 'All properties have widgets and category is not custom. Panel should be hidden',
        e: false
      },
      {
        categoryConfigs: Em.A([
          Em.Object.create({ widget: null }),
          Em.Object.create({ widget: null })
        ]),
        category: Em.Object.create({ customCanAddProperty: false }),
        m: 'All properties have widgets set to `null` and category is not custom. Panel should be hidden',
        e: false
      },
      {
        categoryConfigs: Em.A([
          Em.Object.create({ widget: {someProp: 'a'} }),
          Em.Object.create({ isHiddenByFilter: true })
        ]),
        category: Em.Object.create({ customCanAddProperty: false }),
        m: 'Category contains mixed properties. Properties are hidden by filter. Panel should be hidden',
        e: false
      },
      {
        categoryConfigs: Em.A([
          Em.Object.create({ widget: {someProp: 'a'} }),
          Em.Object.create({ isHiddenByFilter: false })
        ]),
        category: Em.Object.create({ customCanAddProperty: false }),
        m: 'Category contains mixed properties. Properties are visible. Panel should be shown',
        e: true
      }
    ];

    beforeEach(function () {
      this._view = App.ServiceConfigsByCategoryView.create({
        serviceConfigs: Em.A([])
      });
      sinon.stub(this._view, 'filteredCategoryConfigs', Em.K);
    });

    afterEach(function () {
      this._view.filteredCategoryConfigs.restore();
      this._view.destroy();
    });

    tests.forEach(function(test) {
      it(test.m, function() {
        this._view.reopen({
          category: test.category,
          categoryConfigs: test.categoryConfigs
        });
        expect(this._view.get('isShowBlock')).to.be.eql(test.e);

      });
    });
  });

  describe('#isSecureConfig', function () {

    var cases = [
      {
        name: 'n0',
        filename: 'f0',
        isSecureConfig: true,
        title: 'secure config'
      },
      {
        name: 'n1',
        filename: 'f1',
        isSecureConfig: false,
        title: 'secure config with the same name is present in another filename'
      },
      {
        name: 'n2',
        filename: 'f2',
        isSecureConfig: false,
        title: 'no configs of the specified filename are secure'
      }
    ];

    before(function () {
      App.config.reopen({
        secureConfigs: [
          {
            name: 'n0',
            filename: 'f0'
          },
          {
            name: 'n1',
            filename: 'f0'
          },
          {
            name: 'n2',
            filename: 'f1'
          }
        ]
      })
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(view.isSecureConfig(item.name, item.filename)).to.equal(item.isSecureConfig);
      });
    });

  });

  describe('#categoryConfigs', function () {
    var result = [1, 2, 3, 4, 5];
    var cases = [
        {
          categoryNname: 'TestCategory',
          serviceConfigs: [
            Em.Object.create({category: "TestCategory", index: 1, name: "a", isVisible: true, resultId: 1}),
            Em.Object.create({category: "TestCategory", index: 2, name: "b", isVisible: true, resultId: 2}),
            Em.Object.create({category: "TestCategory", index: 5, name: "c", isVisible: true, resultId: 5}),
            Em.Object.create({category: "TestCategory", index: 4, name: "d", isVisible: true, resultId: 4}),
            Em.Object.create({category: "TestCategory", index: 3, name: "e", isVisible: true, resultId: 3})
          ],
          title: 'Order by index with no content type'
        },
        {
          categoryNname: 'TestCategory',
          serviceConfigs: [
            Em.Object.create({category: "TestCategory", index: 1, name: "a", isVisible: true, resultId: 1, displayType: 'int'}),
            Em.Object.create({category: "TestCategory", index: 2, name: "b", isVisible: true, resultId: 4, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", index: 3, name: "c", isVisible: true, resultId: 2}),
            Em.Object.create({category: "TestCategory", index: 4, name: "d", isVisible: true, resultId: 5, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", index: 5, name: "e", isVisible: true, resultId: 3})
          ],
          title: 'Order configs by index and display type equal to content'
        },
        {
          categoryNname: 'TestCategory',
          serviceConfigs: [
            Em.Object.create({category: "TestCategory", name: "a", isVisible: true, resultId: 1, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", name: "b", isVisible: true, resultId: 2, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", name: "c", isVisible: true, resultId: 3, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", name: "d", isVisible: true, resultId: 4, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", name: "e", isVisible: true, resultId: 5, displayType: 'content'})
          ],
          title: 'Order configs by display type equal to content - so they will be sorted alphabetically'
        },
        {
          categoryNname: 'TestCategory',
          serviceConfigs: [
            Em.Object.create({category: "TestCategory", index: 5, name: "a", isVisible: true, resultId: 1, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", index: 4, name: "b", isVisible: true, resultId: 2, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", index: 3, name: "c", isVisible: true, resultId: 3, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", index: 2, name: "d", isVisible: true, resultId: 4, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", index: 1, name: "e", isVisible: true, resultId: 5, displayType: 'content'})
          ],
          title: 'Order configs by display type equal to content - so they will be sorted alphabetically not by index'
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        view = App.ServiceConfigsByCategoryView.create({
          category: {
            name: item.categoryNname
          },
          serviceConfigs: item.serviceConfigs,
          filteredCategoryConfigs: Em.K,
          collapseCategory: Em.K
        });
        view.setCategoryConfigsAll();
        view.setVisibleCategoryConfigs();
        expect(view.get('categoryConfigs').mapProperty('resultId')).to.deep.equal(result);
        view.destroy();
      });
    });
  });

});

});

require.register("test/views/common/configs/widgets/combo_config_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.ComboConfigWidgetView', function() {

  beforeEach(function() {
    this.view = App.ComboConfigWidgetView.create({
      initPopover: Em.K,
      movePopover: Em.K
    });
  });

  afterEach(function() {
    this.view.destroy();
    this.view = null;
  });

  describe('#convertToWidgetUnits', function() {
    var tests = [
      {
        valueAttributes: {
          entries: [
            {
              label: "Item A",
              value: "a"
            },
            {
              label: "Item B",
              value: "b"
            },
          ]
        },
        e: [
          {
            configValue: "a",
            widgetValue: "Item A"
          },
          {
            configValue: "b",
            widgetValue: "Item B"
          }
        ]
      }
    ];

    tests.forEach(function(test) {
      it('should convert {0} to {1}'.format(JSON.stringify(test.valueAttributes), JSON.stringify(test.e)), function() {
        var result = this.view.convertToWidgetUnits(test.valueAttributes);
        expect(JSON.parse(JSON.stringify(result))).to.eql(test.e);
      });
    });
  });

  describe('#generateWidgetValue', function() {
    var tests = [
      {
        valuesList: [
          Em.Object.create({
            configValue: 'a',
            widgetValue: 'Item A'
          }),
          Em.Object.create({
            configValue: 'b',
            widgetValue: 'Item B'
          })
        ],
        value: 'a',
        e: 'Item A'
      },
      {
        valuesList: [
          Em.Object.create({
            configValue: 'a',
            widgetValue: 'Item A'
          }),
          Em.Object.create({
            configValue: 'b',
            widgetValue: 'Item B'
          })
        ],
        value: 'b',
        e: 'Item B'
      }
    ];

    tests.forEach(function(test) {
      it('should convert config value: `{0}` to widget value: `{1}`'.format(test.value, test.e), function() {
        this.view.set('content', {});
        this.view.set('content.valuesList', Em.A(test.valuesList));
        this.view.set('config', {
          isValid: true,
          value: test.value
        });
        expect(this.view.generateWidgetValue(test.value)).to.be.equal(test.e);
      });
    });
  });

  describe('#generateConfigValue', function() {
    var tests = [
      {
        valuesList: [
          Em.Object.create({
            configValue: 'a',
            widgetValue: 'Item A'
          }),
          Em.Object.create({
            configValue: 'b',
            widgetValue: 'Item B'
          })
        ],
        value: 'Item A',
        e: 'a'
      },
      {
        valuesList: [
          Em.Object.create({
            configValue: 'a',
            widgetValue: 'Item A'
          }),
          Em.Object.create({
            configValue: 'b',
            widgetValue: 'Item B'
          })
        ],
        value: 'Item B',
        e: 'b'
      }
    ];

    tests.forEach(function(test) {
      it('should convert widget value: `{0}` to config value: `{1}`'.format(test.value, test.e), function() {
        this.view.set('content', {});
        this.view.set('content.valuesList', Em.A(test.valuesList));
        expect(this.view.generateConfigValue(test.value)).to.be.equal(test.e);
      });
    });
  });

  describe('#isValueCompatibleWithWidget()', function() {
    beforeEach(function() {
      this.view.set('content', {});
      this.view.set('config', {});
    });
    it('pass validation', function() {
      this.view.set('config.isValid', true);
      this.view.set('config.value', 'v1');
      this.view.set('content.valuesList', [{configValue: 'v1'}, {configValue: 'v2'}]);
      expect(this.view.isValueCompatibleWithWidget()).to.be.true;
    });

    it('fail validation by isValid', function() {
      this.view.set('config.isValid', false);
      expect(this.view.isValueCompatibleWithWidget()).to.be.false;
    });

    it('fail validation value that missing from list', function() {
      this.view.set('config.isValid', true);
      this.view.set('config.value', 'v3');
      this.view.set('content.valuesList', [{configValue: 'v1'}, {configValue: 'v2'}]);
      expect(this.view.isValueCompatibleWithWidget()).to.be.false;
    });
  });
});

});

require.register("test/views/common/configs/widgets/config_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var view;

function getView() {
  return App.ConfigWidgetView.create({
    initPopover: Em.K,
    movePopover: Em.K,
    config: Em.Object.create({
      isOriginalSCP: false,
      isPropertyOverridable: false,
      cantBeUndone: false,
      isNotDefaultValue: false
    })
  });
}

describe('App.ConfigWidgetView', function () {

  beforeEach(function () {
    view = getView();
  });

  App.TestAliases.testAsComputedAnd(getView(), 'showPencil', ['supportSwitchToTextBox', '!disabled']);

  App.TestAliases.testAsComputedOr(getView(), 'doNotShowWidget', ['isPropertyUndefined', 'config.showAsTextBox']);

  App.TestAliases.testAsComputedEqual(getView(), 'isPropertyUndefined', 'config.value', 'Undefined');

  describe('#undoAllowed', function () {

    Em.A([
      {
        cfg: {
          cantBeUndone: false,
          isNotDefaultValue: false
        },
        view: {
          disabled: false,
          isOriginalSCP: false
        },
        e: false
      },
      {
        cfg: {
          cantBeUndone: true,
          isNotDefaultValue: false
        },
        view: {
          disabled: false,
          isOriginalSCP: false
        },
        e: false
      },
      {
        cfg: {
          cantBeUndone: false,
          isNotDefaultValue: true
        },
        view: {
          disabled: false,
          isOriginalSCP: true
        },
        e: true
      },
      {
        cfg: {
          cantBeUndone: true,
          isNotDefaultValue: true
        },
        view: {
          disabled: true,
          isOriginalSCP: false
        },
        e: false
      }
    ]).forEach(function (test, index) {
        it('test #' + index, function () {
          view.get('config').setProperties(test.cfg);
          view.setProperties(test.view);
          expect(view.get('undoAllowed')).to.equal(test.e);
        });
      });

  });

  describe('#overrideAllowed', function () {

    Em.A([
        {
          cfg: {
            isOriginalSCP: false,
            isPropertyOverridable: false,
            isComparison: false
          },
          e: false
        },
        {
          cfg: {
            isOriginalSCP: true,
            isPropertyOverridable: false,
            isComparison: false
          },
          e: false
        },
        {
          cfg: {
            isOriginalSCP: false,
            isPropertyOverridable: true,
            isComparison: false
          },
          e: false
        },
        {
          cfg: {
            isOriginalSCP: true,
            isPropertyOverridable: true,
            isComparison: false
          },
          e: true
        },
        {
          cfg: {
            isOriginalSCP: false,
            isPropertyOverridable: false,
            isComparison: true
          },
          e: false
        },
        {
          cfg: {
            isOriginalSCP: true,
            isPropertyOverridable: false,
            isComparison: true
          },
          e: false
        },
        {
          cfg: {
            isOriginalSCP: false,
            isPropertyOverridable: true,
            isComparison: true
          },
          e: false
        },
        {
          cfg: {
            isOriginalSCP: true,
            isPropertyOverridable: true,
            isComparison: true
          },
          e: false
        }
      ]).forEach(function (test, index) {
        it('test #' + index, function () {
          view.get('config').setProperties(test.cfg);
          expect(view.get('overrideAllowed')).to.equal(test.e);
        });
      });

  });

  describe('#restoreDependentConfigs', function() {
    beforeEach(function() {
      view = App.ConfigWidgetView.create({
        controller: Em.Object.extend(App.EnhancedConfigsMixin, {
        }).create({
          updateDependentConfigs: function() {}
        }),
        config: Em.Object.create({ name: 'config1'})
      });
    });

    var tests = [
      {
        dependentConfigs: [
          {name: 'dependent1', parentConfigs: ['config1']},
          {name: 'dependent2', parentConfigs: ['config2']},
          {name: 'dependent3', parentConfigs: ['config1']}
        ],
        e: ['dependent2'],
        m: 'when dependent configs has one parent they should be removed'
      },
      {
        dependentConfigs: [
          {name: 'dependent1', parentConfigs: ['config1', 'config2']},
          {name: 'dependent2', parentConfigs: ['config2']},
          {name: 'dependent3', parentConfigs: ['config1']}
        ],
        e: ['dependent1', 'dependent2'],
        m: 'when dependent configs has multiple parents they should not be removed'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        view.set('controller.recommendations', test.dependentConfigs);
        view.restoreDependentConfigs(view.get('config'));
        expect(view.get('controller.recommendations').mapProperty('name')).to.be.eql(test.e);
      });
    });

    describe('when dependent configs has multiple parents appropriate parent config should be removed', function() {

      beforeEach(function () {
        view.set('controller.recommendations', [
          {name: 'dependent1', parentConfigs: ['config1', 'config2']},
          {name: 'dependent2', parentConfigs: ['config2', 'config1']},
          {name: 'dependent3', parentConfigs: ['config1']}
        ]);
        view.restoreDependentConfigs(view.get('config'));
      });

      it('2 recommendations', function () {
        expect(view.get('controller.recommendations.length')).to.be.equal(2);
      });

      it('dependent1 parent is ["config2"]', function () {
        expect(view.get('controller.recommendations').findProperty('name', 'dependent1').parentConfigs.toArray()).to.be.eql(["config2"]);
      });
      it('dependent2 parent is ["config2"]', function () {
        expect(view.get('controller.recommendations').findProperty('name', 'dependent2').parentConfigs.toArray()).to.be.eql(["config2"]);
      });

    });

    describe('dependent config value should be set with inital or saved when it has one parent', function() {
      var ctrl;

      beforeEach(function () {
        ctrl = view.get('controller');
        ctrl.set('stepConfigs', [
          Em.Object.create({
            configs: Em.A([
              Em.Object.create({ name: 'dependent3', savedValue: '1', value: 2, filename: 'some-file.xml' }),
              Em.Object.create({ name: 'dependent2', savedValue: '4', value: '10', filename: 'some-file.xml' })
            ])
          })
        ]);
        view.set('controller.recommendations', [
          {propertyName: 'dependent1', parentConfigs: ['config1', 'config2'], fileName: 'some-file' },
          {propertyName: 'dependent2', parentConfigs: ['config2', 'config1'], fileName: 'some-file'},
          {propertyName: 'dependent3', parentConfigs: ['config1'], fileName: 'some-file' }
        ]);
        view.restoreDependentConfigs(view.get('config'));
      });

      it('dependent3 value is `1`', function () {
        expect(App.config.findConfigProperty(ctrl.get('stepConfigs'), 'dependent3', 'some-file.xml').get('value')).to.be.equal('1');
      });

      it('dependent2 value is `10`', function () {
        // config with multi dependency should not be updated
        expect(App.config.findConfigProperty(ctrl.get('stepConfigs'), 'dependent2', 'some-file.xml').get('value')).to.be.equal('10');
      });

    });

  });

  describe('#isValueCompatibleWithWidget()', function() {
    it('pass validation', function() {
      view.set('config.isValid', true);
      expect(view.isValueCompatibleWithWidget()).to.be.true;
    });

    it('fail validation', function() {
      view.set('config.isValid', false);
      view.set('supportSwitchToTextBox', true);
      expect(view.isValueCompatibleWithWidget()).to.be.false;
    });
  });

  describe('#setRecommendedValue', function () {

    beforeEach(function () {
      sinon.stub(view, 'sendRequestRorDependentConfigs', function () {
        return $.Deferred().resolve().promise();
      });
      sinon.stub(view, 'restoreDependentConfigs', Em.K);
      view.set('config', Em.Object.create({
        value: 1,
        recommendedValue: 1,
        savedValue: 1
      }));
    });

    afterEach(function () {
      view.sendRequestRorDependentConfigs.restore();
      view.restoreDependentConfigs.restore();
    });

    it('should call restoreDependentConfigs if config.value is equal to config.savedValue', function () {
      view.setRecommendedValue();
      expect(view.restoreDependentConfigs.calledOnce).to.be.true;
    });

    it('should not call restoreDependentConfigs if config.value is not equal to config.savedValue', function () {
      view.set('config.savedValue', 2);
      view.setRecommendedValue();
      expect(view.restoreDependentConfigs.called).to.be.false;
    });

  });

  describe('#showFinalConfig', function () {

    [
      {
        config: {
          isFinal: true,
          isNotEditable: true,
          isHover: true
        },
        e: true
      },
      {
        config: {
          isFinal: true,
          isNotEditable: false,
          isHover: true
        },
        e: true
      },{
        config: {
          isFinal: true,
          isNotEditable: true,
          isHover: false
        },
        e: true
      },{
        config: {
          isFinal: true,
          isNotEditable: false,
          isHover: false
        },
        e: true
      },
      {
        config: {
          isFinal: false,
          isNotEditable: true,
          isHover: true
        },
        e: false
      },
      {
        config: {
          isFinal: false,
          isNotEditable: false,
          isHover: true
        },
        e: false
      },{
      config: {
        isFinal: false,
        isNotEditable: true,
        isHover: false
      },
      e: false
    },{
      config: {
        isFinal: false,
        isNotEditable: false,
        isHover: false
      },
      e: false
    }
    ].forEach(function (test) {

      it(JSON.stringify(test.config), function () {
        view.set('config', Em.Object.create(test.config));
        expect(view.get('showFinalConfig')).to.be.equal(test.e);
      });

    })

  });

  describe('#toggleFinalFlag', function () {

    [
      {isNotEditable: true, isFinal: false},
      {isNotEditable: false, isFinal: true}
    ].forEach(function (test) {
      it('config.isNotEditable ' + test.isNotEditable, function () {
        var config = Em.Object.create({isNotEditable: test.isNotEditable, isFinal: false});
        view.toggleFinalFlag({context: config});
        expect(config.get('isFinal')).to.be.equal(test.isFinal);
      });
    });

  });

  describe('#issueView', function () {

    beforeEach(function () {
      this.issueView = getView().get('issueView').create({config: Em.Object.create()});
      sinon.stub(App, 'tooltip', Em.K);
    });

    afterEach(function () {
      App.tooltip.restore();
    });

    describe('#didInsertElement', function () {

      beforeEach(function () {
        this.issueView.errorLevelObserver = Em.K;
        sinon.spy(this.issueView, 'addObserver');
      });

      afterEach(function () {
        this.issueView.addObserver.restore();
      });

      [
        'issuedConfig.warnMessage',
        'issuedConfig.errorMessage',
        'parentView.isPropertyUndefined'
      ].forEach(function (field) {
        it('add observer for ' + field, function () {
          this.issueView.didInsertElement();
          expect(this.issueView.addObserver.calledWith(field, this.issueView, this.issueView.errorLevelObserver)).to.be.true;
        });
      });

    });

    describe('#willDestroyElement', function () {

      beforeEach(function () {
        this.issueView.errorLevelObserver = Em.K;
        sinon.spy(this.issueView, 'removeObserver');
      });

      afterEach(function () {
        this.issueView.removeObserver.restore();
      });

      [
        'issuedConfig.warnMessage',
        'issuedConfig.errorMessage',
        'parentView.isPropertyUndefined'
      ].forEach(function (field) {
        it('remove observer for ' + field, function () {
          this.issueView.willDestroyElement();
          expect(this.issueView.removeObserver.calledWith(field, this.issueView, this.issueView.errorLevelObserver)).to.be.true;
        });
      });

    });

    describe('#errorLevelObserver', function () {

      beforeEach(function () {

        this.issueView.set('parentView', Em.Object.create());

      });

      [
        {
          issuedConfig: Em.Object.create({
            errorMessage: '123',
            warnMessage: ''
          }),
          isPropertyUndefined: true,
          e: {
            configLabelClass: '',
            issueIconClass: 'hide',
            issueMessage: false
          }
        },
        {
          issuedConfig: Em.Object.create({
            errorMessage: '123',
            warnMessage: ''
          }),
          isPropertyUndefined: false,
          e: {
            configLabelClass: 'text-error',
            issueIconClass: '',
            issueMessage: '123'
          }
        },
        {
          issuedConfig: Em.Object.create({
            errorMessage: '',
            warnMessage: '321'
          }),
          isPropertyUndefined: true,
          e: {
            configLabelClass: '',
            issueIconClass: 'hide',
            issueMessage: false
          }
        },
        {
          issuedConfig: Em.Object.create({
            errorMessage: '',
            warnMessage: '321'
          }),
          isPropertyUndefined: false,
          e: {
            configLabelClass: 'text-warning',
            issueIconClass: 'warning',
            issueMessage: '321'
          }
        },
        {
          issuedConfig: Em.Object.create({
            errorMessage: '',
            warnMessage: ''
          }),
          isPropertyUndefined: true,
          e: {
            configLabelClass: '',
            issueIconClass: 'hide',
            issueMessage: false
          }
        },
        {
          issuedConfig: Em.Object.create({
            errorMessage: '',
            warnMessage: ''
          }),
          isPropertyUndefined: false,
          e: {
            configLabelClass: '',
            issueIconClass: 'hide',
            issueMessage: false
          }
        },
      ].forEach(function (test, index) {
        describe('case #' + (index + 1), function () {

          beforeEach(function () {
            this.issueView.reopen({issuedConfig: test.issuedConfig, parentView: Em.Object.create()});
            this.issueView.set('parentView.isPropertyUndefined', test.isPropertyUndefined);
            this.issueView.errorLevelObserver();
          });

          it('`parentView.configLabelClass`', function () {
            expect(this.issueView.get('parentView.configLabelClass')).to.be.equal(test.e.configLabelClass);
          });

          it('`issueIconClass`', function () {
            expect(this.issueView.get('issueIconClass')).to.be.equal(test.e.issueIconClass);
          });

          it('`issueMessage`', function () {
            expect(this.issueView.get('issueMessage')).to.be.equal(test.e.issueMessage);
          });

          it('`parentView.issueMessage`', function () {
            expect(this.issueView.get('parentView.issueMessage')).to.be.equal(test.e.issueMessage);
          });

        });
      });

    });

  });

  describe('#updateWarningsForCompatibilityWithWidget', function () {

    [
      {
        message: '',
        configLabelClass: ''
      },
      {
        message: 'not empty message',
        configLabelClass: 'text-warning'
      }
    ].forEach(function (test) {
      describe('message - ' + JSON.stringify(test.message), function () {

        beforeEach(function () {
          view.set('config', Em.Object.create());
          view.updateWarningsForCompatibilityWithWidget(test.message);
        });

        it('`warnMessage`', function () {
          expect(view.get('warnMessage')).to.be.equal(test.message);
        });

        it('`config.warnMessage`', function () {
          expect(view.get('config.warnMessage')).to.be.equal(test.message);
        });

        it('`issueMessage`', function () {
          expect(view.get('issueMessage')).to.be.equal(test.message);
        });

        it('`configLabelClass`', function () {
          expect(view.get('configLabelClass')).to.be.equal(test.configLabelClass);
        });

      });
    })

  });

  describe('#widgetToTextBox', function () {

    it('should set `config.showAsTextBox` true', function () {
      Em.setFullPath(view, 'config.showAsTextBox', false);
      view.widgetToTextBox();
      expect(view.get('config.showAsTextBox')).to.be.true;
    });

  });

});

});

require.register("test/views/common/configs/widgets/list_config_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var view;
describe('App.ListConfigWidgetView', function () {

  beforeEach(function () {

    view = App.ListConfigWidgetView.create({
      initPopover: Em.K,
      movePopover: Em.K,
      config: Em.Object.create({
        validate: App.ServiceConfigProperty.prototype.validate,
        name: 'a.b.c',
        savedValue: '2,1',
        value: '2,1',
        filename: 'f1',
        isFinal: false,
        supportsFinal: true,
        widgetType: 'list-widget',
        stackConfigProperty: Em.Object.create({
          valueAttributes: {
            entries: [
              {
                value: '1',
                label: 'first label',
                description: '1'
              },
              {
                value: '2',
                label: 'second label',
                description: '2'
              },
              {
                value: '3',
                label: 'third label',
                description: '3'
              },
              {
                value: '4',
                label: '4th label',
                description: '4'
              },
              {
                value: '5',
                label: '4th label',
                description: '5'
              }
            ],
            selection_cardinality: '3'
          }
        })
      }),
      controller: App.MainServiceInfoConfigsController.create({})
    });
    view.willInsertElement();
    view.didInsertElement();

  });

  describe('#displayVal', function () {

    it('init value', function () {
      expect(view.get('displayVal')).to.equal('second label, first label');
    });

    it('deselect all', function () {
      view.get('options').setEach('isSelected', false);
      expect(view.get('displayVal')).to.equal(Em.I18n.t('services.service.widgets.list-widget.nothingSelected'));
    });

    it('check that value is trimmed', function () {
      view.get('options').setEach('isSelected', true);
      expect(view.get('displayVal').endsWith(' ...')).to.be.true;
    });

  });

  describe('#calculateOptions', function () {

    it('should create options for each entry', function () {
      view.set('options', []);
      view.calculateOptions();
      expect(view.get('options.length')).to.equal(view.get('config.stackConfigProperty.valueAttributes.entries.length'));
    });

    it('should selected options basing on `value`-property', function () {
      expect(view.get('options').mapProperty('isSelected')).to.eql([true, true, false, false, false]);
    });

    it('should set order to the options basing on `value`-property', function () {
      expect(view.get('options').mapProperty('order')).to.eql([2, 1, 0, 0, 0]);
    });

    it('should disable options basing on `valueAttributes.selection_cardinality`-property', function () {
      expect(view.get('options').everyProperty('isDisabled', false)).to.be.true;
    });

  });

  describe('#calculateInitVal', function () {

    it('should take only selected options', function () {
      expect(view.get('val').length).to.equal(2);
    });

    it('should set `val` empty if `value` is empty', function() {
      view.set('val', [{}]);
      view.set('config.value', '');
      view.calculateInitVal();
      expect(view.get('val')).to.eql([]);
    });

  });

  describe('#calculateVal', function () {
    beforeEach(function() {
      sinon.stub(view, 'sendRequestRorDependentConfigs', Em.K)
    });
    afterEach(function() {
      view.sendRequestRorDependentConfigs.restore();
    });
    it('value updates if some option', function () {
      var options = view.get('options');
      view.toggleOption({context: options[2]});
      expect(view.get('config.value')).to.equal('2,1,3');
      view.toggleOption({context: options[1]});
      expect(view.get('config.value')).to.equal('1,3');
      view.toggleOption({context: options[1]});
      expect(view.get('config.value')).to.equal('1,3,2');
    });

  });

  describe('#restoreValue', function () {

    beforeEach(function() {
      sinon.stub(view, 'restoreDependentConfigs', Em.K);
      sinon.stub(view.get('controller'), 'removeCurrentFromDependentList', Em.K);
      sinon.stub(view, 'sendRequestRorDependentConfigs', function() {return {
        done: function() {}
      }});
    });
    afterEach(function() {
      view.restoreDependentConfigs.restore();
      view.get('controller.removeCurrentFromDependentList').restore();
      view.sendRequestRorDependentConfigs.restore();
    });
    it('should restore saved value', function () {
      var options = view.get('options');
      view.toggleOption({context: options[0]});
      view.toggleOption({context: options[1]});
      view.toggleOption({context: options[2]});
      expect(view.get('config.value')).to.equal('3');
      view.restoreValue();
      expect(view.get('config.value')).to.equal('2,1');
      expect(view.get('controller.removeCurrentFromDependentList')).to.be.called;
    });

  });

  describe('#toggleOption', function () {

    beforeEach(function() {
      sinon.stub(view, 'sendRequestRorDependentConfigs', Em.K);
      view.toggleOption({context: view.get('options')[2]});
    });
    afterEach(function() {
      view.sendRequestRorDependentConfigs.restore();
    });

    describe('should doesn\'t do nothing if maximum number of options is selected', function () {

      it('isSelected', function () {
        expect(view.get('options')[2].get('isSelected')).to.be.true;
        expect(view.get('options')[3].get('isSelected')).to.be.false;
        expect(view.get('options')[4].get('isSelected')).to.be.false;
      });

      it('isDisabled', function () {
        expect(view.get('options')[3].get('isDisabled')).to.be.true;
        expect(view.get('options')[4].get('isDisabled')).to.be.true;
      });

    });

    it('should doesn\'t do nothing if maximum number of options is selected (2)', function () {

      view.toggleOption({context: view.get('options')[3]});
      expect(view.get('options')[3].get('isDisabled')).to.be.true;
      expect(view.get('options')[3].get('isSelected')).to.be.false;
    });

  });

  describe('#checkSelectedItemsCount', function () {

    beforeEach(function () {
      view.set('config.stackConfigProperty.valueAttributes.selection_cardinality', '1+');
      view.parseCardinality();
    });

    it('should check minimum count of the selected items', function () {
      view.get('options').setEach('isSelected', false);
      expect(view.get('config.errorMessage')).to.have.property('length').that.is.least(1);
      view.get('options').setEach('isSelected', true);
      expect(view.get('config.errorMessage')).to.equal('');
    });
  });

});

});

require.register("test/views/common/configs/widgets/slider_config_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var validator = require('utils/validator');
var viewInt, viewFloat, viewPercent;

describe('App.SliderConfigWidgetView', function () {

  beforeEach(function () {
    viewInt = App.SliderConfigWidgetView.create({
      initSlider: Em.K,
      initPopover: Em.K,
      movePopover: Em.K,
      slider: {
        enable: Em.K,
        disable: Em.K,
        setValue: Em.K
      },
      config: App.ServiceConfigProperty.create({
        name: 'a.b.c',
        description: 'A B C',
        value: '486',
        savedValue: '486',
        stackConfigProperty: Em.Object.create({
          valueAttributes: Em.Object.create({
            type: 'int',
            minimum: '0',
            maximum: '2096',
            unit: 'MB',
            group1: {
              maximum: '3072'
            }
          }),
          widget: Em.Object.create({
            type: 'slider',
            units: [{ 'unit-name': 'MB'}]
          })
        })
      })
    });
    viewInt.willInsertElement();
    viewInt.didInsertElement();

    viewFloat = App.SliderConfigWidgetView.create({
      initSlider: Em.K,
      initPopover: Em.K,
      slider: {
        enable: Em.K,
        disable: Em.K,
        setValue: Em.K
      },
      config: App.ServiceConfigProperty.create({
        name: 'a.b.c2',
        description: 'A B C 2',
        value: '72.2',
        savedValue: '72.2',
        stackConfigProperty: Em.Object.create({
          valueAttributes: Em.Object.create({
            type: 'float',
            minimum: '0',
            maximum: '100'
          }),
          widget: Em.Object.create({
            type: 'slider',
            units: [{ 'unit-name': 'float'}]
          })
        })
      })
    });
    viewFloat.willInsertElement();
    viewFloat.didInsertElement();

    viewPercent = App.SliderConfigWidgetView.create({
      initSlider: Em.K,
      initPopover: Em.K,
      slider: {
        enable: Em.K,
        disable: Em.K,
        setValue: Em.K
      },
      config: App.ServiceConfigProperty.create({
        name: 'a.b.c3',
        description: 'A B C 3',
        value: '0.22',
        savedValue: '0.22',
        stackConfigProperty: Em.Object.create({
          valueAttributes: Em.Object.create({
            type: 'float',
            minimum: '0',
            maximum: '0.8'
          }),
          widget: Em.Object.create({
            type: 'slider',
            units: [{ 'unit-name': 'percent'}]
          })
        })
      })
    });
    viewPercent.willInsertElement();
    viewPercent.didInsertElement();

    sinon.stub(viewInt, 'changeBoundaries', Em.K);
    sinon.stub(viewFloat, 'changeBoundaries', Em.K);
    sinon.stub(viewPercent, 'changeBoundaries', Em.K);
  });

  afterEach(function() {
    viewInt.changeBoundaries.restore();
    viewFloat.changeBoundaries.restore();
    viewPercent.changeBoundaries.restore();
  });

  describe('#mirrorValue', function () {
    it('should be equal to config.value after init', function () {
      expect(viewInt.get('mirrorValue').toString()).to.be.equal(viewInt.get('config.value'));
      expect(viewFloat.get('mirrorValue').toString()).to.be.equal(viewFloat.get('config.value'));
    });

    it('should be converted according to widget format', function() {
      expect(viewPercent.get('mirrorValue')).to.equal(22);
    });
  });

  describe('#mirrorValueObsOnce', function () {

    beforeEach(function () {
      sinon.stub(Em.run, 'once', Em.tryInvoke);
    });

    afterEach(function () {
      Em.run.once.restore();
    });

    describe('check int', function () {

      describe('valid value', function () {

        beforeEach(function () {
          viewInt.set('mirrorValue', 1000);
        });

        it('isMirrorValueValid is true', function () {
          expect(viewInt.get('isMirrorValueValid')).to.be.true;
        });
        it('config value is 1000', function () {
          expect(viewInt.get('config.value')).to.equal('1000');
        });
        it('errorMessage is empty', function () {
          expect(viewInt.get('config.errorMessage')).to.equal('');
        });
        it('warnMessage is empty', function () {
          expect(viewInt.get('config.warnMessage')).to.equal('');
        });
        it('warn is false', function () {
          expect(viewInt.get('config.warn')).to.be.false;
        });

      });

      describe('invalid value', function () {

        beforeEach(function () {
          viewInt.set('mirrorValue', 100500);
        });

        it('isMirrorValueValid is false', function () {
          expect(viewInt.get('isMirrorValueValid')).to.be.false;
        });
        it('config value is 486', function () {
          expect(viewInt.get('config.value')).to.equal('486');
        });
        it('errorMessage is empty', function () {
          expect(viewInt.get('config.errorMessage')).to.equal('');
        });
        it('warnMessage is not empty', function () {
          expect(viewInt.get('config.warnMessage')).to.have.property('length').that.is.least(1);
        });
        it('warn is true', function () {
          expect(viewInt.get('config.warn')).to.be.true;
        });

      });

    });

    describe('check float', function () {

      describe('valid value', function () {

        beforeEach(function () {
          viewFloat.set('mirrorValue', 55.5);
        });

        it('isMirrorValueValid is true', function () {
          expect(viewFloat.get('isMirrorValueValid')).to.be.true;
        });
        it('config value is 1000', function () {
          expect(viewFloat.get('config.value')).to.equal('55.5');
        });
        it('errorMessage is empty', function () {
          expect(viewFloat.get('config.errorMessage')).to.equal('');
        });
        it('warnMessage is empty', function () {
          expect(viewFloat.get('config.warnMessage')).to.equal('');
        });
        it('warn is false', function () {
          expect(viewFloat.get('config.warn')).to.be.false;
        });

      });

      describe('invalid value', function () {

        beforeEach(function () {
          viewFloat.set('mirrorValue', 100500.5);
        });

        it('isMirrorValueValid is false', function () {
          expect(viewFloat.get('isMirrorValueValid')).to.be.false;
        });
        it('config value is 1000', function () {
          expect(viewFloat.get('config.value')).to.equal('72.2');
        });
        it('errorMessage is empty', function () {
          expect(viewFloat.get('config.errorMessage')).to.equal('');
        });
        it('warnMessage is not empty', function () {
          expect(viewFloat.get('config.warnMessage')).to.have.property('length').that.is.least(1);
        });
        it('warn is true', function () {
          expect(viewFloat.get('config.warn')).to.be.true;
        });

      });

    });

    describe('check percent', function () {

      describe('valid value', function () {

        beforeEach(function () {
          viewPercent.set('mirrorValue', 32);
        });

        it('isMirrorValueValid is true', function () {
          expect(viewPercent.get('isMirrorValueValid')).to.be.true;
        });
        it('config value is 1000', function () {
          expect(viewPercent.get('config.value')).to.equal('0.32');
        });
        it('errorMessage is empty', function () {
          expect(viewPercent.get('config.errorMessage')).to.equal('');
        });
        it('warnMessage is empty', function () {
          expect(viewPercent.get('config.warnMessage')).to.equal('');
        });
        it('warn is false', function () {
          expect(viewPercent.get('config.warn')).to.be.false;
        });

      });

      describe('invalid value', function () {

        beforeEach(function () {
          viewPercent.set('mirrorValue', 100500.5);
        });

        it('isMirrorValueValid is false', function () {
          expect(viewPercent.get('isMirrorValueValid')).to.be.false;
        });
        it('config value is 1000', function () {
          expect(viewPercent.get('config.value')).to.equal('0.22');
        });
        it('errorMessage is empty', function () {
          expect(viewPercent.get('config.errorMessage')).to.equal('');
        });
        it('warnMessage is not empty', function () {
          expect(viewPercent.get('config.warnMessage')).to.have.property('length').that.is.least(1);
        });
        it('warn is true', function () {
          expect(viewPercent.get('config.warn')).to.be.true;
        });

      });

    });

  });

  describe('#getValueAttributeByGroup', function() {
    it('returns default max value', function() {
      viewInt.set('config.group', null);
      expect(viewInt.getValueAttributeByGroup('maximum')).to.equal('2096');
    });

    it('returns max value for group1', function() {
      viewInt.set('config.group', {name: 'group1'});
      expect(viewInt.getValueAttributeByGroup('maximum')).to.equal('3072');
    });

    it('minimum is missing', function () {
      viewInt.set('config.stackConfigProperty.valueAttributes.minimum', undefined);
      expect(viewInt.getValueAttributeByGroup('minimum')).to.equal('486');
    });

    it('minimum is missing, value is invalid', function () {
      viewInt.get('config').setProperties({
        'value': 3072,
        'stackConfigProperty.valueAttributes.minimum': undefined
      });
      expect(viewInt.getValueAttributeByGroup('minimum')).to.equal('2096');
    });
  });

  describe('#initSlider', function() {
    beforeEach(function() {
      this.view = App.SliderConfigWidgetView.create();
      sinon.stub(this.view, '$')
        .withArgs('input.slider-input').returns([])
        .withArgs('.ui-slider-wrapper:eq(0) .slider-tick').returns({
          eq: Em.K,
          addClass: Em.K,
          on: Em.K,
          append: Em.K,
          find: Em.K,
          css: Em.K,
          width: function() {},
          last: Em.K,
          hide: Em.K
        });
    });

    afterEach(function() {
      this.view.$.restore();
      this.view.destroy();
      this.view = null;
    });

    var tests = [
      {
        viewSetup: {
          minMirrorValue: 20,
          maxMirrorValue: 100,
          widgetRecommendedValue: 30,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'float' },
              widget: { units: [ { 'unit-name': "percent"}]}
            })
          })
        },
        e: {
          ticks: [20,30,40,60,80,90,100],
          ticksLabels: ['20 %', '', '', '60 %', '', '', '100 %']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 5,
          maxMirrorValue: 50,
          widgetRecommendedValue: 35,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'int' },
              widget: { units: [ { 'unit-name': "int"}]}
            })
          })
        },
        e: {
          ticks: [5, 16, 22, 28, 35, 39, 50],
          ticksLabels: ['5 ','', '', '28 ', '', '', '50 ']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 1,
          maxMirrorValue: 2,
          widgetRecommendedValue: 2,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'int', increment_step: 1 },
              widget: { units: [ { 'unit-name': "int"}]}
            })
          })
        },
        e: {
          ticks: [1,2],
          ticksLabels: ['1 ', '2 ']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 1,
          maxMirrorValue: 3,
          widgetRecommendedValue: 2,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'int', increment_step: 1 },
              widget: { units: [ { 'unit-name': "int"}]}
            })
          })
        },
        e: {
          ticks: [1,2,3],
          ticksLabels: ['1 ', '2 ', '3 ']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 0,
          maxMirrorValue: 3,
          widgetRecommendedValue: 2,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'int', increment_step: 1 },
              widget: { units: [ { 'unit-name': "int"}]}
            })
          })
        },
        e: {
          ticks: [0,1,2,3],
          ticksLabels: ['0 ', '1 ', '2 ', '3 ']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 1,
          maxMirrorValue: 5,
          widgetRecommendedValue: 2,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'int', increment_step: 1 },
              widget: { units: [ { 'unit-name': "int"}]}
            })
          })
        },
        e: {
          ticks: [1,2,3,4,5],
          ticksLabels: ['1 ', '', '3 ', '', '5 ']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 0,
          maxMirrorValue: 5,
          widgetRecommendedValue: 2,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'int', increment_step: 1 },
              widget: { units: [ { 'unit-name': "int"}]}
            })
          })
        },
        e: {
          ticks: [0,2,3,5],
          ticksLabels: ['0 ', '2 ', '3 ', '5 ']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 0,
          maxMirrorValue: 23,
          widgetRecommendedValue: 2,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'int', increment_step: 1 },
              widget: { units: [ { 'unit-name': "int"}]}
            })
          })
        },
        e: {
          ticks: [0,2,6,12,17,20,23],
          ticksLabels: ['0 ', '', '', '12 ', '', '', '23 ']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 1,
          maxMirrorValue: 30,
          widgetRecommendedValue: 1,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { unit: "B", type: "int", minimum: "1048576", maximum: "31457280", increment_step: "262144" },
              widget: { units: [ { 'unit-name': "MB"}]}
            })
          })
        },
        e: {
          ticks: [1, 8.25, 15.5, 22.75, 30],
          ticksLabels: ["1 MB", "", "15.5 MB", "", "30 MB"]
        }
      },
      {
        viewSetup: {
          minMirrorValue: 1,
          maxMirrorValue: 100,
          widgetRecommendedValue: 10,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: {unit: "B", type: "int", minimum: "1073741824", maximum: "107374182400", increment_step: "1073741824"},
              widget: { units: [ { 'unit-name': "GB"}]}
            })
          })
        },
        e: {
          ticks: [1, 10, 26, 51, 75, 87.5, 100],
          ticksLabels: ["1 GB", "", "", "51 GB", "", "", "100 GB"]
        }
      },
      {
        viewSetup: {
          minMirrorValue: 1,
          maxMirrorValue: 100,
          isCompareMode: true,
          widgetRecommendedValue: 10,
          config: Em.Object.create({
            isOriginalSCP: false,
            stackConfigProperty: Em.Object.create({
              valueAttributes: {unit: "B", type: "int", minimum: "1073741824", maximum: "107374182400", increment_step: "1073741824"},
              widget: { units: [ { 'unit-name': "GB"}]}
            })
          })
        },
        e: {
          ticks: [1, 26, 51, 75, 100],
          ticksLabels: ["1 GB", "", "51 GB", "", "100 GB"]
        }
      },
      {
        viewSetup: {
          minMirrorValue: 0.166,
          maxMirrorValue: 0.5,
          isCompareMode: false,
          widgetRecommendedValue: 0.166,
          config: Em.Object.create({
            isOriginalSCP: true,
            stackConfigProperty: Em.Object.create({
              valueAttributes: {unit: "MB", type: "int", minimum: "170", maximum: "512", increment_step: "256"},
              widget: {"units":[{"unit-name":"GB"}]}
            })
          })
        },
        e: {
          ticks: [0.166, 0.416, 0.5],
          ticksLabels: ["0.166 GB", "0.416 GB", "0.5 GB"]
        }
      }
    ];

    tests.forEach(function(test) {
      describe('should generate ticks: {0} - tick labels: {1}'.format(test.e.ticks, test.e.ticksLabels), function() {
        var ticks, ticksLabels;
        beforeEach(function () {
          this.view.reopen(test.viewSetup);
          this.view.set('controller', {
            isCompareMode: test.viewSetup.isCompareMode
          });
          var sliderCopy = window.Slider.prototype;
          window.Slider = function(a, b) {
            ticks = b.ticks;
            ticksLabels = b.ticks_labels;
            return {
              on: function() {
                return this;
              }
            };
          };
          this.view.willInsertElement();
          this.view.initSlider();
          window.Slider.prototype = sliderCopy;
        });

        it('ticks are ' + test.e.ticks, function () {
          expect(ticks.toArray()).to.be.eql(test.e.ticks);
        });

        it('ticksLabels are ' + test.e.ticksLabels, function () {
          expect(ticksLabels.toArray()).to.be.eql(test.e.ticksLabels);
        });
      });
    });
  });

  describe('#isValueCompatibleWithWidget', function() {
    var stackConfigProperty = null;

    beforeEach(function() {
      viewInt.set('config', App.ServiceConfigProperty.create({}));
      stackConfigProperty = {name: 'p1', widget: { units: [ { 'unit-name': "int"}]}, valueAttributes: {minimum: 1, maximum: 10, increment_step: 4, type: 'int'}};
      viewInt.set('config.stackConfigProperty', stackConfigProperty);
      viewInt.set('config.isValid', true);
    });

    it ('fail by config validation', function() {
      viewInt.set('config.isValid', false);
      expect(viewInt.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('fail by view validation', function() {
      viewInt.set('config.value', 'a');
      expect(viewInt.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('fail by view validation int', function() {
      viewInt.set('config.value', '2.2');
      expect(viewInt.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('fail by view validation float', function() {
      viewFloat.set('config.value', '2.2.2');
      viewFloat.set('validateFunction', validator.isValidFloat);
      expect(viewFloat.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('fail: to large', function() {
      viewInt.set('config.value', 12);
      expect(viewInt.isValueCompatibleWithWidget()).to.be.false;
      expect(viewInt.get('warnMessage')).to.have.property('length').that.is.least(1);
      expect(viewInt.get('issueMessage')).to.have.property('length').that.is.least(1);
    });

    it ('fail: to small', function() {
      viewInt.set('config.value', 0);
      expect(viewInt.isValueCompatibleWithWidget()).to.be.false;
      expect(viewInt.get('warnMessage')).to.have.property('length').that.is.least(1);
      expect(viewInt.get('issueMessage')).to.have.property('length').that.is.least(1);
    });

    it ('fail: for wrong step', function() {
      viewInt.set('config.stackConfigProperty', stackConfigProperty);
      viewInt.set('config.value', '3');
      expect(viewInt.isValueCompatibleWithWidget()).to.be.true;
    });

    it ('ok', function() {
      viewInt.set('config.value', 4);
      expect(viewInt.isValueCompatibleWithWidget()).to.be.true;
      expect(viewInt.get('warnMessage')).to.equal('');
      expect(viewInt.get('issueMessage')).to.equal('');
    });

  });

  describe('#formatTickLabel', function () {

    var bytesView,
      cases = [
        {
          unitLabel: 'B',
          tick: 1024,
          result: '1024B',
          title: 'no conversion'
        },
        {
          unitLabel: 'KB',
          tick: 10240,
          result: '10MB',
          title: 'one exponent up conversion'
        },
        {
          unitLabel: 'MB',
          tick: 10000,
          result: '9.766GB',
          title: 'rounding to three decimals'
        },
        {
          unitLabel: 'GB',
          tick: 10752,
          separator: ' ',
          result: '10.5 TB',
          title: 'rounding to less than three decimals, custom separator'
        },
        {
          unitLabel: 'B',
          tick: 20971520,
          result: '20MB',
          title: 'several exponents up conversion'
        },
        {
          unitLabel: 'TB',
          tick: 10000,
          result: '10000TB',
          title: 'no conversions for the highest exponent unit'
        }
      ];

    beforeEach(function () {
      bytesView = App.SliderConfigWidgetView.create();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        bytesView.set('unitLabel', item.unitLabel);
        expect(bytesView.formatTickLabel(item.tick, item.separator)).to.equal(item.result);
      });
    });

  });

});

});

require.register("test/views/common/configs/widgets/time_interval_spinner_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var view;

describe('App.TimeIntervalSpinnerView', function () {

  beforeEach(function () {
    view = App.TimeIntervalSpinnerView.create({
      movePopover: Em.K,
      controller: Em.Object.create({
        removeCurrentFromDependentList: Em.K
      }),
      initPopover: Em.K
    });
    sinon.stub(Em.run, 'once', Em.K);
  });

  afterEach(function () {
    view.destroy();
    Em.run.once.restore();
  });

  describe('#generateWidgetValue', function () {

    var createProperty = function (widgetUnits, configPropertyUnits, incrementStep) {
      return Em.Object.create({
        stackConfigProperty: Em.Object.create({
          widget: {
            units: [
              { unit: widgetUnits }
            ]
          },
          valueAttributes: {
            unit: configPropertyUnits,
            increment_step: incrementStep
          }
        })
      });
    };

    var tests = [
      {
        input: 60000,
        config: createProperty("days,hours,minutes", "milliseconds", 1000),
        e: [
          { label: 'Days', value: 0, incrementStep: 1, enabled: true},
          { label: 'Hours', value: 0, incrementStep: 1, enabled: true},
          { label: 'Minutes', value: 1, incrementStep: 1, enabled: true}
        ]
      },
      {
        input: "2592000000",
        config: createProperty("days,hours,minutes", "milliseconds", 60000),
        e: [
          { label: 'Days', value: 30, incrementStep: 1, enabled: true},
          { label: 'Hours', value: 0, incrementStep: 1, enabled: true},
          { label: 'Minutes', value: 0, incrementStep: 1, enabled: true}
        ]
      },
      {
        input: "604800000",
        config: createProperty("days,hours,minutes", "milliseconds", 60000),
        e: [
          { label: 'Days', value: 7, incrementStep: 1, enabled: true},
          { label: 'Hours', value: 0, incrementStep: 1, enabled: true},
          { label: 'Minutes', value: 0, incrementStep: 1, enabled: true}
        ]
      },
      {
        input: "804820200",
        config: createProperty("days,hours,minutes", "milliseconds", 60000),
        e: [
          { label: 'Days', value: 9, incrementStep: 1, enabled: true},
          { label: 'Hours', value: 7, incrementStep: 1, enabled: true},
          { label: 'Minutes', value: 33, incrementStep: 1, enabled: true}
        ]
      },
      {
        input: "70000",
        config: createProperty("minutes", "milliseconds", 1000),
        e: [
          { label: 'Minutes', value: 1, incrementStep: 1, enabled: true}
        ]
      },
      {
        input: "140",
        config: createProperty("hours,minutes", "minutes", 1),
        e: [
          { label: 'Hours', value: 2, incrementStep: 1, enabled: true},
          { label: 'Minutes', value: 20, incrementStep: 1, enabled: true}
        ]
      },
      {
        input: "2",
        config: createProperty("hours", "hours", 1),
        e: [
          { label: 'Hours', value: 2, incrementStep: 1, enabled: true}
        ]
      }
    ];

    tests.forEach(function (test) {
      it('should convert {0} {1} to {2}'.format(test.input, test.config.get('stackConfigProperty.valueAttributes.unit'), JSON.stringify(test.e)), function () {
        view.set('config', test.config);
        var result = view.generateWidgetValue(test.input, test.inputType, test.desiredUnits).map(function (item) {
          // remove unnecessary keys
          return App.permit(item, ['label', 'value', 'enabled', 'incrementStep']);
        });
        expect(result).to.eql(test.e);
      });
    });

  });

  describe('#parseIncrement', function () {

    var createProperty = function (widgetUnits, configPropertyUnits, incrementStep, value, min, max) {
      return Em.Object.create({
        value: value,
        isValid: true,
        stackConfigProperty: Em.Object.create({
          widget: {
            units: [
              { unit: widgetUnits }
            ]
          },
          valueAttributes: {
            unit: configPropertyUnits,
            minimum: min,
            maximum: max,
            increment_step: incrementStep
          }
        })
      });
    };

    Em.A([
        {
          input: "120000",
          config: createProperty("minutes,seconds", "milliseconds", 10000, "120000", 0, 240000),
          e: [
            { label: 'Minutes', value: 2, incrementStep: 1, enabled: true},
            { label: 'Seconds', value: 0, incrementStep: 10, enabled: true}
          ]
        },
        {
          input: "120000",
          config: createProperty("minutes,seconds", "milliseconds", 60000, "120000", "0", "240000"),
          e: [
            { label: 'Minutes', value: 2, incrementStep: 1, enabled: true},
            { label: 'Seconds', value: 0, incrementStep: 60, enabled: false}
          ]
        }
      ]).forEach(function (test) {
        it('should convert {0} {1} to {2}'.format(test.input, test.config.get('stackConfigProperty.valueAttributes.unit'), JSON.stringify(test.e)), function () {
          view.set('config', test.config);
          view.prepareContent();
          var result = view.get('content').map(function (c) {
            return App.permit(c, ['label', 'value', 'incrementStep', 'enabled']);
          });
          expect(result).to.eql(test.e);
        });
      });

  });

  describe('#checkErrors', function () {

    Em.A([
        {
          config: Em.Object.create({
            value: "540",
            isValid: true,
            stackConfigProperty: Em.Object.create({
              widget: {
                units: [
                  { unit: "hours,minutes" }
                ]
              },
              valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
            })
          }),
          e: {
            warnMessage: Em.I18n.t('config.warnMessage.outOfBoundaries.less').format("10 Minutes"),
            warn: true
          }
        },
        {
          config: Em.Object.create({
            value: "86460",
            isValid: true,
            stackConfigProperty: Em.Object.create({
              widget: {
                units: [
                  { unit: "hours,minutes" }
                ]
              },
              valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
            })
          }),
          e: {
            warnMessage: Em.I18n.t('config.warnMessage.outOfBoundaries.greater').format("24 Hours"),
            warn: true
          }
        },
        {
          config: Em.Object.create({
            value: "12000",
            stackConfigProperty: Em.Object.create({
              widget: {
                units: [
                  { unit: "hours,minutes" }
                ]
              },
              valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
            })
          }),
          e: {
            warnMessage:'',
            warn: false
          }
        }
      ]).forEach(function (test) {
        it(test.e.warn + ' ' + test.e.warnMessage, function () {
          view.set('config', test.config);
          view.prepareContent();
          view.checkErrors();
          expect(view.get('config.warnMessage')).to.equal(test.e.warnMessage);
          expect(view.get('config.warn')).to.equal(test.e.warn);
        });
      });

  });

  describe('#isValueCompatibleWithWidget', function() {
    var stackConfigProperty = null;

    beforeEach(function() {
      view.set('config', Em.Object.create({}));
      stackConfigProperty = {
        name: 'p1', valueAttributes: {
          minimum: 1, maximum: 10, increment_step: 4, type: 'int', unit: 'seconds'
        },
        widget: {
          units: [
            {
              'unit-name': 'hours,minutes'
            }
          ]
        }
      };
      view.set('config.stackConfigProperty', stackConfigProperty);
      view.set('config.isValid', true);
      view.set('maxValue', [{"value":10,"type":"hours","minValue":0,"maxValue":10,"incrementStep":1,"enabled":true},{"value":0,"type":"minutes","minValue":0,"maxValue":59,"incrementStep":1,"enabled":true}]);
      view.set('minValue', [{"value":0,"type":"hours","minValue":0,"maxValue":23,"incrementStep":1,"enabled":true},{"value":10,"type":"minutes","minValue":0,"maxValue":59,"incrementStep":1,"enabled":true}]);
    });

    it ('fail by config validation', function() {
      view.set('config.isValid', false);
      expect(view.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('fail by view validation', function() {
      view.set('config.value', 'a');
      expect(view.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('fail by view validation int', function() {
      view.set('config.value', '2.2');
      expect(view.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('fail: to large', function() {
      view.set('config.value', 12);
      expect(view.isValueCompatibleWithWidget()).to.be.false;
      expect(view.get('warnMessage')).to.have.property('length').that.is.least(1);
      expect(view.get('issueMessage')).to.have.property('length').that.is.least(1);
    });

    it ('fail: to small', function() {
      view.set('config.value', 0);
      expect(view.isValueCompatibleWithWidget()).to.be.false;
      expect(view.get('warnMessage')).to.have.property('length').that.is.least(1);
      expect(view.get('issueMessage')).to.have.property('length').that.is.least(1);
    });

    it ('fail: wrong step', function() {
      view.set('config.stackConfigProperty', stackConfigProperty);
      view.set('config.value', '3');
      expect(view.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('ok', function() {
      view.set('config.value', 4);
      expect(view.isValueCompatibleWithWidget()).to.be.true;
      expect(view.get('warnMessage')).to.equal('');
      expect(view.get('issueMessage')).to.equal('');
    });
  });

  describe('#showAsTextBox', function() {
    Em.A([
      {
        config: App.ServiceConfigProperty.create({
          value: "600",
          isValid: true,
          stackConfigProperty: Em.Object.create({
            widget: {
              units: [
                { unit: "hours,minutes" }
              ]
            },
            valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
          })
        }),
        m: 'original config with valid value should be shown as widget',
        e: false
      },
      {
        config: App.ServiceConfigProperty.create({
          value: "test",
          isValid: true,
          stackConfigProperty: Em.Object.create({
            widget: {
              units: [
                { unit: "hours,minutes" }
              ]
            },
            valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
          })
        }),
        m: 'original config with invalid value should be shown as textbox',
        e: true
      },
      {
        config: App.ServiceConfigProperty.create({
          value: "600",
          isValid: true,
          stackConfigProperty: Em.Object.create({
            widget: {
              units: [
                { unit: "hours,minutes" }
              ]
            },
            valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
          }),
          parentSCP: Em.Object.create({ value: "600" })
        }),
        m: 'overriden config have same value as original and values of both configs are valid, widget should be shown',
        e: false
      },
      {
        config: App.ServiceConfigProperty.create({
          value: "test",
          isValid: true,
          stackConfigProperty: Em.Object.create({
            widget: {
              units: [
                { unit: "hours,minutes" }
              ]
            },
            valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
          }),
          parentSCP: Em.Object.create({ value: "test" })
        }),
        m: 'overriden config have same value as original and values of both configs are NOT valid, textbox should be shown',
        e: true
      },
      {
        config: App.ServiceConfigProperty.create({
          value: "test",
          isValid: true,
          stackConfigProperty: Em.Object.create({
            widget: {
              units: [
                { unit: "hours,minutes" }
              ]
            },
            valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
          }),
          parentSCP: Em.Object.create({ value: "500" })
        }),
        m: 'overriden config have different value as original and values of override NOT valid, textbox should be shown',
        e: true
      }
    ]).forEach(function (test) {
      it(test.m, function() {
        view.set('config', test.config);
        view.didInsertElement();
        expect(view.get('config.showAsTextBox')).to.eql(test.e);
      });
    });
  });
});

});

require.register("test/views/common/configs/widgets/toggle_config_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.ToggleConfigWidgetView', function () {

  beforeEach(function () {

    this.view = App.ToggleConfigWidgetView.create({
      initSwitcher: Em.K,
      initPopover: Em.K,
      movePopover: Em.K,
      config: Em.Object.create({
        name: 'a.b.c',
        value: 'active',
        savedValue: 'active',
        stackConfigProperty: Em.Object.create({
          valueAttributes: {
            "type": "value-list",
            "entries":
              [
                {value: "active", label: "Active"},
                {value: "inactive", label: "Inactive"}
              ],
            "entries_editable": "false",
            "selection_cardinality": 1
          }
        })
      })
    });
    this.view.didInsertElement();
  });

  afterEach(function() {
    this.view.destroy();
    this.view = null;
  });

  describe('#getNewSwitcherValue', function () {

    it('should represent string value to boolean', function () {
      expect(this.view.getNewSwitcherValue('inactive')).to.be.false;
      expect(this.view.getNewSwitcherValue('active')).to.be.true;
    });

  });

  describe('#updateConfigValue', function () {

    it('should represent boolean value to string', function () {
      this.view.set('switcherValue', false);
      expect(this.view.get('config.value')).to.equal('inactive');
      this.view.set('switcherValue', true);
      expect(this.view.get('config.value')).to.equal('active');
    });

  });

  describe('#isValueCompatibleWithWidget', function () {

    it('valid', function () {
      this.view.get('config').setProperties({
        value: 'active',
        isValid: true
      });
      expect(this.view.isValueCompatibleWithWidget()).to.be.true;
      expect(this.view.get('warnMessage')).to.equal('');
      expect(this.view.get('issueMessage')).to.equal('');
    });

    it('invalid', function () {
      this.view.get('config').setProperties({
        value: 'invalid',
        isValid: true
      });
      expect(this.view.isValueCompatibleWithWidget()).to.be.false;
      expect(this.view.get('warnMessage')).to.be.not.empty;
      expect(this.view.get('issueMessage')).to.be.not.empty;
    });

  });

});

});

require.register("test/views/common/controls_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/controls_view');
var validator = require('utils/validator');
var testHelpers = require('test/helpers');

describe('App.ServiceConfigRadioButtons', function () {

  var view;

  beforeEach(function () {
    view = App.ServiceConfigRadioButtons.create();
  });

  describe('#handleDBConnectionProperty', function () {

    var cases = [
        {
          dbType: 'mysql',
          driver: 'mysql-connector-java.jar',
          serviceConfig: {
            name: 'hive_database',
            value: 'New MySQL Database',
            serviceName: 'HIVE'
          },
          controller: Em.Object.create({
            selectedService: {
              configs: [
                Em.Object.create({
                  name: 'javax.jdo.option.ConnectionURL',
                  displayName: 'Database URL'
                }),
                Em.Object.create({
                  name: 'hive_database',
                  displayName: 'Hive Database'
                })
              ]
            }
          }),
          currentStackVersion: 'HDP-2.2',
          rangerVersion: '0.4.0',
          propertyAppendTo1: 'javax.jdo.option.ConnectionURL',
          propertyAppendTo2: 'hive_database',
          isAdditionalView1Null: true,
          isAdditionalView2Null: true,
          title: 'Hive, embedded database'
        },
        {
          dbType: 'postgres',
          driver: 'postgresql.jar',
          serviceConfig: {
            name: 'hive_database',
            value: 'Existing PostgreSQL Database',
            serviceName: 'HIVE'
          },
          controller: Em.Object.create({
            selectedService: {
              configs: [
                Em.Object.create({
                  name: 'javax.jdo.option.ConnectionURL',
                  displayName: 'Database URL'
                }),
                Em.Object.create({
                  name: 'hive_database',
                  displayName: 'Hive Database'
                })
              ]
            }
          }),
          currentStackVersion: 'HDP-2.2',
          rangerVersion: '0.4.0',
          propertyAppendTo1: 'javax.jdo.option.ConnectionURL',
          propertyAppendTo2: 'hive_database',
          isAdditionalView1Null: false,
          isAdditionalView2Null: false,
          title: 'Hive, external database'
        },
        {
          dbType: 'derby',
          driver: 'driver.jar',
          serviceConfig: {
            name: 'oozie_database',
            value: 'New Derby Database',
            serviceName: 'OOZIE'
          },
          controller: Em.Object.create({
            selectedService: {
              configs: [
                Em.Object.create({
                  name: 'oozie.service.JPAService.jdbc.url',
                  displayName: 'Database URL'
                }),
                Em.Object.create({
                  name: 'oozie_database',
                  displayName: 'Oozie Database'
                })
              ]
            }
          }),
          currentStackVersion: 'HDP-2.2',
          rangerVersion: '0.4.0',
          propertyAppendTo1: 'oozie.service.JPAService.jdbc.url',
          propertyAppendTo2: 'oozie_database',
          isAdditionalView1Null: true,
          isAdditionalView2Null: true,
          title: 'Oozie, embedded database'
        },
        {
          dbType: 'oracle',
          driver: 'ojdbc6.jar',
          serviceConfig: {
            name: 'oozie_database',
            value: 'Existing Oracle Database',
            serviceName: 'OOZIE'
          },
          controller: Em.Object.create({
            selectedService: {
              configs: [
                Em.Object.create({
                  name: 'oozie.service.JPAService.jdbc.url',
                  displayName: 'Database URL'
                }),
                Em.Object.create({
                  name: 'oozie_database',
                  displayName: 'Oozie Database'
                })
              ]
            }
          }),
          currentStackVersion: 'HDP-2.2',
          rangerVersion: '0.4.0',
          propertyAppendTo1: 'oozie.service.JPAService.jdbc.url',
          propertyAppendTo2: 'oozie_database',
          isAdditionalView1Null: false,
          isAdditionalView2Null: false,
          title: 'Oozie, external database'
        },
        {
          dbType: 'mysql',
          driver: 'mysql-connector-java.jar',
          serviceConfig: {
            name: 'DB_FLAVOR',
            value: 'MYSQL',
            serviceName: 'RANGER'
          },
          controller: Em.Object.create({
            selectedService: {
              configs: [
                Em.Object.create({
                  name: 'ranger.jpa.jdbc.url'
                }),
                Em.Object.create({
                  name: 'DB_FLAVOR'
                })
              ]
            }
          }),
          currentStackVersion: 'HDP-2.2',
          rangerVersion: '0.4.0',
          propertyAppendTo1: 'ranger.jpa.jdbc.url',
          propertyAppendTo2: 'DB_FLAVOR',
          isAdditionalView1Null: true,
          isAdditionalView2Null: true,
          title: 'Ranger, HDP 2.2, external database'
        },
        {
          dbType: 'mssql',
          driver: 'sqljdbc4.jar',
          serviceConfig: {
            name: 'DB_FLAVOR',
            value: 'MSSQL',
            serviceName: 'RANGER'
          },
          controller: Em.Object.create({
            selectedService: {
              configs: [
                Em.Object.create({
                  name: 'ranger.jpa.jdbc.url'
                }),
                Em.Object.create({
                  name: 'DB_FLAVOR'
                })
              ]
            }
          }),
          currentStackVersion: 'HDP-2.3',
          rangerVersion: '0.5.0',
          propertyAppendTo1: 'ranger.jpa.jdbc.url',
          propertyAppendTo2: 'DB_FLAVOR',
          isAdditionalView1Null: false,
          isAdditionalView2Null: false,
          title: 'Ranger, HDP 2.3, external database'
        }
      ];
    var rangerVersion = '';

    before(function () {
      sinon.stub(Em.run, 'next', function (arg) {
        arg();
      });
    });

    beforeEach(function () {
      sinon.stub(view, 'sendRequestRorDependentConfigs', Em.K);
      this.stub = sinon.stub(App, 'get');
      this.stub.withArgs('currentStackName').returns('HDP');
      sinon.stub(App.StackService, 'find', function() {
        return [Em.Object.create({
          serviceName: 'RANGER',
          serviceVersion: rangerVersion || ''
        })];
      });
    });

    afterEach(function () {
      App.get.restore();
      App.StackService.find.restore();
      view.sendRequestRorDependentConfigs.restore();
    });

    after(function () {
      Em.run.next.restore();
    });

    cases.forEach(function (item) {
      describe(item.title, function () {

        var additionalView1, additionalView2;
        beforeEach(function () {
          this.stub.withArgs('currentStackVersion').returns(item.currentStackVersion);
          rangerVersion = item.rangerVersion;
          view.reopen({controller: item.controller});
          view.setProperties({
            categoryConfigsAll: item.controller.get('selectedService.configs'),
            serviceConfig: item.serviceConfig
          });

          additionalView1 = view.get('categoryConfigsAll').findProperty('name', item.propertyAppendTo1).get('additionalView');
          additionalView2 = view.get('categoryConfigsAll').findProperty('name', item.propertyAppendTo2).get('additionalView');
        });

        it('additionalView1 is ' + (item.isAdditionalView1Null ? '' : 'not') + ' null', function () {
          expect(Em.isNone(additionalView1)).to.equal(item.isAdditionalView1Null);
        });

        it('additionalView2 is ' + (item.isAdditionalView2Null ? '' : 'not') + ' null', function () {
          expect(Em.isNone(additionalView2)).to.equal(item.isAdditionalView2Null);
        });

        if (!item.isAdditionalView2Null) {
          it('additionalView2.message is valid', function () {
            expect(additionalView2.create().get('message')).to.equal(Em.I18n.t('services.service.config.database.msg.jdbcSetup').format(item.dbType, item.driver));
          });
        }

      });
    });

  });

  describe('#options', function () {

    var options = [
        {
          displayName: 'MySQL'
        },
        {
          displayName: 'New PostgreSQL Database'
        },
        {
          displayName: 'existing postgres db'
        },
        {
          displayName: 'sqla database: existing'
        },
        {
          displayName: 'SQL Anywhere database (New)'
        },
        {
          displayName: 'displayName'
        }
      ],
      classNames = ['mysql', 'new-postgres', 'postgres', 'sqla', 'new-sqla', undefined];

    beforeEach(function () {
      view.reopen({
        serviceConfig: Em.Object.create({
          options: options
        })
      });
    });

    it('should set class names for options', function () {
      expect(view.get('options').mapProperty('displayName')).to.eql(options.mapProperty('displayName'));
      expect(view.get('options').mapProperty('className')).to.eql(classNames);
    });

  });

  describe('#name', function () {

    var cases = [
      {
        serviceConfig: {
          radioName: 'n0',
          isOriginalSCP: true,
          isComparison: false
        },
        name: 'n0',
        title: 'original value'
      },
      {
        serviceConfig: {
          radioName: 'n1',
          isOriginalSCP: false,
          isComparison: true,
          compareConfigs: []
        },
        controller: {
          selectedVersion: 1
        },
        name: 'n1-v1',
        title: 'comparison view, original value'
      },
      {
        serviceConfig: {
          radioName: 'n2',
          isOriginalSCP: false,
          isComparison: true,
          compareConfigs: null
        },
        version: 2,
        name: 'n2-v2',
        title: 'comparison view, value to be compared with'
      },
      {
        serviceConfig: {
          radioName: 'n3',
          isOriginalSCP: false,
          isComparison: false,
          group: {
            name: 'g'
          }
        },
        name: 'n3-g',
        title: 'override value'
      }
    ];

    beforeEach(function () {
      view.reopen({
        serviceConfig: Em.Object.create()
      });
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        if (item.controller) {
          view.reopen({
            controller: item.controller
          });
        }
        view.set('version', item.version);
        view.get('serviceConfig').setProperties(item.serviceConfig);
        expect(view.get('name')).to.equal(item.name);
      });
    });

  });

  describe('#dontUseHandleDbConnection', function () {
    var rangerService = Em.Object.create({
      serviceName: 'RANGER'
    });
    beforeEach(function () {
      sinon.stub(App.StackService, 'find', function () {
        return [rangerService];
      });
    });

    afterEach(function () {
      App.StackService.find.restore();
    });

    var cases = [
      {
        title: 'Should return properties for old version of Ranger',
        version: '0.1',
        result: ['DB_FLAVOR', 'authentication_method']
      },
      {
        title: 'Should return properties for old version of Ranger',
        version: '0.4.0',
        result: ['DB_FLAVOR', 'authentication_method']
      },
      {
        title: 'Should return properties for old version of Ranger',
        version: '0.4.9',
        result: ['DB_FLAVOR', 'authentication_method']
      },
      {
        title: 'Should return properties for new version of Ranger',
        version: '0.5.0',
        result: ['ranger.authentication.method']
      },
      {
        title: 'Should return properties for new version of Ranger',
        version: '1.0.0',
        result: ['ranger.authentication.method']
      },
      {
        title: 'Should return properties for new version of Ranger',
        version: '0.5.0.1',
        result: ['ranger.authentication.method']
      }
    ];

    cases.forEach(function (test) {
      it(test.title, function () {
        rangerService.set('serviceVersion', test.version);
        expect(view.get('dontUseHandleDbConnection')).to.eql(test.result);
      });
    });
  });

});

describe('App.ServiceConfigRadioButton', function () {

  var view;

  beforeEach(function () {
    view = App.ServiceConfigRadioButton.create({
      parentView: Em.Object.create({
        serviceConfig: Em.Object.create()
      }),
      controller: Em.Object.create({
        wizardController: Em.Object.create({
          name: null
        })
      })
    })
  });

  describe('#disabled', function () {

    var cases = [
      {
        wizardControllerName: 'addServiceController',
        value: 'New MySQL Database',
        title: 'Add Service Wizard, new database',
        disabled: false
      },
      {
        wizardControllerName: 'installerController',
        value: 'New MySQL Database',
        title: 'Install Wizard, new database',
        disabled: false
      },
      {
        wizardControllerName: 'addServiceController',
        value: 'Existing MySQL Database',
        title: 'Add Service Wizard, existing database',
        disabled: false
      },
      {
        wizardControllerName: 'installerController',
        value: 'Existing MySQL Database',
        title: 'Install Wizard, existing database',
        disabled: false
      },
      {
        wizardControllerName: null,
        value: 'New MySQL Database',
        title: 'No installer, new database',
        disabled: true
      },
      {
        wizardControllerName: null,
        value: 'Existing MySQL Database',
        title: 'No installer, existing database',
        disabled: false
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        view.setProperties({
          'value': item.value,
          'controller.wizardController.name': item.wizardControllerName,
          'parentView.serviceConfig.isEditable': true
        });
        expect(view.get('disabled')).to.equal(item.disabled);
      });
    });

    it('parent view is disabled', function () {
      view.set('parentView.serviceConfig.isEditable', false);
      expect(view.get('disabled')).to.be.true;
    });

  });

  describe('#onChecked', function () {

    var cases = [
      {
        clicked: true,
        value: 'v1',
        sendRequestRorDependentConfigsCallCount: 1,
        updateForeignKeysCallCount: 1,
        title: 'invoked with click'
      },
      {
        clicked: false,
        value: 'v0',
        sendRequestRorDependentConfigsCallCount: 0,
        updateForeignKeysCallCount: 0,
        title: 'not invoked with click'
      }
    ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(Em.run, 'next', function (context, callback) {
            callback.call(context);
          });
          sinon.stub(view, 'sendRequestRorDependentConfigs', Em.K);
          sinon.stub(view, 'updateForeignKeys', Em.K);
          sinon.stub(view, 'updateCheck', Em.K);
          view.setProperties({
            'clicked': item.clicked,
            'parentView.serviceConfig.value': 'v0',
            'value': 'v1'
          });
          view.propertyDidChange('checked');
        });

        afterEach(function () {
          Em.run.next.restore();
          view.sendRequestRorDependentConfigs.restore();
          view.updateForeignKeys.restore();
          view.updateCheck.restore();
        });

        it('property value', function () {
          expect(view.get('parentView.serviceConfig.value')).to.equal(item.value);
        });

        it('dependent configs request', function () {
          expect(view.sendRequestRorDependentConfigs.callCount).to.equal(item.sendRequestRorDependentConfigsCallCount);
        });

        if (item.sendRequestRorDependentConfigsCallCount) {
          it('config object for dependent configs request', function () {
            expect(view.sendRequestRorDependentConfigs.firstCall.args).to.eql([
              Em.Object.create({
                value: item.value
              })
            ]);
          });
        }

        it('clicked flag reset', function () {
          expect(view.get('clicked')).to.be.false;
        });

        it('update foreign keys', function () {
          expect(view.updateForeignKeys.callCount).to.equal(item.updateForeignKeysCallCount);
        });

      });

    });

  });

});

describe('App.CheckDBConnectionView', function () {

  describe('#masterHostName', function () {

    var cases = [
        {
          serviceName: 'OOZIE',
          value: 'h0'
        },
        {
          serviceName: 'KERBEROS',
          value: 'h1'
        },
        {
          serviceName: 'HIVE',
          value: 'h2'
        },
        {
          serviceName: 'RANGER',
          value: 'h3'
        }
      ],
      categoryConfigsAll = [
        Em.Object.create({
          name: 'oozie_server_hosts',
          value: 'h0'
        }),
        Em.Object.create({
          name: 'kdc_hosts',
          value: 'h1'
        }),
        Em.Object.create({
          name: 'hive_metastore_hosts',
          value: 'h2'
        }),
        Em.Object.create({
          name: 'ranger_server_hosts',
          value: 'h3'
        })
      ];

    cases.forEach(function (item) {
      it(item.serviceName, function () {
        var view = App.CheckDBConnectionView.create({
          parentView: {
            service: {
              serviceName: item.serviceName
            },
            categoryConfigsAll: categoryConfigsAll
          }
        });
        expect(view.get('masterHostName')).to.equal(item.value);
      });
    });

  });

  describe('#setResponseStatus', function () {

    var view,
      cases = [
        {
          isSuccess: 'success',
          logsPopupBefore: null,
          logsPopup: null,
          responseCaption: Em.I18n.t('services.service.config.database.connection.success'),
          isConnectionSuccess: true,
          title: 'success, no popup displayed'
        },
        {
          isSuccess: 'success',
          logsPopupBefore: {},
          logsPopup: {
            header: Em.I18n.t('services.service.config.connection.logsPopup.header').format('MySQL', Em.I18n.t('common.success'))
          },
          responseCaption: Em.I18n.t('services.service.config.database.connection.success'),
          isConnectionSuccess: true,
          title: 'success, popup is displayed'
        },
        {
          isSuccess: 'error',
          logsPopupBefore: {},
          logsPopup: {
            header: Em.I18n.t('services.service.config.connection.logsPopup.header').format('MySQL', Em.I18n.t('common.error'))
          },
          responseCaption: Em.I18n.t('services.service.config.database.connection.failed'),
          isConnectionSuccess: false,
          title: 'error, popup is displayed'
        }
      ];

    beforeEach(function () {
      view = App.CheckDBConnectionView.create({
        databaseName: 'MySQL'
      });
      sinon.stub(view, 'setConnectingStatus', Em.K);
    });

    afterEach(function () {
      view.setConnectingStatus.restore();
    });

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          view.set('logsPopup', item.logsPopupBefore);
          view.setResponseStatus(item.isSuccess);
        });

        it('isRequestResolved is true', function () {
          expect(view.get('isRequestResolved')).to.be.true;
        });

        it('setConnectingStatus is called with valid arguments', function () {
          expect(view.setConnectingStatus.calledOnce).to.be.true;
          expect(view.setConnectingStatus.calledWith(false)).to.be.true;
        });

        it('responseCaption is valid', function () {
          expect(view.get('responseCaption')).to.equal(item.responseCaption);
        });

        it('isConnectionSuccess is valid', function () {
          expect(view.get('isConnectionSuccess')).to.equal(item.isConnectionSuccess);
        });

        it('logsPopup is valid', function () {
          expect(view.get('logsPopup')).to.eql(item.logsPopup);
        });

      });
    });

  });

  describe('#showLogsPopup', function () {

    var view;

    beforeEach(function () {
      view = App.CheckDBConnectionView.create({
        databaseName: 'MySQL'
      });
      sinon.spy(App, 'showAlertPopup');
    });

    afterEach(function () {
      App.showAlertPopup.restore();
    });

    it('successful connection', function () {
      view.set('isConnectionSuccess', true);
      view.showLogsPopup();
      expect(App.showAlertPopup.callCount).to.equal(0);
    });

    describe('failed connection without output data, popup dismissed with Close button', function () {

      beforeEach(function () {
        view.set('isConnectionSuccess', false);
        view.set('isRequestResolved', true);
        view.set('responseFromServer', 'fail');
        view.showLogsPopup();
      });

      it('showAlertPopup is called once', function () {
        expect(App.showAlertPopup.callCount).to.equal(1);
      });
      it('logsPopup.header is valid', function () {
        expect(view.get('logsPopup.header')).to.equal(Em.I18n.t('services.service.config.connection.logsPopup.header').format('MySQL', Em.I18n.t('common.error')));
      });
      it('logsPopup.body is valid', function () {
        expect(view.get('logsPopup.body')).to.equal('fail');
      });
      it('logsPopup is null after close', function () {
        view.get('logsPopup').onClose();
        expect(view.get('logsPopup')).to.be.null;
      });
    });

    describe('check in progress with output data, popup dismissed with OK button', function () {
      var response = {
        stderr: 'stderr',
        stdout: 'stdout',
        structuredOut: 'structuredOut'
      };
      beforeEach(function () {
        view.set('isConnectionSuccess', false);
        view.set('isRequestResolved', false);
        view.set('responseFromServer', response);
        view.showLogsPopup();
      });

      it('showAlertPopup is called once', function () {
        expect(App.showAlertPopup.callCount).to.equal(1);
      });
      it('logsPopup.header is valid', function () {
        expect(view.get('logsPopup.header')).to.equal(Em.I18n.t('services.service.config.connection.logsPopup.header').format('MySQL', Em.I18n.t('common.testing')));
      });
      it('logsPopup.bodyClass is valid', function () {
        expect(view.get('logsPopup.bodyClass').create().get('openedTask')).to.eql(response);
      });
      it('logsPopup is null after primary click', function () {
        view.get('logsPopup').onPrimary();
        expect(view.get('logsPopup')).to.be.null;
      });
    });

  });

  describe("#createCustomAction()", function() {
    var view;
    beforeEach(function () {
      view = App.CheckDBConnectionView.create({
        databaseName: 'MySQL',
        getConnectionProperty: Em.K,
        masterHostName: 'host1'
      });
      this.mock = sinon.stub(App.Service, 'find');
    });
    afterEach(function () {
      this.mock.restore();
    });

    it("service not installed", function() {
      this.mock.returns(Em.Object.create({isLoaded: false}));
      view.createCustomAction();
      var args = testHelpers.findAjaxRequest('name', 'custom_action.create');
      expect(args[0]).exists;
    });
    it("service is installed", function() {
      this.mock.returns(Em.Object.create({isLoaded: true}));
      view.createCustomAction();
      var args = testHelpers.findAjaxRequest('name', 'cluster.custom_action.create');
      expect(args[0]).exists;
    });
  });
});

describe('App.BaseUrlTextField', function () {

  var view = App.BaseUrlTextField.create({
    repository: Em.Object.create({
      baseUrl: 'val'
    }),
    parentView: Em.Object.create({
      uiValidation: Em.K
    })
  });

  describe('#valueWasChanged', function () {
    it('should be recalculated after value is changed', function () {
      view.setProperties({
        value: 'val',
        defaultValue: 'val'
      });
      expect(view.get('valueWasChanged')).to.be.false;
      view.set('value', 'newVal');
      expect(view.get('valueWasChanged')).to.be.true;
    });
  });

  describe('#restoreValue()', function () {
    it('should unset value', function () {
      view.setProperties({
        value: 'valNew',
        defaultValue: 'val'
      });
      view.restoreValue();
      expect(view.get('value')).to.equal('val');
    });
  });

  describe('#didInsertElement()', function () {
    it('should set defaultValue', function () {
      view.setProperties({
        value: 'valNew',
        defaultValue: 'val'
      });
      view.didInsertElement();
      expect(view.get('defaultValue')).to.equal('valNew');
    });
  });

  describe('#validate()', function () {
    beforeEach(function(){
      sinon.stub(view.get('parentView'), 'uiValidation', Em.K);
      sinon.stub(validator, 'isValidBaseUrl').returns(true);
    });
    afterEach(function(){
      view.get('parentView').uiValidation.restore();
      validator.isValidBaseUrl.restore();
    });
    it('skip validation', function () {
      view.set('repository', Em.Object.create({
        skipValidation: true
      }));
      expect(view.get('repository.hasError')).to.be.false;
    });
    it('apply validation', function () {
      view.set('repository', Em.Object.create({
          skipValidation: false
      }));
      expect(view.get('repository.hasError')).to.be.false;
      expect(validator.isValidBaseUrl.calledOnce).to.be.true;
    });
  });
});

});

require.register("test/views/common/filter_combo_cleanable_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var view;
describe('App.FilterComboCleanableView', function() {

  beforeEach(function() {
    view = App.FilterComboCleanableView.create();
  });

  describe('#didInsertElement', function() {

    beforeEach(function () {
      sinon.stub(App, 'popover', Em.K);
    });

    afterEach(function () {
      App.popover.restore();
    });

    it('should clean filter when created', function() {
      view.setProperties({
        filter: 'some value',
        popoverDescription: ['', '']
      });
      view.didInsertElement();
      expect(view.get('filter')).to.be.empty;
    });

  });

});
});

require.register("test/views/common/filter_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var filters = require('views/common/filter_view');
require('utils/helper');

describe('filters.getFilterByType', function () {

  describe('ambari-bandwidth', function () {

    var filter = filters.getFilterByType('ambari-bandwidth');
    var testData = [
      {
        condition: '<',
        value: 'any value',
        result: true
      },
      {
        condition: '=',
        value: 'any value',
        result: true
      },
      {
        condition: '>',
        value: 'any value',
        result: true
      },
      {
        condition: '1',
        value: '1GB',
        result: true
      },
      {
        condition: '1g',
        value: '1GB',
        result: true
      },
      {
        condition: '=1g',
        value: '1GB',
        result: true
      },
      {
        condition: '<1g',
        value: '0.9GB',
        result: true
      },
      {
        condition: '>1g',
        value: '1.1GB',
        result: true
      },
      {
        condition: '=1k',
        value: '1KB',
        result: true
      },
      {
        condition: '<1k',
        value: '0.9KB',
        result: true
      },
      {
        condition: '>1k',
        value: '1.1KB',
        result: true
      },
      {
        condition: '=1m',
        value: '1MB',
        result: true
      },
      {
        condition: '<1m',
        value: '0.9MB',
        result: true
      },
      {
        condition: '>1m',
        value: '1.1MB',
        result: true
      },
      {
        condition: '=1024k',
        value: '1MB',
        result: true
      },
      {
        condition: '=1024m',
        value: '1GB',
        result: true
      }
    ];

    testData.forEach(function(item){
      it('Condition: {0} - match value: {1}'.format(JSON.stringify(item.condition), JSON.stringify(item.value)), function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('duration', function () {

    var filter = filters.getFilterByType('duration');
    var testData = [
      {
        condition: '<',
        value: 'any value',
        result: true
      },
      {
        condition: '=',
        value: 'any value',
        result: true
      },
      {
        condition: '>',
        value: 'any value',
        result: true
      },
      {
        condition: '1',
        value: '1000',
        result: true
      },
      {
        condition: '1s',
        value: '1000',
        result: true
      },
      {
        condition: '=1s',
        value: '1000',
        result: true
      },
      {
        condition: '>1s',
        value: '1001',
        result: true
      },
      {
        condition: '<1s',
        value: '999',
        result: true
      },
      {
        condition: '=1m',
        value: '60000',
        result: true
      },
      {
        condition: '>1m',
        value: '60001',
        result: true
      },
      {
        condition: '<1m',
        value: '59999',
        result: true
      },
      {
        condition: '=1h',
        value: '3600000',
        result: true
      },
      {
        condition: '>1h',
        value: '3600001',
        result: true
      },
      {
        condition: '<1h',
        value: '3599999',
        result: true
      }

    ];

    testData.forEach(function(item){
      it('Condition: {0} - match value: {1}'.format(JSON.stringify(item.condition), JSON.stringify(item.value)), function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('date', function () {

    var filter = filters.getFilterByType('date');
    var testData = [
      {
        condition: 'Past 1 Day',
        value: 86300000,
        result: true
      },
      {
        condition: 'Past 2 Days',
        value: 172700000,
        result: true
      },
      {
        condition: 'Past 7 Days',
        value: 604700000,
        result: true
      },
      {
        condition: 'Past 14 Days',
        value: 1209500000,
        result: true
      },
      {
        condition: 'Past 30 Days',
        value: 2591900000,
        result: true
      },
      {
        condition: 'Any',
        value: 'any value',
        result: true
      }
    ];

    testData.forEach(function(item){
      it('Condition: {0} - match value: {1}'.format(JSON.stringify(item.condition), JSON.stringify(item.value)), function () {
        var currentTime = App.dateTime();
        item.value = currentTime - item.value;
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('number', function () {

    var filter = filters.getFilterByType('number');
    var testData = [
      {
        condition: '<',
        value: 'any value',
        result: true
      },
      {
        condition: '=',
        value: 'any value',
        result: true
      },
      {
        condition: '>',
        value: 'any value',
        result: true
      },
      {
        condition: '1',
        value: '1',
        result: true
      },
      {
        condition: '=1',
        value: '1',
        result: true
      },
      {
        condition: '<1',
        value: '0',
        result: true
      },
      {
        condition: '>1',
        value: '2',
        result: true
      }
    ];

    testData.forEach(function(item){
      it('Condition: {0} - match value: {1}'.format(JSON.stringify(item.condition), JSON.stringify(item.value)), function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('multiple', function () {

    var filter = filters.getFilterByType('multiple');
    var commonValue = [
      {componentName: 'DATANODE'},
      {componentName: 'NAMENODE'},
      {componentName: 'JOBTRACKER'}
    ];
    var testData = [
      {
        condition: 'DATANODE',
        value: commonValue,
        result: true
      },
      {
        condition: 'DATANODE,NAMENODE',
        value: commonValue,
        result: true
      },
      {
        condition: 'DATANODE,NAMENODE,JOBTRACKER',
        value: commonValue,
        result: true
      },
      {
        condition: 'JOBTRACKER,TASKTRACKER',
        value: commonValue,
        result: true
      },
      {
        condition: 'TASKTRACKER',
        value: commonValue,
        result: false
      }
    ];

    testData.forEach(function(item) {
      var substr = item.condition + (item.result ? ' - match ' : ' - doesn\'t match ');
      var components = item.value.mapProperty('componentName').join(' ');
      it('Condition: {0} value: {1}'.format(substr, components), function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('string', function () {

    var filter = filters.getFilterByType('string');

    var testData = [
      {
        condition: '',
        value: '',
        result: true
      },
      {
        condition: '',
        value: 'hello',
        result: true
      },
      {
        condition: 'hello',
        value: 'hello',
        result: true
      },
      {
        condition: 'HeLLo',
        value: 'hello',
        result: true
      },
      {
        condition: 'he',
        value: 'hello',
        result: true
      },
      {
        condition: 'lo',
        value: 'hello',
        result: true
      },
      {
        condition: 'lol',
        value: 'hello',
        result: false
      },
      {
        condition: 'hello',
        value: '',
        result: false
      },
      {
        condition: '?',
        value: 'hello',
        result: false
      }
    ];

    testData.forEach(function(item){
      var substr = item.condition + (item.result ? ' - match ' : ' - doesn\'t match ');
      it('Condition: {0} value: {1}'.format(substr, item.value), function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      });
    });
  });

  describe('sub-resource', function () {

    var filter = filters.getFilterByType('sub-resource');

    var testData = [
      {
        title: 'condition is null',
        condition: null,
        value: [Em.Object.create({
          prop1: 1
        })],
        result: true
      },
      {
        title: 'condition is empty',
        condition: [],
        value: [Em.Object.create({
          prop1: 1
        })],
        result: true
      },
      {
        title: 'condition match one property',
        condition: [
          {
            property: 'prop1',
            value: 1
          }
        ],
        value: [Em.Object.create({
          prop1: 1
        })],
        result: true
      },
      {
        title: 'condition match two properties',
        condition: [
          {
            property: 'prop1',
            value: 1
          },
          {
            property: 'prop2',
            value: 2
          }
        ],
        value: [Em.Object.create({
          prop1: 1,
          prop2: 2
        })],
        result: true
      },
      {
        title: 'only one of two properties match',
        condition: [
          {
            property: 'prop1',
            value: 3
          },
          {
            property: 'prop2',
            value: 2
          }
        ],
        value: [Em.Object.create({
          prop1: 1,
          prop2: 2
        })],
        result: false
      },
      {
        title: 'none of two properties match',
        condition: [
          {
            property: 'prop1',
            value: 3
          },
          {
            property: 'prop2',
            value: 4
          }
        ],
        value: [Em.Object.create({
          prop1: 1,
          prop2: 2
        })],
        result: false
      }
    ];

    testData.forEach(function (test) {
      it(test.title, function () {
        expect(filter(test.value, test.condition)).to.equal(test.result);
      })
    });
  });

  describe('alert_status', function () {

    var filter = filters.getFilterByType('alert_status');

    Em.A([
      {
        origin: {OK: {count: 1, maintenanceCount: 0}},
        compareValue: 'OK',
        e: true
      },
      {
        origin: {OK: {count: 0, maintenanceCount: 1}},
        compareValue: 'OK',
        e: true
      },
      {
        origin: {WARN: {count: 1, maintenanceCount: 0}},
        compareValue: 'OK',
        e: false
      },
      {
        origin: {WARN: {count: 0, maintenanceCount: 0}},
        compareValue: 'WARN',
        e: false
      },
      {
        origin: {OK: {count: 0, maintenanceCount: 0}, WARN: {count: 0, maintenanceCount: 0}},
        compareValue: 'PENDING',
        e: true
      },
      {
        origin: {},
        compareValue: 'PENDING',
        e: true
      },
      {
        origin: {OK: {count: 1, maintenanceCount: 0}},
        compareValue: 'PENDING',
        e: false
      }
    ]).forEach(function(test, i) {
        it('test #' + (i + 1), function() {
          expect(filter(test.origin, test.compareValue)).to.equal(test.e);
        });
      });

  });

  describe('alert_group', function () {

    var filter = filters.getFilterByType('alert_group');

    Em.A([
        {
          origin: [{id: 1}, {id: 2}, {id: 3}],
          compareValue: 1,
          e: true
        },
        {
          origin: [],
          compareValue: 1,
          e: false
        },
        {
          origin: [{id: 2}, {id: 3}],
          compareValue: 1,
          e: false
        }
      ]).forEach(function(test, i) {
        it('test #' + (i + 1), function() {
          expect(filter(test.origin, test.compareValue)).to.equal(test.e);
        });
      });

  });

  describe('os', function () {

    var filter = filters.getFilterByType('os');

    [
      {
        origin: [{osType: 'os1'}, {osType: 'os2'}, {osType: 'os3'}],
        compareValue: 'os1',
        e: true
      },
      {
        origin: [{osType: 'os1'}, {osType: 'os2'}, {osType: 'os3'}],
        compareValue: 'os2',
        e: true
      },
      {
        origin: [{osType: 'os1'}, {osType: 'os2'}, {osType: 'os3'}],
        compareValue: 'os3',
        e: true
      },
      {
        origin: [],
        compareValue: 'os1',
        e: false
      },
      {
        origin: [{}, {}, {}],
        compareValue: 'os1',
        e: false
      }
    ].forEach(function (test, i) {
      it('test #' + (i + 1), function () {
        expect(filter(test.origin, test.compareValue)).to.be.equal(test.e);
      });
    });

  });

  describe('range', function () {

    var filter = filters.getFilterByType('range');

    [
      {
        compareValue: [2],
        origin: 1,
        e: false
      },
      {
        compareValue: [0, 1],
        origin: 1,
        e: true
      },
      {
        compareValue: [1, 1],
        origin: 1,
        e: true
      },
      {
        compareValue: [2, 2],
        origin: 1,
        e: false
      },
      {
        compareValue: [4, 2],
        origin: 1,
        e: false
      }
    ].forEach(function (test, i) {
      it('test #' + (i + 1), function () {
        expect(filter(test.origin, test.compareValue)).to.be.equal(test.e);
      });
    });

  });

});

});

require.register("test/views/common/form/manage_kdc_credentials_form_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var credentialUtils = require('utils/credentials');

var view;

function getView() {
  return App.ManageCredentialsFormView.create({
    parentView: Em.Object.create({})
  });
}

describe('#App.ManageCredentialsFormView', function() {
  beforeEach(function() {
    view = getView();
  });

  afterEach(function() {
    view.destroy();
  });

  App.TestAliases.testAsComputedAlias(getView(), 'storePersisted', 'App.isCredentialStorePersistent', 'boolean');

  App.TestAliases.testAsComputedIfThenElse(getView(), 'formHeader', 'isRemovable', Em.I18n.t('admin.kerberos.credentials.form.header.stored'), Em.I18n.t('admin.kerberos.credentials.form.header.not.stored'));

  App.TestAliases.testAsComputedIfThenElse(getView(), 'hintMessage', 'storePersisted', Em.I18n.t('admin.kerberos.credentials.store.hint.supported'), Em.I18n.t('admin.kerberos.credentials.store.hint.not.supported'));

  describe('#prepareContent', function() {

    var credentials;

    beforeEach(function () {
      this.stub = sinon.stub(App, 'get');
      sinon.stub(credentialUtils, 'credentials', function(clusterName, callback) {
        callback(credentials);
      });
    });

    afterEach(function () {
      App.get.restore();
      credentialUtils.credentials.restore();
    });

    [
      {
        isStorePersistent: true,
        credentials: [
          {
            alias: 'kdc.admin.credential',
            type: 'persisted'
          }
        ],
        e: {
          isRemovable: true,
          isRemoveDisabled: false,
          storePersisted: true
        },
        m: 'persistent store is available, previous credentials were stored as persisted. Remove button should be visible and active.'
      },
      {
        isStorePersistent: true,
        credentials: [
          {
            alias: 'kdc.admin.credential',
            type: 'temporary'
          }
        ],
        e: {
          isRemovable: false,
          isRemoveDisabled: true,
          storePersisted: true
        },
        m: 'persistent store is available, previous credentials were stored as temporary. Remove button should be hidden and disabled.'
      }
    ].forEach(function(test) {
      it(test.m, function(done) {
        credentials = test.credentials;
        this.stub.withArgs('isCredentialStorePersistent').returns(test.e.storePersisted);
        view.prepareContent();
        Em.run.next(function() {
          assert.equal(view.get('isRemovable'), test.e.isRemovable, '#isRemovable property validation');
          assert.equal(view.get('isRemoveDisabled'), test.e.isRemoveDisabled, '#isRemoveDisabled property validation');
          assert.equal(view.get('storePersisted'), test.e.storePersisted, '#storePersisted property validation');
          done();
        });
      });
    });
  });

  describe('#isSubmitDisabled', function() {
    it('save button disabled by default', function() {
      expect(view.get('isSubmitDisabled')).to.be.true;
    });
    it('save button disabled when password is empty', function() {
      view.set('principal', 'some_principal');
      expect(view.get('isSubmitDisabled')).to.be.true;
    });
    it('save button disabled when principal is empty', function() {
      view.set('password', 'some_password');
      expect(view.get('isSubmitDisabled')).to.be.true;
    });
    it('save button should be enabled when principal and password are filled', function() {
      view.set('password', 'some_password');
      view.set('principal', 'principal');
      expect(view.get('isSubmitDisabled')).to.be.false;
    });
  });

  describe('fields validation', function() {
    var t = Em.I18n.t;

    it('should flow validation', function() {
      assert.isTrue(view.get('isSubmitDisabled'), 'submit disabled on initial state');
    });

    it('principal is not empty', function() {
      view.set('principal', ' a');
      expect(view.get('principalError')).to.equal(t('host.spacesValidation'));
      assert.isTrue(view.get('isPrincipalDirty'), 'principal name modified');
      assert.isTrue(view.get('isSubmitDisabled'), 'submit disabled because principal not valid');
    });

    it('principal is empty', function() {
      view.set('principal', ' a');
      view.set('principal', '');
      expect(view.get('principalError')).to.equal(t('admin.users.editError.requiredField'));
    });

    it('principal is not empty (2)', function() {
      view.set('principal', 'some_name');
      assert.isFalse(view.get('principalError'), 'principal name valid no message shown');
      assert.isTrue(view.get('isSubmitDisabled'), 'submit disabled because password field not modified');
    });

    it('password is updated', function() {
      view.set('password', '1');
      view.set('password', '');
      expect(view.get('passwordError')).to.equal(t('admin.users.editError.requiredField'));
      assert.isTrue(view.get('isPasswordDirty'), 'password modified');
      assert.isTrue(view.get('isSubmitDisabled'), 'submit disabled because password field is empty');
    });

    it('password is updated (2)', function() {
      view.set('password', 'some_pass');
      view.set('principal', 'some_name');
      assert.isFalse(view.get('passwordError'), 'password valid no message shown');
      assert.isFalse(view.get('isSubmitDisabled'), 'submit enabled all fields are valid');
    });

  });

  describe('#removeKDCCredentials', function() {

    var popup;

    beforeEach(function () {
      popup = view.removeKDCCredentials().popup;
      this.clock = sinon.useFakeTimers();
      sinon.stub(credentialUtils, 'removeCredentials', function() {
        var dfd = $.Deferred();
        setTimeout(function() {
          dfd.resolve();
        }, 500);
        return dfd.promise();
      });
    });

    afterEach(function () {
      popup.destroy();
      credentialUtils.removeCredentials.restore();
      this.clock.restore();
    });

    it('should show confirmation popup', function() {
      expect(popup).be.instanceof(App.ModalPopup);
    });

    it('on popup open', function() {
      assert.isFalse(view.get('actionStatus'), '#actionStatus before remove');
    });

    it('on Primary', function() {
      popup.onPrimary();
      assert.isTrue(view.get('isActionInProgress'), 'action in progress');
      assert.isTrue(view.get('isRemoveDisabled'), 'remove button disabled');
      assert.isTrue(view.get('isSubmitDisabled'), 'submit button disabled');
    });

    it('after 1s', function() {
      popup.onPrimary();
      this.clock.tick(1000);
      assert.isFalse(view.get('isActionInProgress'), 'action finished');
      assert.equal(Em.I18n.t('common.success'), view.get('actionStatus'), '#actionStatus after remove');
      assert.isTrue(view.get('parentView.isCredentialsRemoved'), 'parentView#isCredentialsRemoved property should be triggered when remove complete');
    });
  });

});

});

require.register("test/views/common/form/spinner_input_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var view;
var e;

function getView() {
  return App.SpinnerInputView.create({});
}

describe('App.SpinnerInputView', function () {

  beforeEach(function () {
    view = getView();
    e = {
      preventDefault: Em.K
    };
    sinon.spy(e, 'preventDefault');
  });

  afterEach(function () {
    e.preventDefault.restore();
  });

  App.TestAliases.testAsComputedOr(getView(), 'computedDisabled', ['!content.enabled', 'disabled']);

  describe('#keyDown', function () {

    Em.A([
      {
        charCode: 46,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 8,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 9,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 27,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 13,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 110,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 65,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 67,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 88,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 35,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      }
    ]).forEach(function (test) {
      it('charCode: ' + test.charCode + ', ctrlKey: ' + test.ctrlKey, function () {
        e.charCode = test.charCode;
        e.ctrlKey = test.ctrlKey;
        view.keyDown(e);
        expect(e.preventDefault.called).to.equal(test.e.preventDefault);
      });
    });

    Em.A([
      {
        charCode: 35,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 36,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 37,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 38,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 39,
        e: {
          preventDefault: false
        }
      }
    ]).forEach(function (test) {
      it('charCode: ' + test.charCode, function () {
        e.charCode = test.charCode;
        view.keyDown(e);
        expect(e.preventDefault.called).to.equal(test.e.preventDefault);
      });
    });

    Em.A([
      {
        charCode: 190,
        shiftKey: false,
        e: {
          preventDefault: true
        }
      },
      {
        charCode: 190,
        shiftKey: true,
        e: {
          preventDefault: true
        }
      }
    ]).forEach(function (test) {
      it('charCode: ' + test.charCode + ', shiftKey: ' + test.shiftKey, function () {
        e.charCode = test.charCode;
        e.shiftKey = test.shiftKey;
        view.keyDown(e);
        expect(e.preventDefault.calledOnce).to.equal(test.e.preventDefault);
      });
    });

  });

});

});

require.register("test/views/common/helpers/format_word_break_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var view;

describe('App.FormatWordBreakView', function () {

  beforeEach(function () {
    view = App.FormatWordBreakView.create({});
  });

  describe('#result', function () {

    Em.A([
      {content: 'abc', expected: 'abc'},
      {content: 'a.bc', expected: 'a.<wbr />bc'},
      {content: 'a.b.c', expected: 'a.<wbr />b.<wbr />c'},
      {content: 'a.123456789A123456789B12345.c', expected: 'a.<wbr />123456789<wbr />A123456789<wbr />B12345.<wbr />c'},
      {content: 'a_bc', expected: 'a_<wbr />bc'},
      {content: 'a_b_c', expected: 'a_<wbr />b_<wbr />c'},
      {content: 'a_123456789A123456789B12345_c', expected: 'a_<wbr />123456789<wbr />A123456789<wbr />B12345_<wbr />c'},
      {content: 'a.123456789A123456789B12345_c', expected: 'a.<wbr />123456789<wbr />A123456789<wbr />B12345_<wbr />c'},
      {content: 'a.123456789a123456789b12345_c', expected: 'a.<wbr />123456789a123456789b12345_<wbr />c'},
      {content: 'a.123456789a-23456789b12345_c', expected: 'a.<wbr />123456789a-23456789b12345_<wbr />c'},
      {content: 'a.123456789a 23456789b12345_c', expected: 'a.<wbr />123456789a 23456789b12345_<wbr />c'},
      {content: 'a.123456789a123456789_c', expected: 'a.<wbr />123456789a123456789_<wbr />c'},
    ]).forEach(function (test) {
      var message = 'content: {0}, expected: {1}'.format(JSON.stringify(test.content), JSON.stringify(test.expected));
      it(message, function () {
        view.set('content', test.content);
        expect(view.get('result')).to.be.equal(test.expected);
      });
    });

  });

});
});

require.register("test/views/common/host_progress_popup_body_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var view;

describe('App.HostProgressPopupBodyView', function () {

  beforeEach(function () {
    view = App.HostProgressPopupBodyView.create({
      controller: Em.Object.create({
        dataSourceController: Em.Object.create({}),
        setBackgroundOperationHeader: Em.K,
        hosts: []
      }),
      parentView: Em.Object.create()
    });
  });

  describe('#switchLevel', function () {

    var map = App.HostProgressPopupBodyView.create().get('customControllersSwitchLevelMap');

    Object.keys(map).forEach(function (controllerName) {
      var methodName = map [controllerName];
      var levelName = 'REQUESTS_LIST';

      beforeEach(function () {
        sinon.stub(view, methodName, Em.K);
      });

      afterEach(function () {
        view[methodName].restore();
      });

      it('should call ' + methodName, function () {
        view.set('controller.dataSourceController.name', controllerName);
        view.switchLevel(levelName);
        expect(view[methodName].args[0]).to.eql([levelName]);
      });

    });

  });

  describe('_determineRoleRelation', function() {
    var cases;

    beforeEach(function() {
      sinon.stub(App.StackServiceComponent, 'find').returns([{componentName: 'DATANODE'}]);
      sinon.stub(App.StackService, 'find').returns([{serviceName: 'HDFS'}])
    });

    afterEach(function() {
      App.StackServiceComponent.find.restore();
      App.StackService.find.restore();
    });

    cases = [
      {
        task: { role: 'HDFS_SERVICE_CHECK'},
        m: 'Role is HDFS_SERVICE_CHECK',
        e: {
          type: 'service',
          value: 'HDFS'
        }
      },
      {
        task: { role: 'DATANODE'},
        m: 'Role is DATANODE',
        e: {
          type: 'component',
          value: 'DATANODE'
        }
      },
      {
        task: { role: 'UNDEFINED'},
        m: 'Role is UNDEFINED',
        e: false
      }
    ];

    cases.forEach(function(test) {
      it(test.m, function() {
        view.reopen({
          currentHost: Em.Object.create({
            logTasks: [
              { Tasks: { id: 1, role: test.task.role }}
            ]
          })
        });

        var ret = view._determineRoleRelation(Em.Object.create({ id: 1 }));
        expect(ret).to.be.eql(test.e);
      });
    });
  });

  describe('#didInsertElement', function () {

    beforeEach(function () {
      sinon.stub(view, 'updateHostInfo', Em.K);
      view.didInsertElement();
    });

    afterEach(function () {
      view.updateHostInfo.restore();
    });

    it('should display relevant info', function () {
      expect(view.updateHostInfo.calledOnce).to.be.true;
    });

  });

  describe('#preloadHostModel', function() {
    describe('When Log Search installed', function() {

      beforeEach(function() {
        this.HostModelStub = sinon.stub(App.Host, 'find');
        this.isLogSearchInstalled = sinon.stub(view, 'get').withArgs('isLogSearchInstalled');
        this.logSearchSupported = sinon.stub(App, 'get').withArgs('supports.logSearch');
        this.updateCtrlStub = sinon.stub(App.router.get('updateController'), 'updateLogging');
      });

      afterEach(function () {
        App.Host.find.restore();
        view.get.restore();
        App.get.restore();
        App.router.get('updateController').updateLogging.restore();
      });

      [
        {
          hostName: 'host1',
          logSearchSupported: true,
          isLogSearchInstalled: true,
          requestFailed: false,
          hosts: [
            {
              hostName: 'host2'
            }
          ],
          e: {
            updateLoggingCalled: true
          },
          m: 'Host absent, log search installed and supported'
        },
        {
          hostName: 'host1',
          logSearchSupported: true,
          isLogSearchInstalled: true,
          requestFailed: false,
          hosts: [
            {
              hostName: 'host1'
            }
          ],
          e: {
            updateLoggingCalled: false
          },
          m: 'Host present, log search installed and supported'
        },
        {
          hostName: 'host1',
          logSearchSupported: false,
          isLogSearchInstalled: true,
          requestFailed: false,
          hosts: [
            {
              hostName: 'host1'
            }
          ],
          e: {
            updateLoggingCalled: false
          },
          m: 'Host present, log search installed and support is off'
        },
        {
          hostName: 'host1',
          logSearchSupported: true,
          isLogSearchInstalled: true,
          requestFailed: true,
          hosts: [
            {
              hostName: 'host2'
            }
          ],
          e: {
            updateLoggingCalled: true
          },
          m: 'Host is absent, log search installed and supported, update request was failed'
        },
        {
          hostName: 'host1',
          logSearchSupported: true,
          isLogSearchInstalled: false,
          requestFailed: true,
          hosts: [
            {
              hostName: 'host2'
            }
          ],
          e: {
            updateLoggingCalled: false
          },
          m: 'Host is absent, log search not installed and supported'
        }
      ].forEach(function(test) {

        it('hostInfoLoaded should be true on init', function() {
          expect(Em.get(view, 'hostInfoLoaded')).to.be.true;
        });

        describe(test.m, function () {

          beforeEach(function () {
            this.HostModelStub.returns(test.hosts);
            this.isLogSearchInstalled.returns(test.isLogSearchInstalled);
            this.logSearchSupported.returns(test.logSearchSupported);
            if (test.requestFailed) {
              this.updateCtrlStub.returns($.Deferred().reject().promise());
            } else {
              this.updateCtrlStub.returns($.Deferred().resolve().promise());
            }
            Em.set(view, 'hostInfoLoaded', false);
            view.preloadHostModel(test.hostName);
          });

          it('updateLogging call validation', function() {
            expect(App.router.get('updateController').updateLogging.called).to.be.equal(test.e.updateLoggingCalled);
          });

          it('in result hostInfoLoaded should be always true', function() {
            expect(Em.get(view, 'hostInfoLoaded')).to.be.true;
          });

        });
      });
    });
  });

  describe("#resetState()", function () {

    beforeEach(function() {
      sinon.stub(view.get('controller'), 'setBackgroundOperationHeader');
      sinon.stub(view, 'setOnStart');
      sinon.stub(view, 'rerender');
      sinon.stub(view, 'updateSelectView');
    });

    afterEach(function() {
      view.get('controller').setBackgroundOperationHeader.restore();
      view.setOnStart.restore();
      view.rerender.restore();
      view.updateSelectView.restore();
    });

    it("should set properties of parentView", function() {
      view.set('parentView.isOpen', true);
      expect(JSON.stringify(view.get('parentView'))).to.be.equal(JSON.stringify({
        "isOpen": true,
        "isLogWrapHidden": true,
        "isTaskListHidden": true,
        "isHostListHidden": true,
        "isServiceListHidden": false
      }));
    });

    it("setBackgroundOperationHeader should be called", function() {
      view.set('parentView.isOpen', true);
      expect(view.get('controller').setBackgroundOperationHeader.calledWith(false)).to.be.true;
    });

    it("controller.hosts should be empty", function() {
      view.set('controller.hosts', [{}]);
      view.set('parentView.isOpen', true);
      expect(view.get('controller.hosts')).to.be.empty;
    });

    it("setOnStart should be called", function() {
      view.set('parentView.isOpen', true);
      expect(view.setOnStart.calledOnce).to.be.true;
    });

    it("rerender should be called", function() {
      view.set('parentView.isOpen', true);
      expect(view.rerender.calledOnce).to.be.true;
    });
  });
});

});

require.register("test/views/common/log_file_search_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.LogFileSearchView', function() {
  describe('#serializeFilters', function() {
    var makeLevelItem = function(level, isChecked) {
      return Em.Object.create({
        name: level.toUpperCase(),
        checked: !!isChecked
      });
    };
    var makeSelectedKeyword = function(keyword, isIncluded) {
      return Em.Object.create({
        value: keyword,
        isIncluded: !!isIncluded
      });
    };
    [
      {
        viewContent: {
          keywordsFilterValue: 'some_keyword'
        },
        e: 'keywords=some_keyword'
      },
      {
        viewContent: {
          keywordsFilterValue: 'some_keyword',
          levelsContext: [
            makeLevelItem('debug', true),
            makeLevelItem('error', false),
            makeLevelItem('info', true)
          ]
        },
        e: 'levels=DEBUG,INFO&keywords=some_keyword'
      },
      {
        viewContent: {
          keywordsFilterValue: 'some_keyword',
          dateFromValue: '12/12/2015',
          dateToValue: '14/12/2015',
          levelsContext: [
            makeLevelItem('debug', true),
            makeLevelItem('error', true),
            makeLevelItem('info', true)
          ]
        },
        e: 'levels=DEBUG,ERROR,INFO&keywords=some_keyword&dateTo=12/12/2015&dateFrom=12/12/2015'
      },
      {
        viewContent: {
          keywordsFilterValue: 'some_keyword',
          dateFromValue: '12/12/2015',
          levelsContext: [
            makeLevelItem('debug', true),
            makeLevelItem('error', true),
            makeLevelItem('info', true)
          ]
        },
        e: 'levels=DEBUG,ERROR,INFO&keywords=some_keyword&dateFrom=12/12/2015'
      },
      {
        viewContent: {
          keywordsFilterValue: 'some_keyword',
          dateFromValue: '12/12/2015',
          levelsContext: [
            makeLevelItem('debug', true),
            makeLevelItem('error', true),
            makeLevelItem('info', true)
          ],
          selectedKeywords: [
            makeSelectedKeyword("keyword1", true),
            makeSelectedKeyword("keyword2", true),
            makeSelectedKeyword("keyword3", false)
          ]
        },
        e: 'levels=DEBUG,ERROR,INFO&keywords=some_keyword&dateFrom=12/12/2015&include=keyword1,keyword2&exclude=keyword3'
      }
    ].forEach(function(test) {
      it('validate result: ' + test.e, function() {
        var view = App.LogFileSearchView.extend(test.viewContent).create();
        expect(view.serializeFilters()).to.be.eql(test.e);
        view.destroy();
      })
    });
  });
});

});

require.register("test/views/common/modal_popup_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/modal_popup');

describe('App.ModalPopup', function() {

  var popup;

  beforeEach(function () {
    popup = App.ModalPopup.create(
      {
        primary: 'test',
        secondary: 'test',
        header: 'test',
        body: '<p>text</p><input type="text"><input type="checkbox"><input type="button">',
        $: function () {
          return $(this);
        }
      }
    );
  });

  describe('#didInsertElement', function () {

    beforeEach(function () {
      this.spy = sinon.spy(popup, "focusElement");
    });

    afterEach(function () {
      this.spy.restore();
    });

    it('should focus on the first input element', function () {
      popup.didInsertElement();
      expect(this.spy.called).to.be.true;
    });
  });

  describe('#escapeKeyPressed', function () {

    var returnedValue,
      event = {
        preventDefault: Em.K,
        stopPropagation: Em.K
      },
      cases = [
        {
          buttons: [],
          preventDefaultCallCount: 0,
          stopPropagationCallCount: 0,
          clickCallCount: 0,
          returnedValue: undefined,
          title: 'no close button'
        },
        {
          buttons: [{}],
          preventDefaultCallCount: 1,
          stopPropagationCallCount: 1,
          clickCallCount: 1,
          returnedValue: false,
          title: 'close button available'
        }
      ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          item.buttons.click = Em.K;
          sinon.stub(popup, '$').returns({
            find: function () {
              return {
                last: function () {
                  return item.buttons;
                }
              }
            }
          });
          sinon.spy(item.buttons, 'click');
          sinon.spy(event, 'preventDefault');
          sinon.spy(event, 'stopPropagation');
          returnedValue = popup.escapeKeyPressed(event);
        });

        afterEach(function () {
          popup.$.restore();
          item.buttons.click.restore();
          event.preventDefault.restore();
          event.stopPropagation.restore();
        });

        it('prevent default behaviour', function () {
          expect(event.preventDefault.callCount).to.equal(item.preventDefaultCallCount);
        });

        it('stop event propagation', function () {
          expect(event.stopPropagation.callCount).to.equal(item.stopPropagationCallCount);
        });

        it('close button click', function () {
          expect(item.buttons.click.callCount).to.equal(item.clickCallCount);
        });

        it('returned value', function () {
          expect(returnedValue).to.equal(item.returnedValue);
        });

      });

    });

  });

  describe('#enterKeyPressed', function () {

    var returnedValue,
      event = {
        preventDefault: Em.K,
        stopPropagation: Em.K
      },
      cases = [
        {
          buttons: [],
          isTextArea: true,
          preventDefaultCallCount: 0,
          stopPropagationCallCount: 0,
          clickCallCount: 0,
          returnedValue: undefined,
          title: 'focus on textarea, no primary button'
        },
        {
          buttons: [],
          isTextArea: false,
          preventDefaultCallCount: 0,
          stopPropagationCallCount: 0,
          clickCallCount: 0,
          returnedValue: undefined,
          title: 'no focus on textarea, no primary button'
        },
        {
          buttons: [{}],
          isTextArea: true,
          disabled: 'disabled',
          preventDefaultCallCount: 0,
          stopPropagationCallCount: 0,
          clickCallCount: 0,
          returnedValue: undefined,
          title: 'focus on textarea, primary button disabled'
        },
        {
          buttons: [{}],
          isTextArea: false,
          disabled: 'disabled',
          preventDefaultCallCount: 0,
          stopPropagationCallCount: 0,
          clickCallCount: 0,
          returnedValue: undefined,
          title: 'no focus on textarea, primary button disabled'
        },
        {
          buttons: [{}],
          isTextArea: true,
          disabled: '',
          preventDefaultCallCount: 0,
          stopPropagationCallCount: 0,
          clickCallCount: 0,
          returnedValue: undefined,
          title: 'focus on textarea, primary button enabled'
        },
        {
          buttons: [{}],
          isTextArea: false,
          disabled: '',
          preventDefaultCallCount: 1,
          stopPropagationCallCount: 1,
          clickCallCount: 1,
          returnedValue: false,
          title: 'no focus on textarea, primary button enabled'
        }
      ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          item.buttons.click = Em.K;
          item.buttons.attr = function () {
            return item.disabled;
          };
          sinon.stub(popup, '$').returns({
            find: function () {
              return {
                last: function () {
                  return item.buttons;
                }
              }
            }
          });
          sinon.stub(window, '$').withArgs('*:focus').returns({
            is: function () {
              return item.isTextArea
            }
          });
          sinon.spy(item.buttons, 'click');
          sinon.spy(event, 'preventDefault');
          sinon.spy(event, 'stopPropagation');
          returnedValue = popup.enterKeyPressed(event);
        });

        afterEach(function () {
          popup.$.restore();
          window.$.restore();
          item.buttons.click.restore();
          event.preventDefault.restore();
          event.stopPropagation.restore();
        });

        it('prevent default behaviour', function () {
          expect(event.preventDefault.callCount).to.equal(item.preventDefaultCallCount);
        });

        it('stop event propagation', function () {
          expect(event.stopPropagation.callCount).to.equal(item.stopPropagationCallCount);
        });

        it('primary button click', function () {
          expect(item.buttons.click.callCount).to.equal(item.clickCallCount);
        });

        it('returned value', function () {
          expect(returnedValue).to.equal(item.returnedValue);
        });

      });

    });

  });

});
});

require.register("test/views/common/modal_popups/cluster_check_popup_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/modal_popups/cluster_check_popup');

describe('App.showClusterCheckPopup', function () {

  var isCallbackExecuted,
    callback = function () {
      isCallbackExecuted = true;
    },
    cases = [
      {
        inputData: {
          data: {
            items: [
              {
                UpgradeChecks: {
                  id: 'p0',
                  status: 'PASS'
                }
              },
              {
                UpgradeChecks: {
                  id: 'p1',
                  status: 'PASS'
                }
              }
            ]
          }
        },
        result: {
          primary: Em.I18n.t('common.proceedAnyway'),
          secondary: Em.I18n.t('common.cancel'),
          header: '&nbsp;'
        },
        bodyResult: {
          failTitle: undefined,
          failAlert: undefined,
          warningTitle: undefined,
          warningAlert: undefined,
          fails: [],
          warnings: [],
          hasConfigsMergeConflicts: false,
          isAllPassed: true
        },
        isCallbackExecuted: false,
        title: 'no fails, no warnings, no popup customization'
      },
      {
        inputData: {
          data: {
            items: [
              {
                UpgradeChecks: {
                  id: 'w0',
                  status: 'WARNING'
                }
              },
              {
                UpgradeChecks: {
                  id: 'w1',
                  status: 'WARNING'
                }
              }
            ]
          },
          popup: {
            header: 'checks',
            failTitle: 'fail',
            failAlert: 'something has failed',
            warningTitle: 'warning',
            warningAlert: 'something is not good',
            callback: callback
          }
        },
        result: {
          primary: Em.I18n.t('common.proceedAnyway'),
          secondary: Em.I18n.t('common.cancel'),
          header: 'checks'
        },
        bodyResult: {
          failTitle: 'fail',
          failAlert: 'something has failed',
          warningTitle: 'warning',
          warningAlert: 'something is not good',
          fails: [],
          warnings: [
            {
              UpgradeChecks: {
                id: 'w0',
                status: 'WARNING'
              }
            },
            {
              UpgradeChecks: {
                id: 'w1',
                status: 'WARNING'
              }
            }
          ],
          hasConfigsMergeConflicts: false,
          isAllPassed: false
        },
        isCallbackExecuted: true,
        title: 'no fails, default buttons, callback executed'
      },
      {
        inputData: {
          data: {
            items: [
              {
                UpgradeChecks: {
                  id: 'f0',
                  status: 'FAIL'
                }
              },
              {
                UpgradeChecks: {
                  id: 'f1',
                  status: 'FAIL'
                }
              }
            ]
          },
          popup: {
            callback: callback,
            noCallbackCondition: true
          }
        },
        result: {
          primary: Em.I18n.t('common.dismiss'),
          secondary: false,
          header: '&nbsp;'
        },
        bodyResult: {
          failTitle: undefined,
          failAlert: undefined,
          warningTitle: undefined,
          warningAlert: undefined,
          fails: [
            {
              UpgradeChecks: {
                id: 'f0',
                status: 'FAIL'
              }
            },
            {
              UpgradeChecks: {
                id: 'f1',
                status: 'FAIL'
              }
            }
          ],
          warnings: [],
          hasConfigsMergeConflicts: false,
          isAllPassed: false
        },
        isCallbackExecuted: false,
        title: 'fails detected, default buttons, callback not executed'
      },
      {
        inputData: {
          data: {
            items: [
              {
                UpgradeChecks: {
                  id: 'p0',
                  status: 'PASS'
                }
              },
              {
                UpgradeChecks: {
                  id: 'p1',
                  status: 'PASS'
                }
              }
            ]
          },
          popup: {
            primary: 'ok',
            secondary: 'cancel'
          },
          configs: [
            {
              name: 'c0',
              wasModified: false
            },
            {
              name: 'c1',
              wasModified: true
            }
          ]
        },
        result: {
          primary: 'ok',
          secondary: 'cancel',
          header: '&nbsp;'
        },
        bodyResult: {
          failTitle: undefined,
          failAlert: undefined,
          warningTitle: undefined,
          warningAlert: undefined,
          fails: [],
          warnings: [],
          hasConfigsMergeConflicts: true,
          hasConfigsRecommendations: true,
          isAllPassed: false
        },
        configsResult: [
          {
            name: 'c0',
            wasModified: false
          }
        ],
        configRecommendResult: [
          {
            name: 'c1',
            wasModified: true
          }
        ],
        isCallbackExecuted: false,
        title: 'configs merge conflicts detected, custom buttons'
      }
    ];

  beforeEach(function () {
    isCallbackExecuted = false;
    sinon.stub(App, 'tooltip', Em.K);
  });

  afterEach(function () {
    App.tooltip.restore();
  });

  cases.forEach(function (item) {

    describe(item.title, function () {

      var popup;
      var popupBody;

      beforeEach(function () {
        popup = App.showClusterCheckPopup(item.inputData.data, item.inputData.popup, item.inputData.configs);
        popupBody = popup.bodyClass.create();
        popup.onPrimary();
      });

      describe('result', function () {
        Em.keys(item.result).forEach(function (key) {
          it(key, function () {
            expect(popup[key]).to.equal(item.result[key]);
          });
        });
      });

      describe('bodyResult', function () {
        Em.keys(item.bodyResult).forEach(function (key) {
          it(key, function () {
            expect(popupBody[key]).to.eql(item.bodyResult[key]);
          });
        });
      });

      it('callbackExecuted', function () {
        expect(isCallbackExecuted).to.equal(item.isCallbackExecuted);
      });

      if (item.bodyResult.hasConfigsMergeConflicts) {
        it('hasConfigsMergeConflicts = true', function () {
          var configsMergeTable = popupBody.configsMergeTable.create();
          expect(configsMergeTable.configs).to.eql(item.configsResult);
        });
      }

      if (item.bodyResult.hasConfigsRecommendations) {
        it('hasConfigsRecommendations = true', function () {
          var configsRecommendTable = popupBody.configsRecommendTable.create();
          expect(configsRecommendTable.configs).to.eql(item.configRecommendResult);
        });
      }

    });
  });

});

});

require.register("test/views/common/modal_popups/dependent_configs_list_popup_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/common/modal_popups/hosts_table_list_popup');

var view;

describe('App.showDependentConfigsPopup', function () {

  beforeEach(function () {
    view = App.showDependentConfigsPopup();
    sinon.stub(Em.run, 'next', Em.K);
    sinon.stub(Em.run, 'once', Em.K);
  });

  afterEach(function () {
    Em.run.next.restore();
    Em.run.once.restore();
  });

  describe('#onClose', function () {

    beforeEach(function () {
      this.ff = function () {};
      sinon.spy(this, 'ff');
      view = App.showDependentConfigsPopup([], [], Em.K, this.ff);
    });

    afterEach(function () {
      this.ff.restore();
    });

    it('should call secondary-callback', function () {
      view.onClose();
      expect(this.ff.calledOnce).to.be.true;
    });

  });

});

});

require.register("test/views/common/modal_popups/hosts_table_list_popup_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/common/modal_popups/hosts_table_list_popup');

describe('App.showHostsTableListPopup', function () {

  var cases = [
    {
      header: 'h0',
      hostName: 'hn0',
      items: ['i0', 'i1'],
      isObjectsList: false,
      title: 'strings list'
    },
    {
      header: 'h1',
      hostName: 'hn1',
      items: [
        {
          name: 'n0',
          status: 's0'
        },
        {
          name: 'n1',
          status: 's1'
        }
      ],
      isObjectsList: true,
      title: 'objects list'
    }
  ];

  cases.forEach(function (item) {

    describe(item.title, function () {

      var popup;
      var popupBody;

      beforeEach(function () {
        popup = App.showHostsTableListPopup(item.header, item.hostName, item.items);
        popupBody = popup.bodyClass.create();
      });

      it('header is valid', function () {
        expect(popup.header).to.equal(item.header);
      });
      it('hostName is valid', function () {
        expect(popupBody.get('hostName')).to.equal(item.hostName);
      });
      it('items are valid', function () {
        expect(popupBody.get('items')).to.eql(item.items);
      });
      it('isObjectsList is valid', function () {
        expect(popupBody.get('isObjectsList')).to.equal(item.isObjectsList);
      });

    });

  });

});

});

require.register("test/views/common/progress_bar_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.ProgressBarView', function () {
  var view = App.ProgressBarView.create();

  describe("#progressWidth", function () {
    it("depends on `progress`", function () {
      view.set('progress', 1);
      view.propertyDidChange('progressWidth');
      expect(view.get('progressWidth')).to.equal('width:1%;');
    });
  });

  describe("#barClass", function () {
    var testCases = [
      {
        status: 'FAILED',
        result: 'progress-danger'
      },
      {
        status: 'ABORTED',
        result: 'progress-warning'
      },
      {
        status: 'TIMED_OUT',
        result: 'progress-warning'
      },
      {
        status: 'COMPLETED',
        result: 'progress-success'
      },
      {
        status: 'QUEUED',
        result: 'progress-info active progress-striped'
      },
      {
        status: 'PENDING',
        result: 'progress-info active progress-striped'
      },
      {
        status: 'IN_PROGRESS',
        result: 'progress-info active progress-striped'
      },
      {
        status: null,
        result: 'progress-info'
      }
    ];
    testCases.forEach(function (test) {
      it("status is " + test.status, function () {
        view.set('status', test.status);
        view.propertyDidChange('barClass');
        expect(view.get('barClass')).to.equal(test.result);
      });
    });
  });
});
});

require.register("test/views/common/quick_link_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/quick_view_link_view');
var testHelpers = require('test/helpers');

describe('App.QuickLinksView', function () {

  var quickViewLinks = App.QuickLinksView.create({
    content: Em.Object.create()
  });

  describe("#ambariProperties", function () {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns({p: 1});
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it("ambariProperties are updated", function () {
      expect(quickViewLinks.get('ambariProperties')).to.eql({p: 1});
    });
  });

  describe("#didInsertElement()", function () {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns({p: 1});
      sinon.stub(quickViewLinks, 'loadQuickLinksConfigurations');
    });
    afterEach(function () {
      App.router.get.restore();
      quickViewLinks.loadQuickLinksConfigurations.restore();
    });
    it("loadQuickLinksConfigurations is called once", function () {
      quickViewLinks.didInsertElement();
      expect(quickViewLinks.loadQuickLinksConfigurations.calledOnce).to.be.true;
    });
  });

  describe("#willDestroyElement()", function () {

    beforeEach(function () {
      quickViewLinks.setProperties({
        configProperties: [{}],
        actualTags: [""],
        quickLinks: [{}]
      });
      quickViewLinks.willDestroyElement();
    });

    it("configProperties empty", function () {
      expect(quickViewLinks.get('configProperties')).to.be.empty;
    });

    it("actualTags empty", function () {
      expect(quickViewLinks.get('actualTags')).to.be.empty;
    });

    it("quickLinks empty", function () {
      expect(quickViewLinks.get('quickLinks')).to.be.empty;
    });
  });

  describe("#setQuickLinks()", function () {
    beforeEach(function () {
      this.mock = sinon.stub(App, 'get');
      sinon.stub(quickViewLinks, 'loadTags', Em.K);
    });
    afterEach(function () {
      this.mock.restore();
      quickViewLinks.loadTags.restore();
    });
    it("data loaded", function () {
      this.mock.returns(true);
      quickViewLinks.setQuickLinks();
      expect(quickViewLinks.loadTags.calledOnce).to.be.true;
    });
    it("data not loaded", function () {
      this.mock.returns(false);
      quickViewLinks.setQuickLinks();
      expect(quickViewLinks.loadTags.called).to.be.false;
    });
  });

  describe("#loadTags()", function () {

    it("call $.ajax", function () {
      quickViewLinks.loadTags();
      var args = testHelpers.findAjaxRequest('name', 'config.tags');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(quickViewLinks);
    });
  });

  describe("#loadTagsSuccess()", function () {
    beforeEach(function () {
      sinon.stub(quickViewLinks, 'setConfigProperties', function () {
        return {
          done: Em.clb
        }
      });
      sinon.stub(quickViewLinks, 'getQuickLinksHosts');
      var data = {
        Clusters: {
          desired_configs: {
            site1: {
              tag: 'tag1'
            }
          }
        }
      };
      quickViewLinks.loadTagsSuccess(data);
    });
    afterEach(function () {
      quickViewLinks.setConfigProperties.restore();
      quickViewLinks.getQuickLinksHosts.restore();
    });
    it("actualTags is valid", function () {
      expect(quickViewLinks.get('actualTags')[0]).to.eql(Em.Object.create({
        siteName: 'site1',
        tagName: 'tag1'
      }));
    });
    it("setConfigProperties is called once", function () {
      expect(quickViewLinks.setConfigProperties.calledOnce).to.be.true;
    });
    it("getQuickLinksHosts is called once", function () {
      expect(quickViewLinks.getQuickLinksHosts.calledOnce).to.be.true;
    });
  });

  describe("#loadTagsError()", function () {
    beforeEach(function () {
      sinon.stub(quickViewLinks, 'getQuickLinksHosts');
    });
    afterEach(function () {
      quickViewLinks.getQuickLinksHosts.restore();
    });
    it("call loadQuickLinksConfigurations", function () {
      quickViewLinks.loadTagsError();
      expect(quickViewLinks.getQuickLinksHosts.calledOnce).to.be.true;
    });
  });

  describe("#loadQuickLinksConfigSuccessCallback()", function () {
    var mock;

    beforeEach(function () {
      sinon.stub(App.store, 'commit', Em.K);
      mock = sinon.stub(quickViewLinks, 'getQuickLinksConfiguration');
    });
    afterEach(function () {
      App.store.commit.restore();
      mock.restore();
    });
    it("requiredSites consistent", function () {
      var quickLinksConfigHBASE = {
        protocol: {
          type: "http"
        },
        links: [
          {
            port: {
              site: "hbase-site"
            }
          }
        ]
      };
      var quickLinksConfigYARN = {
        protocol: {
          checks: [
            {
              site: "yarn-site"
            }
          ],
          type: "https"
        },
        links: [
          {
            port: {
              site: "yarn-site"
            }
          }
        ]
      };
      quickViewLinks.set('content.serviceName', 'HBASE');
      mock.returns(quickLinksConfigHBASE);
      quickViewLinks.loadQuickLinksConfigSuccessCallback({items: []});
      quickViewLinks.set('content.serviceName', 'YARN');
      mock.returns(quickLinksConfigYARN);
      quickViewLinks.loadQuickLinksConfigSuccessCallback({items: []});
      expect(quickViewLinks.get('requiredSiteNames')).to.be.eql(["core-site", "hdfs-site", "admin-properties", "hbase-site", "yarn-site"]);
    });
  });

  describe("#getQuickLinksHosts()", function () {
    beforeEach(function () {
      sinon.stub(App.HostComponent, 'find').returns([
        Em.Object.create({
          isMaster: true,
          hostName: 'host1'
        })
      ]);
    });
    afterEach(function () {
      App.HostComponent.find.restore();
    });
    it("call $.ajax", function () {
      quickViewLinks.getQuickLinksHosts();
      var args = testHelpers.findAjaxRequest('name', 'hosts.for_quick_links');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(quickViewLinks);
      expect(args[0].data).to.be.eql({
        clusterName: App.get('clusterName'),
        masterHosts: 'host1',
        urlParams: ''
      });
    });
    it("call $.ajax, HBASE service", function () {
      quickViewLinks.set('content.serviceName', 'HBASE');
      quickViewLinks.getQuickLinksHosts();
      var args = testHelpers.findAjaxRequest('name', 'hosts.for_quick_links');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(quickViewLinks);
      expect(args[0].data).to.be.eql({
        clusterName: App.get('clusterName'),
        masterHosts: 'host1',
        urlParams: ',host_components/metrics/hbase/master/IsActiveMaster'
      });
    });
  });

  describe("#setQuickLinksSuccessCallback()", function () {
    beforeEach(function () {
      this.mock = sinon.stub(quickViewLinks, 'getHosts');
      sinon.stub(quickViewLinks, 'setEmptyLinks');
      sinon.stub(quickViewLinks, 'setSingleHostLinks');
      sinon.stub(quickViewLinks, 'setMultipleHostLinks');
      quickViewLinks.set('content.quickLinks', []);
    });
    afterEach(function () {
      this.mock.restore();
      quickViewLinks.setEmptyLinks.restore();
      quickViewLinks.setSingleHostLinks.restore();
      quickViewLinks.setMultipleHostLinks.restore();
    });
    it("no hosts", function () {
      this.mock.returns([]);
      quickViewLinks.setQuickLinksSuccessCallback();
      expect(quickViewLinks.setEmptyLinks.calledOnce).to.be.true;
    });
    it("quickLinks is not configured", function () {
      this.mock.returns([{}]);
      quickViewLinks.setQuickLinksSuccessCallback();
      expect(quickViewLinks.setEmptyLinks.calledOnce).to.be.false;
    });
    it("single host", function () {
      this.mock.returns([{hostName: 'host1'}]);
      quickViewLinks.setQuickLinksSuccessCallback();
      expect(quickViewLinks.setSingleHostLinks.calledWith([{hostName: 'host1'}])).to.be.true;
    });
    it("multiple hosts", function () {
      this.mock.returns([{hostName: 'host1'}, {hostName: 'host2'}]);
      quickViewLinks.setQuickLinksSuccessCallback();
      expect(quickViewLinks.setMultipleHostLinks.calledWith(
        [{hostName: 'host1'}, {hostName: 'host2'}]
      )).to.be.true;
    });
  });

  describe("#getPublicHostName()", function () {
    it("host present", function () {
      var hosts = [{
        Hosts: {
          host_name: 'host1',
          public_host_name: 'public_name'
        }
      }];
      expect(quickViewLinks.getPublicHostName(hosts, 'host1')).to.equal('public_name');
    });
    it("host absent", function () {
      expect(quickViewLinks.getPublicHostName([], 'host1')).to.be.null;
    });
  });

  describe("#setConfigProperties()", function () {
    var mock = {getConfigsByTags: Em.K};
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns(mock);
      sinon.spy(mock, 'getConfigsByTags');
    });
    afterEach(function () {
      mock.getConfigsByTags.restore();
      App.router.get.restore();
    });
    it("getConfigsByTags called with correct data", function () {
      quickViewLinks.set('actualTags', [{siteName: 'hdfs-site'}]);
      quickViewLinks.set('requiredSiteNames', ['hdfs-site']);
      quickViewLinks.setConfigProperties();
      expect(mock.getConfigsByTags.calledWith([{siteName: 'hdfs-site'}])).to.be.true;
    });
  });

  describe("#setEmptyLinks()", function () {
    it("empty links are set", function () {
      quickViewLinks.setEmptyLinks();
      expect(quickViewLinks.get('quickLinks')).to.eql([{
        label: quickViewLinks.get('quickLinksErrorMessage'),
      }]);
      expect(quickViewLinks.get('isLoaded')).to.be.true;
    });
  });

  describe("#processOozieHosts()", function () {
    it("host status is valid", function () {
      quickViewLinks.set('content.hostComponents', [Em.Object.create({
        componentName: 'OOZIE_SERVER',
        workStatus: 'STARTED',
        hostName: 'host1'
      })]);
      var host = {hostName: 'host1'};
      quickViewLinks.processOozieHosts([host]);
      expect(host.status).to.equal(Em.I18n.t('quick.links.label.active'));
    });
    it("host status is invalid", function () {
      quickViewLinks.set('content.hostComponents', [Em.Object.create({
        componentName: 'OOZIE_SERVER',
        workStatus: 'INSTALLED',
        hostName: 'host1'
      })]);
      var host = {hostName: 'host1'};
      quickViewLinks.processOozieHosts([host]);
      expect(quickViewLinks.get('quickLinksErrorMessage')).to.equal(Em.I18n.t('quick.links.error.oozie.label'));
    });
  });

  describe("#processHdfsHosts()", function () {
    beforeEach(function () {
      quickViewLinks.set('content.activeNameNode', null);
      quickViewLinks.set('content.standbyNameNode', null);
      quickViewLinks.set('content.standbyNameNode2', null);
    });
    it("active namenode host", function () {
      quickViewLinks.set('content.activeNameNode', Em.Object.create({hostName: 'host1'}));
      var host = {hostName: 'host1'};
      quickViewLinks.processHdfsHosts([host]);
      expect(host.status).to.equal(Em.I18n.t('quick.links.label.active'));
    });
    it("standby namenode host", function () {
      quickViewLinks.set('content.standbyNameNode', Em.Object.create({hostName: 'host1'}));
      var host = {hostName: 'host1'};
      quickViewLinks.processHdfsHosts([host]);
      expect(host.status).to.equal(Em.I18n.t('quick.links.label.standby'));
    });
    it("second standby namenode host", function () {
      quickViewLinks.set('content.standbyNameNode2', Em.Object.create({hostName: 'host1'}));
      var host = {hostName: 'host1'};
      quickViewLinks.processHdfsHosts([host]);
      expect(host.status).to.equal(Em.I18n.t('quick.links.label.standby'));
    });
  });

  describe("#processHbaseHosts()", function () {
    it("isActiveMaster is true", function () {
      var response = {
        items: [
          {
            Hosts: {
              host_name: 'host1'
            },
            host_components: [
              {
                HostRoles: {
                  component_name: 'HBASE_MASTER'
                },
                metrics: {
                  hbase: {
                    master: {
                      IsActiveMaster: 'true'
                    }
                  }
                }
              }
            ]
          }
        ]
      };
      var host = {hostName: 'host1'};
      quickViewLinks.processHbaseHosts([host], response);
      expect(host.status).to.equal(Em.I18n.t('quick.links.label.active'));
    });
    it("isActiveMaster is false", function () {
      var response = {
        items: [
          {
            Hosts: {
              host_name: 'host1'
            },
            host_components: [
              {
                HostRoles: {
                  component_name: 'HBASE_MASTER'
                },
                metrics: {
                  hbase: {
                    master: {
                      IsActiveMaster: 'false'
                    }
                  }
                }
              }
            ]
          }
        ]
      };
      var host = {hostName: 'host1'};
      quickViewLinks.processHbaseHosts([host], response);
      expect(host.status).to.equal(Em.I18n.t('quick.links.label.standby'));
    });
    it("isActiveMaster is undefined", function () {
      var response = {
        items: [
          {
            Hosts: {
              host_name: 'host1'
            },
            host_components: [
              {
                HostRoles: {
                  component_name: 'HBASE_MASTER'
                }
              }
            ]
          }
        ]
      };
      var host = {hostName: 'host1'};
      quickViewLinks.processHbaseHosts([host], response);
      expect(host.status).to.be.undefined;
    });
  });

  describe("#processYarnHosts()", function () {
    it("haStatus is ACTIVE", function () {
      quickViewLinks.set('content.hostComponents', [Em.Object.create({
        componentName: 'RESOURCEMANAGER',
        hostName: 'host1',
        haStatus: 'ACTIVE'
      })]);
      var host = {hostName: 'host1'};
      quickViewLinks.processYarnHosts([host]);
      expect(host.status).to.equal(Em.I18n.t('quick.links.label.active'));
    });
    it("haStatus is STANDBY", function () {
      quickViewLinks.set('content.hostComponents', [Em.Object.create({
        componentName: 'RESOURCEMANAGER',
        hostName: 'host1',
        haStatus: 'STANDBY'
      })]);
      var host = {hostName: 'host1'};
      quickViewLinks.processYarnHosts([host]);
      expect(host.status).to.equal(Em.I18n.t('quick.links.label.standby'));
    });
    it("haStatus is undefined", function () {
      quickViewLinks.set('content.hostComponents', [Em.Object.create({
        componentName: 'RESOURCEMANAGER',
        hostName: 'host1'
      })]);
      var host = {hostName: 'host1'};
      quickViewLinks.processYarnHosts([host]);
      expect(host.status).to.be.undefined;
    });
  });

  describe("#findHosts()", function () {
    beforeEach(function () {
      sinon.stub(quickViewLinks, 'getPublicHostName').returns('public_name');
      sinon.stub(App.MasterComponent, 'find').returns([
        Em.Object.create({
          componentName: "C1",
          hostNames: ["host1", "host2"]
        })
      ]);
    });
    afterEach(function () {
      quickViewLinks.getPublicHostName.restore();
      App.MasterComponent.find.restore();
    });
    it("public_name from getPublicHostName", function () {
      expect(quickViewLinks.findHosts('C1', {})).to.eql([
        {
          hostName: 'host1',
          publicHostName: 'public_name',
          componentName: 'C1'
        },
        {
          hostName: 'host2',
          publicHostName: 'public_name',
          componentName: 'C1'
        }
      ]);
    });
  });

  describe('#setProtocol', function () {
    var tests = [
      //Yarn
      {
        serviceName: "YARN",
        configProperties: [
          {type: 'yarn-site', properties: {'yarn.http.policy': 'HTTPS_ONLY'}}
        ],
        quickLinksConfig: {
          protocol:{
            type:"https",
            checks:[
              {property:"yarn.http.policy",
                desired:"HTTPS_ONLY",
                site:"yarn-site"}
            ]
          }
        },
        m: "https for yarn (checks for https passed)",
        result: "https"
      },
      {
        serviceName: "YARN",
        configProperties: [
          {type: 'yarn-site', properties: {'yarn.http.policy': 'HTTP_ONLY'}}
        ],
        quickLinksConfig: {
          protocol:{
            type:"http",
            checks:[
              {property:"yarn.http.policy",
                desired:"HTTP_ONLY",
                site:"yarn-site"}
            ]
          }
        },
        m: "http for yarn (checks for http passed)",
        result: "http"
      },
      {
        serviceName: "YARN",
        configProperties: [
          {type: 'yarn-site', properties: {'yarn.http.policy': 'HTTP_ONLY'}}
        ],
        quickLinksConfig: {
          protocol:{
            type:"https",
            checks:[
              {property:"yarn.http.policy",
                desired:"HTTPS_ONLY",
                site:"yarn-site"}
            ]
          }
        },
        m: "http for yarn (checks for https did not pass)",
        result: "http"
      },
      {
        serviceName: "YARN",
        configProperties: [
          {type: 'yarn-site', properties: {'yarn.http.policy': 'HTTPS_ONLY'}}
        ],
        quickLinksConfig: {
          protocol:{
            type:"http",
            checks:[
              {property:"yarn.http.policy",
                desired:"HTTP_ONLY",
                site:"yarn-site"}
            ]
          }
        },
        m: "https for yarn (checks for http did not pass)",
        result: "https"
      },
      {
        serviceName: "YARN",
        configProperties: [
          {type: 'yarn-site', properties: {'yarn.http.policy': 'HTTP_ONLY'}}
        ],
        quickLinksConfig: {
          protocol:{
            type:"HTTP_ONLY",
            checks:[
              {property:"yarn.http.policy",
                desired:"HTTPS_ONLY",
                site:"yarn-site"}
            ]
          }
        },
        m: "http for yarn (override checks with specific protocol type)",
        result: "http"
      },
      {
        serviceName: "YARN",
        configProperties: [
          {type: 'yarn-site', properties: {'yarn.http.policy': 'HTTPS_ONLY'}}
        ],
        quickLinksConfig: {
          protocol:{
            type:"HTTPS_ONLY",
            checks:[
              {property:"yarn.http.policy",
                desired:"HTTPS_ONLY",
                site:"yarn-site"}
            ]
          }
        },
        m: "https for yarn (override checks with specific protocol type)",
        result: "https"
      },
      //Any service - override hadoop.ssl.enabled
      {
        serviceName: "MyService",
        configProperties: [
          {type: 'myservice-site', properties: {'myservice.http.policy': 'HTTPS_ONLY'}},
          {type: 'hdfs-site', properties: {'dfs.http.policy':'HTTP_ONLY'}}
        ],
        quickLinksConfig: {
          protocol:{
            type:"https",
            checks:[
              {property:"myservice.http.policy",
                desired:"HTTPS_ONLY",
                site:"myservice-site"}
            ]
          }
        },
        m: "https for MyService (checks for https passed, override hadoop.ssl.enabled)",
        result: "https"
      },
      //Oozie
      {
        serviceName: "OOZIE",
        configProperties: [
          {type: 'oozie-site', properties: {'oozie.https.port': '12345', 'oozie.https.keystore.file':'/tmp/oozie.jks', 'oozie.https.keystore.pass':'mypass'}}
        ],
        quickLinksConfig: {
          protocol:{
            type:"https",
            checks:
              [
                {
                  "property":"oozie.https.port",
                  "desired":"EXIST",
                  "site":"oozie-site"
                },
                {
                  "property":"oozie.https.keystore.file",
                  "desired":"EXIST",
                  "site":"oozie-site"
                },
                {
                  "property":"oozie.https.keystore.pass",
                  "desired":"EXIST",
                  "site":"oozie-site"
                }
              ]
          }
        },
        m: "https for oozie (checks for https passed)",
        result: "https"
      },
      {
        serviceName: "OOZIE",
        configProperties: [
          {type: 'oozie-site', properties: {"oozie.base.url":"http://c6401.ambari.apache.org:11000/oozie"}}
        ],
        quickLinksConfig: {
          protocol:{
            type:"https",
            checks:
              [
                {
                  "property":"oozie.https.port",
                  "desired":"EXIST",
                  "site":"oozie-site"
                },
                {
                  "property":"oozie.https.keystore.file",
                  "desired":"EXIST",
                  "site":"oozie-site"
                },
                {
                  "property":"oozie.https.keystore.pass",
                  "desired":"EXIST",
                  "site":"oozie-site"
                }
              ]
          }
        },
        m: "http for oozie (checks for https did not pass)",
        result: "http"
      },
      //Ranger: HDP 2.2
      {
        serviceName: "RANGER",
        configProperties: [{type: 'ranger-site', properties: {'http.enabled': 'false'}}],
        quickLinksConfig: {
          protocol:{
            type:"https",
            checks:
              [
                {
                  "property":"http.enabled",
                  "desired":"false",
                  "site":"ranger-site"
                }
              ]
          }
        },
        m: "https for ranger (HDP2.2, checks passed)",
        result: "https"
      },
      {
        serviceName: "RANGER",
        configProperties: [{type: 'ranger-site', properties: {'http.enabled': 'true'}}],
        quickLinksConfig: {
          protocol:{
            type:"https",
            checks:
              [
                {
                  "property":"http.enabled",
                  "desired":"false",
                  "site":"ranger-site"
                }
              ]
          }
        },
        m: "http for ranger (HDP2.2, checks for https did not pass)",
        result: "http"
      },
      //Ranger: HDP 2.3
      {
        serviceName: "RANGER",
        configProperties:
          [
            {
              type: 'ranger-admin-site',
              properties: {'ranger.service.http.enabled': 'false', 'ranger.service.https.attrib.ssl.enabled': 'true'}
            }
          ],
        quickLinksConfig: {
          protocol:{
            type:"https",
            checks:
              [
                {
                  "property":"ranger.service.http.enabled",
                  "desired":"false",
                  "site":"ranger-admin-site"
                },
                {
                  "property":"ranger.service.https.attrib.ssl.enabled",
                  "desired":"true",
                  "site":"ranger-admin-site"
                }
              ]
          }
        },

        m: "https for ranger (HDP2.3, checks passed)",
        result: "https"
      },
      {
        serviceName: "RANGER",
        configProperties:
          [
            {
              type: 'ranger-admin-site',
              properties: {'ranger.service.http.enabled': 'true', 'ranger.service.https.attrib.ssl.enabled': 'false'}
            }
          ],
        quickLinksConfig: {
          protocol:{
            type:"https",
            checks:
              [
                {
                  "property":"ranger.service.http.enabled",
                  "desired":"false",
                  "site":"ranger-admin-site"
                },
                {
                  "property":"ranger.service.https.attrib.ssl.enabled",
                  "desired":"true",
                  "site":"ranger-admin-site"
                }
              ]
          }
        },
        m: "http for ranger (HDP2.3, checks for https did not pass)",
        result: "http"
      }
    ];

    tests.forEach(function (t) {
      it(t.m, function () {
        quickViewLinks.set('servicesSupportsHttps', t.servicesSupportsHttps);
        expect(quickViewLinks.setProtocol(t.configProperties, t.quickLinksConfig.protocol)).to.equal(t.result);
      });
    });
  });

  describe('#setPort', function () {
    var testData = [
      Em.Object.create({
        'protocol': 'http',
        'port':{
          'http_property':'yarn.timeline-service.webapp.address',
          'http_default_port':'8188',
          'https_property':'yarn.timeline-service.webapp.https.address',
          'https_default_port':'8090',
          'regex': '\\w*:(\\d+)',
          'site':'yarn-site'
        },
        'configProperties':
          [
            {
              'type': 'yarn-site',
              'properties': {'yarn.timeline-service.webapp.address': 'c6401.ambari.apache.org:8188'}
            }
          ],
        'result': '8188'
      }),

      Em.Object.create({
        'protocol': 'https',
        'port':{
          'http_property':'yarn.timeline-service.webapp.address',
          'http_default_port':'8188',
          'https_property':'yarn.timeline-service.webapp.https.address',
          'https_default_port':'8090',
          'regex': '\\w*:(\\d+)',
          'site':'yarn-site'
        },
        'configProperties':
          [
            {
              'type': 'yarn-site',
              'properties': {'yarn.timeline-service.webapp.https.address': 'c6401.ambari.apache.org:8090'}
            }
          ],
        'result': '8090'
      })
    ];

    after(function () {
      quickViewLinks.set('configProperties', []);
    });

    testData.forEach(function (item) {
      it(item.service_id + ' ' + item.protocol, function () {
        quickViewLinks.set('configProperties', item.configProperties || []);
        expect(quickViewLinks.setPort(item.port, item.protocol, item.configProperties)).to.equal(item.result);
      })
    }, this);
  });

  describe("#getHosts()", function() {

    beforeEach(function() {
      sinon.stub(quickViewLinks, 'processOozieHosts').returns(['oozieHost']);
      sinon.stub(quickViewLinks, 'processHdfsHosts').returns(['hdfsHost']);
      sinon.stub(quickViewLinks, 'processHbaseHosts').returns(['hbaseHost']);
      sinon.stub(quickViewLinks, 'processYarnHosts').returns(['yarnHost']);
      sinon.stub(quickViewLinks, 'findHosts').returns(['host1']);
      App.set('singleNodeInstall', false);
      sinon.stub(App.QuickLinksConfig, 'find').returns([
        Em.Object.create({
          id: 'OOZIE',
          links: [
            {
              component_name: 'OOZIE_SERVER'
            }
          ]
        }),
        Em.Object.create({
          id: 'HDFS',
          links: [
            {
              component_name: 'NAMENODE'
            }
          ]
        }),
        Em.Object.create({
          id: 'HBASE',
          links: [
            {
              component_name: 'HBASE_MASTER'
            }
          ]
        }),
        Em.Object.create({
          id: 'YARN',
          links: [
            {
              component_name: 'RESOURCEMANAGER'
            }
          ]
        }),
        Em.Object.create({
          id: 'STORM',
          links: [
            {
              component_name: 'STORM_UI_SERVER'
            }
          ]
        }),
        Em.Object.create({
          id: 'ACCUMULO',
          links: [
            {
              component_name: 'ACCUMULO_MONITOR'
            }
          ]
        }),
        Em.Object.create({
          id: 'ATLAS',
          links: [
            {
              component_name: 'ATLAS_SERVER'
            }
          ]
        }),
        Em.Object.create({
          id: 'MAPREDUCE2',
          links: [
            {
              component_name: 'HISTORYSERVER'
            }
          ]
        }),
        Em.Object.create({
          id: 'AMBARI_METRICS',
          links: [
            {
              component_name: 'METRICS_GRAFANA'
            }
          ]
        }),
        Em.Object.create({
          id: 'LOGSEARCH',
          links: [
            {
              component_name: 'LOGSEARCH_SERVER'
            }
          ]
        }),
        Em.Object.create({
          id: 'HIVE',
          links: [
            {
              component_name: 'METRICS_GRAFANA'
            },
            {
              component_name: 'HIVE_SERVER_INTERACTIVE'
            }
          ]
        })
      ]);
    });
    afterEach(function() {
      quickViewLinks.processOozieHosts.restore();
      quickViewLinks.processHdfsHosts.restore();
      quickViewLinks.processHbaseHosts.restore();
      quickViewLinks.findHosts.restore();
      quickViewLinks.processYarnHosts.restore();
      App.QuickLinksConfig.find.restore();
    });

    it("singleNodeInstall is true", function() {
      App.set('singleNodeInstall', true);
      App.set('singleNodeAlias', 'host1');
      expect(quickViewLinks.getHosts({}, 'S1')).to.eql([{
        hostName: 'host1',
        publicHostName: 'host1'
      }])
    });

    var tests = [
      {
        serviceName: 'OOZIE',
        callback: 'processOozieHosts',
        result: ['oozieHost']
      },
      {
        serviceName: 'HDFS',
        callback: 'processHdfsHosts',
        result: ['hdfsHost']
      },
      {
        serviceName: 'HBASE',
        callback: 'processHbaseHosts',
        result: ['hbaseHost']
      },
      {
        serviceName: 'YARN',
        callback: 'processYarnHosts',
        result: ['yarnHost']
      },
      {
        serviceName: 'STORM'
      },
      {
        serviceName: 'ACCUMULO'
      },
      {
        serviceName: 'ATLAS'
      },
      {
        serviceName: 'MAPREDUCE2'
      },
      {
        serviceName: 'AMBARI_METRICS'
      },
      {
        serviceName: 'LOGSEARCH'
      },
      {
        serviceName: 'HIVE',
        result: ['host1', 'host1']
      }
    ];

    tests.forEach(function (_test) {
      var serviceName = _test.serviceName;
      describe(serviceName, function () {
        var componentNames;

        beforeEach(function () {
          componentNames = App.QuickLinksConfig.find().findProperty('id', serviceName).get('links').mapProperty('component_name');
          this.result = quickViewLinks.getHosts({}, serviceName);
        });

        it('hosts', function () {
          expect(this.result).to.be.eql(_test.result || ['host1']);
        });

        it('components', function () {
          expect(quickViewLinks.findHosts.callCount).to.be.equal(componentNames.length);
        });

        if (_test.callback) {
          it('callback is called once', function () {
            expect(quickViewLinks[_test.callback].calledOnce).to.be.true;
          });
        }
      });
    });

    it("custom service without master", function() {
      expect(quickViewLinks.getHosts({}, 'S1')).to.be.empty;
    });
  });

  describe('#reverseType', function () {

    Em.A([
      {
        input: 'https',
        output: 'http'
      },
      {
        input: 'http',
        output: 'https'
      },
      {
        input: 'some',
        output: ''
      }
    ]).forEach(function (test) {
      it(JSON.stringify(test.input) + ' -> ' + JSON.stringify(test.output), function () {
        expect(quickViewLinks.reverseType(test.input)).to.be.equal(test.output)
      });
    });

  });

  describe('#meetDesired', function () {

    var configProperties = [
      {type: 't1', properties: {p1: 1234, p2: null, p3: 'CUSTOM'}}
    ];

    it('no needed config property', function () {
      expect(quickViewLinks.meetDesired([], '', '', '')).to.be.false;
    });

    it('desiredState is `NOT_EXIST` and currentPropertyValue is null', function () {
      expect(quickViewLinks.meetDesired(configProperties, 't1', 'p2', 'NOT_EXIST')).to.be.true;
    });

    it('desiredState is `NOT_EXIST` and currentPropertyValue is not null', function () {
      expect(quickViewLinks.meetDesired(configProperties, 't1', 'p1', 'NOT_EXIST')).to.be.false;
    });

    it('desiredState is `EXIST` and currentPropertyValue is null', function () {
      expect(quickViewLinks.meetDesired(configProperties, 't1', 'p2', 'EXIST')).to.be.false;
    });

    it('desiredState is `EXIST` and currentPropertyValue is not null', function () {
      expect(quickViewLinks.meetDesired(configProperties, 't1', 'p1', 'EXIST')).to.be.true;
    });

    it('desiredState is `CUSTOM` and currentPropertyValue is `CUSTOM`', function () {
      expect(quickViewLinks.meetDesired(configProperties, 't1', 'p3', 'CUSTOM')).to.be.true;
    });

    it('desiredState is `CUSTOM` and currentPropertyValue is not `CUSTOM`', function () {
      expect(quickViewLinks.meetDesired(configProperties, 't1', 'p2', 'CUSTOM')).to.be.false;
    });

  });

});

});

require.register("test/views/common/rolling_restart_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/rolling_restart_view');

describe('App.RollingRestartView', function () {

  var view = App.RollingRestartView.create({
    restartHostComponents: []
  });

  describe('#initialize', function () {
    var testCases = [
      {
        restartHostComponents: [],
        result: {
          batchSize: 1,
          tolerateSize: 1
        }
      },
      {
        hostComponentName: 'NOT_DATANODE',
        restartHostComponents: new Array(10),
        result: {
          batchSize: 1,
          tolerateSize: 1
        }
      },
      {
        hostComponentName: 'NOT_DATANODE',
        restartHostComponents: new Array(11),
        result: {
          batchSize: 2,
          tolerateSize: 2
        }
      },
      {
        hostComponentName: 'NOT_DATANODE',
        restartHostComponents: new Array(20),
        result: {
          batchSize: 2,
          tolerateSize: 2
        }
      },
      {
        hostComponentName: 'DATANODE',
        restartHostComponents: new Array(20),
        result: {
          batchSize: 1,
          tolerateSize: 1
        }
      }
    ];

    testCases.forEach(function (test) {
      describe(test.restartHostComponents.length + ' components to restart', function () {

        beforeEach(function () {
          view.set('batchSize', -1);
          view.set('interBatchWaitTimeSeconds', -1);
          view.set('tolerateSize', -1);
          view.set('hostComponentName', test.hostComponentName);
          view.set('restartHostComponents', test.restartHostComponents);
          view.initialize();
        });

        it('batchSize is ' + test.result.batchSize, function() {
          expect(view.get('batchSize')).to.equal(test.result.batchSize);
        });

        it('tolerateSize is ' + test.result.tolerateSize, function() {
          expect(view.get('tolerateSize')).to.equal(test.result.tolerateSize);
        });
      })
    }, this);
  });
});

});

require.register("test/views/common/select_custom_date_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/select_custom_date_view');

describe('App.JobsCustomDatesSelectView', function () {

  var view;

  beforeEach(function () {
    view = App.JobsCustomDatesSelectView.create();
  });

  describe('#isCustomEndDate', function () {

    var cases = [
      {
        duration: null,
        isCustomEndDate: false,
        title: 'duration not set'
      },
      {
        duration: 1000,
        isCustomEndDate: false,
        title: 'preset duration'
      },
      {
        duration: 0,
        isCustomEndDate: true,
        title: 'custom duration'
      }
    ];

    beforeEach(function () {
      view.reopen({
        validate: Em.K
      });
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.set('customDateFormFields.duration', {
          value: item.duration
        });
        expect(view.get('isCustomEndDate')).to.equal(item.isCustomEndDate);
      });
    });

  });

  describe('#createCustomStartDate', function () {

    var cases = [
      {
        startDate: '01/01/2016',
        hoursForStart: '01',
        minutesForStart: '00',
        middayPeriodForStart: 'AM',
        isInvalidDate: false,
        title: 'valid date and time'
      },
      {
        startDate: '',
        hoursForStart: '01',
        minutesForStart: '00',
        middayPeriodForStart: 'AM',
        isInvalidDate: true,
        title: 'no date specified'
      },
      {
        startDate: '01/01/2016',
        hoursForStart: '',
        minutesForStart: '00',
        middayPeriodForStart: 'AM',
        isInvalidDate: true,
        title: 'no hours specified'
      },
      {
        startDate: '01/01/2016',
        hoursForStart: '01',
        minutesForStart: '',
        middayPeriodForStart: 'AM',
        isInvalidDate: true,
        title: 'no minutes specified'
      },

      {
        startDate: '01/01/2016',
        hoursForStart: '01',
        minutesForStart: '00',
        middayPeriodForStart: '',
        isInvalidDate: true,
        title: 'no midday period specified'
      }
    ];

    beforeEach(function () {
      view.reopen({
        validate: Em.K
      });
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.get('customDateFormFields').setProperties({
          startDate: item.startDate,
          hoursForStart: item.hoursForStart,
          minutesForStart: item.minutesForStart,
          middayPeriodForStart: item.middayPeriodForStart
        });
        expect(Em.isNone(view.createCustomStartDate())).to.equal(item.isInvalidDate);
      });
    });

  });

  describe('#createCustomEndDate', function () {

    var customEndCases = [
      {
        endDate: '01/01/2016',
        hoursForEnd: '01',
        minutesForEnd: '00',
        middayPeriodForEnd: 'AM',
        isInvalidDate: false,
        title: 'valid date and time'
      },
      {
        endDate: '',
        hoursForEnd: '01',
        minutesForEnd: '00',
        middayPeriodForEnd: 'AM',
        isInvalidDate: true,
        title: 'no date specified'
      },
      {
        endDate: '01/01/2016',
        hoursForEnd: '',
        minutesForEnd: '00',
        middayPeriodForEnd: 'AM',
        isInvalidDate: true,
        title: 'no hours specified'
      },
      {
        endDate: '01/01/2016',
        hoursForEnd: '01',
        minutesForEnd: '',
        middayPeriodForEnd: 'AM',
        isInvalidDate: true,
        title: 'no minutes specified'
      },

      {
        endDate: '01/01/2016',
        hoursForEnd: '01',
        minutesForEnd: '00',
        middayPeriodForEnd: '',
        isInvalidDate: true,
        title: 'no midday period specified'
      }
    ];

    beforeEach(function () {
      view.reopen({
        validate: Em.K
      });
    });

    customEndCases.forEach(function (item) {
      it(item.title, function () {
        view.get('customDateFormFields').setProperties({
          endDate: item.endDate,
          hoursForEnd: item.hoursForEnd,
          minutesForEnd: item.minutesForEnd,
          middayPeriodForEnd: item.middayPeriodForEnd,
          duration: {
            value: 0
          }
        });
        expect(Em.isNone(view.createCustomEndDate(1000))).to.equal(item.isInvalidDate);
      });
    });

    it('preset duration', function () {
      view.set('customDateFormFields.duration', {
        value: 900000
      });
      expect(view.createCustomEndDate(1000)).to.equal(901000);
    });

  });

  describe('#setErrorMessage', function () {

    var cases = [
      {
        key: 'startDate',
        property: 'isStartDateError',
        value: true,
        message: 'error',
        errorMessage: 'error',
        title: 'error'
      },
      {
        key: 'endDate',
        property: 'isEndDateError',
        value: false,
        message: null,
        errorMessage: '',
        title: 'no error'
      }
    ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          view.get('errors').setProperties({
            isStartDateError: false,
            isEndDateError: true
          });
          view.get('errorMessages').setProperties({
            startDate: '',
            endDate: 'error'
          });
          view.setErrorMessage(item.key, item.message);
        });

        it('should set error flag', function () {
          expect(view.get('errors').get(item.property)).to.equal(item.value);
        });

        it('should set error message', function () {
          expect(view.get('errorMessages').get(item.key)).to.equal(item.errorMessage);
        });

      });

    });

  });

  describe('#durationSelect', function () {

    var select;

    beforeEach(function () {
      select = view.get('durationSelect').create();
    });

    describe('#willInsertElement', function () {

      var cases = [
        {
          duration: 1800000,
          selection: {
            value: 1800000,
            label: Em.I18n.t('jobs.customDateFilter.duration.30min')
          },
          title: 'should detect preset option by value'
        },
        {
          duration: Em.I18n.t('jobs.customDateFilter.duration.2hr'),
          selection: {
            value: 7200000,
            label: Em.I18n.t('jobs.customDateFilter.duration.2hr')
          },
          title: 'should detect preset option by label'
        },
        {
          duration: '40 minutes',
          selection: {
            value: 0,
            label: Em.I18n.t('common.custom')
          },
          title: 'should set "Custom" option if preset one can\'t be detected'
        }
      ];

      cases.forEach(function (item) {
        it(item.title, function () {
          select.set('selection', item.duration);
          select.willInsertElement();
          expect(select.get('selection')).to.eql(item.selection);
        });
      });

    });

  });

});

});

require.register("test/views/common/sort_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var sort = require('views/common/sort_view');
require('utils/misc');
require('utils/string_utils');

describe('#wrapperView', function () {

  describe('#getSortFunc', function () {

    describe('number', function () {

      var property = Em.Object.create({type: 'number', name: 'lastTriggered'});

      Em.A([
          {
            a: Em.Object.create({lastTriggered: 1}),
            b: Em.Object.create({lastTriggered: 0}),
            order: true,
            e: 1
          },
          {
            a: Em.Object.create({lastTriggered: 1}),
            b: Em.Object.create({lastTriggered: 0}),
            order: false,
            e: -1
          },
          {
            a: Em.Object.create({lastTriggered: null}),
            b: Em.Object.create({lastTriggered: 1}),
            order: true,
            e: -Infinity
          },
          {
            a: Em.Object.create({lastTriggered: null}),
            b: Em.Object.create({lastTriggered: 1}),
            order: false,
            e: Infinity
          }
        ]).forEach(function (test, i) {
          it('test #' + (i + 1), function () {
            var func = sort.wrapperView.create().getSortFunc(property, test.order);
            expect(func(test.a, test.b)).to.equal(test.e);
          });
      });

    });

    describe('default', function () {

      var property = Em.Object.create({type: 'string', name: 'serviceName'});

      Em.A([
          {
            a: Em.Object.create({serviceName: 's1'}),
            b: Em.Object.create({serviceName: 's2'}),
            order: true,
            e: 1
          },
          {
            a: Em.Object.create({serviceName: 's1'}),
            b: Em.Object.create({serviceName: 's2'}),
            order: false,
            e: -1
          },
          {
            a: Em.Object.create({serviceName: 's1'}),
            b: Em.Object.create({serviceName: 's1'}),
            order: true,
            e: 0
          },
          {
            a: Em.Object.create({serviceName: null}),
            b: Em.Object.create({serviceName: 's2'}),
            order: true,
            e: 1
          },
          {
            a: Em.Object.create({serviceName: null}),
            b: Em.Object.create({serviceName: 's2'}),
            order: false,
            e: -1
          },
          {
            a: Em.Object.create({serviceName: 's1'}),
            b: Em.Object.create({serviceName: 'S2'}),
            order: true,
            e: 1
          },
          {
            a: Em.Object.create({serviceName: 's1'}),
            b: Em.Object.create({serviceName: 'S2'}),
            order: false,
            e: -1
          }
        ]).forEach(function (test, i) {
          it('test #' + (i + 1), function () {
            var func = sort.wrapperView.create().getSortFunc(property, test.order);
            expect(func(test.a, test.b)).to.equal(test.e);
          });
      });

      it('test non-string values', function () {
        property = Em.Object.create({type: 'string', name: 'enabled'});
        var func = sort.wrapperView.create().getSortFunc(property, true),
        a = Em.Object.create({enabled: false}),
        b = Em.Object.create({enabled: true});
        expect(func(a, b)).to.equal(1);
      });

    });

  });

  describe('#fieldView', function () {

    var fieldView, wrapperView;

    describe('#click', function () {

      beforeEach(function () {
        fieldView = sort.fieldView.create({
          controller: Em.Object.create({
            sortingColumn: null
          })
        });
        wrapperView = sort.wrapperView.create({
          childViews: [fieldView]
        });
        fieldView.reopen({'parentView': wrapperView});

        sinon.stub(wrapperView, 'sort', Em.K);
        sinon.stub(wrapperView, 'removeSortingObserver', Em.K);
        sinon.stub(wrapperView, 'addSortingObserver', Em.K);
      });

      afterEach(function () {
        wrapperView.sort.restore();
        wrapperView.removeSortingObserver.restore();
        wrapperView.addSortingObserver.restore();
      });

      it('should call sort function of wrapperView', function () {
        fieldView.click();
        expect(wrapperView.sort.calledOnce).to.be.true;
      });

      it('should call removeSortingObserver function of wrapperView if sortingColumn is absent in controller', function () {
        fieldView.reopen({
          controller: Em.Object.create({
            sortingColumn: {name: 'test'}
          })
        });
        fieldView.click();
        expect(wrapperView.removeSortingObserver.calledOnce).to.be.true;
      });

      it('should not call removeSortingObserver function of wrapperView if sortingColumn exists in controller', function () {
        fieldView.click();
        expect(wrapperView.removeSortingObserver.calledOnce).to.be.false;
      });

      it('should call addSortingObserver function of wrapperView', function () {
        fieldView.click();
        expect(wrapperView.addSortingObserver.calledOnce).to.be.true;
      });

    })
  })

});
});

require.register("test/views/common/table_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/db');
require('views/common/filter_view');
require('views/common/sort_view');
require('mixins');
require('mixins/common/userPref');
require('views/common/table_view');

function getView() {
  return App.TableView.create({
    controller: Em.Object.create()
  });
}

describe('App.TableView', function () {

  var view;

  beforeEach(function() {
    App.db.cleanUp();
    sinon.stub(App.db, 'setFilterConditions', Em.K);
  });

  afterEach(function() {
    App.db.cleanUp();
    App.db.setFilterConditions.restore();
  });

  App.TestAliases.testAsComputedAlias(getView(), 'filteredCount', 'filteredContent.length', 'number');

  App.TestAliases.testAsComputedAlias(getView(), 'totalCount', 'content.length', 'number');

  describe('#init', function() {

    it('should set filterConditions on instance', function() {
      var tableView = App.TableView.create();
      expect(tableView.get('filterConditions')).to.be.not.equal(App.TableView.prototype.filterConditions);
    });

  });

  describe('#updatePaging', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        filtersUsedCalc: function() {},
        filter: function() {}
      });
      view.clearFilters();
      view.updateFilter();
    });

    it('should set "startIndex" to 0 if "filteredContent" is empty', function() {
      view.set('filteredContent', []);
      expect(view.get('startIndex')).to.equal(0);
    });

    it('should set "startIndex" to 1 if "filteredContent" is not empty', function() {
      view.set('filteredContent', d3.range(1, 10));
      expect(view.get('startIndex')).to.equal(1);
    });

  });

  describe('#endIndex', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        filtersUsedCalc: function() {},
        filter: function() {}
      });
      view.clearFilters();
      view.updateFilter();
    });

    it('should be recalculated if "startIndex" was changed', function() {
      view.set('startIndex', 2);
      expect(view.get('endIndex')).to.equal(11);
    });

    it('should be recalculated if "displayLength" was changed', function() {
      view.set('displayLength', 5);
      expect(view.get('endIndex')).to.equal(5);
    });

    it('should be recalculated (but not changed) if "filteredContent" was changed (and "filterContent.length" is more than "startIndex + displayLength")', function() {
      var endIndexBefore = view.get('endIndex');
      view.set('filteredContent', d3.range(2,100));
      expect(view.get('endIndex')).to.equal(endIndexBefore);
    });

    it('should be recalculated (and changed) if "filteredContent" was changed (and "filterContent.length" is less than "startIndex + displayLength")', function() {
      var endIndexBefore = view.get('endIndex');
      var indx = 4;
      view.set('filteredContent', d3.range(1,indx));
      expect(view.get('endIndex')).to.not.equal(endIndexBefore);
      expect(view.get('endIndex')).to.equal(indx - 1);
    });

  });

  describe('#pageContent', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 10,
        filtersUsedCalc: function() {},
        filter: function() {}
      });
      view.clearFilters();
      view.updateFilter();
    });

    it('should be recalculated if "startIndex" was changed', function() {
      view.set('startIndex', 2);
      expect(view.get('pageContent').length).to.equal(9);
    });

    it('should be recalculated if "endIndex" was changed', function() {
      view.set('endIndex', 5);
      expect(view.get('pageContent').length).to.equal(5);
    });

    it('should be recalculated if "filteredContent" was changed', function() {
      var pageContentBefore = view.get('pageContent');
      view.set('filteredContent', d3.range(2,100));
      expect(view.get('pageContent').length).to.equal(pageContentBefore.length);
      expect(view.get('pageContent')).to.not.eql(pageContentBefore);
    });

  });

  describe('#clearFilters', function() {

    it('should set "filterConditions" to empty array', function() {
      view.clearFilters();
      expect(view.get('filterConditions')).to.eql([]);
    });

  });

  describe('#filtersUsedCalc', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 10,
        filter: function() {}
      });
    });

    it('should set "filtersUsed" to false if "filterConditions" is empty array', function() {
      view.set('filterConditions', []);
      view.filtersUsedCalc();
      expect(view.get('filtersUsed')).to.equal(false);
    });

    it('should set "filtersUsed" to false if each value in "filterConditions" is empty', function() {
      view.set('filterConditions', [{value:''}, {value:''}]);
      view.filtersUsedCalc();
      expect(view.get('filtersUsed')).to.equal(false);
    });

    it('should set "filtersUsed" to true if one or more values in "filterConditions" are not empty', function() {
      view.set('filterConditions', [{value:''}, {value:'lol'}]);
      view.filtersUsedCalc();
      expect(view.get('filtersUsed')).to.equal(true);
    });

  });

  describe('#nextPage', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 10,
        filter: function() {}
      });
    });

    it('should set "startIndex" if "filteredContent.length is greater than "startIndex" + "displayLength"', function() {
      var oldStartIndex = view.get('startIndex');
      var displayLength = 50;
      view.set('displayLength', displayLength);
      view.nextPage();
      expect(view.get('startIndex')).to.equal(oldStartIndex + displayLength);
    });

    it('should not set "startIndex" if "filteredContent.length is equal to "startIndex" + "displayLength"', function() {
      var oldStartIndex = view.get('startIndex');
      var displayLength = 99;
      view.set('displayLength', displayLength);
      view.nextPage();
      expect(view.get('startIndex')).to.equal(oldStartIndex);
    });

    it('should not set "startIndex" if "filteredContent.length is less than "startIndex" + "displayLength"', function() {
      var oldStartIndex = view.get('startIndex');
      var displayLength = 100;
      view.set('displayLength', displayLength);
      view.nextPage();
      expect(view.get('startIndex')).to.equal(oldStartIndex);
    });

  });

  describe('#previousPage', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 50,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 60,
        filter: function() {}
      });
    });

    it('should set "startIndex" to 1', function() {
      var displayLength = 50;
      view.set('displayLength', displayLength);
      view.previousPage();
      expect(view.get('startIndex')).to.equal(1);
    });

    it('should not set "startIndex" to 40', function() {
      view.set('startIndex', 50);
      var displayLength = 10;
      view.set('displayLength', displayLength);
      view.previousPage();
      expect(view.get('startIndex')).to.equal(40);
    });

  });

  describe("#showFilteredContent", function() {
    beforeEach(function() {
      view = App.TableView.create({});
    });

    it('hide clear filters link', function () {
      view.set('filterConditions', []);
      expect(view.get('showFilteredContent')).to.be.false;
    });

    it('shows clear filters link', function () {
      view.set('filterConditions', [{value: "1"}]);
      expect(view.get('showFilteredContent')).to.be.true;
    });

    it('shows clear filters link for array filter', function () {
      view.set('filterConditions', [{value: ["1", "2"]}]);
      expect(view.get('showFilteredContent')).to.be.true;
    });
  });

  describe('#filter', function () {

    var cases = [
      {
        filterConditions: [
          {
            iColumn: 1,
            type: 'string',
            value: 'v0'
          }
        ],
        content: [
          Em.Object.create({
            c0: 'v0'
          }),
          Em.Object.create({
            c1: 'v1'
          })
        ],
        filteredContent: [],
        title: 'no matches'
      },
      {
        filterConditions: [
          {
            iColumn: 0,
            type: 'string',
            value: 'v1'
          }
        ],
        content: [
          Em.Object.create({
            c0: 'v1'
          }),
          Em.Object.create({
            c0: 'v11'
          }),
          Em.Object.create({
            c1: 'v01'
          })
        ],
        filteredContent: [
          Em.Object.create({
            c0: 'v1'
          }),
          Em.Object.create({
            c0: 'v11'
          })
        ],
        title: 'matches present'
      },
      {
        filterConditions: [],
        content: [
          Em.Object.create({
            c0: 'v0'
          }),
          Em.Object.create({
            c1: 'v1'
          })
        ],
        filteredContent: [
          Em.Object.create({
            c0: 'v0'
          }),
          Em.Object.create({
            c1: 'v1'
          })
        ],
        title: 'no filter conditions'
      },
      {
        filterConditions: [],
        filteredContent: [],
        title: 'no filter conditions, no content'
      }
    ];

    beforeEach(function () {
      view = App.TableView.create({
        colPropAssoc: ['c0', 'c1']
      });
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.setProperties({
          filterConditions: item.filterConditions,
          content: item.content
        });
        view.filter();
        expect(view.get('filteredContent')).to.eql(item.filteredContent);
      });
    });

  });

  describe('#clearStartIndex', function() {
    var view;

    beforeEach(function() {
      view = getView();
    });

    it('should reset start index', function() {
      view.set('controller.resetStartIndex', false);
      view.set('controller.startIndex', 11);
      expect(view.clearStartIndex()).to.be.true;
      expect(view.get('controller.resetStartIndex')).to.be.true;
    });

    it('should not reset start index', function() {
      view.set('controller.resetStartIndex', false);
      view.set('controller.startIndex', 1);
      expect(view.clearStartIndex()).to.be.false;
      expect(view.get('controller.resetStartIndex')).to.be.false;
    });
  });

});

});

require.register("test/views/common/widget/gauge_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/widget/gauge_widget_view');

describe('App.GaugeWidgetView', function () {

  var view;

  beforeEach(function () {
    view = App.GaugeWidgetView.create({
      value: 0,
      content: {
        properties: {
          warning_threshold: 0,
          critical_threshold: 0
        }
      }
    });
  });

  afterEach(function () {
    clearTimeout(view.get('timeoutId'));
    view.destroy();
  });

  describe("#chartView.contentColor()", function() {
    var testCases = [
      {
        title: 'both thresholds NOT existed',
        data: {
          value: 0.2,
          warningThreshold: null,
          criticalThreshold: null
        },
        result: App.healthStatusGreen
      },
      {
        title: 'both thresholds existed 1',
        data: {
          value: 0.2,
          warningThreshold: 0.1,
          criticalThreshold: 0.3
        },
        result: App.healthStatusOrange
      },
      {
        title: 'both thresholds existed 2',
        data: {
          value: 0.2,
          warningThreshold: 0.3,
          criticalThreshold: 0.1
        },
        result: App.healthStatusOrange
      },
      {
        title: 'both thresholds existed 3',
        data: {
          value: 0.05,
          warningThreshold: 0.1,
          criticalThreshold: 0.3
        },
        result: App.healthStatusGreen
      },
      {
        title: 'both thresholds existed 4',
        data: {
          value: 0.35,
          warningThreshold: 0.3,
          criticalThreshold: 0.1
        },
        result: App.healthStatusGreen
      },
      {
        title: 'both thresholds existed 5',
        data: {
          value: 0.35,
          warningThreshold: 0.1,
          criticalThreshold: 0.3
        },
        result: App.healthStatusRed
      },
      {
        title: 'both thresholds existed 6',
        data: {
          value: 0.05,
          warningThreshold: 0.3,
          criticalThreshold: 0.1
        },
        result: App.healthStatusRed
      },
      {
        title: 'only warning threshold existed 1',
        data: {
          value: 0,
          warningThreshold: 1,
          criticalThreshold: null
        },
        result: App.healthStatusGreen
      },
      {
        title: 'only warning threshold existed 2',
        data: {
          value: 2,
          warningThreshold: 1,
          criticalThreshold: null
        },
        result: App.healthStatusOrange
      },
      {
        title: 'only critical threshold existed 1',
        data: {
          value: 0.5,
          warningThreshold: null,
          criticalThreshold: 1
        },
        result: App.healthStatusGreen
      },
      {
        title: 'only critical threshold existed 2',
        data: {
          value: 1.5,
          warningThreshold: null,
          criticalThreshold: 1
        },
        result: App.healthStatusRed
      },
      {
        title: 'invalid thresholds 1',
        data: {
          value: 1.5,
          warningThreshold: '&*&%',
          criticalThreshold: 1
        },
        result: App.healthStatusRed
      },
      {
        title: 'invalid thresholds 2',
        data: {
          value: 1.5,
          warningThreshold: '&*&%',
          criticalThreshold: '@#^^'
        },
        result: App.healthStatusGreen
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('value', test.data.value);
        view.set('content.properties.warning_threshold', test.data.warningThreshold);
        view.set('content.properties.error_threshold', test.data.criticalThreshold);
        var chartView = view.chartView.create({
          parentView: view
        });
        expect(chartView.get('contentColor')).to.eql(test.result);
      });
    });
  });
});
});

require.register("test/views/common/widget/graph_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/widget/graph_widget_view');
var fileUtils = require('utils/file_utils');

describe('App.GraphWidgetView', function () {

  var view;

  beforeEach(function () {
    view = App.GraphWidgetView.create({
      content: Em.Object.create({
        properties: {}
      }),
      parentView: Em.Object.create()
    });
  });

  afterEach(function () {
    clearTimeout(view.get('timeoutId'));
    view.destroy();
  });

  describe("#adjustData()", function() {
    var testCases = [
      {
        title: 'empty data',
        data: {
          dataLinks: {},
          dataLength: 0
        },
        result: {}
      },
      {
        title: 'correct data',
        data: {
          dataLinks: {
            s1: [[0, 0]]
          },
          dataLength: 1
        },
        result:  {
          s1: [[0, 0]]
        }
      },
      {
        title: 'second series empty',
        data: {
          dataLinks: {
            s1: [[1, 0]],
            s2: []
          },
          dataLength: 1
        },
        result:  {
          s1: [[1, 0]],
          s2: [[null, 0]]
        }
      },
      {
        title: 'second series missing data at the end',
        data: {
          dataLinks: {
            s1: [[1, 0], [2, 1], [3, 2]],
            s2: [[1, 0]]
          },
          dataLength: 3
        },
        result:  {
          s1: [[1, 0], [2, 1], [3, 2]],
          s2: [[1, 0], [null, 1], [null, 2]]
        }
      },
      {
        title: 'second series missing data at the beginning',
        data: {
          dataLinks: {
            s1: [[1, 0], [2, 1], [3, 2]],
            s2: [[3, 2]]
          },
          dataLength: 3
        },
        result:  {
          s1: [[1, 0], [2, 1], [3, 2]],
          s2: [[null, 0], [null, 1], [3, 2]]
        }
      },
      {
        title: 'second series missing data in the middle',
        data: {
          dataLinks: {
            s1: [[1, 0], [2, 1], [3, 2]],
            s2: [[1, 1]]
          },
          dataLength: 3
        },
        result:  {
          s1: [[1, 0], [2, 1], [3, 2]],
          s2: [[null, 0], [1, 1], [null, 2]]
        }
      },
      {
        title: 'second and third series missing data',
        data: {
          dataLinks: {
            s1: [[1, 0], [2, 1], [3, 2]],
            s2: [[1, 1]],
            s3: [[1, 2]]
          },
          dataLength: 3
        },
        result:  {
          s1: [[1, 0], [2, 1], [3, 2]],
          s2: [[null, 0], [1, 1], [null, 2]],
          s3: [[null, 0], [null, 1], [1, 2]]
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        view.adjustData(test.data.dataLinks, test.data.dataLength);
        expect(test.data.dataLinks).to.eql(test.result);
      });
    });
  });

  describe('#exportGraphData', function () {

    var cases = [
      {
        data: null,
        downloadTextFileCallCount: 0,
        showAlertPopupCallCount: 1,
        title: 'no data'
      },
      {
        data: {},
        downloadTextFileCallCount: 0,
        showAlertPopupCallCount: 1,
        title: 'invalid data'
      },
      {
        data: [
          {
            data: null
          }
        ],
        downloadTextFileCallCount: 0,
        showAlertPopupCallCount: 1,
        title: 'empty data'
      },
      {
        data: [
          {
            data: {}
          }
        ],
        downloadTextFileCallCount: 0,
        showAlertPopupCallCount: 1,
        title: 'malformed data'
      },
      {
        data: [
          {
            name: 'name',
            data: [0,1]
          }
        ],
        downloadTextFileCallCount: 1,
        showAlertPopupCallCount: 0,
        fileData: '[{"name":"name","data":[0,1]}]',
        title: 'JSON export'
      },
      {
        data: [
          {
            data: [
              {
                key: 'value'
              }
            ]
          }
        ],
        event: {
          context: true
        },
        downloadTextFileCallCount: 1,
        showAlertPopupCallCount: 0,
        fileData: 'key,value',
        title: 'CSV export'
      }
    ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(view, 'prepareCSV').returns('key,value');
          sinon.stub(fileUtils, 'downloadTextFile', Em.K);
          sinon.stub(App, 'showAlertPopup', Em.K);
          view.set('data', item.data);
          view.exportGraphData(item.event || {});
        });

        afterEach(function () {
          view.prepareCSV.restore();
          fileUtils.downloadTextFile.restore();
          App.showAlertPopup.restore();
        });

        it('isExportMenuHidden is true', function () {
          expect(view.get('isExportMenuHidden')).to.be.true;
        });

        it('downloadTextFile calls count is calid', function () {
          expect(fileUtils.downloadTextFile.callCount).to.equal(item.downloadTextFileCallCount);
        });

        it('showAlertPopup calls count is valid', function () {
          expect(App.showAlertPopup.callCount).to.equal(item.showAlertPopupCallCount);
        });

        if (item.downloadTextFileCallCount) {
          it('download args are valid', function () {
            var fileType = item.event && item.event.context ? 'csv' : 'json',
              downloadArgs = fileUtils.downloadTextFile.firstCall.args;
            expect(downloadArgs[0].replace(/\s/g, '')).to.equal(item.fileData);
            expect(downloadArgs[1]).to.equal(fileType);
            expect(downloadArgs[2]).to.equal('data.' + fileType);
          });
        }

      });

    });

  });

  describe('#exportTargetView', function () {

    var childViews = [
        {
          p0: 'v0'
        },
        {
          p1: 'v1'
        }
      ],
      title = 'should take last child view';

    beforeEach(function () {
      view.get('childViews').pushObjects(childViews);
      view.propertyDidChange('exportTargetView');
    });

    it(title, function () {
      expect(view.get('exportTargetView')).to.eql(childViews[1]);
    });
  });

  describe("#timeRange()", function () {
    var testCases = [
      {
        time_range: null,
        currentTimeIndex: 1,
        customTimeRange: null,
        expected: 3600
      },
      {
        time_range: null,
        currentTimeIndex: 1,
        customTimeRange: 2,
        expected: 2
      },
      {
        time_range: null,
        currentTimeIndex: 8,
        customTimeRange: 2,
        expected: 0
      },
      {
        time_range: 2,
        currentTimeIndex: 1,
        customTimeRange: null,
        expected: 7200
      }
    ];

    testCases.forEach(function(test) {
      it("time_range=" + test.time_range +
         " currentTimeIndex=" + test.currentTimeIndex +
         " customTimeRange=" + test.customTimeRange, function() {
        view.set('content.properties.time_range', test.time_range);
        view.set('customTimeRange', test.customTimeRange);
        view.reopen({
          exportTargetView: Em.Object.create({
            currentTimeIndex: test.currentTimeIndex
          })
        });
        view.propertyDidChange('timeRange');
        expect(view.get('timeRange')).to.be.equal(test.expected);
      });
    });
  });

  describe("#drawWidget()", function () {

    beforeEach(function() {
      sinon.stub(view, 'calculateValues').returns({});
      view.set('data', null);
    });

    afterEach(function() {
      view.calculateValues.restore();
    });

    it("isLoaded = false", function() {
      view.set('isLoaded', false);
      view.drawWidget();
      expect(view.get('data')).to.be.null;
    });

    it("isLoaded = true", function() {
      view.set('isLoaded', true);
      view.drawWidget();
      expect(view.get('data')).to.be.eql({});
    });
  });

  describe("#calculateValues()", function () {
    beforeEach(function() {
      this.mockExtract = sinon.stub(view, 'extractExpressions');
      this.mockCompute = sinon.stub(view, 'computeExpression');
    });

    afterEach(function() {
      this.mockExtract.restore();
      this.mockCompute.restore();
    });

    var testCases = [
      {
        metrics: {},
        values: [],
        expression: [],
        computed: {},
        expected: []
      },
      {
        metrics: {},
        values: [{}],
        expression: [],
        computed: {},
        expected: []
      },
      {
        metrics: {},
        values: [{
          value: '${m1}'
        }],
        expression: ['${m1}'],
        computed: {
          '${m1}': []
        },
        expected: []
      },
      {
        metrics: {},
        values: [{
          value: '${m1}',
          name: 'v1'
        }],
        expression: ['${m1}'],
        computed: {
          '${m1}': [{
            m1: {}
          }]
        },
        expected: [
          {
            name: 'v1',
            data: [{
              m1: {}
            }]
          }
        ]
      }
    ];

    testCases.forEach(function(test) {
      it("metrics=" + JSON.stringify(test.metrics) +
         " values=" + JSON.stringify(test.values) +
         " expression=" + test.expression +
         " computed=" + test.computed, function() {
        view.set('metrics', test.metrics);
        view.set('content.values', test.values);
        this.mockCompute.returns(test.computed);
        this.mockExtract.returns(test.expression);
        expect(view.calculateValues()).to.be.eql(test.expected);
      });
    });
  });

  describe("#computeExpression()", function () {

    beforeEach(function() {
      sinon.stub(view, 'adjustData', function (dataLinks) {
        dataLinks.m1[1] = [3, 1112];
      });
    });

    afterEach(function() {
      view.adjustData.restore();
    });

    var testCases = [
      {
        expression: '1',
        metrics: [],
        expected: {
          '${1}': []
        },
        adjustDataCalled: false
      },
      {
        expression: 'm1',
        metrics: [],
        expected: {
          '${m1}': []
        },
        adjustDataCalled: false
      },
      {
        expression: 'm1',
        metrics: [{
          name: 'm1',
          data: []
        }],
        expected: {
          '${m1}': []
        },
        adjustDataCalled: false
      },
      {
        expression: 'm1',
        metrics: [{
          name: 'm1',
          data: [
            [null, 1111]
          ]
        }],
        expected: {
          '${m1}': [
            [null, 1111]
          ]
        },
        adjustDataCalled: false
      },
      {
        expression: 'm1',
        metrics: [{
          name: 'm1',
          data: [
            [1, 1111]
          ]
        }],
        expected: {
          '${m1}': [
            [1, 1111]
          ]
        },
        adjustDataCalled: false
      },
      {
        expression: 'm1+1',
        metrics: [{
          name: 'm1',
          data: [
            [1, 1111]
          ]
        }],
        expected: {
          '${m1+1}': [
            [2, 1111]
          ]
        },
        adjustDataCalled: false
      },
      {
        expression: 'm1/m2',
        metrics: [
          {
            name: 'm1',
            data: [
              [0, 1111]
            ]
          },
          {
            name: 'm2',
            data: [
              [0, 1111]
            ]
          }
        ],
        expected: {
          '${m1/m2}': [
            [0, 1111]
          ]
        },
        adjustDataCalled: false
      },
      {
        expression: 'm1+m2',
        metrics: [
          {
            name: 'm1',
            data: [
              [1, 1111]
            ]
          },
          {
            name: 'm2',
            data: [
              [1, 1111],
              [2, 1112]
            ]
          }],
        expected: {
          '${m1+m2}': [
            [2, 1111],
            [5, 1112]
          ]
        },
        adjustDataCalled: true
      }
    ];

    testCases.forEach(function(test) {
      it("expression=" + test.expression +
         " metrics=" + JSON.stringify(test.metrics), function() {
        expect(view.computeExpression(test.expression, test.metrics)).to.be.eql(test.expected);
        expect(view.adjustData.calledOnce).to.be.equal(test.adjustDataCalled);
      });
    });
  });

  describe("#addTimeProperties()", function () {

    beforeEach(function() {
      sinon.stub(App, 'dateTime').returns(10000);
      view.set('timeStep', 15);
    });

    afterEach(function() {
      App.dateTime.restore();
    });

    it("targetView is null", function() {
      view.reopen({
        exportTargetView: null
      });
      view.set('parentView', null);
      expect(view.addTimeProperties([{}])).to.be.empty;
    });

    it("empty metricPaths", function() {
      expect(view.addTimeProperties([])).to.be.empty;
    });

    it("timeRange=5", function() {
      view.reopen({
        timeRange: 5,
        exportTargetView: Em.Object.create({
          isPopup: true
        })
      });
      expect(view.addTimeProperties(['m1'])).to.be.eql([
        "m1[5,10,15]"
      ]);
    });

    it("timeRange=0, customStartTime=null", function() {
      view.reopen({
        timeRange: 0,
        exportTargetView: Em.Object.create({
          isPopup: true,
          customStartTime: null
        })
      });
      expect(view.addTimeProperties(['m1'])).to.be.eql([
        "m1[10,10,15]"
      ]);
    });

    it("timeRange=0, customStartTime=1000, customEndTime=null", function() {
      view.reopen({
        timeRange: 0,
        exportTargetView: Em.Object.create({
          isPopup: true,
          customStartTime: 1000,
          customEndTime: null
        })
      });
      expect(view.addTimeProperties(['m1'])).to.be.eql([
        "m1[10,10,15]"
      ]);
    });

    it("timeRange=0, customStartTime=1000, customEndTime=10000", function() {
      view.reopen({
        timeRange: 0,
        exportTargetView: Em.Object.create({
          isPopup: true,
          customStartTime: 1000,
          customEndTime: 10000
        })
      });
      expect(view.addTimeProperties(['m1'])).to.be.eql([
        "m1[1,10,15]"
      ]);
    });
  });

  describe("#graphView", function () {
    var graphView;

    beforeEach(function () {
      graphView = view.get('graphView').create({
        parentView: view,
        _refreshGraph: Em.K,
        $: function() {
          return {
            closest: function() {
              return {on: Em.K}
            }
          }
        }
      });
    });

    describe("#setYAxisFormatter()", function () {

      beforeEach(function () {
        sinon.stub(App.ChartLinearTimeView, 'DisplayUnitFormatter');
        graphView.set('yAxisFormatter', null);
      });

      afterEach(function () {
        App.ChartLinearTimeView.DisplayUnitFormatter.restore();
      });

      it("yAxisFormatter should not be set", function () {
        graphView.reopen({
          displayUnit: null
        });
        graphView.setYAxisFormatter();
        expect(graphView.get('yAxisFormatter')).to.be.null;
      });

      it("yAxisFormatter should be set", function () {
        graphView.reopen({
          displayUnit: 'u1'
        });
        graphView.setYAxisFormatter();
        expect(graphView.get('yAxisFormatter')).to.be.function;
      });
    });

    describe("#setTimeRange", function () {

      beforeEach(function() {
        sinon.stub(graphView.get('parentView'), 'propertyDidChange');
      });

      afterEach(function() {
        graphView.get('parentView').propertyDidChange.restore();
      });

      it("isPopup=false", function() {
        graphView.set('isPopup', false);
        graphView.setTimeRange();
        expect(graphView.get('parentView.customTimeRange')).to.be.null;
      });

      it("isPopup=true, currentTimeIndex=8", function() {
        graphView.set('isPopup', true);
        graphView.set('currentTimeIndex', 8);
        graphView.setTimeRange();
        expect(graphView.get('parentView').propertyDidChange.calledWith('customTimeRange')).to.be.true;
      });

      it("isPopup=true, currentTimeIndex=1", function() {
        graphView.set('isPopup', true);
        graphView.set('currentTimeIndex', 1);
        graphView.set('timeUnitSeconds', 10);
        expect(graphView.get('parentView.customTimeRange')).to.be.equal(10);
      });
    });

    describe("#id", function () {

      it("should return id", function() {
        graphView.set('parentView.content.id', 'g1');
        graphView.propertyDidChange('id');
        expect(graphView.get('id')).to.be.equal('widget_g1_graph');
      });
    });

    describe("#renderer", function () {

      it("should return area", function() {
        graphView.set('parentView.content.properties.graph_type', 'STACK');
        graphView.propertyDidChange('renderer');
        expect(graphView.get('renderer')).to.be.equal('area');
      });

      it("should return line", function() {
        graphView.set('parentView.content.properties.graph_type', '');
        graphView.propertyDidChange('renderer');
        expect(graphView.get('renderer')).to.be.equal('line');
      });
    });

    describe("#transformToSeries()", function () {

      beforeEach(function() {
        sinon.stub(graphView, 'transformData').returns({});
      });

      afterEach(function() {
        graphView.transformData.restore();
      });

      it("empty data", function() {
        expect(graphView.transformToSeries([])).to.be.empty;
      });

      it("should return series", function() {
        expect(graphView.transformToSeries([{}])).to.be.eql([{}]);
      });
    });

    describe("#loadData()", function () {

      beforeEach(function() {
        sinon.stub(Em.run, 'next', function(context, callback) {
          callback.apply(context);
        });
        sinon.stub(graphView, '_refreshGraph');
      });

      afterEach(function() {
        Em.run.next.restore();
        graphView._refreshGraph.restore();
      });

      it("_refreshGraph should be called", function() {
        graphView.loadData();
        expect(graphView._refreshGraph.calledOnce).to.be.true;
      });
    });

    describe("#didInsertElement()", function () {

      beforeEach(function() {
        sinon.stub(graphView, 'setYAxisFormatter');
        sinon.stub(graphView, 'loadData');
        sinon.stub(Em.run, 'next', Em.clb);
        sinon.stub(App, 'tooltip');
      });

      afterEach(function() {
        graphView.setYAxisFormatter.restore();
        graphView.loadData.restore();
        Em.run.next.restore();
        App.tooltip.restore();
      });

      it("setYAxisFormatter should be called", function() {
        graphView.didInsertElement();
        expect(graphView.setYAxisFormatter.calledOnce).to.be.true;
      });

      it("loadData should be called", function() {
        graphView.didInsertElement();
        expect(graphView.loadData.calledOnce).to.be.true;
      });

      it("App.tooltip should be called, isPreview=false", function() {
        graphView.didInsertElement();
        expect(App.tooltip.getCall(0).args[1]).to.be.eql({
          placement: 'left',
          template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner graph-tooltip"></div></div>'
        });
      });

      it("App.tooltip should be called, isPreview=true", function() {
        graphView.reopen({
          isPreview: true
        });
        graphView.didInsertElement();
        expect(App.tooltip.getCall(0).args[1]).to.be.equal('disable');
      });
    });
  });
});
});

require.register("test/views/common/widget/number_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/widget/number_widget_view');

describe('App.NumberWidgetView', function () {

  var view;

  beforeEach(function () {
    view = App.NumberWidgetView.create({
      value: 0,
      content: {
        properties: {
          warning_threshold: 0,
          critical_threshold: 0
        }
      }
    });
  });

  afterEach(function () {
    clearTimeout(view.get('timeoutId'));
    view.destroy();
  });

  describe("#contentColor()", function() {
    var testCases = [
      {
        title: 'no value',
        data: {
          value: null,
          warningThreshold: 1,
          criticalThreshold: 3
        },
        result: 'grey'
      },
      {
        title: 'no value',
        data: {
          value: null,
          warningThreshold: null,
          criticalThreshold: null
        },
        result: 'grey'
      },
      {
        title: 'no value',
        data: {
          value: null,
          warningThreshold: null,
          criticalThreshold: 3
        },
        result: 'grey'
      },
      {
        title: 'both thresholds NOT existed',
        data: {
          value: 2,
          warningThreshold: null,
          criticalThreshold: null
        },
        result: 'green'
      },
      {
        title: 'both thresholds existed',
        data: {
          value: 2,
          warningThreshold: 1,
          criticalThreshold: 3
        },
        result: 'orange'
      },
      {
        title: 'both thresholds existed',
        data: {
          value: 2,
          warningThreshold: 3,
          criticalThreshold: 1
        },
        result: 'orange'
      },
      {
        title: 'both thresholds existed',
        data: {
          value: 0.5,
          warningThreshold: 1,
          criticalThreshold: 3
        },
        result: 'green'
      },
      {
        title: 'both thresholds existed',
        data: {
          value: 3.5,
          warningThreshold: 3,
          criticalThreshold: 1
        },
        result: 'green'
      },
      {
        title: 'both thresholds existed',
        data: {
          value: 3.5,
          warningThreshold: 1,
          criticalThreshold: 3
        },
        result: 'red'
      },
      {
        title: 'both thresholds existed',
        data: {
          value: 0.5,
          warningThreshold: 3,
          criticalThreshold: 1
        },
        result: 'red'
      },
      {
        title: 'only warning threshold existed',
        data: {
          value: 0,
          warningThreshold: 1,
          criticalThreshold: null
        },
        result: 'green'
      },
      {
        title: 'only warning threshold existed',
        data: {
          value: 2,
          warningThreshold: 1,
          criticalThreshold: null
        },
        result: 'orange'
      },
      {
        title: 'only critical threshold existed',
        data: {
          value: 0.5,
          warningThreshold: null,
          criticalThreshold: 1
        },
        result: 'green'
      },
      {
        title: 'only critical threshold existed',
        data: {
          value: 1.5,
          warningThreshold: null,
          criticalThreshold: 1
        },
        result: 'red'
      },
      {
        title: 'invalid thresholds',
        data: {
          value: 1.5,
          warningThreshold: '&*&%',
          criticalThreshold: 1
        },
        result: 'red'
      },
      {
        title: 'invalid thresholds',
        data: {
          value: 1.5,
          warningThreshold: '&*&%',
          criticalThreshold: '@#^^'
        },
        result: 'green'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('value', test.data.value);
        view.set('content.properties.warning_threshold', test.data.warningThreshold);
        view.set('content.properties.error_threshold', test.data.criticalThreshold);
        expect(view.get('contentColor')).to.eql(test.result);
      });
    });
  });
});
});

require.register("test/views/installer_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/installer');

var view,
  stepsCount = 11,
  isStepDisabled = [],
  properties = [];

for (var i = 0; i < stepsCount; i++ ) {
  isStepDisabled.push(Em.Object.create({
    step: i,
    value: Boolean(Math.floor(Math.random() * 2))
  }));
  properties.push('isStep' + i + 'Disabled');
}

describe('App.InstallerView', function () {

  beforeEach(function () {
    view = App.InstallerView.create({
      controller: {
        isStepDisabled: isStepDisabled
      }
    });
  });

  properties.forEach(function (item, index) {
    describe(item, function () {
      it('should take value from isStepDisabled', function () {
        expect(view.get(item)).to.equal(isStepDisabled.findProperty('step', index).get('value'));
      });
    });
  });

});

});

require.register("test/views/login_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/login');

var view,
  pass;

describe('App.LoginView', function () {

  before(function () {
    sinon.stub(App, 'get', function(k) {
      if (k === 'router') {
        return {
          login: Em.K
        };
      }
      return Em.get(App, k);
    });
  });

  beforeEach(function () {
    view = App.LoginView.create();
    pass = view.passTextField.create({
      controller: App.LoginController.create()
    });
  });

  after(function () {
    App.get.restore();
  });

  describe('#passTextField', function () {
    it('should change error message', function () {
      pass.insertNewline();
      expect(pass.get('controller.errorMessage')).to.be.empty;
    });
  });

});

});

require.register("test/views/main/admin/highAvailability/nameNode/step1_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/highAvailability/nameNode/step1_view');

describe('App.HighAvailabilityWizardStep1View', function () {
  var view = App.HighAvailabilityWizardStep1View.create({
    controller: Em.Object.create({
      content: {}
    })
  });

  describe("#didInsertElement()", function() {
    before(function(){
      sinon.stub(App, 'popover', Em.K);
    });
    after(function(){
      App.popover.restore();
    });
    it("init popover", function() {
      view.didInsertElement();
      expect(App.popover.calledOnce).to.be.true;
    });
  });

  describe("#showInputError", function() {
    it("isNameServiceIdValid is true, nameServiceId is empty", function() {
      view.set('controller.isNameServiceIdValid', true);
      view.set('controller.content.nameServiceId', "");
      view.propertyDidChange('showInputError');
      expect(view.get('showInputError')).to.be.false;
    });
    it("isNameServiceIdValid is false, nameServiceId is empty", function() {
      view.set('controller.isNameServiceIdValid', false);
      view.set('controller.content.nameServiceId', "");
      view.propertyDidChange('showInputError');
      expect(view.get('showInputError')).to.be.false;
    });
    it("isNameServiceIdValid is true, nameServiceId is valid", function() {
      view.set('controller.isNameServiceIdValid', true);
      view.set('controller.content.nameServiceId', "name");
      view.propertyDidChange('showInputError');
      expect(view.get('showInputError')).to.be.false;
    });
    it("isNameServiceIdValid is false, nameServiceId is valid", function() {
      view.set('controller.isNameServiceIdValid', false);
      view.set('controller.content.nameServiceId', "name");
      view.propertyDidChange('showInputError');
      expect(view.get('showInputError')).to.be.true;
    });
  });
});

});

require.register("test/views/main/admin/highAvailability/nameNode/step3_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/highAvailability/nameNode/step3_view');

describe('App.HighAvailabilityWizardStep3View', function () {
  var view = App.HighAvailabilityWizardStep3View.create({
    controller: Em.Object.create({
      content: {},
      loadStep: Em.K
    })
  });

  describe("#didInsertElement()", function () {
    before(function () {
      sinon.spy(view.get('controller'), 'loadStep');
    });
    after(function () {
      view.get('controller').loadStep.restore();
    });
    it("call loadStep", function () {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.be.true;
    });
  });

  describe("#curNameNode", function() {
    it("curNameNode is get from `masterComponentHosts`", function() {
      view.set('controller.content.masterComponentHosts', [{
        component: 'NAMENODE',
        isInstalled: true,
        hostName: 'host1'
      }]);
      view.propertyDidChange('curNameNode');
      expect(view.get('curNameNode')).to.equal('host1');
    });
  });

  describe("#addNameNode", function() {
    it("addNameNode is get from `masterComponentHosts`", function() {
      view.set('controller.content.masterComponentHosts', [{
        component: 'NAMENODE',
        isInstalled: false,
        hostName: 'host1'
      }]);
      view.propertyDidChange('addNameNode');
      expect(view.get('addNameNode')).to.equal('host1');
    });
  });

  describe("#secondaryNameNode", function() {
    it("secondaryNameNode is get from `masterComponentHosts`", function() {
      view.set('controller.content.masterComponentHosts', [{
        component: 'SECONDARY_NAMENODE',
        hostName: 'host1'
      }]);
      view.propertyDidChange('secondaryNameNode');
      expect(view.get('secondaryNameNode')).to.equal('host1');
    });
  });

  describe("#journalNodes", function() {
    it("journalNodes is get from `masterComponentHosts`", function() {
      view.set('controller.content.masterComponentHosts', [{
        component: 'JOURNALNODE',
        hostName: 'host1'
      }]);
      view.propertyDidChange('journalNodes');
      expect(view.get('journalNodes')).to.eql([{
        component: 'JOURNALNODE',
        hostName: 'host1'
      }]);
    });
  });
});

});

require.register("test/views/main/admin/highAvailability/nameNode/step4_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/highAvailability/nameNode/step4_view');

describe('App.HighAvailabilityWizardStep4View', function () {
  var view = App.HighAvailabilityWizardStep4View.create({
    controller: Em.Object.create({
      content: {},
      pullCheckPointStatus: Em.K
    })
  });

  describe("#didInsertElement()", function () {
    before(function () {
      sinon.spy(view.get('controller'), 'pullCheckPointStatus');
    });
    after(function () {
      view.get('controller').pullCheckPointStatus.restore();
    });
    it("call pullCheckPointStatus", function () {
      view.didInsertElement();
      expect(view.get('controller').pullCheckPointStatus.calledOnce).to.be.true;
    });
  });

  describe("#step4BodyText", function() {
    it("formatted with dependent data", function() {
      view.set('controller.content.masterComponentHosts', [{
        component: 'NAMENODE',
        isInstalled: true,
        hostName: 'host1'
      }]);
      view.set('controller.content.hdfsUser', 'user');
      view.propertyDidChange('step4BodyText');
      expect(view.get('step4BodyText')).to.equal(Em.I18n.t('admin.highAvailability.wizard.step4.body').format('user', 'host1'));
    });
  });

  App.TestAliases.testAsComputedIfThenElse(view, 'nnCheckPointText', 'controller.isNextEnabled', Em.I18n.t('admin.highAvailability.wizard.step4.ckCreated'), Em.I18n.t('admin.highAvailability.wizard.step4.ckNotCreated'));

});

});

require.register("test/views/main/admin/highAvailability/nameNode/step6_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/highAvailability/nameNode/step6_view');

describe('App.HighAvailabilityWizardStep6View', function () {
  var view = App.HighAvailabilityWizardStep6View.create({
    controller: Em.Object.create({
      content: {},
      loadStep: Em.K
    })
  });

  describe("#didInsertElement()", function () {
    before(function () {
      sinon.spy(view.get('controller'), 'loadStep');
    });
    after(function () {
      view.get('controller').loadStep.restore();
    });
    it("call loadStep", function () {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.be.true;
    });
  });

  describe("#step6BodyText", function() {
    it("step6BodyText is formatted with dependent data", function() {
      view.set('controller.content.masterComponentHosts', [{
        component: 'NAMENODE',
        isInstalled: true,
        hostName: 'host1'
      }]);
      view.set('controller.content.hdfsUser', 'user');
      view.propertyDidChange('step6BodyText');
      expect(view.get('step6BodyText')).to.equal(Em.I18n.t('admin.highAvailability.wizard.step6.body').format('user', 'host1'));
    });
  });

  describe("#jnCheckPointText", function() {
    it("status is done", function() {
      view.set('controller.status', 'done');
      view.propertyDidChange('jnCheckPointText');
      expect(view.get('jnCheckPointText')).to.equal(Em.I18n.t('admin.highAvailability.wizard.step6.jsInit'));
    });
    it("status is waiting", function() {
      view.set('controller.status', 'waiting');
      view.propertyDidChange('jnCheckPointText');
      expect(view.get('jnCheckPointText')).to.equal(Em.I18n.t('admin.highAvailability.wizard.step6.jsNoInit'));
    });
    it("status is journalnode_stopped", function() {
      view.set('controller.status', 'journalnode_stopped');
      view.propertyDidChange('jnCheckPointText');
      expect(view.get('jnCheckPointText')).to.equal(Em.I18n.t('admin.highAvailability.wizard.step6.jnStopped'));
    });
  });
});

});

require.register("test/views/main/admin/highAvailability/nameNode/step8_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/highAvailability/nameNode/step8_view');

describe('App.HighAvailabilityWizardStep8View', function () {
  var view = App.HighAvailabilityWizardStep8View.create({
    controller: Em.Object.create({
      content: {},
      pullCheckPointStatus: Em.K
    })
  });

  describe("#step8BodyText", function() {
    it("step8BodyText is formatted with dependent data", function() {
      view.set('controller.content.masterComponentHosts', [
        {
          component: 'NAMENODE',
          isInstalled: true,
          hostName: 'host1'
        },
        {
          component: 'NAMENODE',
          isInstalled: false,
          hostName: 'host2'
        }
      ]);
      view.set('controller.content.hdfsUser', 'user');
      view.propertyDidChange('step8BodyText');
      expect(view.get('step8BodyText')).to.equal(Em.I18n.t('admin.highAvailability.wizard.step8.body').format('user', 'host1', 'host2'));
    });
  });
});

});

require.register("test/views/main/admin/highAvailability/nameNode/wizard_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/highAvailability/nameNode/wizard_view');

describe('App.HighAvailabilityWizardView', function () {
  var view = App.HighAvailabilityWizardView.create({
    controller: Em.Object.create({
      content: {},
      setLowerStepsDisable: Em.K,
      isStepDisabled: []
    })
  });

  describe("#didInsertElement()", function () {
    beforeEach(function () {
      sinon.spy(view.get('controller'), 'setLowerStepsDisable');
    });
    afterEach(function () {
      view.get('controller').setLowerStepsDisable.restore();
    });
    it("currentStep is 0", function () {
      view.set('controller.currentStep', 0);
      view.didInsertElement();
      expect(view.get('controller').setLowerStepsDisable.called).to.be.false;
    });
    it("currentStep is 4", function () {
      view.set('controller.currentStep', 4);
      view.didInsertElement();
      expect(view.get('controller').setLowerStepsDisable.called).to.be.false;
    });
    it("currentStep is 5", function () {
      view.set('controller.currentStep', 5);
      view.didInsertElement();
      expect(view.get('controller').setLowerStepsDisable.calledWith(5)).to.be.true;
    });
  });
});
});

require.register("test/views/main/admin/highAvailability/progress_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/highAvailability/progress_view');

describe('App.HighAvailabilityProgressPageView', function () {

  var view = App.HighAvailabilityProgressPageView.create({
    controller: Em.Object.create({
      loadStep: Em.K
    })
  });


  describe("#didInsertElement()", function () {
    beforeEach(function () {
      sinon.spy(view.get('controller'), 'loadStep');
    });
    afterEach(function () {
      view.get('controller').loadStep.restore();
    });
    it("loadStep is called once", function () {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.be.true;
    });
  });

  describe("#headerTitle", function () {
    beforeEach(function () {
      this.mock = sinon.stub(App.router, 'get');
    });
    afterEach(function () {
      this.mock.restore();
    });
    it("currentStep is 1", function () {
      this.mock.returns(1);
      view.propertyDidChange('headerTitle');
      expect(view.get('headerTitle')).to.equal(Em.I18n.t('admin.highAvailability.wizard.rollback.header.title'));
    });
    it("currentStep is 2", function () {
      this.mock.returns(2);
      view.propertyDidChange('headerTitle');
      expect(view.get('headerTitle')).to.equal(Em.I18n.t('admin.highAvailability.wizard.step2.header'));
    });
  });

  describe("#noticeInProgress", function () {
    beforeEach(function () {
      this.mock = sinon.stub(App.router, 'get');
    });
    afterEach(function () {
      this.mock.restore();
    });
    it("currentStep is 1", function () {
      this.mock.returns(1);
      view.propertyDidChange('noticeInProgress');
      expect(view.get('noticeInProgress')).to.equal(Em.I18n.t('admin.highAvailability.rollback.notice.inProgress'));
    });
    it("currentStep is 2", function () {
      this.mock.returns(2);
      view.propertyDidChange('noticeInProgress');
      expect(view.get('noticeInProgress')).to.equal(Em.I18n.t('admin.highAvailability.wizard.progressPage.notice.inProgress'));
    });
  });

  describe("#onStatusChange()", function() {
    it("COMPLETED status", function() {
      view.reopen({
        noticeCompleted: 'noticeCompleted'
      });
      view.set('controller.status', 'COMPLETED');
      expect(view.get('notice')).to.equal('noticeCompleted');
      expect(view.get('noticeClass')).to.equal('alert alert-success');
    });
    it("FAILED status", function() {
      view.reopen({
        noticeFailed: 'noticeFailed'
      });
      view.set('controller.status', 'FAILED');
      expect(view.get('notice')).to.equal('noticeFailed');
      expect(view.get('noticeClass')).to.equal('alert alert-error');
    });
    it("IN_PROGRESS status", function() {
      view.reopen({
        noticeInProgress: 'noticeInProgress'
      });
      view.set('controller.status', 'IN_PROGRESS');
      expect(view.get('notice')).to.equal('noticeInProgress');
      expect(view.get('noticeClass')).to.equal('alert alert-info');
    });
  });

  describe("#taskView", function() {
    var taskView = view.get('taskView').create({
      content: Em.Object.create()
    });

    describe("#didInsertElement()", function () {
      beforeEach(function () {
        sinon.spy(taskView, 'onStatus');
      });
      afterEach(function () {
        taskView.onStatus.restore();
      });
      it("onStatus is called once", function () {
        taskView.didInsertElement();
        expect(taskView.onStatus.calledOnce).to.be.true;
      });
    });

    describe("#barWidth", function () {
      it("currentStep is 1", function () {
        taskView.set('content.progress', 1);
        taskView.propertyDidChange('barWidth');
        expect(taskView.get('barWidth')).to.equal('width: 1%;');
      });
    });

    describe("#onStatus", function() {
      it("IN_PROGRESS status", function() {
        taskView.set('content.status', 'IN_PROGRESS');
        taskView.set('content.requestIds', []);
        taskView.onStatus();
        expect(taskView.get('linkClass')).to.equal('active-text');
        expect(taskView.get('icon')).to.equal('icon-cog');
        expect(taskView.get('iconColor')).to.equal('text-info');
      });
      it("FAILED status", function() {
        taskView.set('content.status', 'FAILED');
        taskView.set('content.requestIds', [{}]);
        taskView.onStatus();
        expect(taskView.get('linkClass')).to.equal('active-link');
        expect(taskView.get('icon')).to.equal('icon-exclamation-sign');
        expect(taskView.get('iconColor')).to.equal('text-error');
      });
      it("COMPLETED status", function() {
        taskView.set('content.status', 'COMPLETED');
        taskView.set('content.requestIds', []);
        taskView.onStatus();
        expect(taskView.get('linkClass')).to.equal('active-text');
        expect(taskView.get('icon')).to.equal('icon-ok');
        expect(taskView.get('iconColor')).to.equal('text-success');
      });
      it("else status", function() {
        taskView.set('content.status', '');
        taskView.set('content.requestIds', []);
        taskView.onStatus();
        expect(taskView.get('linkClass')).to.equal('not-active-link');
        expect(taskView.get('icon')).to.equal('icon-cog');
        expect(taskView.get('iconColor')).to.be.empty;
      });
    });
  });
});

});

require.register("test/views/main/admin/highAvailability/resourceManager/step3_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/highAvailability/resourceManager/step3_view');

describe('App.RMHighAvailabilityWizardStep3View', function () {
  var view;

  beforeEach(function() {
    view = App.RMHighAvailabilityWizardStep3View.create({
      controller: Em.Object.create({
        content: Em.Object.create(),
        loadStep: Em.K
      })
    });
  });

  describe("#didInsertElement()", function () {

    beforeEach(function () {
      sinon.spy(view.get('controller'), 'loadStep');
    });
    afterEach(function () {
      view.get('controller').loadStep.restore();
    });

    it("call loadStep", function () {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.be.true;
    });
  });
});

});

require.register("test/views/main/admin/highAvailability/resourceManager/wizard_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
var testHelpers = require('test/helpers');
require('views/main/admin/highAvailability/resourceManager/wizard_view');

describe('App.RMHighAvailabilityWizardView', function () {
  var view;

  beforeEach(function() {
    view = App.RMHighAvailabilityWizardView.create({
      controller: Em.Object.create({
        content: Em.Object.create(),
        setLowerStepsDisable: Em.K
      })
    });
  });

  describe("#didInsertElement()", function () {

    beforeEach(function () {
      sinon.spy(view.get('controller'), 'setLowerStepsDisable');
    });
    afterEach(function () {
      view.get('controller').setLowerStepsDisable.restore();
    });

    it("setLowerStepsDisable should not be called", function () {
      view.set('controller.currentStep', 3);
      view.didInsertElement();
      expect(view.get('controller').setLowerStepsDisable.called).to.be.false;
    });

    it("call setLowerStepsDisable", function () {
      view.set('controller.currentStep', 4);
      view.didInsertElement();
      expect(view.get('controller').setLowerStepsDisable.calledOnce).to.be.true;
    });
  });

  describe("#willInsertElement", function() {

    beforeEach(function() {
      sinon.stub(view, 'loadHosts');
    });
    afterEach(function() {
      view.loadHosts.restore();
    });

    it("loadHosts should be called", function() {
      view.willInsertElement();
      expect(view.loadHosts.calledOnce).to.be.true;
      expect(view.get('isLoaded')).to.be.false;
    });
  });

  describe("#loadHosts()", function() {

    it("App.ajax.send should be called", function() {
      view.loadHosts();
      var args = testHelpers.findAjaxRequest('name', 'hosts.high_availability.wizard');
      expect(args).to.be.exist;
    });
  });

  describe("#loadHostsSuccessCallback()", function() {
    var data = {
      items: [
        {
          Hosts: {
            host_name: 'host1',
            cpu_count: 1,
            total_mem: 1,
            disk_info: {},
            maintenance_state: 'OFF'
          }
        }
      ]
    };

    beforeEach(function() {
      sinon.stub(App.db, 'setHosts');
    });
    afterEach(function() {
      App.db.setHosts.restore();
    });

    it("App.db.setHosts should be called", function () {
      view.loadHostsSuccessCallback(data);
      expect(view.get('isLoaded')).to.be.true;
      expect(view.get('controller.content.hosts')).to.be.eql({
        "host1": {
          "name": "host1",
          "cpu": 1,
          "memory": 1,
          "disk_info": {},
          "bootStatus": "REGISTERED",
          "isInstalled": true,
          "maintenance_state": "OFF"
        }
      });
      expect(App.db.setHosts.calledWith({
        "host1": {
          "name": "host1",
          "cpu": 1,
          "memory": 1,
          "disk_info": {},
          "bootStatus": "REGISTERED",
          "isInstalled": true,
          "maintenance_state": "OFF"
        }
      })).to.be.true;
    });
  });

  describe("#loadHostsErrorCallback()", function() {

    it("isLoaded should be true", function() {
      view.loadHostsErrorCallback();
      expect(view.get('isLoaded')).to.be.true;
    });
  });
});

});

require.register("test/views/main/admin/stack_upgrade/failed_hosts_modal_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/failed_hosts_modal_view');

describe('App.FailedHostsPopupBodyView', function () {
  var view = App.FailedHostsPopupBodyView.create({
    parentView: Em.Object.create({
      content: {}
    })
  });


  describe("#subHeader", function() {
    it("subHeader is formatted with hosts count", function() {
      view.set('parentView.content', {
        hosts: ['host1', 'host2', 'host3']
      });
      view.propertyDidChange('subHeader');
      expect(view.get('subHeader')).to.equal(Em.I18n.t('admin.stackUpgrade.failedHosts.subHeader').format(3));
    });
  });

  describe("#hosts", function() {
    beforeEach(function(){
      sinon.stub(App.format, 'role', function(name){
        return name;
      })
    });
    afterEach(function(){
      App.format.role.restore();
    });

    it("hosts are mapped from parentView.content", function() {
      view.set('parentView.content', {
        hosts: ['host1', 'long.host.50.chars.commmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm'],
        host_detail: {
          "host1": [
            {
              component: 'DATANODE',
              service: 'HDFS'
            },
            {
              component: 'HBASE_REGIONSERVER',
              service: 'HBASE'
            }
          ],
          "long.host.50.chars.commmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm": [
            {
              service: 'FLUME',
              component: 'FLUME_AGENT'
            }
          ]
        }
      });
      view.propertyDidChange('hosts');
      expect(view.get('hosts')).to.eql([
        Em.Object.create({
          hostName: 'host1',
          displayName: 'host1',
          collapseId: 'collapse0',
          collapseHref: '#collapse0',
          hostComponents: [
            Em.Object.create({
              componentName: 'DATANODE',
              serviceName: 'HDFS'
            }),
            Em.Object.create({
              componentName: 'HBASE_REGIONSERVER',
              serviceName: 'HBASE'
            })
          ]
        }),
        Em.Object.create({
          hostName: 'long.host.50.chars.commmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm',
          displayName: 'long.host.50.chars.commmmmmmmmmmmmmmmmmmmmmmmmmmmm...',
          collapseId: 'collapse1',
          collapseHref: '#collapse1',
          hostComponents: [
            Em.Object.create({
              componentName: 'FLUME_AGENT',
              serviceName: 'FLUME'
            })
          ]
        })
      ]);
    });
  });
});

});

require.register("test/views/main/admin/stack_upgrade/menu_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var view;

describe('App.MainAdminStackMenuView', function () {

  beforeEach(function () {
    view = App.MainAdminStackMenuView.create({});
  });

  describe('#content', function () {

    beforeEach(function () {
      this.stub = sinon.stub(App, 'get');
    });

    afterEach(function () {
      App.get.restore();
    });

    Em.A([
        {
          stackVersionsAvailable: true,
          m: '`versions` is visible',
          e: false
        },
        {
          stackVersionsAvailable: false,
          m: '`versions` is invisible',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          this.stub.withArgs('stackVersionsAvailable').returns(test.stackVersionsAvailable);
          view.propertyDidChange('content');
          expect(view.get('content').findProperty('name', 'versions').get('hidden')).to.equal(test.e);
        });
      });

  });

});
});

require.register("test/views/main/admin/stack_upgrade/services_view_test", function(exports, require, module) {
 /**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/services_view');

describe('App.MainAdminStackServicesView', function () {
  var view = App.MainAdminStackServicesView.create();

  describe("#goToAddService()" , function() {
    var mock = Em.Object.create({
        checkAndStartKerberosWizard: Em.K,
        setDBProperty: sinon.spy()
      }),
      isAccessibleMock;
    beforeEach(function() {
      sinon.stub(App.get('router'), 'transitionTo', Em.K);
      sinon.stub(App.router, 'get').returns(mock);
      sinon.spy(mock, 'checkAndStartKerberosWizard');
      isAccessibleMock = sinon.stub(App, 'isAuthorized');
    });
    afterEach(function() {
      App.get('router').transitionTo.restore();
      App.router.get.restore();
      mock.checkAndStartKerberosWizard.restore();
      App.isAuthorized.restore();
    });
    it ("operations locked", function () {
      isAccessibleMock.returns(false);
      view.goToAddService();
      expect(App.router.get.called).to.be.false;
      expect(App.get('router').transitionTo.called).to.be.false;
    });
    it("routes to Add Service Wizard and set redirect path on wizard close", function() {
      isAccessibleMock.returns(true);
      view.goToAddService({context: "serviceName"});
      expect(App.router.get.calledWith('addServiceController')).to.be.true;
      expect(mock.setDBProperty.calledWith('onClosePath', 'main.admin.stackAndUpgrade.services')).to.be.true;
      expect(App.get('router').transitionTo.calledWith('main.serviceAdd')).to.be.true;
      expect(mock.get('serviceToInstall')).to.be.equal("serviceName");
    });
    it("routes to Security Wizard", function() {
      isAccessibleMock.returns(true);
      view.goToAddService({context: "KERBEROS"});
      expect(App.router.get.calledWith('kerberosWizardController')).to.be.true;
      expect(mock.setDBProperty.calledWith('onClosePath', 'main.admin.stackAndUpgrade.services')).to.be.true;
      expect(mock.checkAndStartKerberosWizard.calledOnce).to.be.true;
    });
  });

  describe('#isAddServiceAvailable', function () {

    var cases = [true, false],
      titleTemplate = 'should be {0}',
      isAccessibleMock;

    beforeEach(function() {
      isAccessibleMock = sinon.stub(App, 'isAuthorized');
    });

    afterEach(function() {
      App.isAuthorized.restore();
    });

    cases.forEach(function (item) {
      it(titleTemplate.format(item.toString()), function () {
        isAccessibleMock.returns(item);
        view.propertyDidChange('isAddServiceAvailable');
        expect(view.get('isAddServiceAvailable')).to.equal(item);
      });
    });

  });
});

});

require.register("test/views/main/admin/stack_upgrade/upgrade_group_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/upgrade_group_view');

describe('App.upgradeGroupView', function () {
  var view;

  beforeEach(function () {
    view = App.upgradeGroupView.create({
      content: Em.Object.create({}),
      failedStatuses: ['FAILED']
    });
  });

  afterEach(function () {
    clearTimeout(view.get('timer'));
    clearTimeout(view.get('upgradeItemTimer'));
    view.destroy();
  });

  describe("#toggleExpanded()", function () {
    var data;
    beforeEach(function () {
      sinon.stub(view, 'collapseLowerLevels', Em.K);
      data = {
        context: Em.Object.create({
          isExpanded: true
        }),
        contexts: [
          [],
          [
            Em.Object.create({
              isExpanded: true
            })
          ]
        ]
      };
      view.toggleExpanded(data);
    });
    afterEach(function () {
      view.collapseLowerLevels.restore();
    });
    it("collapseLowerLevels called twice", function () {
      expect(view.collapseLowerLevels.calledTwice).to.be.true;
    });
    it("context.isExpanded is false", function () {
      expect(data.context.get('isExpanded')).to.be.false;
    });
    it("contexts[1][0].isExpanded is false", function () {
      expect(data.contexts[1][0].get('isExpanded')).to.be.false;
    });
  });

  describe("#collapseLowerLevels()", function () {
    beforeEach(function () {
      sinon.spy(view, 'collapseLowerLevels');
    });
    afterEach(function () {
      view.collapseLowerLevels.restore();
    });
    it("isExpanded false", function () {
      var data = Em.Object.create({
        isExpanded: false
      });
      view.collapseLowerLevels(data);
      expect(view.collapseLowerLevels.calledOnce).to.be.true;
      expect(data.get('isExpanded')).to.be.false;
    });
    it("ITEM expanded", function () {
      var data = Em.Object.create({
        isExpanded: true,
        type: 'ITEM',
        tasks: [
          Em.Object.create({
            isExpanded: true
          })
        ]
      });
      view.collapseLowerLevels(data);
      expect(view.collapseLowerLevels.calledOnce).to.be.true;
      expect(data.get('tasks')[0].get('isExpanded')).to.be.false;
    });
    it("GROUP expanded", function () {
      var data = Em.Object.create({
        isExpanded: true,
        type: 'GROUP',
        upgradeItems: [
          Em.Object.create({
            isExpanded: true
          })
        ]
      });
      view.collapseLowerLevels(data);
      expect(view.collapseLowerLevels.calledTwice).to.be.true;
      expect(data.get('upgradeItems')[0].get('isExpanded')).to.be.false;
    });
  });

});
});

require.register("test/views/main/admin/stack_upgrade/upgrade_history_details_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/upgrade_history_details_view');
var testHelpers = require('test/helpers');

describe('App.MainAdminStackUpgradeHistoryDetailsView', function () {
  var view;

  beforeEach(function () {
    view = App.MainAdminStackUpgradeHistoryDetailsView.create({
      controller: {
        currentUpgradeRecord: App.StackUpgradeHistory.createRecord({
          'requestId':1,
          'direction':'DOWNGRADE',
        }),
      }
    });
  });

  afterEach(function () {
    view.destroy();
  });

  describe("#overallProgress", function () {
    it("progress is 1.9", function () {
      view.set('controller.upgradeData', {
        Upgrade: {
          progress_percent: 1.9
        }
      });
      expect(view.get('overallProgress')).to.equal(1);
    });
    it("progress is 1", function () {
      view.set('controller.upgradeData', {
        Upgrade: {
          progress_percent: 1
        }
      });
      expect(view.get('overallProgress')).to.equal(1);
    });
  });

  describe("#willInsertElement()", function() {
    beforeEach(function () {
      sinon.spy(view.get('controller'), 'loadStackUpgradeRecord');
    });
    afterEach(function () {
      view.get('controller').loadStackUpgradeRecord.restore();
    });
    it("load data by controller is called once", function() {
      view.set('controller.currentUpgradeRecord', App.StackUpgradeHistory.createRecord({
        'requestId':1,
        'direction':'DOWNGRADE',
      }));
      view.willInsertElement();
      expect(view.get('controller').loadStackUpgradeRecord.calledOnce).to.be.true;
    });
  });

  describe("#willDestroyElement()", function () {
    it("reset ready flag", function () {
      view.set('isReady', true);
      view.willDestroyElement();
      expect(view.get('isReady')).to.be.false;
    });
  });

  describe("#upgradeStatusLabel", function () {
    beforeEach(function () {
      Em.setFullPath(view, 'controller.upgradeData.Upgrade', {});
    });

    [
      {
        data: {
          status: 'QUEUED',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress')
      },
      {
        data: {
          status: 'PENDING',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress')
      },
      {
        data: {
          status: 'IN_PROGRESS',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress')
      },
      {
        data: {
          status: 'COMPLETED',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.completed')
      },
      {
        data: {
          status: 'ABORTED',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: 'TIMEDOUT',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: 'FAILED',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: 'HOLDING_FAILED',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: 'HOLDING_TIMEDOUT',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: 'HOLDING',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: '',
          isDowngrade: false
        },
        result: ''
      },
      {
        data: {
          status: 'QUEUED',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress.downgrade')
      },
      {
        data: {
          status: 'PENDING',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress.downgrade')
      },
      {
        data: {
          status: 'IN_PROGRESS',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress.downgrade')
      },
      {
        data: {
          status: 'COMPLETED',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.completed.downgrade')
      },
      {
        data: {
          status: 'ABORTED',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      },
      {
        data: {
          status: 'TIMEDOUT',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      },
      {
        data: {
          status: 'FAILED',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      },
      {
        data: {
          status: 'HOLDING_FAILED',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      },
      {
        data: {
          status: 'HOLDING_TIMEDOUT',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      },
      {
        data: {
          status: 'HOLDING',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      }
    ].forEach(function (test) {
        it('status = ' + test.data.status + ", isDowngrade = " + test.data.isDowngrade, function () {
          view.set('controller.isDowngrade', test.data.isDowngrade);
          view.set('controller.upgradeData.Upgrade.request_status', test.data.status);
          view.propertyDidChange('upgradeStatusLabel');
          expect(view.get('upgradeStatusLabel')).to.equal(test.result);
        });
      });
  });
});
});

require.register("test/views/main/admin/stack_upgrade/upgrade_history_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/upgrade_history_view');

describe('App.MainAdminStackUpgradeHistoryView', function () {
  var view;

  beforeEach(function () {
    view = App.MainAdminStackUpgradeHistoryView.create();
  });

  afterEach(function () {
    view.destroy();
  });

  describe("#filterBy()", function () {
    var records = [
        Em.Object.create({
          requestStatus: "ABORTED",
          direction: "UPGRADE"
        }),
        Em.Object.create({
          requestStatus: "ABORTED",
          direction: "DOWNGRADE"
        }),
        Em.Object.create({
          requestStatus: "COMPLETED",
          direction: "UPGRADE"
        }),
        Em.Object.create({
          requestStatus: "COMPLETED",
          direction: "DOWNGRADE"
        })
      ];


    beforeEach(function () {
      this.mock = sinon.stub(App.StackUpgradeHistory, 'find');
    });

    afterEach(function () {
      this.mock.restore();
    });

    it('All should return all records', function(){
      this.mock.returns(records);
      var filteredResults = view.filterBy('ALL')
      expect(filteredResults.length).to.be.equal(4);
    });

    it('Filter aborted upgrades', function(){
      this.mock.returns(records);
      var filteredResults = view.filterBy('UPGRADE_ABORTED')
      expect(filteredResults.length).to.be.equal(1);
    });

    it('Filter completed upgrades', function(){
      this.mock.returns(records);
      var filteredResults = view.filterBy('UPGRADE_COMPLETED')
      expect(filteredResults.length).to.be.equal(1);
    });

    it('Filter aborted downgrades', function(){
      this.mock.returns(records);
      var filteredResults = view.filterBy('DOWNGRADE_ABORTED')
      expect(filteredResults.length).to.be.equal(1);
    });

    it('Filter completed downgrades', function(){
      this.mock.returns(records);
      var filteredResults = view.filterBy('DOWNGRADE_COMPLETED')
      expect(filteredResults.length).to.be.equal(1);
    });
  });

  describe("#didInsertElement()", function() {
    beforeEach(function () {
      sinon.stub(view, 'observesCategories', Em.K);
    });
    afterEach(function () {
      view.observesCategories.restore();
    });
    it("observesCategories is called once", function() {
      view.didInsertElement();
      expect(view.observesCategories.calledOnce).to.be.true;
    });
  });

  describe("#observesCategories()", function () {
    var mock = {format: Em.K};
    beforeEach(function () {
      sinon.stub(Em.I18n, 't').returns(mock);
      sinon.stub(mock, 'format').returns('label');
      sinon.stub(view, 'filterBy').returns([]);
      view.set('categories', [
        Em.Object.create({
          labelKey: 'labelKey',
          value: 'value',
          isSelected: false
        })
      ]);
      view.observesCategories();
    });
    afterEach(function () {
      Em.I18n.t.restore();
      mock.format.restore();
      view.filterBy.restore();
    });
    it("categories[0].label is updated", function () {
      expect(view.get('categories')[0].get('label')).to.equal('label');
    });
  });

  describe("#selectCategory()", function() {
    var event;
    beforeEach(function () {
      event = {
        context: Em.Object.create({
          isSelected: false,
          value: 'ALL',
        })
      };
      view.set('categories', [
        Em.Object.create({
          isSelected: true,
          value: 'UPGRADE_COMPLETED',
        }),
        event.context
      ]);
      view.selectCategory(event);
    });
    afterEach(function () {
    });
    it("categories[0].isSelected false", function() {
      expect(view.get('categories')[0].get('isSelected')).to.be.false;
    });
    it("isSelected is true", function() {
      expect(event.context.get('isSelected')).to.be.true;
    });
  });

  describe("#willInsertElement()", function() {
    beforeEach(function () {
      sinon.spy(view.get('controller'), 'loadStackUpgradeHistoryToModel');
    });
    afterEach(function () {
      view.get('controller').loadStackUpgradeHistoryToModel.restore();
    });
    it("load data by controller is called once", function() {
      view.willInsertElement();
      expect(view.get('controller').loadStackUpgradeHistoryToModel.calledOnce).to.be.true;
    });
  });

  describe('#processForDisplay', function () {

    var timestamp = 1484698121448;

    var content = [
      Em.Object.create({
        direction: 'UPGRADE',
        upgradeType: 'ROLLING',
        startTime: timestamp,
        endTime: timestamp + 3600 * 1000
      }),
      Em.Object.create({
        direction: 'DOWNGRADE',
        upgradeType: 'HOST_ORDERED',
        startTime: timestamp,
        endTime: timestamp + 3600 * 1000 * 2
      })
    ];

    var expected = [
      Em.Object.create({
        directionLabel: Em.I18n.t('common.upgrade'),
        upgradeTypeLabel: Em.I18n.t('common.rolling'),
        duration: '1.00 hours'
      }),
      Em.Object.create({
        directionLabel: Em.I18n.t('common.downgrade'),
        upgradeTypeLabel: Em.I18n.t('common.hostOrdered'),
        duration: '2.00 hours'
      })
    ];

    var fields = ['directionLabel', 'upgradeTypeLabel', 'duration'];

    var processedContent;

    beforeEach(function () {
      sinon.stub(App, 'dateTimeWithTimeZone', function (ts) {
        return ts - 3600 * 1000 * 2
      });
      processedContent = view.processForDisplay(content);
    });

    afterEach(function () {
      App.dateTimeWithTimeZone.restore();
    });

    expected.forEach(function (item, index) {

      describe('test #' + (index + 1), function () {

        fields.forEach(function (field) {
          it('#' + field, function () {
            expect(processedContent[index].get(field)).to.be.equal(item.get(field));
          });
        });

      });

    });


    it('End Time for upgrade in progress is `Not finished`', function () {
      processedContent = view.processForDisplay([Em.Object.create({endTime: -1})]);
      expect(processedContent[0].get('endTimeLabel')).to.be.equal('Not finished');
    });
  });

});

});

require.register("test/views/main/admin/stack_upgrade/upgrade_task_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/upgrade_task_view');

describe('App.upgradeTaskView', function () {
  var view = App.upgradeTaskView.create({
    content: Em.Object.create(),
    taskDetailsProperties: ['prop1']
  });
  view.removeObserver('content.isExpanded', view, 'doPolling');
  view.removeObserver('outsideView', view, 'doPolling');

  App.TestAliases.testAsComputedOr(view, 'showContent', ['outsideView', 'content.isExpanded']);

  describe("#logTabId", function() {
    it("depends on `elementId`", function() {
      view.reopen({
        elementId: 'elementId'
      });
      expect(view.get('logTabId')).to.equal('elementId-log-tab');
    });
  });

  describe("#errorTabId", function() {
    it("depends on `elementId`", function() {
      view.reopen({
        elementId: 'elementId'
      });
      expect(view.get('errorTabId')).to.equal('elementId-error-tab');
    });
  });

  describe("#logTabIdLink", function() {
    it("depends on `logTabId`", function() {
      view.reopen({
        logTabId: 'elementId-log-tab'
      });
      expect(view.get('logTabIdLink')).to.equal('#elementId-log-tab');
    });
  });

  describe("#errorTabIdLInk", function() {
    it("depends on `errorTabId`", function() {
      view.reopen({
        errorTabId: 'elementId-error-tab'
      });
      expect(view.get('errorTabIdLInk')).to.equal('#elementId-error-tab');
    });
  });

  describe("#copyErrLog()", function () {
    before(function () {
      sinon.stub(view, 'toggleProperty', Em.K);
    });
    after(function () {
      view.toggleProperty.restore();
    });
    it("`errorLogOpened` is toggled", function () {
      view.copyErrLog();
      expect(view.toggleProperty.calledWith('errorLogOpened')).to.be.true;
    });
  });

  describe("#copyOutLog()", function () {
    before(function () {
      sinon.stub(view, 'toggleProperty', Em.K);
    });
    after(function () {
      view.toggleProperty.restore();
    });
    it("outputLogOpened is toggled", function () {
      view.copyOutLog();
      expect(view.toggleProperty.calledWith('outputLogOpened')).to.be.true;
    });
  });

  describe("#openErrorLog()", function () {
    before(function () {
      sinon.stub(view, 'openLogWindow', Em.K);
    });
    after(function () {
      view.openLogWindow.restore();
    });
    it("stderr is open with openLogWindow", function () {
      view.set('content.stderr', 'stderr');
      view.openErrorLog();
      expect(view.openLogWindow.calledWith('stderr')).to.be.true;
    });
  });

  describe("#openOutLog()", function () {
    before(function () {
      sinon.stub(view, 'openLogWindow', Em.K);
    });
    after(function () {
      view.openLogWindow.restore();
    });
    it("stdout is open with openLogWindow", function () {
      view.set('content.stdout', 'stdout');
      view.openOutLog();
      expect(view.openLogWindow.calledWith('stdout')).to.be.true;
    });
  });

  describe("#openLogWindow()", function () {
    var mockAppendChild = {
        appendChild: Em.K
      },
      mockWindow = {
        document: {
          write: Em.K,
          close: Em.K,
          createElement: function () {
            return mockAppendChild;
          },
          createTextNode: Em.K,
          body: mockAppendChild
        }
      };
    beforeEach(function () {
      sinon.stub(window, 'open').returns(mockWindow);
      sinon.spy(mockWindow.document, 'write');
      sinon.spy(mockWindow.document, 'close');
      sinon.spy(mockWindow.document, 'createElement');
      sinon.spy(mockWindow.document, 'createTextNode');
      sinon.spy(mockAppendChild, 'appendChild');
      view.openLogWindow('log');
    });
    afterEach(function () {
      window.open.restore();
      mockWindow.document.write.restore();
      mockWindow.document.close.restore();
      mockWindow.document.createElement.restore();
      mockWindow.document.createTextNode.restore();
      mockAppendChild.appendChild.restore();
    });
    it("window.open is called once", function () {
      expect(window.open.calledOnce).to.be.true;
    });
    it("pre-element is created", function () {
      expect(mockWindow.document.createElement.calledWith('pre')).to.be.true;
    });
    it("log-node is created", function () {
      expect(mockWindow.document.createTextNode.calledWith('log')).to.be.true;
    });
    it("two nodes are appended", function () {
      expect(mockAppendChild.appendChild.calledTwice).to.be.true;
    });
    it("document is closed", function () {
      expect(mockWindow.document.close.calledOnce).to.be.true;
    });
  });

});

});

require.register("test/views/main/admin/stack_upgrade/upgrade_version_box_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/upgrade_version_box_view');

describe('App.UpgradeVersionBoxView', function () {

  var view;

  beforeEach(function () {
    sinon.stub(App.db, 'setFilterConditions', Em.K);
    sinon.stub(App.db, 'getFilterConditions', function () {return [];});
    view = App.UpgradeVersionBoxView.create({
      initFilters: Em.K,
      controller: Em.Object.create({
        upgrade: Em.K,
        currentVersion: Em.Object.create()
      }),
      content: Em.Object.create(),
      parentView: Em.Object.create({
        repoVersions: []
      })
    });
  });

  afterEach(function () {
    App.db.setFilterConditions.restore();
    App.db.getFilterConditions.restore();
  });

  describe("#isUpgrading", function () {
    afterEach(function () {
      App.set('upgradeState', 'INIT');
    });
    it("wrong version", function () {
      App.set('upgradeState', 'IN_PROGRESS');
      view.set('controller.upgradeVersion', 'HDP-2.2.1');
      view.set('content.displayName', 'HDP-2.2.2');
      view.propertyDidChange('isUpgrading');
      expect(view.get('isUpgrading')).to.be.false;
    });
    it("correct version", function () {
      App.set('upgradeState', 'IN_PROGRESS');
      view.set('controller.upgradeVersion', 'HDP-2.2.2');
      view.set('content.displayName', 'HDP-2.2.2');
      view.propertyDidChange('isUpgrading');
      expect(view.get('isUpgrading')).to.be.true;
    });
    it("upgradeState INIT", function () {
      App.set('upgradeState', 'INIT');
      view.set('controller.upgradeVersion', 'HDP-2.2.2');
      view.set('content.displayName', 'HDP-2.2.2');
      view.propertyDidChange('isUpgrading');
      expect(view.get('isUpgrading')).to.be.false;
    });
    it("upgradeState INIT and wrong version", function () {
      App.set('upgradeState', 'INIT');
      view.set('controller.upgradeVersion', 'HDP-2.2.2');
      view.set('content.displayName', 'HDP-2.2.1');
      view.propertyDidChange('isUpgrading');
      expect(view.get('isUpgrading')).to.be.false;
    });
  });

  describe("#installProgress", function () {

    beforeEach(function () {
      this.mockDB = sinon.stub(App.db, 'get');
      this.mock = sinon.stub(App.router, 'get');
      App.set('testMode', false);
    });
    afterEach(function () {
      this.mockDB.restore();
      this.mock.restore();
    });

    it("request id is not set", function () {
      this.mock.returns([]);
      this.mockDB.returns(undefined);
      view.propertyDidChange('installProgress');
      expect(view.get('installProgress')).to.equal(0);
    });
    it("request absent", function () {
      this.mock.returns([]);
      this.mockDB.returns([1]);
      view.propertyDidChange('installProgress');
      expect(view.get('installProgress')).to.equal(0);
    });
    it("request present", function () {
      this.mockDB.returns([1]);
      this.mock.returns([Em.Object.create({progress: 100, id: 1})]);
      view.propertyDidChange('installProgress');
      expect(view.get('installProgress')).to.equal(100);
    });
  });

  describe("#versionClass", function () {
    it("status CURRENT", function () {
      view.set('content.status', 'CURRENT');
      view.propertyDidChange('versionClass');
      expect(view.get('versionClass')).to.equal('current-version-box');
    });
    it("status INSTALLED", function () {
      view.set('content.status', 'INSTALLED');
      view.propertyDidChange('versionClass');
      expect(view.get('versionClass')).to.equal('');
    });
  });

  describe("#isOutOfSync", function () {
    it("status OUT_OF_SYNC", function () {
      view.set('content.status', 'OUT_OF_SYNC');
      view.propertyDidChange('isOutOfSync');
      expect(view.get('isOutOfSync')).to.be.true;
    });
  });

  describe("#didInsertElement()", function () {
    beforeEach(function () {
      sinon.stub(App, 'tooltip').returns(1);
    });
    afterEach(function () {
      App.tooltip.restore();
    });
    it("init tooltips", function () {
      view.didInsertElement();
      expect(App.tooltip.callCount).to.equal(4);
    });
  });

  describe("#runAction()", function () {
    var hasClass = function () {
        return true;
      },
      jQueryMock;
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'upgrade').returns(1);
      jQueryMock = sinon.stub(window, '$');
    });
    afterEach(function () {
      view.get('controller').upgrade.restore();
      jQueryMock.restore();
    });
    it("action = null", function () {
      view.set('stateElement.action', null);
      view.runAction({context: null});
      expect(view.get('controller').upgrade.called).to.be.false;
    });
    it("action = 'upgrade'", function () {
      view.set('content', 'content');
      view.runAction({context: 'upgrade'});
      expect(view.get('controller').upgrade.calledWith('content')).to.be.true;
    });
    it("action is taken from stateElement", function () {
      view.setProperties({
        'content': 'content',
        'stateElement.action': 'upgrade'
      });
      view.runAction();
      expect(view.get('controller').upgrade.calledWith('content')).to.be.true;
    });
    it("link is disabled", function () {
      jQueryMock.returns({
        hasClass: hasClass,
        parent: function () {
          return {
            hasClass: Em.K
          };
        }
      });
      view.runAction({
        context: 'upgrade',
        target: {}
      });
      expect(view.get('controller').upgrade.called).to.be.false;
    });
    it("link parent element is disabled", function () {
      jQueryMock.returns({
        height: Em.K,
        hasClass: Em.K,
        parent: function () {
          return {
            hasClass: hasClass
          };
        }
      });
      view.runAction({
        context: 'upgrade',
        target: {}
      });
      expect(view.get('controller').upgrade.called).to.be.false;
    });
  });
  
  describe("#getStackVersionNumber()", function(){
    it("get stack version number", function(){
      var repoRecord = Em.Object.create({
        operatingSystems: [
          Em.Object.create({
            osType: "redhat6",
            repositories: [Em.Object.create({
                "baseUrl": "111121",
                "repoId": "HDP-2.3",
                "repoName": "HDP",
                "stackVersion": "2.3",
                hasError: false
            }), Em.Object.create({
                "baseUrl": "1",
                "repoId": "HDP-UTILS-1.1.0.20",
                "repoName": "HDP-UTILS",
                "stackVersion": "2.3",
                hasError: false
              })]
           })
        ]
      });
      
      var stackVersionNumber = view.getStackVersionNumber(repoRecord);
      expect(stackVersionNumber).to.equal('2.3');
    });
  });
  
  describe("#editRepositories()", function () {
    var cases = [
      {
        isRepoUrlsEditDisabled: true,
        popupShowCallCount: 0,
        title: 'edit repo URLS disabled, popup shouldn\'t be shown'
      },
      {
        isRepoUrlsEditDisabled: false,
        popupShowCallCount: 1,
        title: 'edit repo URLS enabled, popup should be shown'
      }
    ];
    beforeEach(function () {
      sinon.stub(App.RepositoryVersion, 'find').returns(Em.Object.create({
        operatingSystems: []
      }));
      sinon.stub(App.ModalPopup, 'show', Em.K);
    });
    afterEach(function () {
      App.RepositoryVersion.find.restore();
      App.ModalPopup.show.restore();
    });
    cases.forEach(function (item) {
      it(item.title, function () {
        view.reopen({
          isRepoUrlsEditDisabled: item.isRepoUrlsEditDisabled
        });
        view.editRepositories();
        expect(App.ModalPopup.show.callCount).to.equal(item.popupShowCallCount);
      });
    });
  });

  describe("#showHosts()", function () {
    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(view, 'filterHostsByStack', Em.K);
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
      view.filterHostsByStack.restore();
    });
    it("no hosts", function () {
      view.set('content', Em.Object.create({
        p1: []
      }));
      view.set('p1', []);
      view.showHosts({contexts: [
        {'property': 'p1'}
      ]});
      expect(App.ModalPopup.show.called).to.be.false;
    });
    it("one host", function () {
      view.set('content', Em.Object.create({
        p1: ['host1'],
        displayName: 'version'
      }));
      view.set('p1', ['host1']);
      var popup = view.showHosts({contexts: [
        {value: 1, 'property': 'p1'}
      ]});
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(view.filterHostsByStack.calledWith('version', 1)).to.be.true;
    });
  });

  describe("#filterHostsByStack()", function () {
    var mock = {
      set: Em.K,
      filterByStack: Em.K
    };
    beforeEach(function () {
      sinon.stub(App.router, 'get').withArgs('mainHostController').returns(mock);
      sinon.stub(App.router, 'transitionTo', Em.K);
      sinon.spy(mock, 'set');
      sinon.spy(mock, 'filterByStack');
    });
    afterEach(function () {
      App.router.get.restore();
      App.router.transitionTo.restore();
      mock.set.restore();
      mock.filterByStack.restore();
    });
    it("version and state are valid", function () {
      view.filterHostsByStack('version', 'state');
      expect(mock.set.calledWith('showFilterConditionsFirstLoad', true)).to.be.true;
      expect(mock.set.calledWith('filterChangeHappened', true)).to.be.true;
      expect(mock.filterByStack.calledWith('version', 'state')).to.be.true;
      expect(App.router.transitionTo.calledWith('hosts.index')).to.be.true;
    });
    it("version is null", function () {
      view.filterHostsByStack(null, 'state');
      expect(mock.set.called).to.be.false;
      expect(mock.filterByStack.called).to.be.false;
      expect(App.router.transitionTo.called).to.be.false;
    });
    it("state is null", function () {
      view.filterHostsByStack('version', null);
      expect(mock.set.called).to.be.false;
      expect(mock.filterByStack.called).to.be.false;
      expect(App.router.transitionTo.called).to.be.false;
    });
    it("state and version are null", function () {
      view.filterHostsByStack(null, null);
      expect(mock.set.called).to.be.false;
      expect(mock.filterByStack.called).to.be.false;
      expect(App.router.transitionTo.called).to.be.false;
    });
  });

  describe('#stateElement', function () {

    var cases = [
      {
        inputData: {
          'content.status': 'CURRENT'
        },
        expected: {
          status: 'CURRENT',
          isLabel: true,
          text: Em.I18n.t('common.current'),
          class: 'label label-success'
        },
        title: 'current version'
      },
      {
        inputData: {
          'content.status': 'INIT',
          'controller.requestInProgress': false,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'INIT'
            })
          ]
        },
        setup: function () {
          this.isAccessibleMock.withArgs('CLUSTER.UPGRADE_DOWNGRADE_STACK').returns(false);
          this.initMock.returns(false);
        },
        expected: {
          status: 'INIT',
          isButton: true,
          buttons: [],
          isDisabled: false
        },
        title: 'INIT state, no admin access, no requests in progress'
      },
      {
        inputData: {
          'content.status': 'INIT',
          'controller.requestInProgress': true,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'INIT'
            })
          ]
        },
        setup: function () {
          this.isAccessibleMock.withArgs('CLUSTER.UPGRADE_DOWNGRADE_STACK').returns(false);
          this.initMock.returns(true);
        },
        expected: {
          status: 'INIT',
          isButton: true,
          buttons: [],
          isDisabled: true
        },
        title: 'INIT state, no admin access, request in progress, not installation'
      },
      {
        inputData: {
          'content.status': 'INSTALL_FAILED',
          'controller.requestInProgress': true,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'INSTALL_FAILED'
            }),
            Em.Object.create({
              status: 'INSTALLING'
            })
          ],
          'controller.currentVersion': {
            repository_version: '2.2.0'
          },
          'content.repositoryVersion': '2.2.1',
          'controller.upgradeVersion': 'HDP-2.2.0',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.isAccessibleMock.withArgs('CLUSTER.UPGRADE_DOWNGRADE_STACK').returns(false);
          this.initMock.returns(true);
        },
        expected: {
          status: 'INSTALL_FAILED',
          isButtonGroup: true,
          buttons: [{
            text: Em.I18n.t('admin.stackVersions.version.reinstall'),
            action: 'installRepoVersionConfirmation',
            isDisabled: true
          }],
          text: Em.I18n.t('admin.stackVersions.version.performUpgrade'),
          action: 'confirmUpgrade',
          isDisabled: true
        },
        title: 'INSTALL_FAILED state, no admin access, request in progress, another installation running'
      },
      {
        inputData: {
          'content.status': 'INSTALL_FAILED',
          'controller.requestInProgress': false,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'INSTALL_FAILED'
            }),
            Em.Object.create({
              status: 'INSTALLING'
            })
          ],
          'controller.currentVersion': {
            repository_version: '2.2.0'
          },
          'content.repositoryVersion': '2.2.1',
          'controller.upgradeVersion': 'HDP-2.2.0',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.isAccessibleMock.withArgs('CLUSTER.UPGRADE_DOWNGRADE_STACK').returns(false);
          this.initMock.returns(true);
        },
        expected: {
          status: 'INSTALL_FAILED',
          isButtonGroup: true,
          buttons: [{
            text: Em.I18n.t('admin.stackVersions.version.reinstall'),
            action: 'installRepoVersionConfirmation',
            isDisabled: true
          }],
          text: Em.I18n.t('admin.stackVersions.version.performUpgrade'),
          action: 'confirmUpgrade',
          isDisabled: true
        },
        title: 'INSTALL_FAILED state, no admin access, no requests in progress, another installation running'
      },
      {
        inputData: {
          'content.status': 'OUT_OF_SYNC',
          'controller.requestInProgress': false,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'OUT_OF_SYNC'
            })
          ],
          'controller.currentVersion': {
            repository_version: '2.2.0'
          },
          'content.repositoryVersion': '2.2.1',
          'controller.upgradeVersion': 'HDP-2.2.0',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.isAccessibleMock.withArgs('CLUSTER.UPGRADE_DOWNGRADE_STACK').returns(true);
          this.initMock.returns(true);
          this.isDisabledMock.returns(false);
        },
        expected: {
          status: 'OUT_OF_SYNC',
          isButtonGroup: true,
          buttons: [{
            text: Em.I18n.t('admin.stackVersions.version.performUpgrade'),
            action: 'confirmUpgrade',
            isDisabled: false
          }],
          text: Em.I18n.t('admin.stackVersions.version.reinstall'),
          action: 'installRepoVersionConfirmation',
          isDisabled: false
        },
        title: 'OUT_OF_SYNC state, admin access, no requests in progress, no installation'
      },
      {
        inputData: {
          'content.status': 'OUT_OF_SYNC',
          'controller.requestInProgress': true,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'OUT_OF_SYNC'
            })
          ],
          'controller.currentVersion': {
            repository_version: '2.2.0'
          },
          'content.repositoryVersion': '2.2.1',
          'controller.upgradeVersion': 'HDP-2.2.0',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.isAccessibleMock.withArgs('CLUSTER.UPGRADE_DOWNGRADE_STACK').returns(true);
        },
        expected: {
          status: 'OUT_OF_SYNC',
          isButtonGroup: true,
          buttons: [{
            text: Em.I18n.t('admin.stackVersions.version.performUpgrade'),
            action: 'confirmUpgrade',
            isDisabled: true
          }],
          text: Em.I18n.t('admin.stackVersions.version.reinstall'),
          action: 'installRepoVersionConfirmation',
          isDisabled: true
        },
        title: 'OUT_OF_SYNC state, admin access, request in progress, no installation'
      },
      {
        inputData: {
          'content.status': 'INSTALLED',
          'controller.currentVersion': {
            repository_version: '2.2.1'
          },
          'content.repositoryVersion': '2.2.0',
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.0'
        },
        expected: {
          status: 'INSTALLED',
          isLink: true,
          iconClass: 'icon-ok',
          text: Em.I18n.t('common.installed'),
          action: null
        },
        title: 'installed version, earlier than current one'
      },
      {
        inputData: {
          'content.status': 'INSTALLED',
          'controller.requestInProgress': true,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'INSTALLED'
            }),
            Em.Object.create({
              status: 'INSTALLING'
            })
          ],
          'controller.currentVersion': {
            repository_version: '2.2.0'
          },
          'content.repositoryVersion': '2.2.1',
          'controller.upgradeVersion': 'HDP-2.2.0',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.isAccessibleMock.withArgs('CLUSTER.UPGRADE_DOWNGRADE_STACK').returns(true);
          this.initMock.returns(true);
        },
        expected: {
          status: 'INSTALLED',
          isButtonGroup: true,
          buttons: [
            {
              text: Em.I18n.t('admin.stackVersions.version.reinstall'),
              action: 'installRepoVersionConfirmation',
              isDisabled: true
            }
          ],
          isDisabled: true
        },
        title: 'installed version, later than current one, admin access, request in progress, another installation running'
      },
      {
        inputData: {
          'content.status': 'INSTALLED',
          'controller.requestInProgress': false,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'INSTALLED'
            }),
            Em.Object.create({
              status: 'INSTALLING'
            })
          ],
          'controller.currentVersion': {
            repository_version: '2.2.0'
          },
          'content.repositoryVersion': '2.2.1',
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.0'
        },
        setup: function () {
          this.isAccessibleMock.withArgs('CLUSTER.UPGRADE_DOWNGRADE_STACK').returns(true);
        },
        expected: {
          status: 'INSTALLED',
          isButtonGroup: true,
          buttons: [
            {
              text: Em.I18n.t('admin.stackVersions.version.reinstall'),
              action: 'installRepoVersionConfirmation',
              isDisabled: true
            }
          ],
          isDisabled: true
        },
        title: 'installed version, later than current one, admin access, no requests in progress, another installation running'
      },
      {
        inputData: {
          'content.status': 'INSTALLED',
          'controller.isDowngrade': true,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns(null);
        },
        expected: {
          status: 'INSTALLED',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-cog',
          text: Em.I18n.t('admin.stackVersions.version.downgrade.running')
        },
        title: 'downgrading'
      },
      {
        inputData: {
          'content.status': 'INSTALLED',
          'isUpgrading': true,
          'controller.isDowngrade': false,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('IN_PROGRESS');
        },
        expected: {
          status: 'INSTALLED',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-cog',
          text: Em.I18n.t('admin.stackVersions.version.upgrade.running')
        },
        title: 'upgrading'
      },
      {
        inputData: {
          'content.status': 'UPGRADING',
          'isUpgrading': true,
          'controller.isDowngrade': false,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('HOLDING');
        },
        expected: {
          status: 'UPGRADING',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-pause',
          text: Em.I18n.t('admin.stackVersions.version.upgrade.pause')
        },
        title: 'upgrading, holding'
      },
      {
        inputData: {
          'content.status': 'UPGRADING',
          'isUpgrading': true,
          'controller.isDowngrade': false,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'controller.isWizardRestricted': true,
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('HOLDING');
        },
        expected: {
          isDisabled: true,
          status: 'UPGRADING',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-pause',
          text: Em.I18n.t('admin.stackVersions.version.upgrade.pause')
        },
        title: 'upgrading, holding, isWizardRestricted=true'
      },
      {
        inputData: {
          'content.status': 'UPGRADING',
          'isUpgrading': true,
          'controller.isDowngrade': false,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('HOLDING_FAILED');
        },
        expected: {
          status: 'UPGRADING',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-pause',
          text: Em.I18n.t('admin.stackVersions.version.upgrade.pause')
        },
        title: 'upgrading, holding failed'
      },
      {
        inputData: {
          'content.status': 'UPGRADING',
          'isUpgrading': true,
          'controller.isDowngrade': false,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('ABORTED');
        },
        expected: {
          status: 'UPGRADING',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-pause',
          text: Em.I18n.t('admin.stackVersions.version.upgrade.pause')
        },
        title: 'upgrading, upgrade aborted'
      },
      {
        inputData: {
          'content.status': 'UPGRADE_FAILED',
          'isUpgrading': true,
          'controller.isDowngrade': false,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('HOLDING_TIMEDOUT');
        },
        expected: {
          status: 'UPGRADE_FAILED',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-pause',
          text: Em.I18n.t('admin.stackVersions.version.upgrade.pause')
        },
        title: 'upgrade failed, holding finished on timeout'
      },
      {
        inputData: {
          'content.status': 'UPGRADE_FAILED',
          'isUpgrading': true,
          'controller.isDowngrade': true,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('HOLDING');
        },
        expected: {
          status: 'UPGRADE_FAILED',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-pause',
          text: Em.I18n.t('admin.stackVersions.version.downgrade.pause')
        },
        title: 'downgrading, holding'
      },
      {
        inputData: {
          'content.status': 'UPGRADED',
          'isUpgrading': true,
          'controller.isDowngrade': true,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('HOLDING_FAILED');
        },
        expected: {
          status: 'UPGRADED',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-pause',
          text: Em.I18n.t('admin.stackVersions.version.downgrade.pause')
        },
        title: 'downgrading, holding failed'
      },
      {
        inputData: {
          'content.status': 'UPGRADED',
          'isUpgrading': true,
          'controller.isDowngrade': true,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('ABORTED');
        },
        expected: {
          status: 'UPGRADED',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-pause',
          text: Em.I18n.t('admin.stackVersions.version.downgrade.pause')
        },
        title: 'downgrading, upgrade aborted'
      },
      {
        inputData: {
          'content.status': 'UPGRADED',
          'isUpgrading': true,
          'controller.isDowngrade': true,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('HOLDING_TIMEDOUT');
        },
        expected: {
          status: 'UPGRADED',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-pause',
          text: Em.I18n.t('admin.stackVersions.version.downgrade.pause')
        },
        title: 'downgrading, holding finished on timeout'
      },
      {
        inputData: {
          'content.status': 'UPGRADING',
          'isUpgrading': true,
          'controller.isDowngrade': false,
          'controller.requestInProgress': false,
          'parentView.repoVersions': []
        },
        setup: function () {
          this.getMock.withArgs('upgradeSuspended').returns('true');
        },
        expected: {
          status: 'UPGRADING',
          isButton: true,
          action: 'resumeUpgrade',
          text: Em.I18n.t('admin.stackUpgrade.dialog.resume'),
          isDisabled: false
        },
        title: 'upgrade suspended'
      },
      {
        inputData: {
          'content.status': 'UPGRADE_FAILED',
          'isUpgrading': true,
          'controller.isDowngrade': true,
          'controller.requestInProgress': true,
          'parentView.repoVersions': []
        },
        setup: function () {
          this.getMock.withArgs('upgradeSuspended').returns('true');
        },
        expected: {
          status: 'UPGRADE_FAILED',
          isButton: true,
          action: 'resumeUpgrade',
          text: Em.I18n.t('admin.stackUpgrade.dialog.resume.downgrade'),
          isDisabled: true
        },
        title: 'downgrade suspended, request in progress'
      }
    ];

    beforeEach(function () {
      this.getMock = sinon.stub(App, 'get');
      this.isAccessibleMock = sinon.stub(App, 'isAuthorized');
      this.initMock = sinon.stub(view, 'isDisabledOnInit');
      this.isDisabledMock = sinon.stub(view, 'isDisabledOnInstalled').returns(true);
    });
    afterEach(function () {
      this.getMock.restore();
      this.isAccessibleMock.restore();
      this.initMock.restore();
      this.isDisabledMock.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        if (item.setup) {
          item.setup.call(this);
        }
        view.setProperties(item.inputData);
        var result = view.get('stateElement').getProperties(Em.keys(item.expected));
        if (result.buttons) {
          result.buttons = result.buttons.toArray();
        }
        expect(result).to.eql(item.expected);
      });
    }, this);

  });

  describe('#isRepoUrlsEditDisabled', function () {

    var cases = [
      {
        status: 'INSTALLING',
        isUpgrading: false,
        isRepoUrlsEditDisabled: true,
        title: 'installing packages'
      },
      {
        status: 'UPGRADING',
        isUpgrading: true,
        isRepoUrlsEditDisabled: true,
        title: 'upgrading'
      },
      {
        status: 'INSTALLED',
        isUpgrading: true,
        isRepoUrlsEditDisabled: true,
        title: 'upgrading just started'
      },
      {
        status: 'INIT',
        isUpgrading: false,
        isRepoUrlsEditDisabled: false,
        title: 'neither upgrading nor installing packages'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        view.reopen({
          isUpgrading: item.isUpgrading
        });
        view.set('content.status', item.status);
        expect(view.get('isRepoUrlsEditDisabled')).to.equal(item.isRepoUrlsEditDisabled);
      });
    });
  });

  describe("#isDisabledOnInit()", function () {
    var testCases = [
      {
        requestInProgress: true,
        upgradeIsRunning: true,
        upgradeSuspended: true,
        status: 'INSTALLED',
        isCompatible: true,
        expected: true
      },
      {
        requestInProgress: false,
        upgradeIsRunning: true,
        upgradeSuspended: false,
        status: 'INSTALLED',
        isCompatible: true,
        expected: true
      },
      {
        requestInProgress: false,
        upgradeIsRunning: false,
        upgradeSuspended: false,
        status: 'INSTALLING',
        isCompatible: true,
        expected: true
      },
      {
        requestInProgress: false,
        upgradeIsRunning: true,
        upgradeSuspended: true,
        status: 'INSTALLED',
        isCompatible: false,
        expected: true
      },
      {
        requestInProgress: false,
        upgradeIsRunning: true,
        upgradeSuspended: true,
        status: 'INSTALLED',
        isCompatible: true,
        expected: false
      },
      {
        requestInProgress: false,
        upgradeIsRunning: false,
        upgradeSuspended: false,
        status: 'INSTALLED',
        isCompatible: true,
        expected: false
      }
    ];

    beforeEach(function() {
      this.mock = sinon.stub(App, 'get');
    });

    afterEach(function() {
      this.mock.restore();
    });

    testCases.forEach(function(test) {
      it("requestInProgress: " + test.requestInProgress +
         " upgradeIsRunning: " + test.upgradeIsRunning +
         " upgradeSuspended: " + test.upgradeSuspended +
         " status" + test.status +
         " isCompatible" + test.isCompatible, function() {
        this.mock.withArgs('upgradeSuspended').returns(test.upgradeSuspended);
        this.mock.withArgs('upgradeIsRunning').returns(test.upgradeIsRunning);
        view.set('parentView.repoVersions', [Em.Object.create({
          status: test.status
        })]);
        view.set('controller.requestInProgress', test.requestInProgress);
        view.set('content.isCompatible', test.isCompatible);
        expect(view.isDisabledOnInit()).to.be.equal(test.expected);
      });
    });
  });

  describe("#isDisabledOnInstalled()", function () {

    beforeEach(function() {
      this.authorizedMock = sinon.stub(App, 'isAuthorized');
    });

    afterEach(function() {
      this.authorizedMock.restore();
    });

    var testCases = [
      {
        isAuthorized: false,
        requestInProgress: false,
        status: 'INSTALLED',
        isDowngrade: false,
        repositoryName: 'HDP-2.2',
        upgradeVersion: 'HDP-2.3',
        expected: true
      },
      {
        isAuthorized: true,
        requestInProgress: true,
        status: 'INSTALLED',
        isDowngrade: false,
        repositoryName: 'HDP-2.2',
        upgradeVersion: 'HDP-2.3',
        expected: true
      },
      {
        isAuthorized: true,
        requestInProgress: false,
        status: 'INSTALLING',
        isDowngrade: false,
        repositoryName: 'HDP-2.2',
        upgradeVersion: 'HDP-2.3',
        expected: true
      },
      {
        isAuthorized: true,
        requestInProgress: false,
        status: 'INSTALLED',
        isDowngrade: true,
        repositoryName: 'HDP-2.2',
        upgradeVersion: 'HDP-2.2',
        expected: true
      },
      {
        isAuthorized: true,
        requestInProgress: false,
        status: 'INSTALLED',
        isDowngrade: true,
        repositoryName: 'HDP-2.2',
        upgradeVersion: 'HDP-2.3',
        expected: false
      },
      {
        isAuthorized: true,
        requestInProgress: false,
        status: 'INSTALLED',
        isDowngrade: false,
        repositoryName: 'HDP-2.2',
        upgradeVersion: 'HDP-2.2',
        expected: false
      }
    ];

    testCases.forEach(function(test) {
      it( "isAuthorized: " + test.isAuthorized +
          "requestInProgress: " + test.requestInProgress +
          "status: " + test.status +
          "isDowngrade: " + test.isDowngrade +
          "repositoryName: " + test.repositoryName +
          "upgradeVersion: " + test.upgradeVersion, function() {
        this.authorizedMock.returns(test.isAuthorized);
        view.set('controller.requestInProgress', test.requestInProgress);
        view.set('parentView.repoVersions', [Em.Object.create({status: test.status})]);
        view.set('controller.isDowngrade', test.isDowngrade);
        view.set('controller.currentVersion.repository_name', test.repositoryName);
        view.set('controller.upgradeVersion', test.upgradeVersion);
        expect(view.isDisabledOnInstalled()).to.be.equal(test.expected);
      });
    });
  });
});

});

require.register("test/views/main/admin/stack_upgrade/upgrade_wizard_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/upgrade_wizard_view');
var testHelpers = require('test/helpers');

function getView() {
  var v = App.upgradeWizardView.create({
    failedStatuses: ['FAILED']
  });
  v.reopen({
    controller: Em.Object.create({
      finalizeContext: 'Confirm Finalize',
      upgradeData: Em.Object.create(),
      loadUpgradeData: Em.K,
      setUpgradeItemStatus: Em.K,
      getUpgradeItem: function () {
        return {complete: Em.K};
      }
    })
  });
  v.removeObserver('App.clusterName', v, 'startPolling');
  return v;
}

describe('App.upgradeWizardView', function () {
  var view;

  beforeEach(function () {
    App.ajax.send.restore();
    sinon.stub(App.ajax, 'send').returns({
      complete: Em.clb
    });
    view = getView();
  });

  afterEach(function () {
    clearTimeout(view.get('upgradeItemTimer'));
    view.destroy();
  });

  App.TestAliases.testAsComputedOr(getView(), 'isManualProceedDisabled', ['!isManualDone', 'controller.requestInProgress']);

  App.TestAliases.testAsComputedEqualProperties(getView(), 'isFinalizeItem', 'manualItem.context', 'controller.finalizeContext');

  describe("#upgradeGroups", function () {
    it("upgradeGroups is null", function () {
      view.set('controller.upgradeData.upgradeGroups', null);
      view.propertyDidChange('upgradeGroups');
      expect(view.get('upgradeGroups')).to.be.empty;
    });
    it("upgradeGroups is valid", function () {
      view.set('controller.upgradeData.upgradeGroups', [Em.Object.create()]);
      view.propertyDidChange('upgradeGroups');
      expect(view.get('upgradeGroups')).to.not.be.empty;
    });
  });

  describe("#activeGroup", function () {
    it("status is updated", function () {
      view.reopen({
        activeStatuses: ['IN_PROGRESS'],
        upgradeGroups: [Em.Object.create({
          status: 'IN_PROGRESS'
        })]
      });
      view.propertyDidChange('activeGroup');
      expect(view.get('activeGroup')).to.eql(Em.Object.create({
        status: 'IN_PROGRESS'
      }));
    });
  });

  describe("#overallProgress", function () {
    it("progress is 1.9", function () {
      view.set('controller.upgradeData', {
        Upgrade: {
          progress_percent: 1.9
        }
      });
      expect(view.get('overallProgress')).to.equal(1);
    });
    it("progress is 1", function () {
      view.set('controller.upgradeData', {
        Upgrade: {
          progress_percent: 1
        }
      });
      expect(view.get('overallProgress')).to.equal(1);
    });
  });

  describe("#startPolling()", function () {
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'loadUpgradeData', function () {
        return {
          done: Em.clb
        }
      });
      sinon.stub(view, 'doPolling', Em.K);
      view.set('isLoaded', false);
    });
    afterEach(function () {
      view.get('controller').loadUpgradeData.restore();
      view.doPolling.restore();
    });
    it("clusterName is null", function () {
      App.set('clusterName', null);
      view.startPolling();
      expect(view.doPolling.called).to.be.false;
      expect(view.get('isLoaded')).to.be.false;
    });
    it("clusterName set", function () {
      App.set('clusterName', 'c1');
      view.startPolling();
      expect(view.get('controller').loadUpgradeData.calledOnce).to.be.true;
      expect(view.doPolling.calledOnce).to.be.true;
      expect(view.get('isLoaded')).to.be.true;
    });
  });

  describe("#willInsertElement()", function () {
    beforeEach(function () {
      sinon.stub(view, 'startPolling', Em.K);
    });
    afterEach(function () {
      view.startPolling.restore();
    });
    it("call startPolling()", function () {
      view.willInsertElement();
      expect(view.startPolling.calledOnce).to.be.true;
    });
  });

  describe("#willDestroyElement()", function () {
    it("call startPolling()", function () {
      view.set('isLoaded', true);
      view.willDestroyElement();
      expect(view.get('isLoaded')).to.be.false;
    });
  });

  describe("#doPolling()", function () {
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'loadUpgradeData', function () {
        return {
          done: Em.clb
        }
      });
      sinon.spy(view, 'doPolling');
      this.clock = sinon.useFakeTimers();
      view.doPolling();
      this.clock.tick(App.bgOperationsUpdateInterval);
    });
    afterEach(function () {
      view.get('controller').loadUpgradeData.restore();
      view.doPolling.restore();
      this.clock.restore();
    });
    it("loadUpgradeData is called once", function () {
      expect(view.get('controller').loadUpgradeData.calledOnce).to.be.true;
    });
    it("doPolling is called twice", function () {
      expect(view.doPolling.calledTwice).to.be.true;
    });
  });

  describe("#continue()", function () {
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'setUpgradeItemStatus', Em.K);
      view.continue({context: Em.Object.create({'status': 'HOLDING_FAILED'})});
    });
    afterEach(function () {
      view.get('controller').setUpgradeItemStatus.restore();
    });
    it("setUpgradeItemStatus is called with correct data", function () {
      expect(view.get('controller').setUpgradeItemStatus.calledWith(Em.Object.create({'status': 'HOLDING_FAILED'}), 'FAILED')).to.be.true;
    });
    it("isDetailsOpened is false", function () {
      expect(view.get('isDetailsOpened')).to.be.false;
    });
  });

  describe("#complete()", function () {
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'setUpgradeItemStatus', Em.K);
      view.complete({context: Em.Object.create({'status': 'FAILED'})});
    });
    afterEach(function () {
      view.get('controller').setUpgradeItemStatus.restore();
    });
    it("setUpgradeItemStatus is called with correct data", function () {
      expect(view.get('controller').setUpgradeItemStatus.calledWith(Em.Object.create({'status': 'FAILED'}), 'COMPLETED')).to.be.true;
    });
    it("isManualDone is false", function () {
      expect(view.get('isManualDone')).to.be.false;
    });
  });

  describe("#retry()", function () {
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'setUpgradeItemStatus', Em.K);
      view.retry({context: Em.Object.create({'status': 'FAILED'})});
    });
    afterEach(function () {
      view.get('controller').setUpgradeItemStatus.restore();
    });
    it("setUpgradeItemStatus is called with correct data", function () {
      expect(view.get('controller').setUpgradeItemStatus.calledWith(Em.Object.create({'status': 'FAILED'}), 'PENDING')).to.be.true;
    });
    it("isDetailsOpened is false", function () {
      expect(view.get('isDetailsOpened')).to.be.false;
    });
  });

  describe("#manualItem", function () {

    beforeEach(function () {
      view.reopen({
        activeGroup: Em.Object.create()
      });
    });

    it("no running item", function () {
      view.set('activeGroup.upgradeItems', []);
      view.propertyDidChange('manualItem');
      expect(view.get('manualItem')).to.be.undefined;
    });
    it("running item present", function () {
      view.set('activeGroup.upgradeItems', [Em.Object.create({status: 'HOLDING'})]);
      view.propertyDidChange('manualItem');
      expect(view.get('manualItem')).to.be.eql(Em.Object.create({status: 'HOLDING'}));
    });
  });

  describe("#resetManualDone()", function() {
    it("isManualDone is set to false", function() {
      view.set('isManualDone', true);
      view.propertyDidChange('manualItem');
      expect(view.get('isManualDone')).to.be.false;
    });
  });

  describe("#failedItem", function () {

    beforeEach(function () {
      view.reopen({
        activeGroup: Em.Object.create()
      });
    });

    it("no running item", function () {
      view.set('activeGroup.upgradeItems', []);
      view.propertyDidChange('failedItem');
      expect(view.get('failedItem')).to.be.undefined;
    });
    it("running item present", function () {
      view.set('activeGroup.upgradeItems', [Em.Object.create({status: 'FAILED'})]);
      view.propertyDidChange('failedItem');
      expect(view.get('failedItem')).to.be.eql(Em.Object.create({status: 'FAILED'}));
    });
  });

  describe("#runningItem", function () {

    beforeEach(function () {
      view.reopen({
        activeGroup: Em.Object.create()
      });
    });

    it("no running item", function () {
      view.set('activeGroup.upgradeItems', []);
      view.propertyDidChange('runningItem');
      expect(view.get('runningItem')).to.be.undefined;
    });
    it("running item present", function () {
      view.set('activeGroup.upgradeItems', [
        Em.Object.create({status: 'IN_PROGRESS'})
      ]);
      view.propertyDidChange('runningItem');
      expect(view.get('runningItem')).to.be.eql(Em.Object.create({status: 'IN_PROGRESS'}));
    });
  });

  describe("#noActiveItem", function () {
    beforeEach(function () {
      this.mock = sinon.stub(App, 'get');
    });
    afterEach(function () {
      this.mock.restore();
    });
    [
      {
        data: {
          failedItem: null,
          runningItem: null,
          manualItem: null,
          upgradeState: 'COMPLETED'
        },
        result: false
      },
      {
        data: {
          failedItem: null,
          runningItem: null,
          manualItem: null,
          upgradeState: 'INIT'
        },
        result: false
      },
      {
        data: {
          failedItem: null,
          runningItem: null,
          manualItem: null,
          upgradeState: 'ABORTED'
        },
        result: false
      },
      {
        data: {
          failedItem: null,
          runningItem: null,
          manualItem: null,
          upgradeState: 'IN_PROGRESS'
        },
        result: true
      },
      {
        data: {
          failedItem: {},
          runningItem: null,
          manualItem: null,
          upgradeState: 'IN_PROGRESS'
        },
        result: false
      },
      {
        data: {
          failedItem: null,
          runningItem: {},
          manualItem: null,
          upgradeState: 'IN_PROGRESS'
        },
        result: false
      },
      {
        data: {
          failedItem: null,
          runningItem: null,
          manualItem: {},
          upgradeState: 'IN_PROGRESS'
        },
        result: false
      }
    ].forEach(function (test) {
        it("failedItem = " + test.data.failedItem +
        ";runningItem = " + test.data.runningItem +
        ";manualItem = " + test.data.manualItem +
        ";upgradeState = " + test.data.upgradeState, function () {
          view.reopen(test.data);
          this.mock.withArgs('upgradeState').returns(test.data.upgradeState);
          view.propertyDidChange('noActiveItem');
          expect(view.get('noActiveItem')).to.equal(test.result);
        });
      });
  });

  describe("#isHoldingState", function () {
    var testCases = [
      {
        data: {
          failedItem: {status: 'PENDING'}
        },
        result: false
      },
      {
        data: {
          failedItem: {status: 'HOLDING_FAILED'}
        },
        result: true
      },
      {
        data: {
          failedItem: {status: 'HOLDING_TIMED_OUT'}
        },
        result: true
      }
    ];
    testCases.forEach(function (test) {
      it('failedItem - ' + test.data.failedItem, function () {
        view.reopen({
          failedItem: test.data.failedItem
        });
        view.propertyDidChange('isHoldingState');
        expect(view.get('isHoldingState')).to.equal(test.result);
      });
    });
  });

  App.TestAliases.testAsComputedAnd(getView(), 'isDowngradeAvailable', ['!controller.isDowngrade', 'controller.downgradeAllowed', '!controller.cantBeStarted']);

  describe("#taskDetails", function () {
    it("runningItem present", function () {
      view.reopen({
        runningItem: Em.Object.create({
          tasks: [{status: "IN_PROGRESS"}]
        })
      });
      view.propertyDidChange('taskDetails');
      expect(view.get('taskDetails')).to.eql({status: "IN_PROGRESS"});
    });
    it("failedItem present", function () {
      view.reopen({
        failedItem: Em.Object.create({
          tasks: [Em.Object.create({status: "FAILED"})]
        }),
        failedStatuses: ['FAILED'],
        runningItem: null
      });
      view.propertyDidChange('taskDetails');
      expect(view.get('taskDetails').get('status')).to.equal('FAILED');
    });
    it("failedItem and runningItem are absent", function () {
      view.reopen({
        failedItem: null,
        runningItem: null
      });
      view.propertyDidChange('taskDetails');
      expect(view.get('taskDetails')).to.be.null;
    });
  });

  describe("#toggleDetails()", function () {
    beforeEach(function () {
      sinon.stub(view, 'toggleProperty', Em.K);
    });
    afterEach(function () {
      view.toggleProperty.restore();
    });
    it("isDetailsOpened is toggled", function () {
      view.toggleDetails();
      expect(view.toggleProperty.calledWith('isDetailsOpened')).to.be.true;
    });
  });

  describe("#upgradeStatusLabel", function () {

    beforeEach(function () {
      Em.setFullPath(view, 'controller.upgradeData.Upgrade', {});
    });

    [
      {
        data: {
          status: 'QUEUED',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress')
      },
      {
        data: {
          status: 'PENDING',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress')
      },
      {
        data: {
          status: 'IN_PROGRESS',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress')
      },
      {
        data: {
          status: 'COMPLETED',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.completed')
      },
      {
        data: {
          status: 'ABORTED',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: 'TIMEDOUT',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: 'FAILED',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: 'HOLDING_FAILED',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: 'HOLDING_TIMEDOUT',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: 'HOLDING',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: '',
          isDowngrade: false
        },
        result: ''
      },
      {
        data: {
          status: 'QUEUED',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress.downgrade')
      },
      {
        data: {
          status: 'PENDING',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress.downgrade')
      },
      {
        data: {
          status: 'IN_PROGRESS',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress.downgrade')
      },
      {
        data: {
          status: 'COMPLETED',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.completed.downgrade')
      },
      {
        data: {
          status: 'ABORTED',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      },
      {
        data: {
          status: 'TIMEDOUT',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      },
      {
        data: {
          status: 'FAILED',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      },
      {
        data: {
          status: 'HOLDING_FAILED',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      },
      {
        data: {
          status: 'HOLDING_TIMEDOUT',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      },
      {
        data: {
          status: 'HOLDING',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      }
    ].forEach(function (test) {
        it('status = ' + test.data.status + ", isDowngrade = " + test.data.isDowngrade, function () {
          view.set('controller.isDowngrade', test.data.isDowngrade);
          view.set('controller.upgradeData.Upgrade.request_status', test.data.status);
          view.propertyDidChange('upgradeStatusLabel');
          expect(view.get('upgradeStatusLabel')).to.equal(test.result);
        });
      });
  });

  describe("#doUpgradeItemPolling()", function () {
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'getUpgradeItem', function () {
        return {
          complete: Em.clb
        }
      });
      sinon.spy(view, 'doUpgradeItemPolling');
      this.clock = sinon.useFakeTimers();
    });

    afterEach(function () {
      view.get('controller').getUpgradeItem.restore();
      view.doUpgradeItemPolling.restore();
      this.clock.restore();
    });

    it("running item details", function () {
      view.reopen({
        runningItem: {},
        failedItem: null
      });
      view.set('isDetailsOpened', true);
      //doUpgradeItemPolling triggered by observer
      expect(view.get('controller').getUpgradeItem.calledOnce).to.be.true;
      this.clock.tick(App.bgOperationsUpdateInterval);
      expect(view.doUpgradeItemPolling.calledTwice).to.be.true;
    });

    it("failed item details", function () {
      view.reopen({
        failedItem: {},
        runningItem: null
      });
      view.set('isDetailsOpened', true);
      expect(view.get('controller').getUpgradeItem.calledOnce).to.be.true;
      this.clock.tick(App.bgOperationsUpdateInterval);
      expect(view.doUpgradeItemPolling.calledTwice).to.be.true;
    });

    it("details not opened", function () {
      view.set('isDetailsOpened', false);
      //doUpgradeItemPolling triggered by observer
      expect(view.get('controller').getUpgradeItem.called).to.be.false;
    });

  });

  describe('#getSkippedServiceChecks()', function () {

    var cases = [
      {
        isFinalizeItem: false,
        areSkippedServiceChecksLoaded: true,
        ajaxSendCallCount: 0,
        areSkippedServiceChecksLoadedResult: false,
        title: 'no ajax request should be sent away from Finalize step'
      },
      {
        isFinalizeItem: true,
        areSkippedServiceChecksLoaded: true,
        ajaxSendCallCount: 0,
        areSkippedServiceChecksLoadedResult: true,
        title: 'no ajax request should be sent if data is already loaded'
      },
      {
        isFinalizeItem: true,
        areSkippedServiceChecksLoaded: false,
        ajaxSendCallCount: 1,
        areSkippedServiceChecksLoadedResult: true,
        title: 'ajax request should be sent on Finalize step'
      }
    ];

    beforeEach(function () {
      view.set('controller.upgradeId', 1);
    });

    cases.forEach(function (item) {
      describe(item.title, function () {

        beforeEach(function () {
          view.set('controller.areSkippedServiceChecksLoaded', item.areSkippedServiceChecksLoaded);
          view.reopen({
            isFinalizeItem: item.isFinalizeItem
          });
          view.propertyDidChange('isFinalizeItem');
        });

        it('areSkippedServiceChecksLoaded is ' + item.areSkippedServiceChecksLoaded, function () {
          expect(view.get('controller.areSkippedServiceChecksLoaded')).to.equal(item.areSkippedServiceChecksLoadedResult);
        });

        if (item.ajaxSendCallCount) {
          it('request is sent ' + item.ajaxSendCallCount + ' times', function (){
            var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.service_checks');
            expect(args).to.have.property('length').equal(item.ajaxSendCallCount);
          });

          it('upgradeId is 1', function () {
            var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.service_checks');
            expect(args[0].data.upgradeId).to.equal(1);
          });
        }
        else {
          it('request is not sent times', function () {
            var args = testHelpers.findAjaxRequest('name', 'admin.upgrade.service_checks');
            expect(args).not.exists;
          });
        }
      });
    });

  });

  describe('#getSkippedServiceChecksSuccessCallback()', function () {

    var data = {
      items: [
        {
          upgrade_items: [
            {
              tasks: [
                {
                  Tasks: {
                    command_detail: 'SERVICE_CHECK HDFS'
                  }
                }
              ]
            }
          ]
        },
        {
          upgrade_items: [
            {
              tasks: [
                {
                  Tasks: {
                    command_detail: 'SERVICE_CHECK ZOOKEEPER'
                  }
                }
              ]
            },
            {
              tasks: [
                {
                  Tasks: {
                    command_detail: 'SERVICE_CHECK YARN'
                  }
                }
              ]
            },
            {},
            {
              tasks: []
            },
            {
              tasks: [
                {
                  Tasks: null
                },
                {
                  Tasks: {
                    command_detail: 'SERVICE_CHECK HIVE'
                  }
                }
              ]
            },
            {
              tasks: [
                {
                  Tasks: {
                    command_detail: null
                  }
                },
                {
                  Tasks: {
                    command_detail: 'SERVICE_CHECK YARN'
                  }
                }
              ]
            },
            {
              tasks: [
                {
                  Tasks: {
                    command_detail: 'RESTART HDFS'
                  }
                }
              ]
            }
          ]
        }
      ]
    };

    it('should set an array of service names from tha latest service checks step', function () {
      view.getSkippedServiceChecksSuccessCallback(data);
      expect(view.get('controller.skippedServiceChecks')).to.eql(['ZooKeeper', 'YARN', 'Hive']);
    });

  });

  describe("#failedHostsMessage", function() {
    it("is formatted with slaveComponentStructuredInfo", function() {
      view.set('controller.slaveComponentStructuredInfo', {
        hosts: ['host1']
      });
      view.propertyDidChange('failedHostsMessage');
      expect(view.get('failedHostsMessage')).to.equal(Em.I18n.t('admin.stackUpgrade.failedHosts.showHosts').format(1));
    });
  });

  describe("#getSlaveComponentItem()", function() {
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'getUpgradeItem', function () {
        return {
          complete: Em.clb
        }
      });
      view.set('controller.areSlaveComponentFailuresHostsLoaded', false);
    });
    afterEach(function () {
      view.get('controller').getUpgradeItem.restore();
    });

    it("isSlaveComponentFailuresItem is false", function() {
      view.reopen({
        isSlaveComponentFailuresItem: false
      });
      view.getSlaveComponentItem();
      expect(view.get('controller.areSlaveComponentFailuresHostsLoaded')).to.be.false;
    });
    it("isSlaveComponentFailuresItem is true", function() {
      view.reopen({
        isSlaveComponentFailuresItem: true
      });
      view.getSlaveComponentItem();
      expect(view.get('controller').getUpgradeItem.calledOnce).to.be.true;
      expect(view.get('controller.areSlaveComponentFailuresHostsLoaded')).to.be.true;
    });
  });

  describe("#getServiceCheckItem()", function() {
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'getUpgradeItem', function () {
        return {
          complete: Em.clb
        }
      });
      view.set('controller.areServiceCheckFailuresServicenamesLoaded', false);
    });
    afterEach(function () {
      view.get('controller').getUpgradeItem.restore();
    });

    it("isServiceCheckFailuresItem is false", function() {
      view.reopen({
        isServiceCheckFailuresItem: false
      });
      view.getServiceCheckItem();
      expect(view.get('controller.areServiceCheckFailuresServicenamesLoaded')).to.be.false;
    });
    it("isServiceCheckFailuresItem is true", function() {
      view.reopen({
        isServiceCheckFailuresItem: true
      });
      view.getServiceCheckItem();
      expect(view.get('controller').getUpgradeItem.calledOnce).to.be.true;
      expect(view.get('controller.areServiceCheckFailuresServicenamesLoaded')).to.be.true;
    });
  });

});

});

require.register("test/views/main/admin/stack_upgrade/version_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/upgrade_wizard_view');
var testHelpers = require('test/helpers');

describe('App.mainAdminStackVersionsView', function () {
  var view;

  beforeEach(function () {
    view = App.MainAdminStackVersionsView.create({
      controller: {
        currentVersion: {
          repository_version: "2.2.1.0",
          runningCheckRequests: []
        },
        load: Em.K
      }
    });
  });

  afterEach(function () {
    clearTimeout(view.get('updateTimer'));
    view.destroy();
  });

  describe("#filterBy()", function () {
    var versions = [
        Em.Object.create({
          status: "INIT",
          repositoryVersion: "2.2.1.1"
        }),
        Em.Object.create({
          status: "INSTALLING",
          repositoryVersion: "2.2.1.1"
        }),
        Em.Object.create({
          status: "INSTALLED",
          repositoryVersion: "2.2.0.1"
        }),
        Em.Object.create({
          status: "INSTALLED",
          repositoryVersion: "2.2.2.1"
        }),
        Em.Object.create({
          status: "INSTALLED",
          repositoryVersion: "2.2.3.1",
          displayName: 'HDP-2.2'
        }),
        Em.Object.create({
          status: "INSTALL_FAILED",
          repositoryVersion: "2.2.1.1"
        }),
        Em.Object.create({
          status: "OUT_OF_SYNC",
          repositoryVersion: "2.2.1.1"
        }),
        Em.Object.create({
          status: "UPGRADED",
          repositoryVersion: "2.2.1.1"
        }),
        Em.Object.create({
          status: "CURRENT",
          repositoryVersion: "2.2.1.1"
        })
      ],
      testCases = [
        {
          filter:  Em.Object.create({
            value: ''
          }),
          filteredVersions: [
            Em.Object.create({
              status: "INIT",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "INSTALLING",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "INSTALLED",
              repositoryVersion: "2.2.2.1"
            }),
            Em.Object.create({
              status: "INSTALLED",
              repositoryVersion: "2.2.3.1",
              displayName: 'HDP-2.2'
            }),
            Em.Object.create({
              status: "INSTALL_FAILED",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "OUT_OF_SYNC",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "UPGRADED",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "CURRENT",
              repositoryVersion: "2.2.1.1"
            })
          ]
        },
        {
          filter:  Em.Object.create({
            value: 'NOT_INSTALLED'
          }),
          filteredVersions: [
            Em.Object.create({
              status: "INIT",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "INSTALLING",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "INSTALL_FAILED",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "OUT_OF_SYNC",
              repositoryVersion: "2.2.1.1"
            })
          ]
        },
        {
          filter:  Em.Object.create({
            value: 'INSTALLED'
          }),
          filteredVersions: [

          ]
        },
        {
          filter:  Em.Object.create({
            value: 'UPGRADE_READY'
          }),
          filteredVersions: [
            Em.Object.create({
              status: "INSTALLED",
              repositoryVersion: "2.2.2.1"
            })
          ]
        },
        {
          filter:  Em.Object.create({
            value: 'CURRENT'
          }),
          filteredVersions: [
            Em.Object.create({
              status: "CURRENT",
              repositoryVersion: "2.2.1.1"
            })
          ]
        },
        {
          filter:  Em.Object.create({
            value: 'UPGRADING'
          }),
          filteredVersions: [
            Em.Object.create({
              status: "INSTALLED",
              repositoryVersion: "2.2.3.1",
              displayName: 'HDP-2.2'
            })
          ]
        },
        {
          filter:  Em.Object.create({
            value: 'UPGRADED'
          }),
          filteredVersions: [
            Em.Object.create({
              status: "UPGRADED",
              repositoryVersion: "2.2.1.1"
            })
          ]
        },
        {
          noCurrentVersion: true,
          filter:  Em.Object.create({
            value: ''
          }),
          filteredVersions: versions,
          message: 'no current version'
        },
        {
          displayOlderVersions: true,
          filter:  Em.Object.create({
            value: ''
          }),
          filteredVersions: versions,
          message: 'display older versions'
        }
      ];

    var displayOlderVersions = false;

    beforeEach(function () {
      sinon.stub(App, 'get', function (key) {
        return key === 'supports.displayOlderVersions' ? displayOlderVersions : Em.get(App, key);
      });
      sinon.stub(App.router, 'get').returns('HDP-2.2')
    });

    afterEach(function () {
      App.get.restore();
      App.router.get.restore();
    });

    testCases.forEach(function(t) {
      var msg = t.filter.get('value') || "All";
      it(t.message || "filter By " + msg, function () {
        displayOlderVersions = t.displayOlderVersions;
        view.set('controller.currentVersion', t.noCurrentVersion ? null : {repository_version: '2.2.1.1'});
        expect(view.filterBy(versions, t.filter)).to.eql(t.filteredVersions);
      });
    });
  });

  describe("#didInsertElement()", function() {
    beforeEach(function () {
      sinon.stub(view, 'observesCategories', Em.K);
    });
    afterEach(function () {
      view.observesCategories.restore();
    });
    it("observesCategories is called once", function() {
      view.didInsertElement();
      expect(view.observesCategories.calledOnce).to.be.true;
    });
  });

  describe("#observesCategories()", function () {
    var mock = {format: Em.K};
    beforeEach(function () {
      sinon.stub(Em.I18n, 't').returns(mock);
      sinon.stub(mock, 'format').returns('label');
      sinon.stub(view, 'filterBy').returns([]);
      sinon.stub(view, 'filterVersions');
      view.set('categories', [
        Em.Object.create({
          labelKey: 'labelKey',
          value: 'value',
          isSelected: false
        })
      ]);
      view.observesCategories();
    });
    afterEach(function () {
      Em.I18n.t.restore();
      mock.format.restore();
      view.filterBy.restore();
      view.filterVersions.restore();
    });
    it("categories[0].label is updated", function () {
      expect(view.get('categories')[0].get('label')).to.equal('label');
    });
    it("filterVersions is called once", function () {
      expect(view.filterVersions.calledOnce).to.be.true;
    });
  });

  describe("#selectCategory()", function() {
    var event;
    beforeEach(function () {
      sinon.stub(view, 'filterVersions');
      event = {
        context: Em.Object.create({
          isSelected: false
        })
      };
      view.set('categories', [
        Em.Object.create({
          isSelected: true
        }),
        event.context
      ]);
      view.selectCategory(event);
    });
    afterEach(function () {
      view.filterVersions.restore();
    });
    it("categories[0].isSelected false", function() {
      expect(view.get('categories')[0].get('isSelected')).to.be.false;
    });
    it("isSelected is true", function() {
      expect(event.context.get('isSelected')).to.be.true;
    });
    it("filterVersions is called with correct data", function() {
      expect(view.filterVersions.calledWith(event.context)).to.be.true;
    });
  });

  describe("#filterVersions()", function() {
    beforeEach(function () {
      sinon.stub(view, 'filterBy').returns([{id: 1}]);
      sinon.stub(view, 'observesCategories', Em.K);
    });
    afterEach(function () {
      view.filterBy.restore();
      view.observesCategories.restore();
    });
    it("isVisible for repoVersion is updated", function() {
      view.set('repoVersions', [Em.Object.create({id: 1})]);
      view.filterVersions();
      expect(view.get('repoVersions')[0].get('isVisible')).to.be.true;
    });
  });

  describe("#goToVersions()", function() {
    var data = {
      components: [{
        'RootServiceComponents': {
          'component_version': '1.9.0'
        }
      }, {
        'RootServiceComponents': {
          'component_version': '2.1.0'
        }
      }, {
        'RootServiceComponents': {
          'component_version': '2.0.0'
        }
      }]
    };
    before(function () {
      sinon.spy(App, 'showConfirmationPopup');
      sinon.stub(window.location, 'replace', Em.K);
    });
    after(function () {
      App.showConfirmationPopup.restore();
      window.location.replace.restore();
    });

    beforeEach(function () {
      App.ajax.send.restore();
      sinon.stub(App.ajax, 'send').returns({
        then: function(callback) {
          callback(data);
        }
      });
    });

    it("should go to link using the version retrieved by query", function() {
      var popup = view.goToVersions();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      var args = testHelpers.findAjaxRequest('name', 'ambari.service.load_server_version');
      expect(args[0]).exists;
      expect(window.location.replace.calledWith('/views/ADMIN_VIEW/2.1.0/INSTANCE/#/stackVersions')).to.be.true;
    });
  });

  describe("#willInsertElement()", function() {
    beforeEach(function () {
      sinon.stub(view, 'poll', Em.K);
    });
    afterEach(function () {
      view.poll.restore();
    });
    it("poll is called once", function() {
      view.willInsertElement();
      expect(view.poll.calledOnce).to.be.true;
    });
  });

  describe("#willDestroyElement()", function() {
    var request;
    beforeEach(function () {
      request = {
        abort: Em.K
      };
      sinon.spy(window, 'clearTimeout');
      sinon.spy(request, 'abort');
      view.set('controller.runningCheckRequests', [request, request]);
      view.willDestroyElement();
    });
    afterEach(function () {
      window.clearTimeout.restore();
      request.abort.restore();
    });
    it("clearTimeout is called once", function() {
      expect(window.clearTimeout.calledOnce).to.be.true;
    });
    it("abort is called twice", function() {
      expect(request.abort.calledTwice).to.be.true;
    });
    it("runningCheckRequests is empty", function() {
      expect(view.get('controller.runningCheckRequests')).to.have.length(0);
    });
  });

  describe("#poll()", function() {
    beforeEach(function () {
      this.mock = sinon.stub(App.router, 'get');
      sinon.stub(view.get('controller'), 'load').returns({done: Em.K});
    });
    afterEach(function () {
      this.mock.restore();
      view.get('controller').load.restore();
    });
    it("update is working", function() {
      this.mock.returns(Em.Object.create({isWorking: true}));
      view.poll();
      expect(view.get('controller').load.calledOnce).to.be.true;
    });
    it("update is not working", function() {
      this.mock.returns(Em.Object.create({isWorking: false}));
      view.poll();
      expect(view.get('controller').load.called).to.be.false;
    });
  });
});

});

require.register("test/views/main/admin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin');

describe('App.MainAdminView', function () {

  var view;

  beforeEach(function () {
    view = App.MainAdminView.create({
      controller: Em.Object.create()
    });
  });

  describe.skip('#categories', function () {

    var cases = [
      {
        isHadoopWindowsStack: true,
        categories: [
          {
            name: 'stackAndUpgrade',
            url: 'stackAndUpgrade.index',
            label: Em.I18n.t('admin.stackUpgrade.title')
          },
          {
            name: 'adminServiceAccounts',
            url: 'adminServiceAccounts',
            label: Em.I18n.t('common.serviceAccounts')
          }
        ],
        title: 'HDPWIN'
      },
      {
        isHadoopWindowsStack: false,
        categories: [
          {
            name: 'stackAndUpgrade',
            url: 'stackAndUpgrade.index',
            label: Em.I18n.t('admin.stackUpgrade.title')
          },
          {
            name: 'adminServiceAccounts',
            url: 'adminServiceAccounts',
            label: Em.I18n.t('common.serviceAccounts')
          },
          {
            name: 'kerberos',
            url: 'adminKerberos.index',
            label: Em.I18n.t('common.kerberos')
          }
        ],
        title: 'not HDPWIN'
      }
    ];

    beforeEach(function () {
      this.stub = sinon.stub(App, 'get');
    });

    afterEach(function () {
      App.get.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        this.stub.withArgs('isHadoopWindowsStack').returns(item.isHadoopWindowsStack);
        view.propertyDidChange('categories');
        expect(view.get('categories')).to.eql(item.categories);
      });
    });
  });

  describe("#willDestroyElement()", function() {
    it("controller.category is set to null", function() {
      view.willDestroyElement();
      expect(view.get('controller.category')).to.be.null;
    });
  });

});
});

require.register("test/views/main/alert_definitions_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('messages');
require('views/main/alert_definitions_view');

var view;

function getView() {
  return App.MainAlertDefinitionsView.create({});
}

describe('App.MainAlertDefinitionsView', function () {

  beforeEach(function () {
    view = getView();
    sinon.stub(App.db, 'setFilterConditions', Em.K);
    sinon.stub(App.db, 'getFilterConditions').returns([]);
    sinon.stub(App.db, 'getDisplayLength', Em.K);
    sinon.stub(App.db, 'setStartIndex', Em.K);
    sinon.stub(view, 'initFilters', Em.K);
  });

  afterEach(function () {
    App.db.setFilterConditions.restore();
    App.db.getFilterConditions.restore();
    App.db.getDisplayLength.restore();
    App.db.setStartIndex.restore();
    view.initFilters.restore();
  });

  App.TestAliases.testAsComputedAlias(getView(), 'totalCount', 'content.length', 'number');

  describe('#serviceFilterView', function () {
    it('Add Ambari service to filters', function () {
      var serviceFilterClass = view.serviceFilterView;
      var content = serviceFilterClass.create({}).get('content');
      expect(content[0].label).to.be.equal(Em.I18n.t('common.all'));
      expect(content[content.length - 1].label).to.be.equal(Em.I18n.t('app.name'));
    });
  });

  describe('#willInsertElement', function () {

    beforeEach(function(){
      sinon.stub(view, 'clearFilterConditionsFromLocalStorage', Em.K);
      sinon.stub(App.db, 'getSortingStatuses').returns([
        {
          name: "summary",
          status: "sorting_asc"
        }
      ]);
    });

    afterEach(function(){
      view.clearFilterConditionsFromLocalStorage.restore();
      App.db.getSortingStatuses.restore();
    });

    it('should call clearFilterCondition if controller.showFilterConditionsFirstLoad is false', function () {
      view.set('controller', {showFilterConditionsFirstLoad: false, content: []});
      view.willInsertElement();
      expect(view.clearFilterConditionsFromLocalStorage.calledOnce).to.be.true;
    });

    it('should not call clearFilterCondition if controller.showFilterConditionsFirstLoad is true', function () {
      view.set('controller', {showFilterConditionsFirstLoad: true, content: []});
      view.willInsertElement();
      expect(view.clearFilterConditionsFromLocalStorage.calledOnce).to.be.false;
    });
  });

});

});

require.register("test/views/main/alerts/add_alert_definition/step1_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/alerts/add_alert_definition/step1_view');

var view;

describe('App.AddAlertDefinitionStep1View', function () {

  beforeEach(function () {
    view = App.AddAlertDefinitionStep1View.create({
      controller: Em.Object.create({
        loadStep: Em.K
      })
    });
  });

  describe("#didInsertElement()", function () {
    beforeEach(function () {
      sinon.spy(view.get('controller'), 'loadStep');
    });
    afterEach(function () {
      view.get('controller').loadStep.restore();
    });

    it("loadStep should be called", function () {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.be.true;
    });
  });
});

});

require.register("test/views/main/alerts/add_alert_definition/step3_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/alerts/add_alert_definition/step3_view');

var view;

describe('App.AddAlertDefinitionStep3View', function () {

  beforeEach(function () {
    view = App.AddAlertDefinitionStep3View.create({
      controller: Em.Object.create()
    });
  });

  describe("#willInsertElement()", function () {
    it("alertDefinitionToDisplay should be set", function () {
      view.set('controller.content', {
        formattedToRequestConfigs: 'formattedToRequestConfigs'
      });
      view.willInsertElement();
      expect(view.get('alertDefinitionToDisplay')).to.equal('\"formattedToRequestConfigs\"');
    });
  });
});

});

require.register("test/views/main/alerts/definition_configs_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var alertDefinitionConfigsView, alertConfigRadioButtonView;

describe('App.AlertDefinitionConfigsView', function () {

  beforeEach(function () {
    alertDefinitionConfigsView = App.AlertDefinitionConfigsView.create({
      controller: Em.Object.create({
        renderConfigs: Em.K
      })
    });
  });

  describe("#init()", function() {

    beforeEach(function() {
      sinon.spy(alertDefinitionConfigsView.get('controller'), 'renderConfigs');
      alertDefinitionConfigsView.set('canEdit', true);
      alertDefinitionConfigsView.set('isWizard', true);
      alertDefinitionConfigsView.set('alertDefinitionType', 't1');
      alertDefinitionConfigsView.set('content', {});
      alertDefinitionConfigsView.init();
    });

    afterEach(function() {
      alertDefinitionConfigsView.get('controller').renderConfigs.restore();
    });

    it("should set canEdit to controller", function() {
      expect(alertDefinitionConfigsView.get('controller.canEdit')).to.be.true;
    });

    it("should set isWizard to controller", function() {
      expect(alertDefinitionConfigsView.get('controller.isWizard')).to.be.true;
    });

    it("should set alertDefinitionType to controller", function() {
      expect(alertDefinitionConfigsView.get('controller.alertDefinitionType')).to.equal('t1');
    });

    it("should set content to controller", function() {
      expect(alertDefinitionConfigsView.get('controller.content')).to.eql({});
    });

    it("should call renderConfigs of controller", function() {
      expect(alertDefinitionConfigsView.get('controller').renderConfigs.calledOnce).to.be.true;
    });
  });
});

describe('App.AlertConfigRadioButtonView', function () {

  beforeEach(function () {
    alertConfigRadioButtonView = App.AlertConfigRadioButtonView.create({
      parentView: Em.Object.create({
        controller: Em.Object.create({
          changeType: Em.K,
          configs: [
            Em.Object.create({
              group: 'g1',
              value: true
            })
          ]
        })
      }),
      property: {
        name: 'p1'
      }
    });
  });

  describe("#change", function() {
    var config = Em.Object.create({
      group: 'g1',
      value: true
    });

    beforeEach(function() {
      sinon.stub(alertConfigRadioButtonView.get('parentView.controller'), 'changeType');
      alertConfigRadioButtonView.reopen({
        name: 'g1'
      });
      alertConfigRadioButtonView.set('parentView.controller.configs', [config]);
      alertConfigRadioButtonView.change();
    });

    afterEach(function() {
      alertConfigRadioButtonView.get('parentView.controller').changeType.restore();
    });

    it("should set property.value", function() {
      expect(alertConfigRadioButtonView.get('property.value')).to.be.true;
    });

    it("should set config value", function() {
      expect(config.get('value')).to.be.false;
    });

    it("should call changeType()", function() {
      expect(alertConfigRadioButtonView.get('parentView.controller').changeType.calledWith('p1')).to.be.true;
    });
  });

});
});

require.register("test/views/main/alerts/definition_details_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var view;

function getView() {
  return App.MainAlertDefinitionDetailsView.create({
    initFilters: Em.K,
    controller: Em.Object.create({
      loadAlertInstances: Em.K,
      clearStep: Em.K,
      content: Em.Object.create()
    })
  });
}

describe('App.MainAlertDefinitionDetailsView', function () {

  beforeEach(function () {
    view = getView();
  });

  describe("#willInsertElement()", function() {

    beforeEach(function() {
      sinon.spy(view.get('controller'), 'clearStep');
      sinon.spy(view.get('controller'), 'loadAlertInstances');
      sinon.stub(view, 'loadDefinitionDetails');
    });

    afterEach(function() {
      view.get('controller').clearStep.restore();
      view.get('controller').loadAlertInstances.restore();
      view.loadDefinitionDetails.restore();
    });

    it("clearStep() should be called", function() {
      view.willInsertElement();
      expect(view.get('controller').clearStep.calledOnce).to.be.true;
    });

    it("content is loaded", function() {
      view.set('controller.content.isLoaded', true);
      view.willInsertElement();
      expect(view.get('isLoaded')).to.be.true;
      expect(view.get('controller').loadAlertInstances.calledOnce).to.be.true;
    });

    it("content is not loaded", function() {
      view.set('controller.content.isLoaded', false);
      view.willInsertElement();
      expect(view.get('isLoaded')).to.be.false;
      expect(view.loadDefinitionDetails.calledOnce).to.be.true;
    });
  });

  describe("#loadDefinitionDetails()", function() {
    var mock = {
      updateAlertGroups: function(callback) { callback(); },
      updateAlertDefinitions: function(callback) { callback(); },
      updateAlertDefinitionSummary: function(callback) { callback(); }
    };

    beforeEach(function() {
      sinon.stub(App.router, 'get').returns(mock);
      sinon.spy(mock, 'updateAlertGroups');
      sinon.spy(mock, 'updateAlertDefinitions');
      sinon.spy(mock, 'updateAlertDefinitionSummary');
      sinon.stub(view.get('controller'), 'loadAlertInstances');
      sinon.stub(App.AlertDefinition, 'find').returns({});

      view.loadDefinitionDetails();
    });

    afterEach(function() {
      App.router.get.restore();
      mock.updateAlertGroups.restore();
      mock.updateAlertDefinitions.restore();
      mock.updateAlertDefinitionSummary.restore();
      view.get('controller').loadAlertInstances.restore();
      App.AlertDefinition.find.restore();
    });

    it("updateAlertGroups() should be called", function() {
      expect(mock.updateAlertGroups.calledOnce).to.be.true;
    });

    it("updateAlertDefinitions() should be called", function() {
      expect(mock.updateAlertDefinitions.calledOnce).to.be.true;
    });

    it("updateAlertDefinitionSummary() should be called", function() {
      expect(mock.updateAlertDefinitionSummary.calledOnce).to.be.true;
    });

    it("loadAlertInstances() should be called", function() {
      expect(view.get('isLoaded')).to.be.true;
      expect(view.get('controller.content')).to.eql({});
      expect(view.get('controller').loadAlertInstances.calledOnce).to.be.true;
    });
  });

  describe("#nameValidation", function() {

    view = getView();
    
    var tests = [
     {
       it: "Should display no error if user inputs valid characters in alert name",
       errorMessage: "", 
       alert: Ember.Object.create ({
          label: Ember.Object.create ({
            value: 'validAlertName'
          })
       })
     },    
     {
       it: "Should display an error if user inputs invalid characters in alert name",
       errorMessage: Em.I18n.t("alert.definition.name.invalid"), 
       alert: Ember.Object.create ({
          label: Ember.Object.create ({
            value: 'invalidAlertName\\?<'
          })
       })
     }
    ];

    tests.forEach(function(test) {
      it(test.it, function() {
        view.set('controller.editing',test.alert);
        expect(view.get('controller.errorMessage')).to.equal(test.errorMessage);
      })
    });
  });

  describe("#didInsertElement()", function() {

    beforeEach(function() {
      sinon.stub(view, 'tooltipsUpdater');
      sinon.stub(view, 'filter');
    });

    afterEach(function() {
      view.tooltipsUpdater.restore();
      view.filter.restore();
    });

    it("filter() should be called", function() {
      view.didInsertElement();
      expect(view.filter.calledOnce).to.be.true;
    });

    it("tooltipsUpdater() should be called", function() {
      view.didInsertElement();
      expect(view.tooltipsUpdater.calledOnce).to.be.true;
    });
  });

  describe("#tooltipsUpdater()", function () {

    beforeEach(function () {
      sinon.stub(Em.run, 'next', Em.clb);
      sinon.stub(App, 'tooltip');
    });

    afterEach(function () {
      Em.run.next.restore();
      App.tooltip.restore();
    });

    it("Em.run.next should be called", function () {
      view.tooltipsUpdater();
      expect(Em.run.next.calledOnce).to.be.true;
      expect(App.tooltip.calledOnce).to.be.true;
    });
  });

  describe("#lastDayCount", function () {
    var lastDayCountView;

    beforeEach(function () {
      lastDayCountView = view.get('lastDayCount').create({
        hostName: 'host1',
        parentView: Em.Object.create({
          controller: Em.Object.create()
        })
      });
    });

    describe("#count()", function () {

      it("lastDayAlertsCount is null", function () {
        lastDayCountView.set('parentView.controller.lastDayAlertsCount', null);
        expect(lastDayCountView.get('count')).to.equal(Em.I18n.t('app.loadingPlaceholder'));
      });

      it("lastDayAlertsCount does not contain host", function () {
        lastDayCountView.set('parentView.controller.lastDayAlertsCount', {});
        expect(lastDayCountView.get('count')).to.equal(0);
      });

      it("lastDayAlertsCount is {host1: 1}", function () {
        lastDayCountView.set('parentView.controller.lastDayAlertsCount', {host1: 1});
        expect(lastDayCountView.get('count')).to.equal(1);
      });

    });
  });

  describe("#instanceTableRow", function() {
    var instanceTableRowView;

    beforeEach(function () {
      instanceTableRowView = view.get('instanceTableRow').create();
    });

    describe("#didInsertElement()", function() {

      beforeEach(function() {
        sinon.stub(App, 'tooltip');
      });
      afterEach(function() {
        App.tooltip.restore();
      });

      it("App.tooltip should be called", function() {
        instanceTableRowView.didInsertElement();
        expect(App.tooltip.calledTwice).to.be.true;
      });
    });

    describe("#goToService()", function() {

      beforeEach(function() {
        sinon.stub(App.router, 'transitionTo');
      });
      afterEach(function() {
        App.router.transitionTo.restore();
      });

      it("event is null", function() {
        instanceTableRowView.goToService(null);
        expect(App.router.transitionTo.called).to.be.false;
      });

      it("context is null", function() {
        instanceTableRowView.goToService({context: null});
        expect(App.router.transitionTo.called).to.be.false;
      });

      it("correct context", function() {
        instanceTableRowView.goToService({context: {}});
        expect(App.router.transitionTo.calledWith('main.services.service.summary', {})).to.be.true;
      });
    });

    describe("#goToHostAlerts()", function() {
      var ctrl = Em.Object.create({
        referer: null
      });

      beforeEach(function() {
        sinon.stub(App.router, 'transitionTo');
        sinon.stub(App.router, 'get').returns(ctrl);
      });
      afterEach(function() {
        App.router.transitionTo.restore();
        App.router.get.restore();
      });

      it("event is null", function() {
        instanceTableRowView.goToHostAlerts(null);
        expect(App.router.transitionTo.called).to.be.false;
        expect(ctrl.get('referer')).to.be.null;
      });

      it("context is null", function() {
        instanceTableRowView.goToHostAlerts({context: null});
        expect(App.router.transitionTo.called).to.be.false;
        expect(ctrl.get('referer')).to.be.null;
      });

      it("correct context", function() {
        instanceTableRowView.goToHostAlerts({context: {}});
        expect(ctrl.get('referer')).to.equal('/login');
        expect(App.router.transitionTo.calledWith('main.hosts.hostDetails.alerts', {})).to.be.true;
      });
    });
    describe("#openFullResponse()", function() {

      beforeEach(function() {
        sinon.stub(App, 'showLogsPopup');
      });

      afterEach(function() {
        App.showLogsPopup.restore();
      });

      it("App.showLogsPopup should be called", function() {
        instanceTableRowView.openFullResponse({context: Em.Object.create({text: 'text1'})});
        expect(App.showLogsPopup.calledWith(Em.I18n.t('alerts.instance.fullLogPopup.header'), 'text1')).to.be.true;
      });
    });
  });



  describe("#paginationLeftClass", function() {

    it("startIndex is 2", function() {
      view.set('startIndex', 2);
      expect(view.get('paginationLeftClass')).to.equal('paginate_previous');
    });

    it("startIndex is 1", function() {
      view.set('startIndex', 1);
      expect(view.get('paginationLeftClass')).to.equal('paginate_disabled_previous');
    });

    it("startIndex is 0", function() {
      view.set('startIndex', 0);
      expect(view.get('paginationLeftClass')).to.equal('paginate_disabled_previous');
    });
  });

  describe("#paginationRightClass", function() {

    it("endIndex more than filteredCount", function() {
      view.reopen({
        endIndex: 4,
        filteredCount: 3
      });
      expect(view.get('paginationRightClass')).to.equal('paginate_disabled_next');
    });

    it("endIndex equal to filteredCount", function() {
      view.reopen({
        endIndex: 4,
        filteredCount: 4
      });
      expect(view.get('paginationRightClass')).to.equal('paginate_disabled_next');
    });

    it("endIndex less than filteredCount", function() {
      view.reopen({
        endIndex: 3,
        filteredCount: 4
      });
      view.propertyDidChange('paginationRightClass');
      expect(view.get('paginationRightClass')).to.equal('paginate_next');
    });
  });

});

function getInstanceView() {
  return App.AlertInstanceServiceHostView.create();
}

describe('App.AlertInstanceServiceHostView', function () {

  var instanceView;

  beforeEach(function() {
    instanceView = getInstanceView();
  });

  App.TestAliases.testAsComputedAnd(getInstanceView(), 'showSeparator', ['instance.serviceDisplayName', 'instance.hostName']);

  describe("#serviceIsLink", function() {

    beforeEach(function() {
      sinon.stub(App, 'get').returns(['S1']);
    });
    afterEach(function() {
      App.get.restore();
    });

    it("service belongs to all", function() {
      instanceView.set('instance', Em.Object.create({
        service: Em.Object.create({
          serviceName: 'S1'
        })
      }));
      expect(instanceView.get('serviceIsLink')).to.be.true;
    });
    it("service does not belong to all", function() {
      instanceView.set('instance', Em.Object.create({
        service: Em.Object.create({
          serviceName: 'S2'
        })
      }));
      expect(instanceView.get('serviceIsLink')).to.be.false;
    });
  });
});

});

require.register("test/views/main/alerts/manage_alert_groups/select_definitions_popup_body_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/alerts/manage_alert_groups/select_definitions_popup_body_view');


var view;

describe('App.SelectDefinitionsPopupBodyView', function () {

  beforeEach(function () {
    view = App.SelectDefinitionsPopupBodyView.create({
      parentView: Em.Object.create()
    });
    sinon.stub(App.db, 'setFilterConditions', Em.K);
    sinon.stub(App.db, 'getFilterConditions', function () {
      return [];
    });
    sinon.stub(view, 'initFilters', Em.K)
  });

  afterEach(function () {
    App.db.setFilterConditions.restore();
    App.db.getFilterConditions.restore();
    view.initFilters.restore();
  });

  describe("#filteredContentObs()", function () {
    beforeEach(function () {
      sinon.stub(Em.run, 'once', Em.K);
    });
    afterEach(function () {
      Em.run.once.restore();
    });

    it("Em.run.once should be called", function () {
      view.filteredContentObs();
      expect(Em.run.once.calledWith(view)).to.be.true;
    });
  });

  describe("#filteredContentObsOnce()", function () {
    beforeEach(function () {
      sinon.stub(view, 'filterDefs', Em.K);
    });
    afterEach(function () {
      view.filterDefs.restore();
    });
    it("filteredContent should be set", function () {
      view.set('parentView.availableDefs', [
        {
          filtered: true
        },
        {
          filtered: false
        }
      ]);
      view.filteredContentObsOnce();
      expect(view.get('filteredContent')).to.eql([{
        filtered: true
      }]);
    });
  });

  describe("#didInsertElement()", function () {
    beforeEach(function () {
      sinon.stub(view, 'filterDefs', Em.K);
      sinon.stub(view, 'filteredContentObsOnce', Em.K);
      view.set('initialDefs', [
        Em.Object.create({filtered: true}),
        Em.Object.create({filtered: false})
      ]);
      view.didInsertElement();
    });
    afterEach(function () {
      view.filterDefs.restore();
      view.filteredContentObsOnce.restore();
    });
    it("each availableDefs filtered is updated", function () {
      expect(view.get('parentView.availableDefs').mapProperty('filtered')).to.eql([true, true]);
    });
    it("parentView.isLoaded is true", function () {
      expect(view.get('parentView.isLoaded')).to.be.true;
    });
    it("filteredContentObsOnce is called once", function () {
      expect(view.filteredContentObsOnce.calledOnce).to.be.true;
    });
  });

  describe("#filterDefs()", function () {
    var testCases = [
      {
        title: 'should be filtered',
        data: {
          defs: [
            Em.Object.create({
              filtered: false
            })
          ],
          filterComponent: null,
          filterService: null,
          showOnlySelectedDefs: false
        },
        result: [true]
      },
      {
        title: 'should be filtered by serviceName',
        data: {
          defs: [
            Em.Object.create({
              filtered: false,
              serviceName: 'S1'
            })
          ],
          filterComponent: null,
          filterService: Em.Object.create({serviceName: 'S1'}),
          showOnlySelectedDefs: false
        },
        result: [true]
      },
      {
        title: 'fail to be filtered by serviceName',
        data: {
          defs: [
            Em.Object.create({
              filtered: false,
              serviceName: 'S1'
            })
          ],
          filterComponent: null,
          filterService: Em.Object.create({serviceName: 'S2'}),
          showOnlySelectedDefs: false
        },
        result: [false]
      },
      {
        title: 'should be filtered by componentName',
        data: {
          defs: [
            Em.Object.create({
              filtered: false,
              componentName: 'C1'
            })
          ],
          filterComponent: Em.Object.create({componentName: 'C1'}),
          filterService: null,
          showOnlySelectedDefs: false
        },
        result: [true]
      },
      {
        title: 'fail to be filtered by componentName',
        data: {
          defs: [
            Em.Object.create({
              filtered: false,
              componentName: 'C1'
            })
          ],
          filterComponent: Em.Object.create({componentName: 'C2'}),
          filterService: null,
          showOnlySelectedDefs: false
        },
        result: [false]
      },
      {
        title: 'should be filtered by showOnlySelectedDefs',
        data: {
          defs: [
            Em.Object.create({
              filtered: false,
              selected: true
            })
          ],
          filterComponent: null,
          filterService: null,
          showOnlySelectedDefs: true
        },
        result: [true]
      },
      {
        title: 'fail to be filtered by showOnlySelectedDefs',
        data: {
          defs: [
            Em.Object.create({
              filtered: false,
              selected: false
            })
          ],
          filterComponent: null,
          filterService: null,
          showOnlySelectedDefs: true
        },
        result: [false]
      },
      {
        title: 'should be filtered by all filters',
        data: {
          defs: [
            Em.Object.create({
              filtered: false,
              componentName: 'C1',
              serviceName: 'S1',
              selected: true
            })
          ],
          filterComponent: Em.Object.create({componentName: 'C1'}),
          filterService: Em.Object.create({serviceName: 'S1'}),
          showOnlySelectedDefs: true
        },
        result: [true]
      }
    ];
    testCases.forEach(function (test) {
      describe(test.title, function () {

        beforeEach(function () {
          view.set('parentView.availableDefs', test.data.defs);
          view.set('showOnlySelectedDefs', test.data.showOnlySelectedDefs);
          view.set('filterComponent', test.data.filterComponent);
          view.set('filterService', test.data.filterService);

          view.filterDefs();
        });

        it('availableDefs.@each.filtered is ' + test.result, function () {
          expect(view.get('parentView.availableDefs').mapProperty('filtered')).to.eql(test.result);
        });

        it('startIndex is 1', function () {
          expect(view.get('startIndex')).to.equal(1);
        });

      });
    });
  });

  describe("#defSelectMessage", function () {
    beforeEach(function () {
      sinon.stub(view, 'filterDefs', Em.K);
    });
    afterEach(function () {
      view.filterDefs.restore();
    });
    it("is formatted with parentView.availableDefs", function () {
      view.set('parentView.availableDefs', [
        {selected: true},
        {selected: false}
      ]);
      expect(view.get('defSelectMessage')).to.equal(Em.I18n.t('alerts.actions.manage_alert_groups_popup.selectDefsDialog.selectedDefsLink').format(1, 2));
    });
  });

  describe("#selectFilterComponent()", function() {
    beforeEach(function () {
      sinon.stub(view, 'filterDefs', Em.K);
    });
    afterEach(function () {
      view.filterDefs.restore();
    });

    it("event is null", function() {
      view.set('filterComponent', null);
      view.selectFilterComponent(null);
      expect(view.get('filterComponent')).to.be.null;
    });
    it("componentName is empty", function() {
      view.set('filterComponent', null);
      view.selectFilterComponent({context: Em.Object.create({componentName: ""})});
      expect(view.get('filterComponent')).to.be.null;
    });
    it("filterComponent is null", function() {
      var context = Em.Object.create({componentName: "C1"});
      view.set('filterComponent', null);
      view.selectFilterComponent({context: context});
      expect(view.get('filterComponent')).to.eql(context);
      expect(view.get('filterComponent.selected')).to.be.true;
    });
    it("filterComponent exist", function() {
      var context = Em.Object.create({componentName: "C1"});
      var filterComponent = Em.Object.create();
      view.set('filterComponent', filterComponent);
      view.selectFilterComponent({context: context});
      expect(view.get('filterComponent')).to.eql(context);
      expect(view.get('filterComponent.selected')).to.be.true;
      expect(filterComponent.get('selected')).to.be.false;
    });
    it("the same filterComponent selected", function() {
      var context = Em.Object.create({componentName: "C1"});
      var filterComponent = Em.Object.create({componentName: 'C1'});
      view.set('filterComponent', filterComponent);
      view.selectFilterComponent({context: context});
      expect(view.get('filterComponent')).to.be.null;
      expect(filterComponent.get('selected')).to.be.false;
    });
  });

  describe("#selectFilterService()", function() {
    beforeEach(function () {
      sinon.stub(view, 'filterDefs', Em.K);
    });
    afterEach(function () {
      view.filterDefs.restore();
    });

    it("event is null", function() {
      view.set('filterService', null);
      view.selectFilterService(null);
      expect(view.get('filterService')).to.be.null;
    });
    it("serviceName is empty", function() {
      view.set('filterService', null);
      view.selectFilterService({context: Em.Object.create({serviceName: ""})});
      expect(view.get('filterService')).to.be.null;
    });
    it("filterService is null", function() {
      var context = Em.Object.create({serviceName: "C1"});
      view.set('filterService', null);
      view.selectFilterService({context: context});
      expect(view.get('filterService')).to.eql(context);
      expect(view.get('filterService.selected')).to.be.true;
    });
    it("filterService exist", function() {
      var context = Em.Object.create({serviceName: "C1"});
      var filterService = Em.Object.create();
      view.set('filterService', filterService);
      view.selectFilterService({context: context});
      expect(view.get('filterService')).to.eql(context);
      expect(view.get('filterService.selected')).to.be.true;
      expect(filterService.get('selected')).to.be.false;
    });
    it("the same filterService selected", function() {
      var context = Em.Object.create({serviceName: "C1"});
      var filterService = Em.Object.create({serviceName: 'C1'});
      view.set('filterService', filterService);
      view.selectFilterService({context: context});
      expect(view.get('filterService')).to.be.null;
      expect(filterService.get('selected')).to.be.false;
    });
  });

  describe("#toggleSelectAllDefs()", function() {
    beforeEach(function () {
      sinon.stub(view, 'filterDefs', Em.K);
    });
    afterEach(function () {
      view.filterDefs.restore();
    });

    it("allDefsSelected is false", function() {
      view.set('parentView.availableDefs', [
        Em.Object.create({filtered: true, selected: true}),
        Em.Object.create({filtered: false, selected: false})
      ]);
      view.set('allDefsSelected', false);
      view.toggleSelectAllDefs();
      expect(view.get('parentView.availableDefs').mapProperty('selected')).to.eql([false, false]);
    });
    it("allDefsSelected is true", function() {
      view.set('parentView.availableDefs', [
        Em.Object.create({filtered: false, selected: true}),
        Em.Object.create({filtered: true, selected: false})
      ]);
      view.set('allDefsSelected', true);
      view.toggleSelectAllDefs();
      expect(view.get('parentView.availableDefs').mapProperty('selected')).to.eql([true, true]);
    });
  });

  describe("#toggleShowSelectedDefs()", function() {
    var filterComponent;
    var filterService;
    beforeEach(function () {
      sinon.stub(view, 'filterDefs', Em.K);
      view.set('showOnlySelectedDefs', true);
      filterComponent = Em.Object.create();
      filterService = Em.Object.create();
      view.set('filterComponent', filterComponent);
      view.set('filterService', filterService);
      view.toggleShowSelectedDefs();
    });
    afterEach(function () {
      view.filterDefs.restore();
    });

    it("filterComponent.selected is false", function() {
      expect(filterComponent.get('selected')).to.be.false;
    });

    it("filterService.selected is false", function() {
      expect(filterService.get('selected')).to.be.false;
    });

    it("filterComponent is null", function() {
      expect(view.get('filterComponent')).to.be.null;
    });

    it("filterService is null", function() {
      expect(view.get('filterService')).to.be.null;
    });

    it("showOnlySelectedDefs is false", function() {
      expect(view.get('showOnlySelectedDefs')).to.be.false;
    });
  });
});

});

require.register("test/views/main/alerts/manage_alert_groups_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var view;

function getView() {
  return App.MainAlertsManageAlertGroupView.create({
    controller: Em.Object.create()
  });
}

describe('App.MainAlertsManageAlertGroupView', function () {

  beforeEach(function () {
    view = getView();
  });

  App.TestAliases.testAsComputedIfThenElse(getView(), 'removeButtonTooltip', 'controller.isRemoveButtonDisabled', Em.I18n.t('alerts.actions.manage_alert_groups_popup.removeButtonDisabled'), Em.I18n.t('alerts.actions.manage_alert_groups_popup.removeButton'))


  describe("#onGroupSelect()", function() {

    beforeEach(function() {
      view.removeObserver('selectedAlertGroup', view, 'onGroupSelect');
      view.set('controller', Em.Object.create({selectedAlertGroup: null}));
    });

    it("selectedAlertGroup is null", function() {
      view.set('selectedAlertGroup', null);
      view.onGroupSelect();
      expect(view.get('selectedAlertGroup')).to.be.null;
      expect(view.get('controller.selectedAlertGroup')).to.be.null;
      expect(view.get('controller.selectedDefinitions')).to.be.empty;
    });

    it("selectedAlertGroup is empty array", function() {
      view.set('selectedAlertGroup', []);
      view.onGroupSelect();
      expect(view.get('selectedAlertGroup')).to.be.empty;
      expect(view.get('controller.selectedAlertGroup')).to.be.null;
      expect(view.get('controller.selectedDefinitions')).to.be.empty;
    });

    it("selectedAlertGroup is array with single element", function() {
      view.set('selectedAlertGroup', [1]);
      view.onGroupSelect();
      expect(view.get('selectedAlertGroup')).to.eql([1]);
      expect(view.get('controller.selectedAlertGroup')).to.equal(1);
      expect(view.get('controller.selectedDefinitions')).to.be.empty;
    });

    it("selectedAlertGroup is array with two elements", function() {
      view.set('selectedAlertGroup', [1, 2]);
      view.onGroupSelect();
      expect(view.get('selectedAlertGroup')).to.equal(2);
      expect(view.get('controller.selectedAlertGroup')).to.equal(2);
      expect(view.get('controller.selectedDefinitions')).to.be.empty;
    });
  });

  describe("#setGroupInController()", function() {

    beforeEach(function() {
      view.removeObserver('controller.selectedAlertGroup', view, 'setGroupInController');
      view.set('controller', Em.Object.create({selectedAlertGroup: 1}));
      view.set('selectedAlertGroup', null);
      sinon.stub(view, 'onGroupSelect');
    });

    afterEach(function() {
      view.onGroupSelect.restore();
    });

    it("controller.isLoaded is false", function() {
      view.set('controller.isLoaded', false);
      view.setGroupInController();
      expect(view.get('selectedAlertGroup')).to.be.null;
    });

    it("controller.isLoaded is true", function() {
      view.set('controller.isLoaded', true);
      view.setGroupInController();
      expect(view.get('selectedAlertGroup')).to.eql([1]);
    });
  });

  describe("#onLoad()", function() {

    beforeEach(function() {
      view.removeObserver('controller.isLoaded', view, 'onLoad');
      view.set('controller', Em.Object.create({alertGroups: Em.A([{}])}));
      view.set('selectedAlertGroup', null);
      sinon.stub(view, 'setTooltips');
    });

    afterEach(function() {
      view.setTooltips.restore();
    });

    it("controller.isLoaded is false", function() {
      view.set('controller.isLoaded', false);
      view.onLoad();
      expect(view.get('selectedAlertGroup')).to.be.null;
      expect(view.setTooltips.called).to.be.false;
    });

    it("controller.isLoaded is true", function() {
      view.set('controller.isLoaded', true);
      view.onLoad();
      expect(view.get('selectedAlertGroup')).to.eql([{}]);
      expect(view.setTooltips.calledOnce).to.be.true;
    });
  });

  describe("#willInsertElement()", function() {

    beforeEach(function() {
      view.set('controller', Em.Object.create({loadAlertNotifications: Em.K}));
      sinon.spy(view.get('controller'), 'loadAlertNotifications');
    });
    afterEach(function() {
      view.get('controller').loadAlertNotifications.restore();
    });

    it("loadAlertNotifications should be called", function() {
      view.willInsertElement();
      expect(view.get('controller').loadAlertNotifications.calledOnce).to.be.true;
    });
  });

  describe("#didInsertElement()", function() {

    beforeEach(function() {
      sinon.stub(view, 'onLoad');
    });
    afterEach(function() {
      view.onLoad.restore();
    });

    it("loadAlertNotifications should be called", function() {
      view.didInsertElement();
      expect(view.onLoad.calledOnce).to.be.true;
    });
  });

  describe("#setTooltips()", function() {

    beforeEach(function() {
      sinon.stub(Em.run, 'next', Em.clb);
      sinon.stub(App, 'tooltip');
      view.setTooltips();
    });
    afterEach(function() {
      Em.run.next.restore();
      App.tooltip.restore();
    });

    it("Em.run.next should be called", function() {
      expect(Em.run.next.calledOnce).to.be.true;
    });

    it("App.tooltip should be called twice", function() {
      expect(App.tooltip.calledTwice).to.be.true;
    });
  });

  describe("#addDefinitionTooltip", function() {

    beforeEach(function() {
      view.set('controller', Em.Object.create({selectedAlertGroup: Em.Object.create()}));
    });

    it("controller.selectedAlertGroup.default is true", function() {
      view.set('controller.selectedAlertGroup.default', true);
      expect(view.get('addDefinitionTooltip')).to.equal(Em.I18n.t('alerts.actions.manage_alert_groups_popup.addDefinitionToDefault'));
    });

    it("controller.selectedAlertGroup.isAddDefinitionsDisabled is true", function() {
      view.set('controller.selectedAlertGroup.isAddDefinitionsDisabled', true);
      expect(view.get('addDefinitionTooltip')).to.equal(Em.I18n.t('alerts.actions.manage_alert_groups_popup.addDefinitionDisabled'));
    });

    it("controller.selectedAlertGroup is null", function() {
      view.set('controller.selectedAlertGroup', null);
      expect(view.get('addDefinitionTooltip')).to.equal(Em.I18n.t('alerts.actions.manage_alert_groups_popup.addDefinition'));
    });
  });

  describe("#removeDefinitionTooltip", function() {

    beforeEach(function() {
      view.set('controller', Em.Object.create({selectedAlertGroup: Em.Object.create()}));
    });

    it("controller.selectedAlertGroup.default is true", function() {
      view.set('controller.selectedAlertGroup.default', true);
      expect(view.get('removeDefinitionTooltip')).to.equal(Em.I18n.t('alerts.actions.manage_alert_groups_popup.removeDefinitionDisabled'));
    });

    it("controller.isDeleteDefinitionsDisabled is true", function() {
      view.set('controller.isDeleteDefinitionsDisabled', true);
      expect(view.get('removeDefinitionTooltip')).to.equal(Em.I18n.t('common.nothingToDelete'));
    });

    it("isDeleteDefinitionsDisabled & selectedAlertGroup.default are false", function() {
      view.set('controller.selectedAlertGroup.default', false);
      view.set('controller.isDeleteDefinitionsDisabled', false);
      expect(view.get('removeDefinitionTooltip')).to.equal(Em.I18n.t('alerts.actions.manage_alert_groups_popup.removeDefinition'));
    });
  });
});

});

require.register("test/views/main/alerts/manage_alert_notifications_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var view;

describe('App.ManageAlertNotificationsView', function () {

  beforeEach(function () {

    view = App.ManageAlertNotificationsView.create({
      controller: Em.Object.create()
    });

  });

  describe('#showEmailDetails', function () {

    Em.A([
      {
        selectedAlertNotification: {type: 'SNMP'},
        e: false
      },
      {
        selectedAlertNotification: {type: 'EMAIL'},
        e: true
      }
    ]).forEach(function (test, i) {
      it('test ' + (i + 1), function () {
        view.set('controller.selectedAlertNotification', test.selectedAlertNotification);
        expect(view.get('showEmailDetails')).to.equal(test.e);
      });
    });

  });

  describe('#showSNMPDetails', function () {

    Em.A([
      {
        selectedAlertNotification: {type: 'SNMP'},
        e: true
      },
      {
        selectedAlertNotification: {type: 'EMAIL'},
        e: false
      }
    ]).forEach(function (test, i) {
      it('test ' + (i + 1), function () {
        view.set('controller.selectedAlertNotification', test.selectedAlertNotification);
        expect(view.get('showSNMPDetails')).to.equal(test.e);
      });
    });

  });

  describe("#selectedAlertNotificationGroups", function () {
    it("should contain group names", function () {
      view.set('controller', Em.Object.create({
        selectedAlertNotification: Em.Object.create({
          groups: [
            Em.Object.create({
              displayName: 'g1'
            }),
            Em.Object.create({
              displayName: 'g2'
            })
          ]
        })
      }));
      expect(view.get('selectedAlertNotificationGroups')).to.equal('g1, g2');
    });
  });

  describe("#email", function () {
    it("should return ambari.dispatch.recipients", function () {
      view.set('controller', Em.Object.create({
        selectedAlertNotification: Em.Object.create({
          properties: {
            'ambari.dispatch.recipients': 1
          }
        })
      }));
      expect(view.get('email')).to.equal(1);
    });
  });

  describe("#severities", function () {
    it("should return list of states", function () {
      view.set('controller', Em.Object.create({
        selectedAlertNotification: Em.Object.create({
          alertStates: ['st1', 'st2']
        })
      }));
      expect(view.get('severities')).to.equal('st1, st2');
    });
  });

  describe("#onAlertNotificationSelect()", function () {

    beforeEach(function () {
      view.removeObserver('selectedAlertNotification', view, 'onAlertNotificationSelect');
      view.set('controller', Em.Object.create({selectedAlertNotification: null}));
    });

    it("selectedAlertNotification is null", function () {
      view.set('selectedAlertNotification', null);
      view.onAlertNotificationSelect();
      expect(view.get('selectedAlertNotification')).to.be.null;
      expect(view.get('controller.selectedAlertNotification')).to.be.null;
    });

    it("selectedAlertNotification is empty array", function () {
      view.set('selectedAlertNotification', []);
      view.onAlertNotificationSelect();
      expect(view.get('selectedAlertNotification')).to.be.empty;
      expect(view.get('controller.selectedAlertNotification')).to.be.null;
    });

    it("selectedAlertNotification is array with single element", function () {
      view.set('selectedAlertNotification', [1]);
      view.onAlertNotificationSelect();
      expect(view.get('selectedAlertNotification')).to.eql([1]);
      expect(view.get('controller.selectedAlertNotification')).to.equal(1);
    });

    it("selectedAlertNotification is array with two elements", function () {
      view.set('selectedAlertNotification', [1, 2]);
      view.onAlertNotificationSelect();
      expect(view.get('selectedAlertNotification')).to.equal(2);
      expect(view.get('controller.selectedAlertNotification')).to.equal(2);
    });
  });

  describe("#willInsertElement()", function () {

    beforeEach(function () {
      view.set('controller', Em.Object.create({loadAlertNotifications: Em.K}));
      sinon.spy(view.get('controller'), 'loadAlertNotifications');
    });
    afterEach(function () {
      view.get('controller').loadAlertNotifications.restore();
    });

    it("loadAlertNotifications should be called", function () {
      view.willInsertElement();
      expect(view.get('controller').loadAlertNotifications.calledOnce).to.be.true;
    });
  });

  describe("#didInsertElement()", function () {

    beforeEach(function () {
      sinon.stub(view, 'onLoad');
    });
    afterEach(function () {
      view.onLoad.restore();
    });

    it("loadAlertNotifications should be called", function () {
      view.didInsertElement();
      expect(view.onLoad.calledOnce).to.be.true;
    });
  });

  describe("#onLoad()", function () {

    beforeEach(function () {
      view.removeObserver('controller.isLoaded', view, 'onLoad');
      view.set('controller', Em.Object.create());
      sinon.stub(Em.run, 'later', function (context, callback) {
        callback();
      });
      sinon.stub(App, 'tooltip');
      this.clock = sinon.useFakeTimers();
    });
    afterEach(function () {
      Em.run.later.restore();
      App.tooltip.restore();
      this.clock.restore();
    });

    it("controller.isLoaded is false", function () {
      view.set('controller.isLoaded', false);
      view.onLoad();
      expect(Em.run.later.called).to.be.false;
    });

    describe("controller.isLoaded is true, alertNotifications is null", function () {

      beforeEach(function () {
        view.set('controller.isLoaded', true);
        view.set('controller.alertNotifications', null);
      });

      it("Em.run.later should be called", function () {
        view.onLoad();
        expect(Em.run.later.calledOnce).to.be.true;
      });

      it("App.tooltip should be called twice", function () {
        view.onLoad();
        this.clock.tick(50);
        expect(App.tooltip.calledTwice).to.be.true;
      });

      it("selectedAlertNotification should be null", function () {
        view.onLoad();
        expect(view.get('selectedAlertNotification')).to.be.null;
      });
    });

    describe("controller.isLoaded is true, alertNotifications is array", function () {

      beforeEach(function () {
        view.set('controller.isLoaded', true);
        view.set('controller.alertNotifications', [{}]);
      });

      it("Em.run.later should be called", function () {
        view.onLoad();
        expect(Em.run.later.calledOnce).to.be.true;
      });

      it("App.tooltip should be called twice", function () {
        view.onLoad();
        this.clock.tick(50);
        expect(App.tooltip.calledTwice).to.be.true;
      });

      it("selectedAlertNotification should be object", function () {
        view.onLoad();
        expect(view.get('selectedAlertNotification')).to.eql({});
      });

    });
  });
});

});

require.register("test/views/main/charts/heatmap/heatmap_host_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
var date = require('utils/date/date');
require('models/host');
require('views/main/charts/heatmap/heatmap_host');

describe('App.MainChartsHeatmapHostView', function () {

  var view = App.MainChartsHeatmapHostView.create({
    templateName: '',
    controller: Em.Object.create(),
    content: {}
  });

  describe('#hostTemperatureStyle', function () {
    var testCases = [
      {
        title: 'if hostToSlotMap is null then hostTemperatureStyle should be empty',
        hostName: 'host',
        controller: Em.Object.create({
          hostToSlotMap: null,
          selectedMetric: {
            slotDefinitions: []
          }
        }),
        result: ''
      },
      {
        title: 'if hostName is null then hostTemperatureStyle should be empty',
        hostName: '',
        controller: Em.Object.create({
          hostToSlotMap: {},
          selectedMetric: {
            slotDefinitions: []
          }
        }),
        result: ''
      },
      {
        title: 'if slot less than 0 then hostTemperatureStyle should be empty',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": -1
          },
          selectedMetric: {
            slotDefinitions: []
          }
        }),
        result: ''
      },
      {
        title: 'if slotDefinitions is null then hostTemperatureStyle should be empty',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": 1
          },
          selectedMetric: {
            slotDefinitions: null
          }
        }),
        result: ''
      },
      {
        title: 'if slotDefinitions length not more than slot number then hostTemperatureStyle should be empty',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": 1
          },
          selectedMetric: {
            slotDefinitions: [{}]
          }
        }),
        result: ''
      },
      {
        title: 'if slotDefinitions correct then hostTemperatureStyle should be "style1"',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": 1
          },
          selectedMetric: {
            slotDefinitions: [
              Em.Object.create({cssStyle: 'style0'}),
              Em.Object.create({cssStyle: 'style1'})
            ]
          }
        }),
        result: 'style1'
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('content.hostName', test.hostName);
        view.set('controller', test.controller);
        expect(view.get('hostTemperatureStyle')).to.equal(test.result);
      });
    });
  });

  describe("#hostModelLink", function () {

    before(function () {
      sinon.stub(App.Host, 'find').returns(Em.Object.create({id: 'host1'}));
    });

    after(function () {
      App.Host.find.restore();
    });

    it("should return hostname", function () {
      view.set('content.hostName', 'host1');
      view.propertyDidChange('hostModelLink');
      expect(view.get('hostModelLink.id')).to.equal('host1');
    });
  });

  describe("#mouseEnter()", function () {

    beforeEach(function () {
      sinon.stub(view, 'getUsage').returns('usage');
      sinon.stub(view, 'getCpuUsage').returns('cpu_usage');
      sinon.stub(view, 'getHostComponents').returns(['c1']);
      sinon.stub(view, 'setMetric');
      sinon.stub(view, 'openDetailsBlock');
      this.mock = sinon.stub(App.MainChartsHeatmapHostDetailView, 'create');
      view.set('details', {});
    });

    afterEach(function () {
      view.getUsage.restore();
      view.getCpuUsage.restore();
      view.getHostComponents.restore();
      view.setMetric.restore();
      view.openDetailsBlock.restore();
      this.mock.restore();
    });

    describe('set diskUsage', function () {
      var childView;
      beforeEach(function () {
        childView = Em.Object.create({
          details: {
            diskUsage: ''
          }
        });
        this.mock.returns(childView);
        view.set('content', {
          diskTotal: 100,
          diskFree: 50
        });
        view.mouseEnter();
      });

      it("details.diskUsage = usage", function () {
        expect(childView.get('details.diskUsage')).to.equal('usage');
      });

      it("getUsage is called with valid arguments", function () {
        expect(view.getUsage.calledWith(100, 50)).to.be.true;
      });

      it("setMetric is called once", function () {
        expect(view.setMetric.calledOnce).to.be.true;
      });

      it("openDetailsBlock is called once", function () {
        expect(view.openDetailsBlock.calledOnce).to.be.true;
      });

    });

    describe('set cpuUsage', function () {
      var childView;
      beforeEach(function () {
        childView = Em.Object.create({
          details: {
            cpuUsage: ''
          }
        });
        this.mock.returns(childView);
        view.set('content', {
          cpuSystem: 100,
          cpuUser: 50
        });
        view.mouseEnter();
      });

      it("details.cpuUsage = cpu_usage", function () {
        expect(childView.get('details.cpuUsage')).to.equal('cpu_usage');
      });

      it("getCpuUsage is called with valid arguments", function () {
        expect(view.getCpuUsage.calledWith(100, 50)).to.be.true;
      });

      it("setMetric is called once", function () {
        expect(view.setMetric.calledOnce).to.be.true;
      });

      it("openDetailsBlock is called once", function () {
        expect(view.openDetailsBlock.calledOnce).to.be.true;
      });

    });

    describe('set memoryUsage', function () {
      var childView;
      beforeEach(function () {
        childView = Em.Object.create({
          details: {
            memoryUsage: ''
          }
        });
        this.mock.returns(childView);
        view.set('content', {
          memTotal: 100,
          memFree: 50
        });
        view.mouseEnter();
      });

      it("details.memoryUsage = usage", function () {
        expect(childView.get('details.memoryUsage')).to.equal('usage');
      });

      it("getUsage is called with valid arguments", function () {
        expect(view.getUsage.calledWith(100, 50)).to.be.true;
      });

      it("setMetric is called once", function () {
        expect(view.setMetric.calledOnce).to.be.true;
      });

      it("openDetailsBlock is called once", function () {
        expect(view.openDetailsBlock.calledOnce).to.be.true;
      });

    });

    describe('set hostComponents', function () {
      var childView;
      beforeEach(function () {
        childView = Em.Object.create({
          details: {
            hostComponents: ''
          }
        });
        this.mock.returns(childView);
        view.set('content', {
          hostComponents: ['host1']
        });
        view.mouseEnter();
      });

      it("hostComponents = ['c1']", function () {
        expect(childView.get('details.hostComponents')).to.eql(['c1']);
      });

      it("getHostComponents is called with valid arguments", function () {
        expect(view.getHostComponents.calledWith(['host1'])).to.be.true;
      });

      it("setMetric is called once", function () {
        expect(view.setMetric.calledOnce).to.be.true;
      });

      it("openDetailsBlock is called once", function () {
        expect(view.openDetailsBlock.calledOnce).to.be.true;
      });

    });

    describe('set hostName', function () {
      var childView;
      beforeEach(function () {
        childView = Em.Object.create({
          details: {
            hostName: ''
          }
        });
        this.mock.returns(childView);
        view.set('content', {
          hostName: 'host1'
        });
        view.mouseEnter();
      });

      it("hostName = host1", function () {
        expect(childView.get('details.hostName')).to.equal('host1');
      });

      it("setMetric is called once", function () {
        expect(view.setMetric.calledOnce).to.be.true;
      });

      it("openDetailsBlock is called once", function () {
        expect(view.openDetailsBlock.calledOnce).to.be.true;
      });

    });
  });

  describe("#getUsage()", function () {
    var testCases = [
      {
        input: {
          total: null,
          free: null
        },
        expected: '0.0'
      },
      {
        input: {
          total: 100,
          free: null
        },
        expected: '0.0'
      },
      {
        input: {
          total: null,
          free: 50
        },
        expected: '0.0'
      },
      {
        input: {
          total: 0,
          free: 0
        },
        expected: '0.0'
      },
      {
        input: {
          total: 100,
          free: 50
        },
        expected: '50.0'
      }
    ];

    testCases.forEach(function (test) {
      it("total = " + test.input.total + "; free = " + test.input.free, function () {
        expect(view.getUsage(test.input.total, test.input.free)).to.equal(test.expected);
      });
    });
  });

  describe("#getCpuUsage()", function () {
    var testCases = [
      {
        input: {
          cpuSystem: null,
          cpuUser: null
        },
        expected: '0.0'
      },
      {
        input: {
          cpuSystem: 1.0,
          cpuUser: null
        },
        expected: '0.0'
      },
      {
        input: {
          cpuSystem: null,
          cpuUser: 1.0
        },
        expected: '0.0'
      },
      {
        input: {
          cpuSystem: 2.22,
          cpuUser: 1.0
        },
        expected: '3.2'
      }
    ];

    testCases.forEach(function (test) {
      it("cpuSystem = " + test.input.cpuSystem + "; cpuUser = " + test.input.cpuUser, function () {
        expect(view.getCpuUsage(test.input.cpuSystem, test.input.cpuUser)).to.equal(test.expected);
      });
    });
  });

  describe("#getHostComponents()", function () {

    beforeEach(function () {
      sinon.stub(App.format, 'role', function (name) {
        return name;
      });
      sinon.stub(App, 'get').returns('non-client');
    });

    afterEach(function () {
      App.format.role.restore();
      App.get.restore();
    });

    it("should return host-components", function () {
      expect(view.getHostComponents(['is-client', 'non-client', 'non-client'])).to.equal('non-client, non-client');
    });
  });

  describe("#setMetric()", function () {
    var viewObject;

    beforeEach(function () {
      sinon.stub(date, 'timingFormat').returns('time');
      viewObject = Em.Object.create({
        details: {}
      });
    });

    afterEach(function () {
      date.timingFormat.restore();
    });

    it("selected metric is null", function () {
      view.set('controller.selectedMetric', null);
      view.setMetric(viewObject, {});
      expect(viewObject.get('details')).to.be.empty;
    });

    it("metric name is null", function () {
      view.set('controller.selectedMetric', Em.Object.create({
        name: null,
        hostToValueMap: {}
      }));
      view.setMetric(viewObject, {});
      expect(viewObject.get('details')).to.be.empty;
    });

    it("host value is undefined", function () {
      view.set('controller.selectedMetric', Em.Object.create({
        name: 'm1',
        hostToValueMap: {}
      }));
      view.setMetric(viewObject, {hostName: 'host1'});
      expect(viewObject.get('details')).to.eql({
        metricName: 'm1',
        metricValue: Em.I18n.t('charts.heatmap.unknown')
      });
    });

    it("metric name is 'Garbage Collection Time'", function () {
      view.set('controller.selectedMetric', Em.Object.create({
        name: 'Garbage Collection Time',
        hostToValueMap: {
          host1: 'val'
        }
      }));
      view.setMetric(viewObject, {hostName: 'host1'});
      expect(viewObject.get('details')).to.eql({
        metricName: 'Garbage Collection Time',
        metricValue: 'time'
      });
    });

    it("metric value is NaN", function () {
      view.set('controller.selectedMetric', Em.Object.create({
        name: 'm1',
        hostToValueMap: {
          host1: 'val'
        }
      }));
      view.setMetric(viewObject, {hostName: 'host1'});
      expect(viewObject.get('details')).to.eql({
        metricName: 'm1',
        metricValue: Em.I18n.t('charts.heatmap.unknown')
      });
    });

    it("metric value is number", function () {
      view.set('controller.selectedMetric', Em.Object.create({
        name: 'm1',
        hostToValueMap: {
          host1: 10
        },
        units: 'mb'
      }));
      view.setMetric(viewObject, {hostName: 'host1'});
      expect(viewObject.get('details')).to.eql({
        metricName: 'm1',
        metricValue: '10mb'
      });
    });
  });
});

});

require.register("test/views/main/charts/heatmap/heatmap_rack_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/charts/heatmap/heatmap_rack');

describe('App.MainChartsHeatmapRackView', function() {

  var view = App.MainChartsHeatmapRackView.create({
    templateName: ''
  });

  describe('#hostCssStyle', function () {
    var testCases = [
      {
        title: 'if hosts haven\'t been loaded yet then hostCssStyle should be have width 100%',
        rack: Em.Object.create({
          hosts: new Array(0),
          isLoaded: false
        }),
        result: "width:100%;float:left;"
      },
      {
        title: 'if hosts number is zero then hostCssStyle should be have width 10%',
        rack: Em.Object.create({
          hosts: new Array(0),
          isLoaded: true
        }),
        result: "width:10%;float:left;"
      },
      {
        title: 'if hosts number is one then hostCssStyle should be have width 99.5%',
        rack: Em.Object.create({
          hosts: new Array(1),
          isLoaded: true
        }),
        result: "width:99.5%;float:left;"
      },
      {
        title: 'if hosts number is ten then hostCssStyle should be have width 9.5%',
        rack: Em.Object.create({
          hosts: new Array(10),
          isLoaded: true
        }),
        result: "width:9.5%;float:left;"
      },
      {
        title: 'if hosts number is ten then hostCssStyle should be have width 10%',
        rack: Em.Object.create({
          hosts: new Array(11),
          isLoaded: true
        }),
        result: "width:10%;float:left;"
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('rack', test.rack);
        expect(view.get('hostCssStyle')).to.equal(test.result);
      });
    });
  });

});

});

require.register("test/views/main/charts/heatmap_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/charts/heatmap');

describe('App.MainChartsHeatmapView', function () {

  var view;

  beforeEach(function () {
    view = App.MainChartsHeatmapView.create({
      controller: Em.Object.create({
        clearActiveWidgetLayout: Em.K,
        loadPageData: Em.K
      })
    });
  });


  describe("#didInsertElement()", function () {
    beforeEach(function () {
      sinon.spy(view.get('controller'), 'loadPageData');
    });
    afterEach(function () {
      view.get('controller').loadPageData.restore();
    });
    it("loadPageData is called once", function () {
      view.didInsertElement();
      expect(view.get('controller').loadPageData.calledOnce).to.be.true;
    });
  });

  describe("#willDestroyElement()", function () {
    beforeEach(function () {
      sinon.spy(view.get('controller'), 'clearActiveWidgetLayout');
    });
    afterEach(function () {
      view.get('controller').clearActiveWidgetLayout.restore();
    });
    it("clearActiveWidgetLayout is called once", function () {
      view.willDestroyElement();
      expect(view.get('controller').clearActiveWidgetLayout.calledOnce).to.be.true;
    });
  });

});
});

require.register("test/views/main/dashboard/config_history_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/dashboard/config_history_view');
require('utils/load_timer');

describe('App.MainConfigHistoryView', function() {
  var view = App.MainConfigHistoryView.create({
    totalCount: 0,
    filteredCount: 0
  });
  view.reopen({
    controller: Em.Object.create({
      name: 'mainConfigHistoryController11',
      paginationProps: [
        {
          name: 'displayLength'
        },
        {
          name: 'startIndex'
        }
      ],
      doPolling: Em.K,
      load: function () {
        return {done: Em.K};
      },
      colPropAssoc: []
    })
  });
  view.removeObserver('controller.resetStartIndex', view, 'resetStartIndex');

  describe("#filteredContentInfo", function () {
    it("is formatted with filteredCount and totalCount", function () {
      view.set('filteredCount', 1);
      view.set('totalCount', 2);
      view.propertyDidChange('filteredContentInfo');
      expect(view.get('filteredContentInfo')).to.eql(Em.I18n.t('tableView.filters.filteredConfigVersionInfo').format(1, 2));
    });
  });

  describe("#serviceFilterView", function () {
    var subView = view.get('serviceFilterView').create({
      parentView: view
    });

    before(function () {
      sinon.stub(App.StackService, 'find').returns([Em.Object.create({
        serviceName: 'S1',
        displayName: 's1'
      })])
    });
    after(function () {
      App.StackService.find.restore();
    });
    it("content", function () {
      expect(subView.get('content')).to.eql([
        {
          "value": "",
          "label": Em.I18n.t('common.all')
        },
        {
          "value": "S1",
          "label": "s1"
        }
      ]);
    });

    before(function () {
      sinon.stub(view, 'updateFilter', Em.K);
    });
    after(function () {
      view.updateFilter.restore();
    });
    it("call onChangeValue()", function () {
      subView.set('column', 1);
      subView.set('value', 'value');
      subView.onChangeValue();
      expect(view.updateFilter.calledWith(1, 'value', 'select')).to.be.true;
    });
  });

  describe("#configGroupFilterView", function () {
    var subView = view.get('configGroupFilterView').create({
      parentView: view
    });

    before(function () {
      sinon.stub(App.ServiceConfigVersion, 'find').returns([
        Em.Object.create({groupName: 'G1'}),
        Em.Object.create({groupName: 'G1'}),
        Em.Object.create({groupName: null})
      ]);
    });
    after(function () {
      App.ServiceConfigVersion.find.restore();
    });
    it("content", function () {
      expect(subView.get('content')).to.eql([
        {
          "value": "",
          "label": Em.I18n.t('common.all')
        },
        {
          "value": "G1",
          "label": "G1"
        }
      ]);
    });

    before(function () {
      sinon.stub(view, 'updateFilter', Em.K);
    });
    after(function () {
      view.updateFilter.restore();
    });
    it("call onChangeValue()", function () {
      subView.set('column', 1);
      subView.set('value', 'value');
      subView.onChangeValue();
      expect(view.updateFilter.calledWith(1, 'value', 'select')).to.be.true;
    });
  });

  /**
   * for now we don't use this method
  describe("#modifiedFilterView", function () {
    var subView = view.get('modifiedFilterView').create({
      parentView: view,
      controller: {
        modifiedFilter: {
          actualValues: {
            startTime: 0,
            endTime: 1
          }
        }
      }
    });

    before(function () {
      sinon.stub(view, 'updateFilter', Em.K);
    });
    after(function () {
      view.updateFilter.restore();
    });
    it("call onTimeChange()", function () {
      subView.set('column', 1);
      subView.onTimeChange();
      expect(view.updateFilter.calledWith(1, [0, 1], 'range')).to.be.true;
    });
  });*/

  describe("#authorFilterView", function () {
    var subView = view.get('authorFilterView').create({
      parentView: view
    });

    before(function () {
      sinon.stub(view, 'updateFilter', Em.K);
    });
    after(function () {
      view.updateFilter.restore();
    });
    it("call onChangeValue()", function () {
      subView.set('column', 1);
      subView.set('value', 'value');
      subView.onChangeValue();
      expect(view.updateFilter.calledWith(1, 'value', 'string')).to.be.true;
    });
  });

  describe("#notesFilterView", function () {
    var subView = view.get('notesFilterView').create({
      parentView: view
    });

    before(function () {
      sinon.stub(view, 'updateFilter', Em.K);
    });
    after(function () {
      view.updateFilter.restore();
    });
    it("call onChangeValue()", function () {
      subView.set('column', 1);
      subView.set('value', 'value');
      subView.onChangeValue();
      expect(view.updateFilter.calledWith(1, 'value', 'string')).to.be.true;
    });
  });

  describe("#ConfigVersionView", function () {
    var subView;
    before(function () {
      subView = view.get('ConfigVersionView').create({
        parentView: view
      });

      sinon.stub(App, 'tooltip', Em.K);
    });
    after(function () {
      App.tooltip.restore();
    });
    it("call didInsertElement()", function () {
      subView.didInsertElement();
      expect(App.tooltip.calledOnce).to.be.true;
    });
    it("call toggleShowLessStatus()", function () {
      subView.set('showLessNotes', true);
      subView.toggleShowLessStatus();
      expect(subView.get('showLessNotes')).to.be.false;
    });

    describe("#isServiceLinkDisable", function () {
      beforeEach(function () {
        subView.set('content', Em.Object.create());
        this.hasKerberos = sinon.stub(App.Service, 'find');
      });
      afterEach(function () {
        App.Service.find.restore();
      });
      it("should be true for deleted kerberos groups", function () {
        subView.set('content.serviceName', 'KERBEROS');
        this.hasKerberos.returns([]);
        expect(subView.get('isServiceLinkDisabled')).to.be.true;
      });
      it("should be false for deleted kerberos groups", function () {
        subView.set('content.serviceName', 'KERBEROS');
        subView.set('content.isConfigGroupDeleted', false);
        this.hasKerberos.returns([{serviceName: 'KERBEROS'}]);
        expect(subView.get('isServiceLinkDisabled')).to.be.false;
      });
      it("should be true if group is deleted", function () {
        subView.set('content.serviceName', 'KERBEROS');
        subView.set('content.isConfigGroupDeleted', true);
        this.hasKerberos.returns([{serviceName: 'KERBEROS'}]);
        expect(subView.get('isServiceLinkDisabled')).to.be.true;
      });
    });
  });

  describe('#didInsertElement()', function() {

    beforeEach(function () {
      sinon.stub(view, 'addObserver', Em.K);
      sinon.spy(view.get('controller'), 'doPolling');
      view.didInsertElement();
    });

    afterEach(function () {
      view.addObserver.restore();
      view.get('controller').doPolling.restore();
    });

    it('addObserver is called twice', function() {
      expect(view.addObserver.calledTwice).to.be.true;
    });

    it('isInitialRendering is true', function() {
      expect(view.get('isInitialRendering')).to.be.true;
    });

    it('controller.isPolling is true', function() {
      expect(view.get('controller.isPolling')).to.be.true;
    });

    it('controller.doPolling is true', function() {
      expect(view.get('controller').doPolling.calledOnce).to.be.true;
    });
  });

  describe('#updateFilter()', function () {
    var cases = [
      {
        isInitialRendering: false,
        updateFilterCalled: true,
        title: 'updateFilter should be called'
      },
      {
        isInitialRendering: true,
        updateFilterCalled: false,
        title: 'updateFilter should not be called'
      }
    ];
    beforeEach(function () {
      sinon.stub(view, 'saveFilterConditions', Em.K);
      view.set('filteringComplete', true);
    });
    afterEach(function () {
      view.saveFilterConditions.restore();
    });
    cases.forEach(function (item) {
      it(item.title, function () {
        view.set('isInitialRendering', item.isInitialRendering);
        view.updateFilter(1, 'value', 'string');
        expect(view.get('saveFilterConditions').calledWith(1, 'value', 'string')).to.equal(item.updateFilterCalled);
      });
    });
  });

  describe('#willDestroyElement()', function() {
    it('controller.isPolling is false', function() {
      view.willDestroyElement();
      expect(view.get('controller.isPolling')).to.be.false;
    });
  });

  describe('#refresh()', function() {

    beforeEach(function () {
      sinon.spy(view.get('controller'), 'load');
      view.refresh();
    });

    afterEach(function () {
      view.get('controller').load.restore();
    });

    it('filteringComplete is false', function() {
      expect(view.get('filteringComplete')).to.be.false;
    });

    it('controller.load is called once', function() {
      expect(view.get('controller').load.calledOnce).to.be.true;
    });
  });

  describe("#refreshDone()", function () {
    beforeEach(function () {
      sinon.stub(view, 'propertyDidChange', Em.K);
      view.set('filteringComplete', false);
      view.set('controller.resetStartIndex', true);
      view.refreshDone();
    });
    afterEach(function () {
      view.propertyDidChange.restore();
    });
    it("filteringComplete is true", function () {
      expect(view.get('filteringComplete')).to.be.true;
    });
    it("controller.resetStartIndex is false", function () {
      expect(view.get('controller.resetStartIndex')).to.be.false;
    });
  });

  App.TestAliases.testAsComputedAlias(view, 'colPropAssoc', 'controller.colPropAssoc', 'array');

});

});

require.register("test/views/main/dashboard/widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/dashboard/widget');

describe('App.DashboardWidgetView', function () {

  var dashboardWidgetView = App.DashboardWidgetView.create({
    parentView: Em.Object.create({
      widgetsMapper: Em.K,
      getUserPref: function () {return {complete: Em.K}},
      postUserPref: Em.K,
      translateToReal: Em.K,
      visibleWidgets: [],
      hiddenWidgets: []
    })
  });

  describe('#viewID', function () {
    it('viewID is computed with id', function () {
      dashboardWidgetView.set('id', 5);
      expect(dashboardWidgetView.get('viewID')).to.equal('widget-5');
    });
  });

  describe('#model', function () {
    it('model_type is null', function () {
      dashboardWidgetView.set('model_type', null);
      dashboardWidgetView.propertyDidChange('model');
      expect(dashboardWidgetView.get('model')).to.eql({});
    });
    it('model_type is valid', function () {
      dashboardWidgetView.set('model_type', 's');
      dashboardWidgetView.propertyDidChange('model');
      dashboardWidgetView.set('parentView.s_model', {'s': {}});
      expect(dashboardWidgetView.get('model')).to.eql({'s': {}});
    });
  });

  describe("#didInsertElement()", function () {
    before(function () {
      sinon.stub(App, 'tooltip', Em.K);
    });
    after(function () {
      App.tooltip.restore();
    });
    it("call App.tooltip", function () {
      dashboardWidgetView.didInsertElement();
      expect(App.tooltip.calledOnce).to.be.true;
    });
  });

  describe("#deleteWidget()", function () {
    beforeEach(function () {
      sinon.stub(dashboardWidgetView.get('parentView'), 'widgetsMapper').returns({});
      sinon.stub(dashboardWidgetView.get('parentView'), 'getUserPref').returns({
        complete: Em.K
      });
    });

    afterEach(function () {
      dashboardWidgetView.get('parentView').widgetsMapper.restore();
      dashboardWidgetView.get('parentView').getUserPref.restore();
    });

    it("testMode is off", function () {
      dashboardWidgetView.set('parentView.persistKey', 'key');
      dashboardWidgetView.deleteWidget();
      expect(dashboardWidgetView.get('parentView').getUserPref.calledWith('key')).to.be.true;
    });
  });

  describe("#deleteWidgetComplete()", function () {
    beforeEach(function () {
      sinon.spy(dashboardWidgetView.get('parentView'), 'postUserPref');
      sinon.spy(dashboardWidgetView.get('parentView'), 'translateToReal');
      dashboardWidgetView.set('parentView.currentPrefObject', {
        dashboardVersion: 'new',
        visible: ['1', '2'],
        hidden: [],
        threshold: 'threshold'
      });
      dashboardWidgetView.set('parentView.persistKey', 'key');
      dashboardWidgetView.deleteWidgetComplete();
    });
    afterEach(function () {
      dashboardWidgetView.get('parentView').postUserPref.restore();
      dashboardWidgetView.get('parentView').translateToReal.restore();
    });
    it("postUserPref is called with correct data", function () {
      var arg = JSON.parse(JSON.stringify(dashboardWidgetView.get('parentView').postUserPref.args[0][1]));
      expect(arg).to.be.eql({
        dashboardVersion: 'new',
        visible: ['1', '2'],
        hidden: [[5, null]],
        threshold: 'threshold'
      });
    });
    it("translateToReal is called with valid data", function () {
      var arg = JSON.parse(JSON.stringify(dashboardWidgetView.get('parentView').translateToReal.args[0][0]));
      expect(arg).to.be.eql({
        dashboardVersion: 'new',
        visible: ['1', '2'],
        hidden: [[5, null]],
        threshold: 'threshold'
      });
    });
  });

  describe("#editWidget()", function () {
    before(function () {
      sinon.stub(dashboardWidgetView, 'showEditDialog', Em.K);
    });
    after(function () {
      dashboardWidgetView.showEditDialog.restore();
    });
    it("call showEditDialog", function () {
      dashboardWidgetView.editWidget();
      expect(dashboardWidgetView.showEditDialog.calledOnce).to.be.true;
    });
  });

  describe("#showEditDialog()", function () {
    var obj = Em.Object.create({
      observeThresh1Value: Em.K,
      observeThresh2Value: Em.K,
      thresh1: '1',
      thresh2: '2'
    });
    beforeEach(function () {
      sinon.spy(obj, 'observeThresh1Value');
      sinon.spy(obj, 'observeThresh2Value');
      sinon.stub(dashboardWidgetView.get('parentView'), 'getUserPref').returns({
        complete: Em.K
      });
      var popup = dashboardWidgetView.showEditDialog(obj);
      popup.onPrimary();
    });
    afterEach(function () {
      obj.observeThresh1Value.restore();
      obj.observeThresh2Value.restore();
      dashboardWidgetView.get('parentView').getUserPref.restore();
    });

    it("observeThresh1Value is called once", function () {
      expect(obj.observeThresh1Value.calledOnce).to.be.true;
    });

    it("observeThresh2Value is called once", function () {
      expect(obj.observeThresh2Value.calledOnce).to.be.true;
    });

    it("thresh1 = 1", function () {
      expect(dashboardWidgetView.get('thresh1')).to.equal(1);
    });

    it("thresh2 = 2", function () {
      expect(dashboardWidgetView.get('thresh2')).to.equal(2);
    });

    it("getUserPref is called once", function () {
      expect(dashboardWidgetView.get('parentView').getUserPref.calledOnce).to.be.true;
    });
  });

  describe('#model', function () {
    it('model_type is null', function () {
      dashboardWidgetView.set('model_type', null);
      dashboardWidgetView.propertyDidChange('model');
      expect(dashboardWidgetView.get('model')).to.eql({});
    });
    it('model_type is valid', function () {
      dashboardWidgetView.set('model_type', 's');
      dashboardWidgetView.propertyDidChange('model');
      dashboardWidgetView.set('parentView.s_model', {'s': {}});
      expect(dashboardWidgetView.get('model')).to.eql({'s': {}});
    });
  });

  describe('#hoverContentTopClass', function () {
    var tests = [
      {
        h: ['', ''],
        e: 'content-hidden-two-line',
        m: '2 lines'
      },
      {
        h: ['', '', ''],
        e: 'content-hidden-three-line',
        m: '3 lines'
      },
      {
        h: [''],
        e: '',
        m: '1 line'
      },
      {
        h: [],
        e: '',
        m: '0 lines'
      },
      {
        h: ['', '', '', '', ''],
        e: 'content-hidden-five-line',
        m: '5 lines'
      },
      {
        h: ['', '', '', ''],
        e: 'content-hidden-four-line',
        m: '4 lines'
      },
      {
        h: ['', '', '', '', '', ''],
        e: 'content-hidden-six-line',
        m: '6 lines'
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        dashboardWidgetView.set('hiddenInfo', test.h);
        expect(dashboardWidgetView.get('hoverContentTopClass')).to.equal(test.e);
      });
    });
  });

  describe("#widgetConfig", function() {
    var widget = dashboardWidgetView.get('widgetConfig').create();
    describe("#hintInfo", function() {
      it("is formatted with maxValue", function() {
        widget.set('maxValue', 1);
        widget.propertyDidChange('hintInfo');
        expect(widget.get('hintInfo')).to.equal(Em.I18n.t('dashboard.widgets.hintInfo.common').format(1));
      });
    });
    describe("#observeThresh1Value", function() {
      beforeEach(function () {
        sinon.stub(widget, 'updateSlider', Em.K);
      });
      afterEach(function () {
        widget.updateSlider.restore();
      });
      var testCases = [
        {
          data: {
            thresh1: '',
            maxValue: 0
          },
          result: {
            isThresh1Error: true,
            errorMessage1: Em.I18n.t('admin.users.editError.requiredField')
          }
        },
        {
          data: {
            thresh1: 'NaN',
            maxValue: 0
          },
          result: {
            isThresh1Error: true,
            errorMessage1: Em.I18n.t('dashboard.widgets.error.invalid').format(0)
          }
        },
        {
          data: {
            thresh1: '-1',
            maxValue: 0
          },
          result: {
            isThresh1Error: true,
            errorMessage1: Em.I18n.t('dashboard.widgets.error.invalid').format(0)
          }
        },
        {
          data: {
            thresh1: '2',
            maxValue: 1
          },
          result: {
            isThresh1Error: true,
            errorMessage1: Em.I18n.t('dashboard.widgets.error.invalid').format(1)
          }
        },
        {
          data: {
            thresh1: '1',
            thresh2: '1',
            maxValue: 2
          },
          result: {
            isThresh1Error: true,
            errorMessage1: Em.I18n.t('dashboard.widgets.error.smaller')
          }
        },
        {
          data: {
            thresh1: '1',
            thresh2: '0',
            maxValue: 2
          },
          result: {
            isThresh1Error: true,
            errorMessage1: Em.I18n.t('dashboard.widgets.error.smaller')
          }
        },
        {
          data: {
            thresh1: '1',
            thresh2: '2',
            maxValue: 2
          },
          result: {
            isThresh1Error: false,
            errorMessage1: ''
          }
        }
      ];
      testCases.forEach(function (test) {
        describe("thresh1 - " + test.data.thresh1 + ', maxValue - ' + test.data.maxValue, function () {

          beforeEach(function () {
            widget.set('isThresh2Error', false);
            widget.set('thresh2', test.data.thresh2 || "");
            widget.set('thresh1', test.data.thresh1);
            widget.set('maxValue', test.data.maxValue);
            widget.observeThresh1Value();
          });

          it('isThresh1Error is ' + test.result.isThresh1Error, function () {
            expect(widget.get('isThresh1Error')).to.equal(test.result.isThresh1Error);
          });

          it('errorMessage1 is ' + test.result.errorMessage1, function () {
            expect(widget.get('errorMessage1')).to.equal(test.result.errorMessage1);
          });

          it('updateSlider is called', function () {
            expect(widget.updateSlider.called).to.be.true;
          });

        });
      });
    });

    describe("#observeThresh2Value", function() {
      beforeEach(function () {
        sinon.stub(widget, 'updateSlider', Em.K);
      });
      afterEach(function () {
        widget.updateSlider.restore();
      });
      var testCases = [
        {
          data: {
            thresh2: '',
            maxValue: 0
          },
          result: {
            isThresh2Error: true,
            errorMessage2: Em.I18n.t('admin.users.editError.requiredField')
          }
        },
        {
          data: {
            thresh2: 'NaN',
            maxValue: 0
          },
          result: {
            isThresh2Error: true,
            errorMessage2: Em.I18n.t('dashboard.widgets.error.invalid').format(0)
          }
        },
        {
          data: {
            thresh2: '-1',
            maxValue: 0
          },
          result: {
            isThresh2Error: true,
            errorMessage2: Em.I18n.t('dashboard.widgets.error.invalid').format(0)
          }
        },
        {
          data: {
            thresh2: '2',
            maxValue: 1
          },
          result: {
            isThresh2Error: true,
            errorMessage2: Em.I18n.t('dashboard.widgets.error.invalid').format(1)
          }
        },
        {
          data: {
            thresh2: '2',
            maxValue: 2
          },
          result: {
            isThresh2Error: false,
            errorMessage2: ''
          }
        }
      ];
      testCases.forEach(function (test) {
        describe("thresh2 - " + test.data.thresh2 + ', maxValue - ' + test.data.maxValue, function () {

          beforeEach(function () {
            widget.set('thresh2', test.data.thresh2 || "");
            widget.set('maxValue', test.data.maxValue);
            widget.observeThresh2Value();
          });

          it('isThresh2Error is ' + test.result.isThresh2Error, function () {
            expect(widget.get('isThresh2Error')).to.equal(test.result.isThresh2Error);
          });

          it('errorMessage2 is ' + JSON.stringify(test.result.errorMessage2), function () {
            expect(widget.get('errorMessage2')).to.equal(test.result.errorMessage2);
          });

          it('updateSlider is called', function () {
            expect(widget.updateSlider.called).to.be.true;
          });
        });
      });
    });
  });

});

});

require.register("test/views/main/dashboard/widgets/cluster_metrics_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widgets/cluster_metrics_widget');

describe('App.ClusterMetricsDashboardWidgetView', function () {

  var view;

  beforeEach(function () {
    view = App.ClusterMetricsDashboardWidgetView.create();
  });

  describe('#exportTargetView', function () {

    var childViews = [
        {
          p0: 'v0'
        },
        {
          p1: 'v1'
        }
      ],
      title = 'should take last child view';

    beforeEach(function () {
      view.get('childViews').pushObjects(childViews);
    });

    it(title, function () {
      expect(view.get('exportTargetView')).to.eql(childViews[1]);
    });
  });

});

});

require.register("test/views/main/dashboard/widgets/datanode_live_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/datanode_live');

var view;

function testCounterOrNa(propertyName, dependentKey) {
  describe('#' + propertyName, function () {

    beforeEach(function () {
      view.reopen({
        model: Em.Object.create({
          metricsNotAvailable: true
        })
      });
      view.get('model').set(dependentKey, []);
    });

    it('n/a (1)', function () {
      view.get('model').set(dependentKey, []);
      view.get('model').set('metricsNotAvailable', true);
      expect(view.get(propertyName)).to.be.equal(Em.I18n.t('services.service.summary.notAvailable'));
    });

    it('n/a (2)', function () {
      view.get('model').set(dependentKey, null);
      view.get('model').set('metricsNotAvailable', true);
      expect(view.get(propertyName)).to.be.equal(Em.I18n.t('services.service.summary.notAvailable'));
    });

    it('n/a (3)', function () {
      view.get('model').set(dependentKey, null);
      view.get('model').set('metricsNotAvailable', false);
      expect(view.get(propertyName)).to.be.equal(Em.I18n.t('services.service.summary.notAvailable'));
    });

    it('value exist', function () {
      view.get('model').set(dependentKey, [{}]);
      view.get('model').set('metricsNotAvailable', false);
      expect(view.get(propertyName)).to.be.equal(1);
    });

  });
}

describe('App.DataNodeUpView', function() {

  beforeEach(function () {
    view = App.DataNodeUpView.create();
  });

  testCounterOrNa('dataNodesLive', 'liveDataNodes');

  testCounterOrNa('dataNodesDead', 'deadDataNodes');

  testCounterOrNa('dataNodesDecom', 'decommissionDataNodes');

});

});

require.register("test/views/main/dashboard/widgets/hawqsegment_live_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/hawqsegment_live');

var view;

function testCounterOrNa(propertyName, dependentKey) {
  describe('#' + propertyName, function () {

    beforeEach(function () {
      view.reopen({
        model: Em.Object.create()
      });
      view.get('model').set(dependentKey, []);
    });

    it('n/a (1)', function () {
      view.get('model').set(dependentKey, null);
      expect(view.get(propertyName)).to.be.equal(Em.I18n.t('services.service.summary.notAvailable'));
    });

    it('n/a (2)', function () {
      view.get('model').set(dependentKey, undefined);
      expect(view.get(propertyName)).to.be.equal(Em.I18n.t('services.service.summary.notAvailable'));
    });

    it('value exist', function () {
      view.get('model').set(dependentKey, 123);
      expect(view.get(propertyName)).to.be.equal(123);
    });

  });
}

describe('App.HawqSegmentUpView', function() {

  beforeEach(function () {
    view = App.HawqSegmentUpView.create();
  });

  testCounterOrNa('hawqSegmentsStarted', 'hawqSegmentsStarted');
  testCounterOrNa('hawqSegmentsInstalled', 'hawqSegmentsInstalled');
  testCounterOrNa('hawqSegmentsStarted', 'hawqSegmentsStarted');

});

});

require.register("test/views/main/dashboard/widgets/hbase_average_load_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/hbase_average_load');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

function getView() {
  return App.HBaseAverageLoadView.create({model_type: null});
}

describe('App.HBaseAverageLoadView', function() {

  var tests = [
    {
      model: {
        averageLoad: 1
      },
      e: {
        isNA: false,
        content: '1'
      }
    },
    {
      model: {
        averageLoad: 10
      },
      e: {
        isNA: false,
        content: '10'
      }
    },
    {
      model: {
        averageLoad: 0
      },
      e: {
        isNA: false,
        content: '0'
      }
    },
    {
      model: {
        averageLoad: null
      },
      e: {
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable')
      }
    }
  ];

  tests.forEach(function(test) {
    describe('averageLoad - ' + test.model.averageLoad, function() {
      var hBaseAverageLoadView = App.HBaseAverageLoadView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(hBaseAverageLoadView.get('content')).to.equal(test.e.content);
      });
      it('isNA', function() {
        expect(hBaseAverageLoadView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

  App.TestAliases.testAsComputedAlias(getView(), 'data', 'model.averageLoad', 'number');

  App.TestAliases.testAsComputedGtProperties(getView(), 'isRed', 'data', 'thresh2');

  App.TestAliases.testAsComputedLteProperties(getView(), 'isGreen', 'data', 'thresh1');

});

});

require.register("test/views/main/dashboard/widgets/hbase_master_uptime_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/hbase_master_uptime');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.HBaseMasterUptimeView', function () {

  var tests = [
    {
      model: Em.Object.create({
        masterStartTime: new Date().getTime() - 192.1 * 24 * 3600 * 1000
      }),
      e: {
        isGreen: true,
        isNA: false,
        content: '192.1 d',
        data: 192.1
      }
    },
    {
      model: Em.Object.create({
        masterStartTime: 0
      }),
      e: {
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    },
    {
      model: Em.Object.create({
        masterStartTime: null
      }),
      e: {
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  beforeEach(function () {
    sinon.stub(App.router, 'get').withArgs('userSettingsController.userSettings.timezone').returns('');
  });

  afterEach(function () {
    App.router.get.restore();
  });

  tests.forEach(function (test) {
    var hBaseMasterUptimeView = App.HBaseMasterUptimeView.create({model_type: null, model: test.model});
    hBaseMasterUptimeView.calc();
    describe('#masterStartTime - ' + test.model.masterStartTime, function () {
      it('content', function () {
        expect(hBaseMasterUptimeView.get('content')).to.equal(test.e.content);
      });
      it('data', function () {
        expect(hBaseMasterUptimeView.get('data')).to.equal(test.e.data);
      });
      it('isGreen', function () {
        expect(hBaseMasterUptimeView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function () {
        expect(hBaseMasterUptimeView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

require.register("test/views/main/dashboard/widgets/hbase_regions_in_transition_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widgets/hbase_regions_in_transition');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

function getView() {
  return App.HBaseRegionsInTransitionView.create({model_type:null});
}

describe('App.HBaseRegionsInTransitionView', function() {

  var tests = [
    {
      model: {
        regionsInTransition: 1
      },
      e: {
        isNA: false,
        content: '1'
      }
    },
    {
      model: {
        regionsInTransition: 10
      },
      e: {
        isNA: false,
        content: '10'
      }
    },
    {
      model: {
        regionsInTransition: 0
      },
      e: {
        isNA: false,
        content: '0'
      }
    },
    {
      model: {
        regionsInTransition: null
      },
      e: {
        isNA: true,
        content: 'null'
      }
    }
  ];

  tests.forEach(function(test) {
    describe('regionsInTransition - ' + test.model.regionsInTransition, function() {
      var hBaseRegionsInTransitionView = App.HBaseRegionsInTransitionView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(hBaseRegionsInTransitionView.get('content')).to.equal(test.e.content);
      });
      it('isNA', function() {
        expect(hBaseRegionsInTransitionView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

  App.TestAliases.testAsComputedAlias(getView(), 'data', 'model.regionsInTransition', 'number');

  App.TestAliases.testAsComputedGtProperties(getView(), 'isRed', 'data', 'thresh2');

  App.TestAliases.testAsComputedLteProperties(getView(), 'isGreen', 'data', 'thresh1');

  App.TestAliases.testAsComputedAnd(getView(), 'isOrange', ['!isGreen', '!isRed']);

});

});

require.register("test/views/main/dashboard/widgets/links_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/host_component');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/links_widget');

describe('App.LinkDashboardWidgetView', function() {

  var model = Em.Object.create({
    field: Em.Object.create({
      publicHostName: 'host1'
    })
  });

  var linkDashboardWidgetView = App.LinkDashboardWidgetView.create({
    model_type: null,
    model: model,
    port: 1234,
    modelField: 'field'
  });

  linkDashboardWidgetView.calc();

  describe('#webUrl', function() {
    it('calc', function() {
      expect(linkDashboardWidgetView.get('webUrl')).to.equal('http://host1:1234');
    });
  });

});

});

require.register("test/views/main/dashboard/widgets/namenode_cpu_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('utils/helper');
require('views/common/chart/pie');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/pie_chart_widget');
require('views/main/dashboard/widgets/namenode_cpu');

describe('App.NameNodeCpuPieChartView', function() {

  var model;
  var nameNodeCpuPieChartView;

  beforeEach(function () {
    model = Em.Object.create({
      used: null,
      max: null
    });
    nameNodeCpuPieChartView = App.NameNodeCpuPieChartView.create({
      model_type: null,
      model: model,
      modelFieldUsed: 'used',
      modelFieldMax: 'max',
      widgetHtmlId: 'fake'
    });
    nameNodeCpuPieChartView.calc();
  });

  afterEach(function () {
    nameNodeCpuPieChartView.destroy();
    clearTimeout(nameNodeCpuPieChartView.get('intervalId'));
  });

  describe('#calcIsPieExists', function() {
    var tests = [
      {
        cpuWio: 1,
        e: true,
        m: 'Exists'
      },
      {
        cpuWio: null,
        e: false,
        m: 'Not exists'
      },
      {
        cpuWio: undefined,
        e: false,
        m: 'Not exists'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        nameNodeCpuPieChartView.set('cpuWio', test.cpuWio);
        expect(nameNodeCpuPieChartView.calcIsPieExists()).to.equal(test.e);
      });
    });
  });

  describe('calcDataForPieChart', function () {
    var tests = [
      {
        cpuWio: 0,
        e: ['0.0', '0.00'],
        m: 'Nothing is used'
      },
      {
        cpuWio: 100,
        e: ['100.0', '100.00'],
        m: 'All is used'
      },
      {
        cpuWio: 50,
        e: ['50.0', '50.00'],
        m: 'Half is used'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        nameNodeCpuPieChartView.set('cpuWio', test.cpuWio);
        expect(nameNodeCpuPieChartView.calcDataForPieChart()).to.eql(test.e);
      });
    });
  });

});

});

require.register("test/views/main/dashboard/widgets/namenode_rpc_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/namenode_rpc');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

function getView() {
  return App.NameNodeRpcView.create({model_type:null});
}

describe('App.NameNodeRpcView', function() {

  var tests = [
    {
      model: {
        nameNodeRpc: 1
      },
      e: {
        isOrange: true,
        isNA: false,
        content: '1.00 ms',
        data: '1.00'
      }
    },
    {
      model: {
        nameNodeRpc: 10
      },
      e: {
        isOrange: false,
        isNA: false,
        content: '10.00 ms',
        data: '10.00'
      }
    },
    {
      model: {
        nameNodeRpc: 0
      },
      e: {
        isOrange: false,
        isNA: false,
        content: '0 ms',
        data: 0
      }
    },
    {
      model: {
        nameNodeRpc: null
      },
      e: {
        isOrange: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    describe('nameNodeRpc - ' + test.model.nameNodeRpc, function() {
      var jobTrackerRpcView = App.NameNodeRpcView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(jobTrackerRpcView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(jobTrackerRpcView.get('data')).to.equal(test.e.data);
      });
      it('isOrange', function() {
        expect(jobTrackerRpcView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isNA', function() {
        expect(jobTrackerRpcView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

  App.TestAliases.testAsComputedGtProperties(getView(), 'isRed', 'data', 'thresh2');

  App.TestAliases.testAsComputedLteProperties(getView(), 'isGreen', 'data', 'thresh1');

});

});

require.register("test/views/main/dashboard/widgets/namenode_uptime_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/namenode_uptime');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.NameNodeUptimeView', function() {

  var tests = [
    {
      model: Em.Object.create({
        nameNodeStartTime: new Date().getTime() - 192.1*24*3600*1000
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '192.1 d',
        data: 192.1
      }
    },
    {
      model:  Em.Object.create({
        nameNodeStartTime: 0
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    },
    {
      model:  Em.Object.create({
        nameNodeStartTime: null
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    var nameNodeUptimeView = App.NameNodeUptimeView.create({model_type:null, model: test.model});
    nameNodeUptimeView.calc();
    describe('nameNodeStartTime - ' + test.model.nameNodeStartTime, function() {
      it('content', function() {
        expect(nameNodeUptimeView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(nameNodeUptimeView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(nameNodeUptimeView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(nameNodeUptimeView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(nameNodeUptimeView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(nameNodeUptimeView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

require.register("test/views/main/dashboard/widgets/node_managers_live_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/node_managers_live');

function getView() {
  return App.NodeManagersLiveView.create({
    parentView: Em.Object.create()
  });
}

describe('App.NodeManagersLiveView', function() {

  App.TestAliases.testAsComputedAnd(getView(), 'isDataAvailable', ['!model.metricsNotAvailable', 'App.router.clusterController.isComponentsStateLoaded']);

  App.TestAliases.testAsComputedAlias(getView(), 'nodeManagersLive', 'model.nodeManagersCountActive');

});

});

require.register("test/views/main/dashboard/widgets/pie_chart_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/common/chart/pie');
require('utils/helper');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/pie_chart_widget');

describe('App.PieChartDashboardWidgetView', function() {

  var model = Em.Object.create({
    used: null,
    max: null
  });
  var pieChartDashboardWidgetView = App.PieChartDashboardWidgetView.create({
    model_type: null,
    model: model,
    modelFieldUsed: 'used',
    modelFieldMax: 'max',
    widgetHtmlId: 'fake'
  });

  pieChartDashboardWidgetView.calc();

  describe('#getUsed', function() {
    var tests = [
      {
        model: Em.Object.create({
          used: 1
        }),
        e: 1,
        m: '"Used" is set'
      },
      {
        model: Em.Object.create({
          used: null
        }),
        e: 0,
        m: '"Used" is not set'
      },
      {
        model: Em.Object.create({}),
        e: 0,
        m: '"Used" is not defined'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.getUsed()).to.equal(test.e);
      });
    });
  });

  describe('#getMax', function() {
    var tests = [
      {
        model: Em.Object.create({
          max: 1
        }),
        e: 1,
        m: '"Max" is set'
      },
      {
        model: Em.Object.create({
          max: null
        }),
        e: 0,
        m: '"Max" is not set'
      },
      {
        model: Em.Object.create({}),
        e: 0,
        m: '"Max" is not defined'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.getMax()).to.equal(test.e);
      });
    });
  });

  describe('#calcIsPieExists', function() {
    var tests = [
      {
        model: Em.Object.create({
          max: 1
        }),
        e: true,
        m: 'Exists'
      },
      {
        model: Em.Object.create({
          max: 0
        }),
        e: false,
        m: 'Not exists'
      },
      {
        model: Em.Object.create({}),
        e: false,
        m: 'Not exists'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.calcIsPieExists()).to.equal(test.e);
      });
    });
  });

  describe('calcDataForPieChart', function() {
    var tests = [
      {
        model: Em.Object.create({
          max: 10,
          used: 0
        }),
        e: ['0', '0.0'],
        m: 'Nothing is used'
      },
      {
        model: Em.Object.create({
          max: 10,
          used: 10
        }),
        e: ['100', '100.0'],
        m: 'All is used'
      },
      {
        model: Em.Object.create({
          max: 10,
          used: 5
        }),
        e: ['50', '50.0'],
        m: 'Half is used'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.calcDataForPieChart()).to.eql(test.e);
      });
    });
  });

});

});

require.register("test/views/main/dashboard/widgets/pxf_live_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/pxf_live');

var view;

function testCounterOrNa(propertyName, dependentKey) {
  describe('#' + propertyName, function () {

    beforeEach(function () {
      view.reopen({
        model: Em.Object.create()
      });
      view.get('model').set(dependentKey, []);
    });

    it('n/a (1)', function () {
      view.get('model').set(dependentKey, null);
      expect(view.get(propertyName)).to.be.equal(Em.I18n.t('services.service.summary.notAvailable'));
    });

    it('n/a (2)', function () {
      view.get('model').set(dependentKey, undefined);
      expect(view.get(propertyName)).to.be.equal(Em.I18n.t('services.service.summary.notAvailable'));
    });

    it('value exist', function () {
      view.get('model').set(dependentKey, 123);
      expect(view.get(propertyName)).to.be.equal(123);
    });

  });
}

describe('App.PxfUpView', function() {

  beforeEach(function () {
    view = App.PxfUpView.create();
  });

  testCounterOrNa('pxfsStarted', 'pxfsStarted');
  testCounterOrNa('pxfsInstalled', 'pxfsInstalled');
  testCounterOrNa('pxfsStarted', 'pxfsStarted');

});

});

require.register("test/views/main/dashboard/widgets/resource_manager_uptime_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/resource_manager_uptime');

describe('App.ResourceManagerUptimeView', function() {

  var tests = [
    {
      model: Em.Object.create({
        resourceManagerStartTime: (new Date()).getTime() - 192.1*24*3600*1000
      }),
      e: {
        isGreen: true,
        isNA: false,
        content: '192.1 d',
        data: 192.1
      }
    },
    {
      model:  Em.Object.create({
        resourceManagerStartTime: 0
      }),
      e: {
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    },
    {
      model:  Em.Object.create({
        resourceManagerStartTime: null
      }),
      e: {
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    var resourceManagerUptimeView = App.ResourceManagerUptimeView.create({model_type:null, model: test.model});
    resourceManagerUptimeView.calc();
    describe('resourceManagerStartTime - ' + test.model.resourceManagerStartTime, function() {
      it('content', function() {
        expect(resourceManagerUptimeView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(resourceManagerUptimeView.get('data')).to.equal(test.e.data);
      });
      it('isGreen', function() {
        expect(resourceManagerUptimeView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(resourceManagerUptimeView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

require.register("test/views/main/dashboard/widgets/text_widget_single_threshold_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget_single_threshold');

function getView() {
  return App.TextDashboardSingleThresholdWidgetView.create({thresh1:0});
}

describe('App.TextDashboardSingleThresholdWidgetView', function() {

  var tests = [
    {
      data: 1,
      e: {
        isNA: false
      }
    },
    {
      data: null,
      e: {
        isNA: true
      }
    }
  ];

  tests.forEach(function(test) {
    describe('data - ' + test.data + ' | thresh1 - 0', function() {
      var textDashboardWidgetSingleThresholdView = App.TextDashboardSingleThresholdWidgetView.create({thresh1:0});
      textDashboardWidgetSingleThresholdView.set('data', test.data);
      it('isNA', function() {
        expect(textDashboardWidgetSingleThresholdView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

  App.TestAliases.testAsComputedGtProperties(getView(), 'isRed', 'data', 'thresh1');
  App.TestAliases.testAsComputedLteProperties(getView(), 'isGreen', 'data', 'thresh1');
});

});

require.register("test/views/main/dashboard/widgets/text_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');

function getView() {
  return App.TextDashboardWidgetView.create({thresh1:40, thresh2:70});
}

describe('App.TextDashboardWidgetView', function() {

  var tests = [
    {
      data: 100,
      e: {
        isNA: false
      }
    },
    {
      data: null,
      e: {
        isNA: true
      }
    }
  ];

  tests.forEach(function(test) {
    describe('data - ' + test.data + ' | thresh1 - 40 | thresh2 - 70', function() {
      var textDashboardWidgetView = App.TextDashboardWidgetView.create({thresh1:40, thresh2:70});
      textDashboardWidgetView.set('data', test.data);
      it('isNA', function() {
        expect(textDashboardWidgetView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

  App.TestAliases.testAsComputedGtProperties(getView(), 'isGreen', 'data', 'thresh2');

  App.TestAliases.testAsComputedLteProperties(getView(), 'isRed', 'data', 'thresh1');

  App.TestAliases.testAsComputedAnd(getView(), 'isOrange', ['!isGreen', '!isRed']);

});

});

require.register("test/views/main/dashboard/widgets/uptime_text_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/uptime_text_widget');

var uptimeTextDashboardWidgetView;
describe('App.UptimeTextDashboardWidgetView', function() {

  beforeEach(function () {
    uptimeTextDashboardWidgetView = App.UptimeTextDashboardWidgetView.create({thresh1:40, thresh2:70});
  });

  describe('#timeConverter', function() {
    var ts1 = 1358245370553, ts2 = 0;
    var timestamps = [
      {
        t: ts1,
        e: {
          l: 2,
          f: new Date(ts1)
        }
      },
      {
        t: ts2,
        e: {
          l: 2,
          f: new Date(ts2)
        }
      }
    ];
    timestamps.forEach(function(timestamp) {
      it('timestamp ' + timestamp.t, function() {
        var result = uptimeTextDashboardWidgetView.timeConverter(timestamp.t);
        expect(result.length).to.equal(timestamp.e.l);
        assert.include(timestamp.e.f.toString(), result[0].toString(), timestamp.e.f + ' contains string ' + result[0]);
      });
    });
  });

  describe('#uptimeProcessing', function() {
    var timestamps = [
      {
        diff: 10*1000,
        e: {
          timeUnit: 's'
        }
      },
      {
        diff: 3600*1000,
        e: {
          timeUnit: 'hr'
        }
      },
      {
        diff: 24*3600*1000,
        e: {
          timeUnit: 'd'
        }
      },
      {
        diff: 1800*1000,
        e: {
          timeUnit: 'min'
        }
      }
    ];
    timestamps.forEach(function(timestamp) {
      it('timestamp {0}. timeUnit should be "{1}"'.format(timestamp.t, timestamp.e.timeUnit), function() {
        uptimeTextDashboardWidgetView.uptimeProcessing(new Date().getTime() - timestamp.diff);
        expect(uptimeTextDashboardWidgetView.get('timeUnit')).to.equal(timestamp.e.timeUnit);
      });
    });
  });

});

});

require.register("test/views/main/dashboard/widgets_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('messages');
require('mixins/common/userPref');
require('mixins/common/localStorage');
require('views/main/dashboard/widgets');

describe('App.MainDashboardWidgetsView', function () {

  var view = App.MainDashboardWidgetsView.create();

  describe('#setInitPrefObject', function () {
    var hostMetricsWidgetsCount = 4;
    var hdfsWidgetsCount = 7;
    var hbaseWidgetsCount = 4;
    var yarnWidgetsCount = 4;
    var totalWidgetsCount = 20;
    var tests = Em.A([
      {
        models: {
          host_metrics_model: null,
          hdfs_model: null,
          hbase_model: null,
          yarn_model: null
        },
        e: {
          visibleL: totalWidgetsCount - hostMetricsWidgetsCount - hdfsWidgetsCount - hbaseWidgetsCount - yarnWidgetsCount - 1,
          hiddenL: 0
        },
        m: 'All models are null'
      },
      {
        models: {
          host_metrics_model: {},
          hdfs_model: null,
          hbase_model: null,
          yarn_model: null
        },
        e: {
          visibleL: totalWidgetsCount - hdfsWidgetsCount - hbaseWidgetsCount - yarnWidgetsCount - 1,
          hiddenL: 0
        },
        m: 'hdfs_model, hbase_model, yarn_model are null'
      },
      {
        models: {
          host_metrics_model: {},
          hdfs_model: {},
          hbase_model: null,
          yarn_model: null
        },
        e: {
          visibleL: totalWidgetsCount - hbaseWidgetsCount - yarnWidgetsCount - 1,
          hiddenL: 0
        },
        m: 'hbase_model, yarn_model are null'
      },
      {
        models: {
          host_metrics_model: {},
          hdfs_model: {},
          hbase_model: null,
          yarn_model: null
        },
        e: {
          visibleL: totalWidgetsCount - hbaseWidgetsCount - yarnWidgetsCount - 1,
          hiddenL: 0
        },
        m: 'hbase_model and yarn_model are null'
      },
      {
        models: {
          host_metrics_model: {},
          hdfs_model: {},
          hbase_model: {},
          yarn_model: null
        },
        e: {
          visibleL: totalWidgetsCount - yarnWidgetsCount - 1,
          hiddenL: 1
        },
        m: 'yarn_model is null'
      },
      {
        models: {
          host_metrics_model: {},
          hdfs_model: {},
          hbase_model: {},
          yarn_model: {}
        },
        e: {
          visibleL: totalWidgetsCount - 1,
          hiddenL: 1
        },
        m: 'All models are not null'
      }
    ]);

    beforeEach(function() {
      sinon.stub(view, 'resolveConfigDependencies');
    });

    afterEach(function() {
      view.resolveConfigDependencies.restore();
    });

    tests.forEach(function (test) {
      describe(test.m, function () {

        beforeEach(function () {
          view.set('host_metrics_model', test.models.host_metrics_model);
          view.set('hdfs_model', test.models.hdfs_model);
          view.set('hbase_model', test.models.hbase_model);
          view.set('yarn_model', test.models.yarn_model);
          view.setInitPrefObject();
        });

        it('visible.length is ' + test.e.visibleL, function () {
          expect(view.get('initPrefObject.visible.length')).to.equal(test.e.visibleL);
        });

        it('hidden.length is ' + test.e.hiddenL, function () {
          expect(view.get('initPrefObject.hidden.length')).to.equal(test.e.hiddenL);
        });

      });
    });
  });

  describe('#persistKey', function () {
    beforeEach(function () {
      sinon.stub(App, 'get').withArgs('router.loginName').returns('tdk');
    });
    afterEach(function () {
      App.get.restore();
    });
    it('Check it', function () {
      expect(view.get('persistKey')).to.equal('user-pref-tdk-dashboard');
    });
  });

  describe("#didInsertElement()", function () {
    beforeEach(function () {
      sinon.stub(view, 'setWidgetsDataModel', Em.K);
      sinon.stub(view, 'setInitPrefObject', Em.K);
      sinon.stub(view, 'setOnLoadVisibleWidgets', Em.K);
      sinon.stub(Em.run, 'next', Em.K);
      view.didInsertElement();
    });
    afterEach(function () {
      view.setWidgetsDataModel.restore();
      view.setInitPrefObject.restore();
      view.setOnLoadVisibleWidgets.restore();
      Em.run.next.restore();
    });
    it("setWidgetsDataModel is called once", function () {
      expect(view.setWidgetsDataModel.calledOnce).to.be.true;
    });
    it("setInitPrefObject is called once", function () {
      expect(view.setInitPrefObject.calledOnce).to.be.true;
    });
    it("setOnLoadVisibleWidgets is called once", function () {
      expect(view.setOnLoadVisibleWidgets.calledOnce).to.be.true;
    });
    it("makeSortable is called in the next loop", function () {
      expect(Em.run.next.calledWith(view, 'makeSortable')).to.be.true;
    });
    it("isDataLoaded is true", function () {
      expect(view.get('isDataLoaded')).to.be.true
    });
  });

  describe("#setWidgetsDataModel()", function () {
    beforeEach(function () {
      this.model = sinon.stub(App.Service, 'find');
      this.get = sinon.stub(App, 'get');
    });
    afterEach(function () {
      this.model.restore();
      this.get.restore();
    });
    it("No host_metrics_model", function () {
      this.get.returns([]);
      this.model.returns([Em.Object.create({
        serviceName: 'S1',
        id: 'S1'
      })]);
      view.set('host_metrics_model', null);
      view.setWidgetsDataModel();
      expect(view.get('host_metrics_model')).to.be.null;
      expect(view.get('s1_model')).to.eql(Em.Object.create({
        serviceName: 'S1',
        id: 'S1'
      }));
    });
    it("host_metrics_model is present", function () {
      this.get.returns([1]);
      this.model.returns([Em.Object.create({
        serviceName: 'HDFS',
        id: 'HDFS'
      })]);
      view.set('host_metrics_model', null);
      view.setWidgetsDataModel();
      expect(view.get('host_metrics_model')).to.eql([1]);
      expect(view.get('hdfs_model.id')).to.equal('HDFS');
    });
  });

  describe("#plusButtonFilterView", function () {
    var plusButtonFilterView = view.get('plusButtonFilterView').create({
      parentView: view
    });
    plusButtonFilterView.reopen({
      visibleWidgets: [],
      hiddenWidgets: []
    });

    describe("#applyFilter()", function () {
      var widget = {checked: true};
      beforeEach(function () {
        sinon.stub(view, 'getUserPref').returns({
          complete: Em.K
        });
        sinon.stub(view, 'widgetsMapper').returns(widget);
      });

      afterEach(function () {
        view.getUserPref.restore();
        view.widgetsMapper.restore();
      });

      it("testMode is off", function () {
        plusButtonFilterView.applyFilter();
        expect(view.getUserPref.calledOnce).to.be.true;
      });
    });

    describe("#applyFilterComplete()", function () {
      beforeEach(function () {
        sinon.stub(view, 'postUserPref');
        sinon.stub(view, 'translateToReal');
        sinon.stub(App.router, 'get', function (k) {
          if ('loginName' === k) return 'tdk';
          return Em.get(App.router, k);
        });
        plusButtonFilterView.set('hiddenWidgets', [
          Em.Object.create({
            checked: true,
            id: 1,
            displayName: 'i1'
          }),
          Em.Object.create({
            checked: false,
            id: 2,
            displayName: 'i2'
          })
        ]);
        view.set('currentPrefObject', Em.Object.create({
          dashboardVersion: 'new',
          visible: [],
          hidden: [],
          threshold: 'threshold'
        }));
        view.set('persistKey', 'key');
        plusButtonFilterView.applyFilterComplete();
      });
      afterEach(function () {
        view.postUserPref.restore();
        view.translateToReal.restore();
        App.router.get.restore();
      });
      it("postUserPref is called once", function () {
        expect(view.postUserPref.calledOnce).to.be.true;
      });
      it("translateToReal is called with correct data", function () {
        expect(view.translateToReal.getCall(0).args[0]).to.eql(Em.Object.create({
          dashboardVersion: 'new',
          visible: [1],
          hidden: [
            [2, 'i2']
          ],
          threshold: 'threshold'
        }));
      });
      it("1 hidden widget", function () {
        expect(plusButtonFilterView.get('hiddenWidgets.length')).to.equal(1);
      });
    });
  });

  describe("#translateToReal()", function () {
    beforeEach(function () {
      sinon.stub(view, 'widgetsMapper').returns(Em.Object.create());
      view.set('visibleWidgets', []);
      view.set('hiddenWidgets', []);
    });
    afterEach(function () {
      view.widgetsMapper.restore();
    });
    it("version is not new", function () {
      var data = {
        dashboardVersion: null,
        visible: [],
        hidden: [],
        threshold: []
      };
      view.translateToReal(data);
      expect(view.get('visibleWidgets')).to.be.empty;
      expect(view.get('hiddenWidgets')).to.be.empty;
    });
    it("version is new", function () {
      var data = {
        dashboardVersion: 'new',
        visible: [1],
        hidden: [
          ['id', 'title']
        ],
        threshold: [
          [],
          [
            ['tresh1'],
            ['tresh2']
          ]
        ]
      };
      view.translateToReal(data);
      expect(view.get('visibleWidgets')).to.not.be.empty;
      expect(view.get('hiddenWidgets')).to.not.be.empty;
    });
  });

  describe("#setOnLoadVisibleWidgets()", function () {
    beforeEach(function () {
      sinon.stub(view, 'translateToReal', Em.K);
      sinon.stub(view, 'getUserPref').returns({complete: Em.K});
    });

    afterEach(function () {
      view.translateToReal.restore();
      view.getUserPref.restore();
    });

    it("testMode is false", function () {
      view.setOnLoadVisibleWidgets();
      expect(view.getUserPref.calledOnce).to.be.true;
    });
  });

  describe("#removeWidget()", function () {
    var widget;
    var value;
    beforeEach(function () {
      widget = {};
      value = {
        visible: [widget],
        hidden: [
          [widget]
        ]
      };
      value = view.removeWidget(value, widget);
    });
    it("value.visible is empty", function () {
      expect(value.visible).to.be.empty;
    });
    it("value.hidden is empty", function () {
      expect(value.hidden).to.be.empty;
    });
  });

  describe("#containsWidget()", function () {
    it("widget visible", function () {
      var widget = {};
      var value = {
        visible: [widget],
        hidden: [
          [widget]
        ]
      };
      expect(view.containsWidget(value, widget)).to.be.true;
    });
    it("widget absent", function () {
      var widget = {};
      var value = {
        visible: [],
        hidden: []
      };
      expect(view.containsWidget(value, widget)).to.be.false;
    });
    it("widget hidden", function () {
      var widget = {};
      var value = {
        visible: [],
        hidden: [
          [widget]
        ]
      };
      expect(view.containsWidget(value, widget)).to.be.true;
    });
  });

  describe("#persistKey", function () {
    before(function () {
      sinon.stub(App, 'get').withArgs('router.loginName').returns('user');
    });
    after(function () {
      App.get.restore();
    });
    it("depends on router.loginName", function () {
      view.propertyDidChange('persistKey');
      expect(view.get('persistKey')).to.equal('user-pref-user-dashboard');
    });
  });

  describe("#getUserPrefSuccessCallback()", function () {

    it("response is null", function () {
      view.set('currentPrefObject', null);
      view.getUserPrefSuccessCallback(null, {}, {});
      expect(view.get('currentPrefObject')).to.be.null;
    });

    it("response is correct", function () {
      view.set('currentPrefObject', null);
      view.getUserPrefSuccessCallback({}, {}, {});
      expect(view.get('currentPrefObject')).to.eql({});
    });

    it('should update missing thresholds', function () {

      view.set('currentPrefObject', null);
      view.getUserPrefSuccessCallback({
        threshold: {
          17: []
        }
      }, {}, {});
      expect(view.get('currentPrefObject.threshold')['17']).to.eql([70, 90]);

    });

  });

  describe("#resetAllWidgets()", function () {

    beforeEach(function () {
      sinon.stub(App, 'showConfirmationPopup', Em.clb);
      sinon.stub(view, 'postUserPref', Em.K);
      sinon.stub(view, 'setDBProperty', Em.K);
      sinon.stub(view, 'translateToReal', Em.K);
      view.setProperties({
        currentTimeRangeIndex: 1,
        customStartTime: 1000,
        customEndTime: 2000
      });
      view.resetAllWidgets();
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
      view.postUserPref.restore();
      view.setDBProperty.restore();
      view.translateToReal.restore();
    });

    it('persist reset', function () {
      expect(view.postUserPref.calledOnce).to.be.true;
    });
    it('local storage reset', function () {
      expect(view.setDBProperty.calledOnce).to.be.true;
    });
    it('time range reset', function () {
      expect(view.get('currentTimeRangeIndex')).to.equal(0);
    });
    it('custom start time reset', function () {
      expect(view.get('customStartTime')).to.be.null;
    });
    it('custom end time reset', function () {
      expect(view.get('customEndTime')).to.be.null;
    });
    it('default settings application', function () {
      expect(view.translateToReal.calledOnce).to.be.true;
    });

  });

  describe('#checkServicesChange', function () {

    var emptyCurrentPref = {
        visible: [],
        hidden: [],
        threshold: {}
      },
      widgetsMap = {
        hdfs_model: ['1', '2', '3', '4', '5', '10', '11'],
        host_metrics_model: ['6', '7', '8', '9'],
        hbase_model: ['12', '13', '14', '15', '16'],
        yarn_model: ['17', '18', '19', '20', '23'],
        storm_model: ['21'],
        flume_model: ['22']
      },
      emptyModelTitle = '{0} absent',
      notEmptyModelTitle = '{0} present';

    Em.keys(widgetsMap).forEach(function (item, index, array) {
      it(notEmptyModelTitle.format(item), function () {
        array.forEach(function (modelName) {
          view.set(modelName, modelName === item ? {} : null);
        });
        expect(view.checkServicesChange(emptyCurrentPref).visible).to.eql(widgetsMap[item]);
      });
    });

    Em.keys(widgetsMap).forEach(function (item, index, array) {
      it(emptyModelTitle.format(item), function () {
        var expected = [];
        array.forEach(function (modelName) {
          if (modelName === item) {
            view.set(modelName, null);
          } else {
            view.set(modelName, {});
            expected = expected.concat(widgetsMap[modelName]);
          }
        });
        expect(view.checkServicesChange({
          visible: widgetsMap[item],
          hidden: [],
          threshold: {}
        }).visible).to.eql(expected);
      });
    });

  });
});

});

require.register("test/views/main/dashboard_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

describe('App.MainDashboardView', function() {});

});

require.register("test/views/main/host/add_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var testHelpers = require('test/helpers');
var view;

describe('App.AddHostView', function () {

  beforeEach(function () {
    view = App.AddHostView.create({
      controller: Em.Object.create({
        getDBProperty: Em.K,
        setDBProperty: Em.K,
        content: Em.Object.create()
      })
    });
  });

  describe("#willInsertElement()", function() {

    beforeEach(function() {
      sinon.stub(view, 'loadHosts');
      this.mock = sinon.stub(view.get('controller'), 'getDBProperty');
    });
    afterEach(function() {
      view.loadHosts.restore();
      this.mock.restore();
    });

    it("hosts saved in DB", function() {
      this.mock.returns(['host1']);
      view.willInsertElement();
      expect(view.get('isLoaded')).to.be.true;
      expect(view.loadHosts.calledOnce).to.be.false;
    });
    it("hosts not saved in DB", function() {
      this.mock.returns(null);
      view.willInsertElement();
      expect(view.get('isLoaded')).to.be.false;
      expect(view.loadHosts.calledOnce).to.be.true;
    });
  });

  describe("#loadHosts()", function() {

    it("App.ajax.send should be called", function() {
      view.loadHosts();
      var args = testHelpers.filterAjaxRequests('name', 'hosts.confirmed.minimal');
      expect(args[0][0]).to.eql({
        name: 'hosts.confirmed.minimal',
        sender: view,
        data: {},
        success: 'loadHostsSuccessCallback',
        error: 'loadHostsErrorCallback'
      });
    });
  });

  describe("#loadHostsSuccessCallback()", function() {

    beforeEach(function() {
      sinon.stub(view.get('controller'), 'setDBProperty');
    });
    afterEach(function() {
      view.get('controller').setDBProperty.restore();
    });

    it("should save hosts to DB", function() {
      var response = {items: [
        {
          Hosts: {
            host_name: 'host1'
          },
          host_components: [
            {
              component_name: 'C1'
            }
          ]
        }
      ]};
      view.loadHostsSuccessCallback(response);
      expect(view.get('isLoaded')).to.be.true;
      expect(view.get('controller').setDBProperty.calledWith('hosts', {
        host1: {
          name: 'host1',
          bootStatus: "REGISTERED",
          isInstalled: true,
          hostComponents: [
            {
              component_name: 'C1'
            }
          ]
        }
      })).to.be.true;
      expect(view.get('controller.content.hosts')).to.eql({
        host1: {
          name: 'host1',
          bootStatus: "REGISTERED",
          isInstalled: true,
          hostComponents: [
            {
              component_name: 'C1'
            }
          ]
        }
      });
    });
  });

  describe("#loadHostsErrorCallback()", function() {
    it("isLoaded should be set to true", function() {
      view.loadHostsErrorCallback();
      expect(view.get('isLoaded')).to.be.true;
    });
  });
});
});

require.register("test/views/main/host/combo_search_box_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var view;

describe('App.MainHostComboSearchBoxView', function () {

  beforeEach(function () {
    view = App.MainHostComboSearchBoxView.create();
  });

  describe("#didInsertElement()", function() {

    beforeEach(function() {
      sinon.stub(view, 'initVS');
      sinon.stub(view, 'showHideClearButton');
    });
    afterEach(function() {
      view.initVS.restore();
    });

    it("initVS should be called", function() {
      view.didInsertElement();
      expect(view.initVS.calledOnce).to.be.true;
    });
  });
});
});

require.register("test/views/main/host/config_service_menu_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var misc = require('utils/misc');
var view;

describe('App.MainHostServiceMenuView', function () {

  beforeEach(function () {
    view = App.MainHostServiceMenuView.create({
      host: Em.Object.create(),
      controller: Em.Object.create({
        connectOutlet: Em.K
      })
    });
  });

  describe("#content", function() {

    beforeEach(function() {
      sinon.stub(App, 'get').returns([]);
      sinon.stub(App.StackService, 'find').returns([]);
      sinon.stub(misc, 'sortByOrder', function(stackServices, services) {
        return services;
      });
    });
    afterEach(function() {
      App.StackService.find.restore();
      misc.sortByOrder.restore();
      App.get.restore();
    });

    it("no hostComponents", function() {
      view.set('host', Em.Object.create({
        hostComponents: null
      }));
      view.propertyDidChange('content');
      expect(view.get('content')).to.be.empty;
    });

    it("hostComponents without service", function() {
      view.set('host', Em.Object.create({
        hostComponents: [
          Em.Object.create({
            service: null
          })
        ]
      }));
      view.propertyDidChange('content');
      expect(view.get('content')).to.be.empty;
    });

    it("hostComponents with service", function() {
      view.set('host', Em.Object.create({
        hostComponents: [
          Em.Object.create({
            service: Em.Object.create({
              serviceName: 'S1'
            })
          })
        ]
      }));
      view.propertyDidChange('content');
      expect(view.get('content').mapProperty('serviceName')).to.eql(['S1']);
    });

    it("hostComponents with the same services", function() {
      view.set('host', Em.Object.create({
        hostComponents: [
          Em.Object.create({
            service: Em.Object.create({
              serviceName: 'S1'
            })
          }),
          Em.Object.create({
            service: Em.Object.create({
              serviceName: 'S1'
            })
          })
        ]
      }));
      view.propertyDidChange('content');
      expect(view.get('content').mapProperty('serviceName')).to.eql(['S1']);
    });
  });



  describe("#showHostService()", function() {

    beforeEach(function() {
      sinon.stub(view.get('controller'), 'connectOutlet');
    });
    afterEach(function() {
      view.get('controller').connectOutlet.restore()
    });

    it("service is absent", function() {
      view.showHostService({contexts: []});
      expect(view.get('controller').connectOutlet.called).to.be.false;
    });

    it("service is present", function() {
      view.showHostService({contexts: [{serviceName: 'S1'}]});
      expect(view.get('controller').connectOutlet.calledWith('service_config_outlet', 'mainHostServiceConfigs', {serviceName: 'S1', host: Em.Object.create()})).to.be.true;
    });
  });

  describe("#didInsertElement()", function() {

    beforeEach(function() {
      sinon.stub(view, 'showHostService');
    });
    afterEach(function() {
      view.showHostService.restore();
    });

    it("showHostService should be called", function() {
      view.didInsertElement();
      expect(view.showHostService.calledWith({contexts: [undefined]})).to.be.true;
    });
  });

});
});

require.register("test/views/main/host/config_service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var view;

describe('App.MainHostServiceConfigsView', function () {

  beforeEach(function () {
    view = App.MainHostServiceConfigsView.create({
      controller: Em.Object.create({
        loadStep: Em.K
      })
    });
  });

  describe("#didInsertElement()", function() {

    beforeEach(function() {
      sinon.stub(view.get('controller'), 'loadStep');
    });
    afterEach(function() {
      view.get('controller').loadStep.restore();
    });

    it("loadStep should be called", function() {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.be.true;
    });
  });
});
});

require.register("test/views/main/host/details/host_component_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host_component');
require('views/main/host/details/host_component_view');

var hostComponentView;

function getView() {
  return App.HostComponentView.create({
    startBlinking: function(){},
    doBlinking: function(){},
    getDesiredAdminState: function(){return $.ajax({});},
    content: Em.Object.create({
      componentName: 'component'
    }),
    hostComponent: Em.Object.create()
  });
}

describe('App.HostComponentView', function() {

  beforeEach(function() {
    hostComponentView = getView();
  });

  App.TestAliases.testAsComputedNotEqual(getView(), 'isRestartComponentDisabled', 'workStatus', App.HostComponentStatus.started);

  describe('#disabled', function() {

    var tests = Em.A([
      {
        parentView: {content: {healthClass: 'health-status-DEAD-YELLOW'}},
        noActionAvailable: '',
        isRestartComponentDisabled: true,
        e: 'disabled'
      },
      {
        parentView: {content: {healthClass: 'another-class'}},
        noActionAvailable: '',
        isRestartComponentDisabled: true,
        e: ''
      },
      {
        parentView: {content: {healthClass: 'another-class'}},
        noActionAvailable: 'hidden',
        isRestartComponentDisabled: true,
        e: 'disabled'
      },
      {
        parentView: {content: {healthClass: 'another-class'}},
        noActionAvailable: 'hidden',
        isRestartComponentDisabled: false,
        e: ''
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          parentView: test.parentView,
          noActionAvailable: test.noActionAvailable,
          isRestartComponentDisabled: test.isRestartComponentDisabled
        });
        expect(hostComponentView.get('disabled')).to.equal(test.e);
      });
    });

  });

  App.TestAliases.testAsComputedEqual(getView(), 'isUpgradeFailed', 'workStatus', App.HostComponentStatus.upgrade_failed);

  App.TestAliases.testAsComputedEqual(getView(), 'isInstallFailed', 'workStatus', App.HostComponentStatus.install_failed);

  App.TestAliases.testAsComputedEqual(getView(), 'isStop', 'workStatus', App.HostComponentStatus.stopped);

  App.TestAliases.testAsComputedEqual(getView(), 'isInstalling', 'workStatus', App.HostComponentStatus.installing);

  App.TestAliases.testAsComputedEqual(getView(), 'isInit', 'workStatus', App.HostComponentStatus.init);

  App.TestAliases.testAsComputedExistsIn(getView(), 'isInProgress', 'workStatus', [App.HostComponentStatus.stopping, App.HostComponentStatus.starting]);

  App.TestAliases.testAsComputedExistsIn(getView(), 'withoutActions', 'workStatus', [App.HostComponentStatus.starting, App.HostComponentStatus.stopping, App.HostComponentStatus.unknown, App.HostComponentStatus.disabled]);

  App.TestAliases.testAsComputedExistsIn(getView(), 'isStart', 'workStatus', [App.HostComponentStatus.started, App.HostComponentStatus.starting]);

  App.TestAliases.testAsComputedIfThenElse(getView(), 'noActionAvailable', 'withoutActions', 'hidden', '');

  App.TestAliases.testAsComputedEqual(getView(), 'isActive', 'content.passiveState', 'OFF');

  describe('#isDeleteComponentDisabled', function() {
    var configs=[
    {
      properties: {
        'hive_database': 'Existing MYSQL Database'
      },
      tag: 'version2',
      type: 'hive-env'
    }
    ];
    beforeEach(function() {
      this.mock = sinon.stub(App.StackServiceComponent, 'find');
      sinon.stub(App.HostComponent, 'getCount').returns(1);
    });
    afterEach(function() {
      this.mock.restore();
      App.HostComponent.getCount.restore();
    });

    it('delete is disabled because min cardinality 1', function() {
      this.mock.returns(Em.Object.create({minToInstall: 1}));
      hostComponentView.get('hostComponent').set('componentName', 'C1');
      hostComponentView.propertyDidChange('isDeleteComponentDisabled');
      expect(hostComponentView.get('isDeleteComponentDisabled')).to.be.true;
    });

    it('delete is disabled because min cardinality 0 and status INSTALLED', function() {
      this.mock.returns(Em.Object.create({minToInstall: 0}));
      hostComponentView.get('hostComponent').set('workStatus', 'INIT');
      hostComponentView.propertyDidChange('isDeleteComponentDisabled');
      expect(hostComponentView.get('isDeleteComponentDisabled')).to.be.false;
    });

    it('delete is enabled because min cardinality 0 and status STARTED', function() {
      this.mock.returns(Em.Object.create({minToInstall: 0}));
      hostComponentView.get('hostComponent').set('workStatus', 'STARTED');
      hostComponentView.propertyDidChange('isDeleteComponentDisabled');
      expect(hostComponentView.get('isDeleteComponentDisabled')).to.be.true;
    });
    
    it('delete is enabled because mysql server is stopped and hive is using external database', function() {
      App.db.setConfigs(configs);
      this.mock.returns(Em.Object.create({minToInstall: 0}));
      hostComponentView.get('hostComponent').set('componentName', 'MYSQL_SERVER');
      hostComponentView.get('hostComponent').set('workStatus', 'STOPPED');
      hostComponentView.propertyDidChange('isDeleteComponentDisabled');
      expect(hostComponentView.get('isDeleteComponentDisabled')).to.be.true;
    });
  });

  describe('#componentTextStatus', function() {

    var tests = Em.A([
      {
        componentTextStatus: 'status',
        hostComponent: null,
        e: 'status',
        m: 'get content status'
      },
      {
        componentTextStatus: 'status',
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        e: 'new_status',
        m: 'get hostComponent status'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          hostComponent: test.hostComponent,
          content: Em.Object.create()
        });
        hostComponentView.get('content').set('componentTextStatus', test.componentTextStatus);
        expect(hostComponentView.get('componentTextStatus')).to.equal(test.e);
      });
    });

  });

  describe('#workStatus', function() {

    var tests = Em.A([
      {
        workStatus: 'status',
        hostComponent: null,
        e: 'status',
        m: 'get content workStatus'
      },
      {
        workStatus: 'status',
        hostComponent: Em.Object.create({workStatus: 'new_status'}),
        e: 'new_status',
        m: 'get hostComponent workStatus'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          hostComponent: test.hostComponent,
          content: Em.Object.create()
        });
        hostComponentView.get('content').set('workStatus', test.workStatus);
        expect(hostComponentView.get('workStatus')).to.equal(test.e);
      });
    });

  });

  describe('#statusClass', function() {

    var tests = Em.A([
      {
        workStatus: App.HostComponentStatus.install_failed,
        passiveState: 'OFF',
        e: 'health-status-color-red icon-cog'
      },
      {
        workStatus: App.HostComponentStatus.installing,
        passiveState: 'OFF',
        e: 'health-status-color-blue icon-cog'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'ON',
        e: 'health-status-started'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'IMPLIED',
        e: 'health-status-started'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'OFF',
        e: 'health-status-started'
      }
    ]);

    tests.forEach(function(test) {
      it(test.workStatus + ' ' + test.passiveState, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          content: Em.Object.create(),
          hostComponent: Em.Object.create()
        });
        hostComponentView.get('hostComponent').set('workStatus',test.workStatus);
        hostComponentView.get('content').set('passiveState', test.passiveState);
        expect(hostComponentView.get('statusClass')).to.equal(test.e);
      });
    });

  });

  describe('#statusIconClass', function() {
    var tests = Em.A([
      {s: 'health-status-started', e: App.healthIconClassGreen},
      {s: 'health-status-starting', e: App.healthIconClassGreen},
      {s: 'health-status-installed', e: App.healthIconClassRed},
      {s: 'health-status-stopping', e: App.healthIconClassRed},
      {s: 'health-status-unknown', e: App.healthIconClassYellow},
      {s: 'health-status-DEAD-ORANGE', e: App.healthIconClassOrange},
      {s: 'other', e: ''}
    ]);

    tests.forEach(function(test) {
      it(test.s, function() {
        hostComponentView.reopen({statusClass: test.s});
        expect(hostComponentView.get('statusIconClass')).to.equal(test.e);
      })
    });
  });

  describe('#slaveCustomCommands', function() {

    var content = [
      {
        componentName: 'SLAVE_COMPONENT',
        hostName: '01'
      },
      {
        componentName: 'NOT_SLAVE_COMPONENT',
        hostName: '02'
      }
    ];
    before(function() {
      sinon.stub(App.StackServiceComponent, 'find', function() {
        return Em.Object.create({
          componentName: 'SLAVE_COMPONENT',
          isSlave: true,
          customCommands: ['SLAVE_CUSTOM_COMMAND']
        });
      });
     sinon.stub(App.HostComponentActionMap, 'getMap', function () {
        return {
          SLAVE_CUSTOM_COMMAND: {
            customCommand: 'SLAVE_CUSTOM_COMMAND',
            cssClass: 'icon-play-circle',
            label: 'Custom Command',
            context: 'Custom Command',
            isHidden: false,
            disabled: false
          }
        }
      });
    });

    it('Should get custom commands for slaves', function() {
      hostComponentView.set('content', content);
      expect(hostComponentView.get('customCommands')).to.have.length(1);
    });

    after(function() {
      App.StackServiceComponent.find.restore();
      App.HostComponentActionMap.getMap.restore();
    });
  });

  describe('#getCustomCommandLabel', function() {

    beforeEach(function () {
      sinon.stub(App.HostComponentActionMap, 'getMap', function () {
        return {
          MASTER_CUSTOM_COMMAND: {
            action: 'executeCustomCommand',
            cssClass: 'icon-play-circle',
            isHidden: false,
            disabled: false
          },
          REFRESHQUEUES: {
            action: 'refreshYarnQueues',
            customCommand: 'REFRESHQUEUES',
            context : Em.I18n.t('services.service.actions.run.yarnRefreshQueues.context'),
            label: Em.I18n.t('services.service.actions.run.yarnRefreshQueues.menu'),
            cssClass: 'icon-refresh',
            disabled: false
          }
        }
      });
    });
    afterEach(function() {
      App.HostComponentActionMap.getMap.restore();
    });

    var tests = Em.A([
      {
        msg: 'Component not present in `App.HostComponentActionMap.getMap()` should have a default valid label',
        command: 'CUSTOM',
        e: Em.I18n.t('services.service.actions.run.executeCustomCommand.menu').format('Custom')
      },
      {
        msg: 'Component present in `App.HostComponentActionMap.getMap()` with no label should have a default valid label',
        command: 'MASTER_CUSTOM_COMMAND',
        e: Em.I18n.t('services.service.actions.run.executeCustomCommand.menu').format('Master Custom Command')
      },
      {
        msg: 'Component present in `App.HostComponentActionMap.getMap()` with label should have a custom valid label',
        command: 'REFRESHQUEUES',
        e: Em.I18n.t('services.service.actions.run.yarnRefreshQueues.menu')
      }
    ]);

    tests.forEach(function(test) {
      it(test.msg, function() {
        expect(hostComponentView.getCustomCommandLabel(test.command)).to.equal(test.e);
      })
    });
  });

  describe("#isDeletableComponent", function() {
    beforeEach(function(){
      sinon.stub(App, 'get').returns(['C1']);
    });
    afterEach(function(){
      App.get.restore();
    });
    it("component deletable", function() {
      hostComponentView.set('content.componentName', 'C1');
      hostComponentView.propertyDidChange('isDeletableComponent');
      expect(hostComponentView.get('isDeletableComponent')).to.be.true;
    });
    it("component is not deletable", function() {
      hostComponentView.set('content.componentName', 'C2');
      hostComponentView.propertyDidChange('isDeletableComponent');
      expect(hostComponentView.get('isDeletableComponent')).to.be.false;
    });
  });

  describe("#isMoveComponentDisabled", function() {
    beforeEach(function(){
      sinon.stub(App.HostComponent, 'find').returns([
        Em.Object.create({componentName: 'C1', hostName: 'host1'}),
        Em.Object.create({componentName: 'C1', hostName: 'host2'}),
        Em.Object.create({componentName: 'C2', hostName: 'host1'})
      ]);
    });
    afterEach(function(){
      App.HostComponent.find.restore();
    });
    it("component is not movable", function() {
      App.set('allHostNames', ['host1', 'host2']);
      hostComponentView.set('content.componentName', 'C1');
      hostComponentView.propertyDidChange('isMoveComponentDisabled');
      expect(hostComponentView.get('isMoveComponentDisabled')).to.be.true;
    });
    it("component movable", function() {
      App.set('allHostNames', ['host1', 'host2']);
      hostComponentView.set('content.componentName', 'C2');
      hostComponentView.propertyDidChange('isMoveComponentDisabled');
      expect(hostComponentView.get('isMoveComponentDisabled')).to.be.false;
    });
  });

  describe("#runningComponentCounter()", function() {
    beforeEach(function(){
      sinon.stub(App.HostComponent, 'find').returns([
        Em.Object.create({componentName: 'C1', workStatus: 'STARTED'}),
        Em.Object.create({componentName: 'C2', workStatus: 'INSTALLED'})
      ]);
    });
    afterEach(function(){
      App.HostComponent.find.restore();
    });
    it("running components present", function() {
      hostComponentView.set('content.componentName', 'C1');
      expect(hostComponentView.runningComponentCounter()).to.equal(1);
    });
    it("running components absent", function() {
      hostComponentView.set('content.componentName', 'C2');
      expect(hostComponentView.runningComponentCounter()).to.equal(0);
    });
  });

  describe("#isReassignable", function() {
    beforeEach(function(){
      sinon.stub(App, 'get').returns(['C1']);
      this.mock = sinon.stub(App.router, 'get');
    });
    afterEach(function(){
      App.get.restore();
      this.mock.restore();
    });
    it("component reassignable and count is 2", function() {
      this.mock.returns({TOTAL: 2});
      hostComponentView.set('content.componentName', 'C1');
      hostComponentView.propertyDidChange('isReassignable');
      expect(hostComponentView.get('isReassignable')).to.be.true;
    });
    it("component reassignable and count is 1", function() {
      this.mock.returns({TOTAL: 1});
      hostComponentView.set('content.componentName', 'C1');
      hostComponentView.propertyDidChange('isReassignable');
      expect(hostComponentView.get('isReassignable')).to.be.false;
    });
    it("component is not reassignable", function() {
      hostComponentView.set('content.componentName', 'C2');
      hostComponentView.propertyDidChange('isReassignable');
      expect(hostComponentView.get('isReassignable')).to.be.false;
    });
  });

  describe("#isRestartableComponent", function() {
    beforeEach(function(){
      sinon.stub(App, 'get').returns(['C1']);
    });
    afterEach(function(){
      App.get.restore();
    });
    it("component deletable", function() {
      hostComponentView.set('content.componentName', 'C1');
      hostComponentView.propertyDidChange('isRestartableComponent');
      expect(hostComponentView.get('isRestartableComponent')).to.be.true;
    });
    it("component is not deletable", function() {
      hostComponentView.set('content.componentName', 'C2');
      hostComponentView.propertyDidChange('isRestartableComponent');
      expect(hostComponentView.get('isRestartableComponent')).to.be.false;
    });
  });

  describe("#isRefreshConfigsAllowed", function() {
    beforeEach(function(){
      sinon.stub(App, 'get').returns(['C1']);
    });
    afterEach(function(){
      App.get.restore();
    });
    it("component deletable", function() {
      hostComponentView.set('content.componentName', 'C1');
      hostComponentView.propertyDidChange('isRefreshConfigsAllowed');
      expect(hostComponentView.get('isRefreshConfigsAllowed')).to.be.true;
    });
    it("component is not deletable", function() {
      hostComponentView.set('content.componentName', 'C2');
      hostComponentView.propertyDidChange('isRefreshConfigsAllowed');
      expect(hostComponentView.get('isRefreshConfigsAllowed')).to.be.false;
    });
  });

});

});

require.register("test/views/main/host/details/host_component_views/datanode_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/host/details/host_component_views/datanode_view');
var testHelpers = require('test/helpers');

describe('App.DataNodeComponentView', function () {
  var view = App.DataNodeComponentView.create({
    content: {
      hostName: 'host1'
    }
  });

  describe("#getDNDecommissionStatus()", function () {

    beforeEach(function () {
      this.stub = sinon.stub(App.HDFSService, 'find');
    });

    afterEach(function () {
      this.stub.restore();
    });

    it("snameNode absent and no activeNameNode", function () {
      this.stub.returns([
        Em.Object.create({
          snameNode: null,
          activeNameNode: null,
          nameNode: {hostName: 'host1'}
        })
      ]);
      view.getDNDecommissionStatus();
      var args = testHelpers.findAjaxRequest('name', 'host.host_component.decommission_status_datanode');
      expect(args[0]).exists;
      expect(args[0].data).to.be.eql({
        "hostName": "host1",
        "componentName": "NAMENODE"
      });
    });

    it("snameNode present and no activeNameNode", function () {
      this.stub.returns([
        Em.Object.create({
          snameNode: {},
          activeNameNode: null,
          nameNode: {hostName: 'host1'}
        })
      ]);
      view.getDNDecommissionStatus();
      var args = testHelpers.findAjaxRequest('name', 'host.host_component.decommission_status_datanode');
      expect(args[0]).exists;
      expect(args[0].data).to.be.eql({
        "hostName": "host1",
        "componentName": "NAMENODE"
      });
    });

    it("snameNode absent and activeNameNode valid", function () {
      this.stub.returns([
        Em.Object.create({
          snameNode: null,
          activeNameNode: {hostName: 'host2'},
          nameNode: {hostName: 'host1'}
        })
      ]);
      view.getDNDecommissionStatus();
      var args = testHelpers.findAjaxRequest('name', 'host.host_component.decommission_status_datanode');
      expect(args[0]).exists;
      expect(args[0].data).to.be.eql({
        "hostName": "host2",
        "componentName": "NAMENODE"
      });
    });

  });

  describe("#getDNDecommissionStatusSuccessCallback()", function () {
    beforeEach(function () {
      sinon.stub(view, 'computeStatus', Em.K);
      view.set('decommissionedStatusObject', null);
    });
    afterEach(function () {
      view.computeStatus.restore();
    });
    it("metric null", function () {
      var data = {
        metrics: {
          dfs: {
            namenode: null
          }
        }
      };
      expect(view.getDNDecommissionStatusSuccessCallback(data)).to.equal(null);
      expect(view.computeStatus.calledOnce).to.be.false;
    });
    it("metric valid", function () {
      var data = {
        metrics: {
          dfs: {
            namenode: "status"
          }
        }
      };
      expect(view.getDNDecommissionStatusSuccessCallback(data)).to.equal("status");
      expect(view.computeStatus.calledOnce).to.be.true;
    });
  });

  describe("#getDNDecommissionStatusErrorCallback()", function () {
    it("reset to null", function () {
      expect(view.getDNDecommissionStatusErrorCallback()).to.be.null;
      expect(view.get('decommissionedStatusObject')).to.be.null;
    });
  });

  describe("#loadComponentDecommissionStatus()", function () {
    before(function () {
      sinon.stub(view, 'getDNDecommissionStatus', Em.K);
    });
    after(function () {
      view.getDNDecommissionStatus.restore();
    });
    it("call getDNDecommissionStatus()", function () {
      view.loadComponentDecommissionStatus();
      expect(view.getDNDecommissionStatus.calledOnce).to.be.true;
    });
  });

  describe("#setDesiredAdminState()", function () {
    before(function () {
      sinon.stub(view, 'setStatusAs', Em.K);
    });
    after(function () {
      view.setStatusAs.restore();
    });
    it("call getDNDecommissionStatus()", function () {
      view.setDesiredAdminState('status');
      expect(view.setStatusAs.calledWith('status')).to.be.true;
    });
  });

  describe("#computeStatus()", function () {
    beforeEach(function () {
      sinon.stub(view, 'getDesiredAdminState', Em.K);
      sinon.stub(view, 'setStatusAs', Em.K);
      this.stub = sinon.stub(App, 'get');
    });
    afterEach(function () {
      view.getDesiredAdminState.restore();
      view.setStatusAs.restore();
      this.stub.restore();
    });
    var testCases = [
      {
        title: 'No live nodes',
        data: {
          curObj: {},
        },
        result: {
          getDesiredAdminStateCalled: true,
          status: "",
          setStatusAsCalled: false
        }
      },
      {
        title: 'Live nodes In Service',
        data: {
          "curObj": {
            "LiveNodes": {
              "host1": {
                "adminState": "In Service"
              }
            }
          }
        },
        result: {
          getDesiredAdminStateCalled: false,
          status: "INSERVICE",
          setStatusAsCalled: true
        }
      },
      {
        title: 'Live nodes In Progress',
        data: {
          "curObj": {
            "LiveNodes": {
              "host1": {
                "adminState": "Decommission In Progress"
              }
            }
          }
        },
        result: {
          getDesiredAdminStateCalled: false,
          status: "DECOMMISSIONING",
          setStatusAsCalled: true
        }
      },
      {
        title: 'Live nodes Decommissioned',
        data: {
          "curObj": {
            "LiveNodes": {
              "host1": {
                "adminState": "Decommissioned"
              }
            }
          }
        },
        result: {
          getDesiredAdminStateCalled: false,
          status: "DECOMMISSIONED",
          setStatusAsCalled: true
        }
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.computeStatus(test.data.curObj);
        expect(view.getDesiredAdminState.called).to.equal(test.result.getDesiredAdminStateCalled);
        expect(view.setStatusAs.calledWith(test.result.status)).to.equal(test.result.setStatusAsCalled);
      });
    }, this);
    it("data is null", function () {
      view.computeStatus(null);
      expect(view.getDesiredAdminState.called).to.be.false;
      expect(view.setStatusAs.called).to.be.false;
    });
  });

});

});

require.register("test/views/main/host/details/host_component_views/decommissionable_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host_component');
require('views/main/host/details/host_component_view');
require('mixins');
require('mixins/main/host/details/host_components/decommissionable');
var testHelpers = require('test/helpers');

var hostComponentView;

describe('App.Decommissionable', function() {

  beforeEach(function() {
    sinon.stub(App.router, 'get', function (k) {
      if (k === 'mainHostDetailsController.content') {
        return Em.Object.create({
          hostComponents: [
            {
              componentName: 'component'
            }
          ]
        });
      }
      return Em.get(App.router, k);
    });
  });

  afterEach(function () {
    App.router.get.restore();
  });

  describe('#componentTextStatus', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: null,
        isComponentRecommissionAvailable: false,
        isComponentDecommissioning: false,
        e: 'status',
        m: 'get content status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: false,
        isComponentDecommissioning: false,
        e: 'new_status',
        m: 'get hostComponent status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: false,
        isComponentDecommissioning: false,
        e: 'new_status',
        m: 'get hostComponent status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: true,
        isComponentDecommissioning: true,
        e: Em.I18n.t('hosts.host.decommissioning'),
        m: 'get decommissioning status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: true,
        isComponentDecommissioning: false,
        e: Em.I18n.t('hosts.host.decommissioned'),
        m: 'get decommissioned status'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create(App.Decommissionable, {
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          content: test.content,
          hostComponent: test.hostComponent,
          isComponentRecommissionAvailable: test.isComponentRecommissionAvailable,
          isComponentDecommissioning: test.isComponentDecommissioning
        });
        expect(hostComponentView.get('componentTextStatus')).to.equal(test.e);
      });
    });

  });

  describe('#statusClass', function() {

    var tests = Em.A([
      {
        workStatus: App.HostComponentStatus.install_failed,
        passiveState: 'OFF',
        isComponentRecommissionAvailable: false,
        e: 'health-status-color-red icon-cog'
      },
      {
        workStatus: App.HostComponentStatus.installing,
        passiveState: 'OFF',
        isComponentRecommissionAvailable: false,
        e: 'health-status-color-blue icon-cog'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'ON',
        isComponentRecommissionAvailable: false,
        e: 'health-status-started'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'IMPLIED',
        isComponentRecommissionAvailable: false,
        e: 'health-status-started'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'OFF',
        isComponentRecommissionAvailable: false,
        e: 'health-status-started'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'OFF',
        isComponentRecommissionAvailable: true,
        e: 'health-status-DEAD-ORANGE'
      },
      {
        workStatus: 'STARTING',
        passiveState: 'OFF',
        isComponentRecommissionAvailable: true,
        e: 'health-status-DEAD-ORANGE'
      },
      {
        workStatus: 'INSTALLED',
        passiveState: 'OFF',
        isComponentRecommissionAvailable: true,
        e: 'health-status-DEAD-ORANGE'
      }

    ]);

    tests.forEach(function(test) {
      it(test.workStatus + ' ' + test.passiveState + ' ' + test.isComponentRecommissionAvailable?'true':'false', function() {
        hostComponentView = App.HostComponentView.create(App.Decommissionable,{
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          isComponentRecommissionAvailable: test.isComponentRecommissionAvailable,
          content: Em.Object.create()
        });
        hostComponentView.get('content').setProperties({
          workStatus: test.workStatus,
          passiveState: test.passiveState
        });
        expect(hostComponentView.get('statusClass')).to.equal(test.e);
      });
    });

  });

  describe('#isInProgress', function() {

    var tests = Em.A([
      {
        workStatus: App.HostComponentStatus.stopping,
        isDecommissioning: false,
        e: true
      },
      {
        workStatus: App.HostComponentStatus.starting,
        isDecommissioning: false,
        e: true
      },
      {
        workStatus: 'other_status',
        isDecommissioning: false,
        e: false
      },
      {
        workStatus: 'other_status',
        isDecommissioning: true,
        e: true
      }
    ]);

    tests.forEach(function(test) {
      it(test.workStatus + ' ' + test.isDecommissioning?'true':'false', function() {

        hostComponentView = App.HostComponentView.create(App.Decommissionable,{
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          isDecommissioning: test.isDecommissioning,
          content: Em.Object.create({workStatus: test.workStatus})
        });

        expect(hostComponentView.get('isInProgress')).to.equal(test.e);
      });
    });

  });

  describe("#getDesiredAdminState()", function() {

    it("content is null", function() {
      hostComponentView = Em.View.create(App.Decommissionable, {
        content: null
      });
      hostComponentView.getDesiredAdminState();
      var args = testHelpers.findAjaxRequest('name', 'host.host_component.slave_desired_admin_state');
      expect(args).not.exists;
    });
    it("content is correct", function() {
      hostComponentView = Em.View.create(App.Decommissionable, {
        content: Em.Object.create({
          hostName: 'host1',
          componentName: 'C1'
        })
      });
      hostComponentView.getDesiredAdminState();
      var args = testHelpers.findAjaxRequest('name', 'host.host_component.slave_desired_admin_state');
      expect(args[0]).exists;
      expect(args[0].sender).to.be.eql(hostComponentView);
      expect(args[0].data).to.be.eql({
        hostName: 'host1',
        componentName: 'C1'
      });
    });
  });
});

});

require.register("test/views/main/host/details/host_component_views/nodemanager_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/host/details/host_component_views/nodemanager_view');

describe('App.NodeManagerComponentView', function () {
  var view = App.NodeManagerComponentView.create({
    content: {
      service: {
        hostComponents: [
          Em.Object.create({
            componentName: 'RESOURCEMANAGER'
          })
        ]
      },
      hostName: 'host1'
    }
  });

  describe("#setDesiredAdminState()", function () {
    beforeEach(function () {
      sinon.stub(view, 'setStatusAs', Em.K);
      sinon.stub(view, 'getDecommissionStatus', Em.K);
    });
    afterEach(function () {
      view.setStatusAs.restore();
      view.getDecommissionStatus.restore();
    });
    it("state INSERVICE", function () {
      view.setDesiredAdminState('INSERVICE');
      expect(view.setStatusAs.calledWith('INSERVICE')).to.be.true;
    });
    it("state DECOMMISSIONED", function () {
      view.setDesiredAdminState('DECOMMISSIONED');
      expect(view.getDecommissionStatus.calledOnce).to.be.true;
    });
  });

  describe("#setDecommissionStatus()", function () {
    beforeEach(function () {
      sinon.stub(view, 'setStatusAs', Em.K);
    });
    afterEach(function () {
      view.setStatusAs.restore();
    });
    it("rm_metrics null", function () {
      view.setDecommissionStatus({rm_metrics: null});
      expect(view.setStatusAs.calledWith('DECOMMISSIONED')).to.be.true;
    });
    it("RM contains host", function () {
      var curObj = {rm_metrics: {
        cluster: {
          nodeManagers: [{
            HostName: 'host1'
          }]
        }
      }};
      view.setDecommissionStatus(curObj);
      expect(view.setStatusAs.calledWith('DECOMMISSIONING')).to.be.true;
    });
    it("RM does not contain host", function () {
      var curObj = {rm_metrics: {
        cluster: {
          nodeManagers: []
        }
      }};
      view.setDecommissionStatus(curObj);
      expect(view.setStatusAs.calledWith('DECOMMISSIONED')).to.be.true;
    });
  });
});

});

require.register("test/views/main/host/details/host_component_views/regionserver_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/host/details/host_component_views/regionserver_view');

describe('App.RegionServerComponentView', function () {
  var view = App.RegionServerComponentView.create();

  describe("#setDesiredAdminState()", function () {
    beforeEach(function () {
      sinon.stub(view, 'setStatusAs', Em.K);
    });
    afterEach(function () {
      view.setStatusAs.restore();
    });
    it("INSERVICE state)", function () {
      view.setDesiredAdminState('INSERVICE');
      expect(view.setStatusAs.calledWith('INSERVICE')).to.be.true;
    });
    it("DECOMMISSIONED state)", function () {
      view.setDesiredAdminState('DECOMMISSIONED');
      expect(view.setStatusAs.calledWith('RS_DECOMMISSIONED')).to.be.true;
    });
  });
});

});

require.register("test/views/main/host/details/host_component_views/tasktracker_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/host/details/host_component_views/tasktracker_view');

describe('App.TaskTrackerComponentView', function () {
  var view = App.TaskTrackerComponentView.create({
    content: {
      hostName: 'host1'
    }
  });

  describe("#setDesiredAdminState()", function () {
    beforeEach(function () {
      sinon.stub(view, 'setStatusAs', Em.K);
      sinon.stub(view, 'getDecommissionStatus', Em.K);
    });
    afterEach(function () {
      view.setStatusAs.restore();
      view.getDecommissionStatus.restore();
    });
    it("INSERVICE state)", function () {
      view.setDesiredAdminState('INSERVICE');
      expect(view.setStatusAs.calledWith('INSERVICE')).to.be.true;
    });
    it("DECOMMISSIONED state)", function () {
      view.setDesiredAdminState('DECOMMISSIONED');
      expect(view.getDecommissionStatus.calledOnce).to.be.true;
    });
  });

  describe("#setDecommissionStatus()", function() {
    beforeEach(function () {
      sinon.stub(view, 'setStatusAs', Em.K);
    });
    afterEach(function () {
      view.setStatusAs.restore();
    });
    it("data is null", function() {
      view.setDecommissionStatus(null);
      expect(view.setStatusAs.called).to.be.false;
    });
    it("AliveNodes is null", function() {
      view.setDecommissionStatus({"AliveNodes": null});
      expect(view.setStatusAs.called).to.be.false;
    });
    it("AliveNodes contain current host", function() {
      view.setDecommissionStatus({"AliveNodes": [
        {
          "hostname": "host1"
        }
      ]});
      expect(view.setStatusAs.calledWith("DECOMMISSIONING")).to.be.true;
    });
    it("AliveNodes does not contain current host", function() {
      view.setDecommissionStatus({"AliveNodes": []});
      expect(view.setStatusAs.calledWith('DECOMMISSIONED')).to.be.true;
    });
  });
});

});

require.register("test/views/main/host/details_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/host/details');

var view,
  activeCases = [
    {
      passiveState: 'ON',
      isActive: false,
      label: 'Off'
    },
    {
      passiveState: 'OFF',
      isActive: true,
      label: 'On'
    }
  ];

describe('App.MainHostDetailsView', function () {

  beforeEach(function () {
    view = App.MainHostDetailsView.create({
       content: Em.Object.create({
          hostComponents: []
       })
    });
  });

  describe('#content', function () {
    it('should take content from controller', function () {
      view.set('content', {
        property: 'value'
      });
      expect(view.get('content.property')).to.equal('value');
    });
  });

  describe('#clients', function () {
    it('should take clients from content', function () {
      view.set('content', {
        hostComponents: [
          {
            isClient: true
          },
          {
            isClient: false
          }
        ]
      });
      expect(view.get('clients')).to.have.length(1);
      view.get('content.hostComponents').pushObject({
        isClient: true
      });
      expect(view.get('clients')).to.have.length(2);
    });
  });

  describe('#isActive', function () {
    activeCases.forEach(function (item) {
      it('should be ' + item.isActive, function () {
        view.set('controller', {
          content: {
            passiveState: item.passiveState
          }
        });
        expect(view.get('isActive')).to.equal(item.isActive);
      });
    });
  });

  describe('#maintenance', function () {
    activeCases.forEach(function (item) {
      it('passive state label should contain ' + item.label, function () {
        view.set('controller', {
          content: {
            passiveState: item.passiveState
          }
        });
        expect(view.get('maintenance').findProperty('action', 'onOffPassiveModeForHost').label).to.contain(item.label);
      });
    });
  });

  describe('#clientsWithConfigs', function() {
    beforeEach(function () {
      view.set('content', {
        hostComponents: [
          Em.Object.create({
            isClient: true,
            service: Em.Object.create({
              serviceName: 'WITH_CONFIGS'
            })
          }),
          Em.Object.create({
            isClient: true,
            service: Em.Object.create({
              serviceName: 'WITHOUT_CONFIGS'
            })
          }),
          Em.Object.create({
            isClient: false,
            service: Em.Object.create({
              serviceName: 'SAMPLE_SERVICE'
            })
          })
        ]
      });

      App.set('services', {
        noConfigTypes: ['WITHOUT_CONFIGS', 'WITHOUT_CONFIGS_2']
      });
    });

    afterEach(function () {
      App.set('services', Em.K);
    });

    it('should get only clients with configs (1)', function() {
      expect(view.get('clientsWithConfigs')).to.have.length(1);
    });

    it('should get only clients with configs (2)', function() {
      view.get('content.hostComponents').pushObject(Em.Object.create({
        isClient: true,
        service: Em.Object.create({
          serviceName: 'WITHOUT_CONFIGS_2'
        })
      }));
      expect(view.get('clientsWithConfigs')).to.have.length(1);
    });

    it('should get only clients with configs (3)', function() {
      view.get('content.hostComponents').pushObject(Em.Object.create({
        isClient: true,
        service: Em.Object.create({
          serviceName: 'WITH_CONFIGS_2'
        })
      }));
      expect(view.get('clientsWithConfigs')).to.have.length(2);
    });
  });

  describe('#didInsertElement()', function () {
    beforeEach(function () {
      sinon.stub(App.router, 'get', function () {
        return {
          updateHost: function (callback) {
            callback();
          }
        }
      });
      sinon.stub(App.router, 'transitionTo', Em.K);
      sinon.stub(App, 'tooltip', Em.K);
    });
    afterEach(function () {
      App.router.transitionTo.restore();
      App.router.get.restore();
      App.tooltip.restore();
    });
    it('host loaded', function () {
      view.set('content.isLoaded', true);
      view.didInsertElement();
      expect(App.router.get.calledWith('updateController')).to.be.true;
      expect(App.tooltip.calledOnce).to.be.true;
      expect(App.router.transitionTo.calledWith('main.hosts.index')).to.be.false;
    });
    it('host is not loaded', function () {
      view.set('content.isLoaded', false);
      view.didInsertElement();
      expect(App.router.get.calledWith('updateController')).to.be.true;
      expect(App.tooltip.calledOnce).to.be.true;
      expect(App.router.transitionTo.calledWith('main.hosts.index')).to.be.true;
    });
  });
});

});

require.register("test/views/main/host/host_alerts_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/host/host_alerts_view');

var view;

describe('App.MainHostAlertsView', function () {

  beforeEach(function () {
    view = App.MainHostAlertsView.create({
      controller: Em.Object.create(),
      parentView: Em.Object.create({
        controller: Em.Object.create()
      })
    });
  });

  describe('#content', function () {
    var cases = [
      {
        m: 'return empty array',
        c: null,
        r: []
      },
      {
        m: 'return empty array',
        c: undefined,
        r: []
      },
      {
        m: 'sort CRITICAL and WARNING to be first',
        c: [
            Em.Object.create({
              state: 'OK'
            }),
            Em.Object.create({
              state: 'WARNING'
            }),
            Em.Object.create({
              state: 'CRITICAL'
            }),
            Em.Object.create({
              state: 'OK'
            })
        ],
        r: [
          Em.Object.create({
            state: 'CRITICAL'
          }),
          Em.Object.create({
            state: 'WARNING'
          }),
          Em.Object.create({
            state: 'OK'
          }),
          Em.Object.create({
            state: 'OK'
          })
        ]
      },
      {
        m: 'sort CRITICAL and WARNING to be first',
        c: [
          Em.Object.create({
            state: 'OTHER'
          }),
          Em.Object.create({
            state: 'WARNING'
          }),
          Em.Object.create({
            state: 'OK'
          }),
          Em.Object.create({
            state: 'CRITICAL'
          })
        ],
        r: [
          Em.Object.create({
            state: 'CRITICAL'
          }),
          Em.Object.create({
            state: 'WARNING'
          }),
          Em.Object.create({
            state: 'OK'
          }),
          Em.Object.create({
            state: 'OTHER'
          })
        ]
      }
    ];

    cases.forEach(function(test){
      it('should ' + test.m, function () {
        view.set('controller.content', test.c);
        expect(view.get('content')).eql(test.r);
      });
    });

  });

  describe("#willInsertElement()", function() {
    var mock = {
      loadAlertInstancesByHost: Em.K
    };

    beforeEach(function() {
      sinon.stub(App.router, 'get').returns(mock);
      sinon.spy(mock, 'loadAlertInstancesByHost');
      sinon.stub(App.router, 'set');
      view.set('parentView.controller.content', Em.Object.create({
        hostName: 'host1'
      }));
      sinon.stub(App.db, 'getSortingStatuses').returns([
        {
          name: "state",
          status: "sorting_asc"
        }
      ]);
    });
    afterEach(function() {
      mock.loadAlertInstancesByHost.restore();
      App.router.get.restore();
      App.router.set.restore();
      App.db.getSortingStatuses.restore();
    });

    it("loadAlertInstancesByHost should be called", function() {
      view.willInsertElement();
      expect(App.router.set.calledWith('mainAlertInstancesController.isUpdating', true)).to.be.true;
    });

    it("App.router.set should be called", function() {
      view.willInsertElement();
      expect(App.router.set.calledWith('mainAlertInstancesController.isUpdating', true)).to.be.true;
    });
  });

  describe("#didInsertElement()", function() {

    beforeEach(function() {
      sinon.spy(view, 'tooltipsUpdater');
    });
    afterEach(function() {
      view.tooltipsUpdater.restore();
    });

    it("tooltipsUpdater should be called", function() {
      view.didInsertElement();
      expect(view.tooltipsUpdater.calledOnce).to.be.true;
    });
  });


  describe("#paginationLeftClass", function() {

    it("startIndex is 2", function() {
      view.set('startIndex', 2);
      expect(view.get('paginationLeftClass')).to.equal('paginate_previous');
    });

    it("startIndex is 1", function() {
      view.set('startIndex', 1);
      expect(view.get('paginationLeftClass')).to.equal('paginate_disabled_previous');
    });

    it("startIndex is 0", function() {
      view.set('startIndex', 0);
      expect(view.get('paginationLeftClass')).to.equal('paginate_disabled_previous');
    });
  });

  describe("#paginationRightClass", function() {

    it("endIndex more than filteredCount", function() {
      view.reopen({
        endIndex: 4,
        filteredCount: 3
      });
      expect(view.get('paginationRightClass')).to.equal('paginate_disabled_next');
    });

    it("endIndex equal to filteredCount", function() {
      view.reopen({
        endIndex: 4,
        filteredCount: 4
      });
      expect(view.get('paginationRightClass')).to.equal('paginate_disabled_next');
    });

    it("endIndex less than filteredCount", function() {
      view.reopen({
        endIndex: 3,
        filteredCount: 4
      });
      view.propertyDidChange('paginationRightClass');
      expect(view.get('paginationRightClass')).to.equal('paginate_next');
    });
  });

  describe("#clearFilters()", function() {
    var mock = {
      clearFilter: Em.K
    };

    beforeEach(function() {
      sinon.spy(mock, 'clearFilter');
    });
    afterEach(function() {
      mock.clearFilter.restore();
    });

    it("clearFilter should be called", function() {
      view.reopen({
        'childViews': [mock]
      });
      view.clearFilters();
      expect(view.get('filterConditions')).to.be.empty;
      expect(mock.clearFilter.calledOnce).to.be.true;
    });
  });

  describe("#willDestroyElement()", function() {
    var mock = {
      tooltip: Em.K
    };

    beforeEach(function() {
      sinon.stub(view, '$').returns(mock);
      sinon.spy(mock, 'tooltip');
    });
    afterEach(function() {
      view.$.restore();
      mock.tooltip.restore();
    });

    it("tooltip should be called", function() {
      view.willDestroyElement();
      expect(view.$.calledWith(".enable-disable-button, .timeago, .alert-text")).to.be.true;
      expect(mock.tooltip.calledWith('destroy')).to.be.true;
    });
  });

});

});

require.register("test/views/main/host/menu_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var view;

describe('App.MainHostMenuView', function () {

  beforeEach(function () {
    view = App.MainHostMenuView.create({});
  });

  describe('#content', function () {

    beforeEach(function () {
      this.mock = sinon.stub(App, 'get');
      this.serviceMock = sinon.stub(App.Service, 'find');
      this.authMock = sinon.stub(App, 'isAuthorized');
    });

    afterEach(function () {
      App.get.restore();
      App.Service.find.restore();
      App.isAuthorized.restore();
    });

    Em.A([
        {
          stackVersionsAvailable: true,
          m: '`versions` is visible',
          e: false
        },
        {
          stackVersionsAvailable: false,
          m: '`versions` is invisible',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          this.mock.withArgs('stackVersionsAvailable').returns(test.stackVersionsAvailable);
          view.propertyDidChange('content');
          expect(view.get('content').findProperty('name', 'versions').get('hidden')).to.equal(test.e);
        });
      });

    Em.A([
      {
        logSearch: false,
        services: [{serviceName: 'LOGSEARCH'}],
        auth: true,
        m: '`logs` tab is invisible',
        e: true
      },
      {
        logSearch: true,
        services: [],
        auth: true,
        m: '`logs` tab is invisible because service not installed',
        e: true
      },
      {
        logSearch: true,
        services: [{serviceName: 'LOGSEARCH'}],
        auth: true,
        m: '`logs` tab is visible',
        e: false
      },
      {
        logSearch: true,
        services: [{serviceName: 'LOGSEARCH'}],
        auth: false,
        m: '`logs` tab is hidden because user has no access',
        e: true
      }
    ]).forEach(function(test) {
      it(test.m, function() {
        this.mock.withArgs('supports.logSearch').returns(test.logSearch);
        this.serviceMock.returns(test.services);
        this.authMock.returns(test.auth);
        view.propertyDidChange('content');
        expect(view.get('content').findProperty('name', 'logs').get('hidden')).to.equal(test.e);
      });
    });
  });

  describe("#updateAlertCounter()", function() {

    it("CRITICAL alerts", function() {
      view.setProperties({
        host: Em.Object.create({
          criticalWarningAlertsCount: 1,
          alertsSummary: Em.Object.create({
            CRITICAL: 1,
            WARNING: 0
          })
        })
      });
      view.updateAlertCounter();
      expect(view.get('content').findProperty('name', 'alerts').get('badgeText')).to.equal('1');
      expect(view.get('content').findProperty('name', 'alerts').get('badgeClasses')).to.equal('label alerts-crit-count');
    });

    it("WARNING alerts", function() {
      view.setProperties({
        host: Em.Object.create({
          criticalWarningAlertsCount: 1,
          alertsSummary: Em.Object.create({
            CRITICAL: 0,
            WARNING: 1
          })
        })
      });
      view.updateAlertCounter();
      expect(view.get('content').findProperty('name', 'alerts').get('badgeText')).to.equal('1');
      expect(view.get('content').findProperty('name', 'alerts').get('badgeClasses')).to.equal('label alerts-warn-count');
    });
  });

  describe("#deactivateChildViews()", function() {
    it("active attr should be empty", function() {
      view.set('_childViews', [Em.Object.create({active: 'active'})]);
      view.deactivateChildViews();
      expect(view.get('_childViews').mapProperty('active')).to.eql(['']);
    });
  });

});

});

require.register("test/views/main/host/metrics/disk_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/host/metrics/disk');

describe('App.ChartHostMetricsDisk', function () {

  var view;

  beforeEach(function () {
    view = App.ChartHostMetricsDisk.create();
  });

  describe('#getData', function () {

    var cases = [
      {
        data: {},
        result: {},
        title: 'no metrics data'
      },
      {
        data: {
          metrics: null
        },
        result: {
          metrics: null
        },
        title: 'malformed metrics data'
      },
      {
        data: {
          metrics: {}
        },
        result: {
          metrics: {}
        },
        title: 'no metrics data'
      },
      {
        data: {
          metrics: {
            part_max_used: 0,
            disk: {}
          }
        },
        result: {
          metrics: {
            part_max_used: 0,
            disk: {
              part_max_used: 0
            }
          }
        },
        title: 'part_max_used = 0'
      },
      {
        data: {
          metrics: {
            part_max_used: 1,
            disk: {}
          }
        },
        result: {
          metrics: {
            part_max_used: 1,
            disk: {
              part_max_used: 1
            }
          }
        },
        title: 'part_max_used != 0'
      },
      {
        data: {
          metrics: {
            part_max_used: 1
          }
        },
        result: {
          metrics: {
            part_max_used: 1
          }
        },
        title: 'no metrics.disk data'
      },
      {
        data: {
          metrics: {
            part_max_used: 1,
            disk: null
          }
        },
        result: {
          metrics: {
            part_max_used: 1,
            disk: null
          }
        },
        title: 'malformed metrics.disk data'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        view.getData(item.data);
        expect(item.data).to.eql(item.result);
      });
    });

  });

});

});

require.register("test/views/main/host/stack_versions_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

function getView() {
  return App.MainHostStackVersionsView.create({
    filteredCount: 0,
    totalCount: 0
  });
}
var view;
describe('App.MainHostStackVersionsView', function() {

  beforeEach(function () {
    view = getView();
  });

  App.TestAliases.testAsComputedAlias(getView(), 'host', 'App.router.mainHostDetailsController.content', 'object');

  App.TestAliases.testAsComputedFilterBy(getView(), 'content', 'host.stackVersions', 'isVisible', true);

  describe("#filteredContentInfo", function () {
    it("formatted with filteredCount and totalCount", function () {
      view.set('filteredCount', 1);
      view.set('totalCount', 2);
      view.propertyDidChange('filteredContentInfo');
      expect(view.get('filteredContentInfo')).to.eql(Em.I18n.t('hosts.host.stackVersions.table.filteredInfo').format(1, 2));
    });
  });
});

});

require.register("test/views/main/host/summary_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host');
require('models/service');
require('models/host_component');
require('mappers/server_data_mapper');
require('views/main/host/summary');

var mainHostSummaryView;
var modelSetup = require('test/init_model_test');

describe('App.MainHostSummaryView', function() {

  beforeEach(function() {
    modelSetup.setupStackServiceComponent();
    mainHostSummaryView = App.MainHostSummaryView.create({content: Em.Object.create()});
  });

  afterEach(function(){
    modelSetup.cleanStackServiceComponent();
  });

  describe("#installedServices", function() {

    beforeEach(function() {
      sinon.stub(App.Service, 'find').returns([Em.Object.create({serviceName: 'S1'})]);
    });
    afterEach(function() {
      App.Service.find.restore();
    });

    it("should return installed services", function() {
      expect(mainHostSummaryView.get('installedServices')).to.eql(['S1']);
    });
  });

  describe('#sortedComponentsFormatter()', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters, slaves and clients',
        e: ['A', 'C', 'B']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters and slaves',
        e: ['A', 'C', 'D', 'B']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters',
        e: ['B', 'A', 'C', 'D']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'D'})
          ])
        }),
        m: 'List of slaves',
        e: ['B', 'A', 'C', 'D']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([])
        }),
        m: 'Empty list',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of clients',
        e: []
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        test.content.get('hostComponents').forEach(function(component) {
          component.set('id', component.get('componentName'));
        });
        mainHostSummaryView.set('sortedComponents', []);
        mainHostSummaryView.set('content', test.content);
        mainHostSummaryView.sortedComponentsFormatter();
        expect(mainHostSummaryView.get('sortedComponents').mapProperty('componentName')).to.eql(test.e);
      });
    });

  });

  describe('#clients', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters, slaves and clients',
        e: ['D']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters and slaves',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'D'})
          ])
        }),
        m: 'List of slaves',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([])
        }),
        m: 'Empty list',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of clients',
        e: ['B', 'A', 'C', 'D']
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        mainHostSummaryView.set('content', test.content);
        expect(mainHostSummaryView.get('clients').mapProperty('componentName')).to.eql(test.e);
      });
    });

    it('should set isInstallFailed for clients with INIT and INSTALL_FAILED workStatus', function() {
      mainHostSummaryView.set('content', Em.Object.create({
        hostComponents: [
          Em.Object.create({isMaster: false, isSlave: false, componentName: 'B', workStatus: 'INIT'}),
          Em.Object.create({isMaster: false, isSlave: false, componentName: 'A', workStatus: 'INSTALLED'}),
          Em.Object.create({isMaster: false, isSlave: false, componentName: 'C', workStatus: 'INSTALL_FAILED'}),
          Em.Object.create({isMaster: false, isSlave: false, componentName: 'D', workStatus: 'INSTALLING'})
        ]
      }));
      expect(mainHostSummaryView.get('clients').filterProperty('isInstallFailed', true).mapProperty('componentName')).to.eql(['B', 'C']);
      expect(mainHostSummaryView.get('clients').filterProperty('isInstallFailed', false).mapProperty('componentName')).to.eql(['A', 'D']);
    });

  });

  describe('#areClientWithStaleConfigs', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D', staleConfigs: true}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C', staleConfigs: false})
          ])
        }),
        m: 'Some clients with stale configs',
        e: true
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D', staleConfigs: false}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C', staleConfigs: false})
          ])
        }),
        m: 'No clients with stale configs',
        e: false
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D', staleConfigs: true}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C', staleConfigs: true})
          ])
        }),
        m: 'All clients with stale configs',
        e: true
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([])
        }),
        m: 'Empty list',
        e: false
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        mainHostSummaryView.set('content', test.content);
        expect(mainHostSummaryView.get('areClientWithStaleConfigs')).to.equal(test.e);
      });
    });

  });

  describe('#isAddComponent', function() {

    var tests = Em.A([
      {content: {healthClass: 'health-status-DEAD-YELLOW', hostComponents: Em.A([])}, e: false},
      {content: {healthClass: 'OTHER_VALUE', hostComponents: Em.A([])}, e: true}
    ]);

    tests.forEach(function(test) {
      it(test.content.healthClass, function() {
        mainHostSummaryView.set('content', test.content);
        expect(mainHostSummaryView.get('isAddComponent')).to.equal(test.e);
      });
    });

  });

  describe('#addableComponents', function() {

    beforeEach(function() {
      this.mock = sinon.stub(App.StackServiceComponent, 'find');
      sinon.stub(mainHostSummaryView, 'hasCardinalityConflict').returns(false);
    });
    afterEach(function() {
      App.StackServiceComponent.find.restore();
      mainHostSummaryView.hasCardinalityConflict.restore();
    });

    var tests = Em.A([
      {
        addableToHostComponents: [
          Em.Object.create({
            serviceName: 'HDFS',
            componentName: 'DATANODE',
            isAddableToHost: true
          }),
          Em.Object.create({
            serviceName: 'HDFS',
            componentName: 'HDFS_CLIENT',
            isAddableToHost: true
          })
        ],
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({
              componentName: 'HDFS_CLIENT'
            })
          ])
        }),
        services: ['HDFS'],
        e: ['DATANODE'],
        m: 'some components are already installed'
      },
      {
        addableToHostComponents: [
          Em.Object.create({
            serviceName: 'HDFS',
            componentName: 'HDFS_CLIENT',
            isAddableToHost: true
          })
        ],
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({
              componentName: 'HDFS_CLIENT'
            })
          ])
        }),
        services: ['HDFS'],
        e: [],
        m: 'all components are already installed'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        this.mock.returns(test.addableToHostComponents);
        mainHostSummaryView.set('content', test.content);
        mainHostSummaryView.reopen({
          installedServices: test.services
        });
        mainHostSummaryView.propertyDidChange('addableComponents');
        expect(mainHostSummaryView.get('addableComponents').mapProperty('componentName')).to.eql(test.e);
      });
    });
  });

  describe('#areClientsNotInstalled', function () {

    var cases = [
      {
        clients: [
          {
            isInstallFailed: true
          }
        ],
        installableClientComponents: [],
        areClientsNotInstalled: true,
        title: 'some clients failed to install, no clients to add'
      },
      {
        clients: [
          {
            isInstallFailed: false
          }
        ],
        installableClientComponents: [{}],
        areClientsNotInstalled: true,
        title: 'no clients failed to install, some clients to add'
      },
      {
        clients: [
          {
            isInstallFailed: true
          }
        ],
        installableClientComponents: [{}],
        areClientsNotInstalled: true,
        title: 'some clients failed to install, some clients to add'
      },
      {
        clients: [
          {
            isInstallFailed: false
          }
        ],
        installableClientComponents: [],
        areClientsNotInstalled: false,
        title: 'no clients failed to install, no clients to add'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        mainHostSummaryView.reopen({
          clients: item.clients,
          installableClientComponents: item.installableClientComponents
        });
        expect(mainHostSummaryView.get('areClientsNotInstalled')).to.equal(item.areClientsNotInstalled);
      });
    });

  });

  describe('#notInstalledClientComponents', function () {

    it('should concat not added clients and the ones that failed to install', function () {
      mainHostSummaryView.reopen({
        clients: [
          Em.Object.create({
            componentName: 'c0',
            workStatus: 'INIT'
          }),
          Em.Object.create({
            componentName: 'c1',
            workStatus: 'INSTALL_FAILED'
          }),
          Em.Object.create({
            componentName: 'c2',
            workStatus: 'INSTALLED'
          })
        ],
        installableClientComponents: [
          Em.Object.create({
            componentName: 'c3'
          })
        ]
      });
      expect(mainHostSummaryView.get('notInstalledClientComponents')).to.eql([
        Em.Object.create({
          componentName: 'c0',
          workStatus: 'INIT'
        }),
        Em.Object.create({
          componentName: 'c1',
          workStatus: 'INSTALL_FAILED'
        }),
        Em.Object.create({
          componentName: 'c3'
        })
      ]);
    });

  });

  describe("#needToRestartMessage", function() {

    it("one component", function() {
      var expected = Em.I18n.t('hosts.host.details.needToRestart').format(1, Em.I18n.t('common.component').toLowerCase());
      mainHostSummaryView.set('content', Em.Object.create({
        componentsWithStaleConfigsCount: 1
      }));
      expect(mainHostSummaryView.get('needToRestartMessage')).to.equal(expected);
    });

    it("multiple components", function() {
      var expected = Em.I18n.t('hosts.host.details.needToRestart').format(2, Em.I18n.t('common.components').toLowerCase());
      mainHostSummaryView.set('content', Em.Object.create({
        componentsWithStaleConfigsCount: 2
      }));
      expect(mainHostSummaryView.get('needToRestartMessage')).to.equal(expected);
    });

  });

  describe("#redrawComponents()", function() {

    beforeEach(function() {
      this.mock = sinon.stub(App.router, 'get');
      sinon.stub(mainHostSummaryView, 'sortedComponentsFormatter');
      sinon.stub(App.router, 'set');
    });
    afterEach(function() {
      this.mock.restore();
      mainHostSummaryView.sortedComponentsFormatter.restore();
      App.router.set.restore();
    });

    it("redrawComponents is false", function() {
      this.mock.returns(false);
      mainHostSummaryView.redrawComponents();
      expect(mainHostSummaryView.sortedComponentsFormatter.called).to.be.false;
    });

    it("redrawComponents is true", function() {
      this.mock.returns(true);
      mainHostSummaryView.redrawComponents();
      expect(mainHostSummaryView.sortedComponentsFormatter.calledOnce).to.be.true;
      expect(mainHostSummaryView.get('sorteComponents')).to.be.empty;
      expect(App.router.set.calledWith('mainHostDetailsController.redrawComponents', false)).to.be.true;
    });

  });

  describe("#willInsertElement()", function() {

    beforeEach(function() {
      sinon.stub(mainHostSummaryView, 'sortedComponentsFormatter');
      sinon.stub(mainHostSummaryView, 'addObserver');
    });
    afterEach(function() {
      mainHostSummaryView.sortedComponentsFormatter.restore();
      mainHostSummaryView.addObserver.restore();
    });

    it("sortedComponentsFormatter should be called ", function() {
      mainHostSummaryView.willInsertElement();
      expect(mainHostSummaryView.sortedComponentsFormatter.calledOnce).to.be.true;
      expect(mainHostSummaryView.addObserver.calledWith('content.hostComponents.length', mainHostSummaryView, 'sortedComponentsFormatter')).to.be.true;
      expect(mainHostSummaryView.get('sortedComponents')).to.be.empty;
    });
  });

  describe("#didInsertElement()", function() {

    beforeEach(function() {
      sinon.stub(mainHostSummaryView, 'addToolTip');
    });
    afterEach(function() {
      mainHostSummaryView.addToolTip.restore();
    });

    it("addToolTip should be called", function() {
      mainHostSummaryView.didInsertElement();
      expect(mainHostSummaryView.addToolTip.calledOnce).to.be.true;
    });
  });

  describe("#addToolTip()", function() {

    beforeEach(function() {
      sinon.stub(App, 'tooltip');
      mainHostSummaryView.removeObserver('addComponentDisabled', mainHostSummaryView, 'addToolTip');
    });
    afterEach(function() {
      App.tooltip.restore();
    });

    it("addComponentDisabled is false ", function() {
      mainHostSummaryView.reopen({
        addComponentDisabled: false
      });
      mainHostSummaryView.addToolTip();
      expect(App.tooltip.called).to.be.false;
    });

    it("addComponentDisabled is true ", function() {
      mainHostSummaryView.reopen({
        addComponentDisabled: true
      });
      mainHostSummaryView.addToolTip();
      expect(App.tooltip.called).to.be.true;
    });

  });

  describe("#installableClientComponents", function() {

    beforeEach(function() {
      sinon.stub(App.StackServiceComponent, 'find').returns([
        Em.Object.create({
          isClient: true,
          serviceName: 'S1',
          componentName: 'C1'
        }),
        Em.Object.create({
          isClient: true,
          serviceName: 'S1',
          componentName: 'C2'
        }),
        Em.Object.create({
          isClient: true,
          serviceName: 'S2',
          componentName: 'C1'
        })
      ]);
    });
    afterEach(function() {
      App.StackServiceComponent.find.restore();
    });

    it("should return installable client components", function() {
      mainHostSummaryView.reopen({
        installedServices: ['S1'],
        clients: [
          Em.Object.create({componentName: 'C2'})
        ]
      });
      mainHostSummaryView.propertyDidChange('installableClientComponents');
      expect(mainHostSummaryView.get('installableClientComponents').mapProperty('componentName')).to.eql(['C1']);
    });
  });

  describe("#hasCardinalityConflict()", function () {

    beforeEach(function() {
      this.mockSlave = sinon.stub(App.SlaveComponent, 'find');
      this.mockStack = sinon.stub(App.StackServiceComponent, 'find');
    });

    afterEach(function() {
      this.mockSlave.restore();
      this.mockStack.restore();
    });

    it("totalCount equal to maxToInstall", function() {
      this.mockSlave.returns(Em.Object.create({
        totalCount: 1
      }));
      this.mockStack.returns(Em.Object.create({
        maxToInstall: 1
      }));
      expect(mainHostSummaryView.hasCardinalityConflict('C1')).to.be.true;
    });

    it("totalCount more than maxToInstall", function() {
      this.mockSlave.returns(Em.Object.create({
        totalCount: 2
      }));
      this.mockStack.returns(Em.Object.create({
        maxToInstall: 1
      }));
      expect(mainHostSummaryView.hasCardinalityConflict('C1')).to.be.true;
    });

    it("totalCount less than maxToInstall", function() {
      this.mockSlave.returns(Em.Object.create({
        totalCount: 0
      }));
      this.mockStack.returns(Em.Object.create({
        maxToInstall: 1
      }));
      expect(mainHostSummaryView.hasCardinalityConflict('C1')).to.be.false;
    });
  });

  describe("#installClients()", function () {

    beforeEach(function () {
      var controller = {installClients: Em.K};
      sinon.spy(controller, 'installClients');
      mainHostSummaryView.set('controller', controller);
      mainHostSummaryView.reopen({'notInstalledClientComponents': [1,2,3]});
    });

    afterEach(function () {
      mainHostSummaryView.get('controller.installClients').restore();
    });

    it("should call installClients method from controller", function () {
      mainHostSummaryView.installClients();
      expect(mainHostSummaryView.get('controller.installClients').calledWith([1,2,3])).to.be.true;
    });
  });

  describe("#reinstallClients()", function () {

    beforeEach(function () {
      var controller = {installClients: Em.K};
      sinon.spy(controller, 'installClients');
      mainHostSummaryView.set('controller', controller);
      mainHostSummaryView.reopen({'installFailedClients': [1,2,3]});
    });

    afterEach(function () {
      mainHostSummaryView.get('controller.installClients').restore();
    });

    it("should call installClients method from controller", function () {
      mainHostSummaryView.reinstallClients();
      expect(mainHostSummaryView.get('controller.installClients').calledWith([1,2,3])).to.be.true;
    });
  });
});

});

require.register("test/views/main/host_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/host');

function getView() {
  return App.MainHostView.create({
    controller: App.MainHostController.create()
  });
}

describe('App.MainHostView', function () {

  var view;

  beforeEach(function () {
    view = getView();
  });

  App.TestAliases.testAsComputedAlias(getView(), 'colPropAssoc', 'controller.colPropAssoc', 'array');

  describe('#didInsertElement', function () {

    var cases = [
        {
          methodName: 'clearFiltersObs',
          propertyToChange: 'controller.clearFilters',
          callCount: 2
        },
        {
          methodName: 'toggleAllHosts',
          propertyToChange: 'selectAllHosts',
          callCount: 1
        },
        {
          methodName: 'updatePagination',
          propertyToChange: 'displayLength',
          callCount: 1
        },
        {
          methodName: 'updatePaging',
          propertyToChange: 'filteredCount',
          callCount: 2
        }
      ],
      title = '{0} changed';

    beforeEach(function () {
      cases.forEach(function (item) {
        sinon.stub(view, item.methodName, Em.K);
      });
      sinon.stub(view, 'overlayObserver');
    });

    afterEach(function () {
      cases.forEach(function (item) {
        view[item.methodName].restore();
      });
      view.overlayObserver.restore();
    });

    cases.forEach(function (item) {
      it(title.format(item.propertyToChange), function () {
        view.didInsertElement();
        view.propertyDidChange(item.propertyToChange);
        expect(view[item.methodName].callCount).to.equal(item.callCount);
      });
    });

    it('overlayObserver should be called', function () {
      view.didInsertElement();
      expect(view.overlayObserver.calledOnce).to.be.true;
    });
  });

  describe('#HostView', function () {

    var hostView;

    beforeEach(function () {
      hostView = view.HostView.create({
        content: {
          hostName: null
        },
        controller: App.MainHostController.create()
      });
    });

    describe('#displayComponents', function () {

      var cases = [
        {
          hostComponents: [
            {
              displayName: 'c0'
            },
            {
              displayName: 'c1'
            }
          ],
          showHostsTableListPopupCallCount: 1,
          title: 'should display host components in modal popup'
        },
        {
          hostComponents: [],
          showHostsTableListPopupCallCount: 0,
          title: 'should not display modal popup'
        }
      ];

      beforeEach(function () {
        sinon.stub(App, 'showHostsTableListPopup', Em.K);
      });

      afterEach(function () {
        App.showHostsTableListPopup.restore();
      });

      cases.forEach(function (item) {
        it(item.title, function () {
          hostView.set('content', {
            hostName: 'h',
            hostComponents: item.hostComponents
          });
          hostView.displayComponents();
          expect(App.showHostsTableListPopup.callCount).to.equal(item.showHostsTableListPopupCallCount);
          if (item.showHostsTableListPopupCallCount) {
            expect(App.showHostsTableListPopup.calledWith(Em.I18n.t('common.components'), 'h', ['c0', 'c1'])).to.be.true;
          }
        });
      });

    });

    describe('#displayVersions', function () {

      var cases = [
        {
          stackVersions: [
            Em.Object.create({
              displayName: 'v0',
              status: 'CURRENT',
              isVisible: true
            }),
            Em.Object.create({
              displayName: 'v1',
              status: 'OUT_OF_SYNC',
              isVisible: true
            }),
            Em.Object.create({
              displayName: 'v2',
              status: 'INSTALL_FAILED',
              isVisible: false
            })
          ],
          showHostsTableListPopupCallCount: 1,
          title: 'should display stack versions in modal popup'
        },
        {
          stackVersions: [
            Em.Object.create({
              displayName: 'v0',
              status: 'CURRENT',
              isVisible: true
            }),
            Em.Object.create({
              displayName: 'v2',
              status: 'INSTALL_FAILED',
              isVisible: false
            })
          ],
          showHostsTableListPopupCallCount: 0,
          title: 'should not display modal popup if there\'s only one visible stack version'
        },
        {
          stackVersions: [
            Em.Object.create({
              displayName: 'v2',
              status: 'INSTALL_FAILED',
              isVisible: false
            })
          ],
          showHostsTableListPopupCallCount: 0,
          title: 'should not display modal popup if there are no visible stack versions available'
        },
        {
          stackVersions: [],
          showHostsTableListPopupCallCount: 0,
          title: 'should not display modal popup if there are no stack versions available'
        }
      ];

      beforeEach(function () {
        sinon.stub(App, 'showHostsTableListPopup', Em.K);
      });

      afterEach(function () {
        App.showHostsTableListPopup.restore();
      });

      cases.forEach(function (item) {
        it('should display stack versions in modal popup', function () {
          hostView.set('content', {
            hostName: 'h',
            stackVersions: item.stackVersions
          });
          hostView.displayVersions();
          expect(App.showHostsTableListPopup.callCount).to.equal(item.showHostsTableListPopupCallCount);
          if (item.showHostsTableListPopupCallCount) {
            expect(App.showHostsTableListPopup.calledWith(Em.I18n.t('common.versions'), 'h', [
              {
                name: 'v0',
                status: 'Current'
              },
              {
                name: 'v1',
                status: 'Out Of Sync'
              }
            ])).to.be.true;
          }
        });
      });

    });

    describe('#currentVersion', function () {

      var cases = [
        {
          stackVersions: [
            Em.Object.create({
              displayName: 'HDP-2.2.0.0-2000'
            }),
            Em.Object.create({
              displayName: 'HDP-2.2.0.0-1000',
              isCurrent: true
            })
          ],
          currentVersion: 'HDP-2.2.0.0-1000',
          title: 'current version specified explicitly'
        },
        {
          stackVersions: [
            Em.Object.create({
              displayName: 'HDP-2.2.0.0-2000'
            }),
            Em.Object.create({
              displayName: 'HDP-2.3.0.0-1000'
            })
          ],
          currentVersion: 'HDP-2.2.0.0-2000',
          title: 'current version not specified explicitly'
        },
        {
          stackVersions: [Em.Object.create()],
          currentVersion: undefined,
          title: 'version display name isn\'t defined'
        },
        {
          stackVersions: [null],
          currentVersion: '',
          title: 'no version data available'
        },
        {
          stackVersions: [],
          currentVersion: '',
          title: 'no versions available'
        }
      ];

      cases.forEach(function (item) {
        it(item.title, function () {
          hostView.set('content.stackVersions', item.stackVersions);
          expect(hostView.get('currentVersion')).to.equal(item.currentVersion);
        });
      });

    });

  });

});

});

require.register("test/views/main/menu_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/menu');

var mainMenuView = App.MainMenuView.create();
describe('App.MainMenuView', function () {

  describe('#itemViewClass', function () {

    beforeEach(function () {
      mainMenuView.reopen({
        content: [
          mainMenuView.get('itemViewClass').create({
            content: {
              routing: 'dashboard'
            }
          }),
          mainMenuView.get('itemViewClass').create({
            content: {
              routing: 'admin'
            }
          })
        ]
      });
    });

    describe.skip('#dropdownCategories', function () {

      var cases = [
        {
          itemName: 'dashboard',
          dropdownCategories: [],
          title: 'not Admin item'
        },
        {
          itemName: 'admin',
          isHadoopWindowsStack: true,
          dropdownCategories: [
            {
              name: 'stackAndUpgrade',
              url: 'stack',
              label: Em.I18n.t('admin.stackUpgrade.title')
            },
            {
              name: 'adminServiceAccounts',
              url: 'serviceAccounts',
              label: Em.I18n.t('common.serviceAccounts')
            }
          ],
          title: 'Admin item, HDPWIN'
        },
        {
          itemName: 'admin',
          isHadoopWindowsStack: false,
          dropdownCategories: [
            {
              name: 'stackAndUpgrade',
              url: 'stack',
              label: Em.I18n.t('admin.stackUpgrade.title')
            },
            {
              name: 'adminServiceAccounts',
              url: 'serviceAccounts',
              label: Em.I18n.t('common.serviceAccounts')
            },
            {
              name: 'kerberos',
              url: 'kerberos/',
              label: Em.I18n.t('common.kerberos')
            }
          ],
          title: 'Admin item, not HDPWIN'
        }
      ];

      beforeEach(function () {
        this.mock = sinon.stub(App, 'get');
      });

      afterEach(function () {
        this.mock.restore();
      });

      cases.forEach(function (item) {
        it(item.title, function () {
          this.mock.withArgs('isHadoopWindowsStack').returns(item.isHadoopWindowsStack);
          var menuItem = mainMenuView.get('content').findProperty('content.routing', item.itemName);
          menuItem.propertyDidChange('dropdownCategories');
          expect(menuItem.get('dropdownCategories')).to.eql(item.dropdownCategories);
        });
      });

    });

  });

});

});

require.register("test/views/main/service/info/component_list_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/service/info/menu');


describe('App.SummaryMasterComponentsView', function () {
  var view;

  beforeEach(function () {
    view = App.SummaryMasterComponentsView.create({
      controller: Em.Object.create()
    });
  });

  describe("#mastersCompWillChange", function() {

    beforeEach(function() {
      sinon.stub(view, 'removeTooltips');
    });
    afterEach(function() {
      view.removeTooltips.restore();
    });

    it("removeTooltips should be called", function() {
      view.mastersCompWillChange();
      expect(view.removeTooltips.calledOnce).to.be.true;
    });
  });

  describe("#mastersCompDidChange", function() {

    beforeEach(function() {
      sinon.stub(view, 'attachTooltip');
    });
    afterEach(function() {
      view.attachTooltip.restore();
    });

    it("attachTooltip should be called", function() {
      view.mastersCompDidChange();
      expect(view.attachTooltip.calledOnce).to.be.true;
    });
  });

  describe("#didInsertElement", function() {

    beforeEach(function() {
      sinon.stub(view, 'attachTooltip');
    });
    afterEach(function() {
      view.attachTooltip.restore();
    });

    it("attachTooltip should be called", function() {
      view.didInsertElement();
      expect(view.attachTooltip.calledOnce).to.be.true;
    });
  });

  describe("#willDestroyElement", function() {
    var mock = {tooltip: Em.K};

    beforeEach(function() {
      sinon.spy(mock, 'tooltip');
      sinon.stub(window, '$').returns(mock);
    });
    afterEach(function() {
      mock.tooltip.restore();
      window.$.restore();
    });

    it("tooltip should be called", function() {
      view.willDestroyElement();
      expect(mock.tooltip.calledWith('destroy')).to.be.true;
    });
  });

  describe("#removeTooltips", function() {
    var mock = {
      tooltip: Em.K
    };

    beforeEach(function() {
      sinon.spy(mock, 'tooltip');
      sinon.stub(window, '$').returns(mock);
    });
    afterEach(function() {
      mock.tooltip.restore();
      window.$.restore();
    });

    it("tooltip should be called", function() {
      mock.length = 1;
      view.removeTooltips();
      expect(mock.tooltip.calledWith('destroy')).to.be.true;
    });

    it("tooltip should not be called", function() {
      mock.length = 0;
      view.removeTooltips();
      expect(mock.tooltip.called).to.be.false;
    });
  });

  describe("#attachTooltip", function() {
    var mock = {
      tooltip: Em.K
    };

    beforeEach(function() {
      sinon.stub(App, 'tooltip');
      sinon.stub(window, '$').returns(mock);
    });
    afterEach(function() {
      App.tooltip.restore();
      window.$.restore();
    });

    it("tooltip should be called", function() {
      mock.length = 1;
      view.attachTooltip();
      expect(App.tooltip.calledOnce).to.be.true;
    });

    it("tooltip should not be called", function() {
      mock.length = 0;
      view.attachTooltip();
      expect(App.tooltip.called).to.be.false;
    });
  });




});

});

require.register("test/views/main/service/info/config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/service/info/configs');
var batchUtils = require('utils/batch_scheduled_requests');

describe('App.MainServiceInfoConfigsView', function () {

  var view;

  beforeEach(function () {
    view = App.MainServiceInfoConfigsView.create({
      controller: Em.Object.create({
        loadStep: Em.K,
        clearStep: Em.K,
        content: Em.Object.create()
      })
    });
  });

  describe("#resetConfigTabSelection()", function () {
    var tab = Em.Object.create({
      serviceName: 'S1',
      isActive: true
    });

    beforeEach(function () {
      sinon.stub(App.Tab, 'find').returns([tab]);
      sinon.stub(view, 'updateComponentInformation');
    });

    afterEach(function () {
      App.Tab.find.restore();
      view.updateComponentInformation.restore();
    });

    it("isActive should be false", function () {
      view.set('controller.content', Em.Object.create({serviceName: 'S1'}));
      view.resetConfigTabSelection();
      expect(tab.get('isActive')).to.be.false;
    });
  });

  describe('#updateComponentInformation', function () {

    var testCases = [
      {
        title: 'if components absent then counters should be 0',
        content: {
          restartRequiredHostsAndComponents: {}
        },
        result: {
          componentsCount: 0,
          hostsCount: 0
        }
      },
      {
        title: 'if host doesn\'t have components then hostsCount should be 1 and componentsCount should be 0',
        content: {
          restartRequiredHostsAndComponents: {
            host1: []
          }
        },
        result: {
          componentsCount: 0,
          hostsCount: 1
        }
      },
      {
        title: 'if host has 1 component then hostsCount should be 1 and componentsCount should be 1',
        content: {
          restartRequiredHostsAndComponents: {
            host1: [{}]
          }
        },
        result: {
          componentsCount: 1,
          hostsCount: 1
        }
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('controller.content', test.content);
        view.updateComponentInformation();
        expect(view.get('componentsCount')).to.equal(test.result.componentsCount);
        expect(view.get('hostsCount')).to.equal(test.result.hostsCount);
      });
    });
  });

  describe("#didInsertElement()", function() {
    var mock = {
      isLoading: function () {
        return {
          done: function (callback) {
            callback();
          }
        }
      }
    };

    beforeEach(function() {
      sinon.stub(App.router, 'get').returns(mock);
      sinon.stub(view.get('controller'), 'loadStep');
      sinon.stub(view, 'resetConfigTabSelection');
      view.didInsertElement();
    });
    afterEach(function() {
      App.router.get.restore();
      view.get('controller').loadStep.restore();
      view.resetConfigTabSelection.restore();
    });

    it("loadStep should be called", function() {
      expect(view.get('controller').loadStep.calledOnce).to.be.true;
    });

    it("resetConfigTabSelection should be called", function() {
      expect(view.resetConfigTabSelection.calledOnce).to.be.true;
    });
  });

  describe("#willDestroyElement()", function() {

    beforeEach(function() {
      sinon.stub(view.get('controller'), 'clearStep');
    });
    afterEach(function() {
      view.get('controller').clearStep.restore();
    });

    it("resetConfigTabSelection should be called", function() {
      view.willDestroyElement();
      expect(view.get('controller').clearStep.calledOnce).to.be.true;
    });
  });

  describe("#rollingRestartSlaveComponentName", function() {

    beforeEach(function() {
      sinon.stub(batchUtils, 'getRollingRestartComponentName', function(input) {
        return input;
      });
    });
    afterEach(function() {
      batchUtils.getRollingRestartComponentName.restore();
    });

    it("should return service name", function() {
      view.set('controller.content.serviceName', 'S1');
      view.propertyDidChange('rollingRestartSlaveComponentName');
      expect(view.get('rollingRestartSlaveComponentName')).to.equal('S1');
    });
  });

  describe("#rollingRestartActionName", function() {

    beforeEach(function() {
      sinon.stub(App.format, 'role', function(input) {
        return input;
      });
    });
    afterEach(function() {
      App.format.role.restore();
    });

    it("should return action name", function() {
      view.reopen({
        rollingRestartSlaveComponentName: 'C1'
      });
      view.propertyDidChange('rollingRestartActionName');
      expect(view.get('rollingRestartActionName')).to.equal(Em.I18n.t('rollingrestart.dialog.title').format('C1'));
    });

    it("should return empty", function() {
      view.reopen({
        rollingRestartSlaveComponentName: null
      });
      view.propertyDidChange('rollingRestartActionName');
      expect(view.get('rollingRestartActionName')).to.be.empty;
    });
  });
});

});

require.register("test/views/main/service/info/menu_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/service/info/menu');


describe('App.MainServiceInfoMenuView', function () {
  var view;

  beforeEach(function () {
    view = App.MainServiceInfoMenuView.create({
      controller: Em.Object.create()
    });
  });

  describe("#content", function() {

    it("heatmapTab and configTab are false", function() {
      view.setProperties({
        configTab: false,
        heatmapTab: false
      });
      view.propertyDidChange('content');
      expect(view.get('content').mapProperty('id')).to.eql(['summary-service-tab']);
    });

    it("heatmapTab - false, configTab - true", function() {
      view.setProperties({
        configTab: true,
        heatmapTab: false
      });
      view.propertyDidChange('content');
      expect(view.get('content').mapProperty('id')).to.eql(['summary-service-tab', 'configs-service-tab']);
    });

    it("heatmapTab - true, configTab - false", function() {
      view.setProperties({
        configTab: false,
        heatmapTab: true
      });
      view.propertyDidChange('content');
      expect(view.get('content').mapProperty('id')).to.eql(['summary-service-tab', 'heatmap-service-tab']);
    });

    it("heatmapTab - true, configTab - true", function() {
      view.setProperties({
        configTab: true,
        heatmapTab: true
      });
      view.propertyDidChange('content');
      expect(view.get('content').mapProperty('id')).to.eql(['summary-service-tab', 'heatmap-service-tab', 'configs-service-tab']);
    });
  });

  describe("#activateView()", function() {
    it("_childViews should be active", function() {
      view.set('_childViews', [
        Em.Object.create({active: '', content: {routing: 'login'}})
      ]);
      view.activateView();
      expect(view.get('_childViews')[0].get('active')).to.equal('active');
    });
  });

  describe("#deactivateChildViews()", function() {
    it("_childViews should be deactivated", function() {
      view.set('_childViews', [
        Em.Object.create({active: 'active'}),
        Em.Object.create({active: 'active'})
      ]);
      view.deactivateChildViews();
      expect(view.get('_childViews')[0].get('active')).to.be.empty;
      expect(view.get('_childViews')[1].get('active')).to.be.empty;
    });
  });
});

});

require.register("test/views/main/service/info/metrics/ambari_metrics/regionserver_base_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/service/info/metrics/ambari_metrics/regionserver_base');

describe('App.ChartServiceMetricsAMS_RegionServerBaseView', function () {

  var regionServerView;
  var jsonData = {
    "metrics": {
      "hbase": {
        "regionserver": {
          "test": [[11.0, 1424948261], [11.0, 1424948306], [11.0, 1424948321]]
        }
      }
    }
  };

  beforeEach(function () {
    regionServerView = App.ChartServiceMetricsAMS_RegionServerBaseView.extend({
      id: "service-metrics-ambari-metrics-region-server-test",
      title: 'test-title',
      ajaxIndex: 'service.metrics.ambari_metrics.region_server.regions',
      displayName: 'test-display-name',
      regionServerName: 'test'
    }).create();
  });

  describe('#transformToSeries', function () {

    beforeEach(function () {
      this.result = regionServerView.transformToSeries(jsonData);
    });

    it('displayName', function () {
      expect(this.result[0].name).to.be.equal(regionServerView.displayName);
    });

    it('data.length', function () {
      expect(this.result[0].data.length).to.equal(jsonData.metrics.hbase.regionserver.test.length);
    });

    it('y-property', function () {
      expect(this.result[0].data[0]).to.have.property('y').to.equal(11);
    });

    it('x-property', function () {
      expect(this.result[0].data[0]).to.have.property('x').to.equal(1424948261);
    });

  });

});
});

require.register("test/views/main/service/info/metrics/flume/flume_agent_metrics_section_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/service/info/metrics/flume/flume_agent_metrics_section');

describe('App.FlumeAgentMetricsSectionView', function () {

  var view;

  beforeEach(function () {
    view = App.FlumeAgentMetricsSectionView.create();
  });

  describe('#id', function () {
    it('should be set depending on index', function () {
      view.set('index', 1);
      expect(view.get('id')).to.equal('metric1');
    });
  });

  describe('#toggleIndex', function () {
    it('should be set depending on id', function () {
      view.reopen({
        id: 'metric1'
      });
      expect(view.get('toggleIndex')).to.equal('#metric1');
    });
  });

  describe('#header', function () {
    it('should be set depending on metric type and host name', function () {
      view.setProperties({
        metricTypeKey: 'sinkName',
        metricViewData: {
          agent: {
            hostName: 'h0'
          }
        }
      });
      expect(view.get('header')).to.equal(Em.I18n.t('services.service.info.metrics.flume.sinkName').
        format(Em.I18n.t('common.metrics')) + ' - h0');
    });
  });

});

});

require.register("test/views/main/service/info/summary_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/service/info/summary');
var batchUtils = require('utils/batch_scheduled_requests');

describe('App.MainServiceInfoSummaryView', function() {

  var view = App.MainServiceInfoSummaryView.create({
    monitorsLiveTextView: Em.View.create(),
    controller: Em.Object.create({
      content: Em.Object.create({
        id: 'HDFS',
        serviceName: 'HDFS',
        hostComponents: []
      }),
      getActiveWidgetLayout: Em.K,
      loadWidgetLayouts: Em.K
    }),
    alertsController: Em.Object.create(),
    service: Em.Object.create()
  });

  App.TestAliases.testAsComputedAlias(view, 'servicesHaveClients', 'App.services.hasClient', 'boolean');

  App.TestAliases.testAsComputedAlias(view, 'serviceName', 'service.serviceName', 'string');

  App.TestAliases.testAsComputedAlias(view, 'alertsCount', 'controller.content.alertsCount', 'number');

  App.TestAliases.testAsComputedAlias(view, 'hasCriticalAlerts', 'controller.content.hasCriticalAlerts', 'boolean');

  describe('#servers', function () {
    it('services shouldn\'t have servers except FLUME and ZOOKEEPER', function () {
      expect(view.get('servers')).to.be.empty;
    });

    describe('if one server exists then first server should have isComma and isAnd property false', function () {

      beforeEach(function () {
        view.set('controller.content', Em.Object.create({
          id: 'ZOOKEEPER',
          serviceName: 'ZOOKEEPER',
          hostComponents: [
            Em.Object.create({
              displayName: '',
              isMaster: true
            })
          ]
        }));
      });

      it('isComma', function () {
        expect(view.get('servers').objectAt(0).isComma).to.equal(false);});

      it('isAnd', function () {
        expect(view.get('servers').objectAt(0).isAnd).to.equal(false);
      });
    });

    describe('if more than one servers exist then first server should have isComma - true and isAnd - false', function() {

      beforeEach(function () {
        view.set('controller.content', Em.Object.create({
          id: 'ZOOKEEPER',
          serviceName: 'ZOOKEEPER',
          hostComponents: [
            Em.Object.create({
              displayName: '',
              isMaster: true
            }),
            Em.Object.create({
              displayName: '',
              isMaster: true
            })
          ]
        }));
      });

      it('0 isComma', function () {
        expect(view.get('servers').objectAt(0).isComma).to.equal(true);
      });

      it('0 isAnd', function () {
        expect(view.get('servers').objectAt(0).isAnd).to.equal(false);
      });

      it('1 isComma', function () {
        expect(view.get('servers').objectAt(1).isComma).to.equal(false);
      });

      it('1 isAnd', function () {
        expect(view.get('servers').objectAt(1).isAnd).to.equal(false);
      });

    });

    describe('if more than two servers exist then second server should have isComma - false and isAnd - true', function () {

      beforeEach(function () {
        view.set('controller.content', Em.Object.create({
          id: 'ZOOKEEPER',
          serviceName: 'ZOOKEEPER',
          hostComponents: [
            Em.Object.create({
              displayName: '',
              isMaster: true
            }),
            Em.Object.create({
              displayName: '',
              isMaster: true
            }),
            Em.Object.create({
              displayName: '',
              isMaster: true
            })
          ]
        }));
      });

      it('0 isComma', function () {
        expect(view.get('servers').objectAt(0).isComma).to.equal(true);
      });

      it('0 isAnd', function () {
        expect(view.get('servers').objectAt(0).isAnd).to.equal(false);
      });

      it('1 isComma', function () {
        expect(view.get('servers').objectAt(1).isComma).to.equal(false);
      });

      it('1 isAnd', function () {
        expect(view.get('servers').objectAt(1).isAnd).to.equal(true);
      });

      it('2 isComma', function () {
        expect(view.get('servers').objectAt(2).isComma).to.equal(false);
      });

      it('2 isAnd', function () {
        expect(view.get('servers').objectAt(2).isAnd).to.equal(false);
      });

    });

  });

  describe('#hasAlertDefinitions', function () {

    beforeEach(function () {
      sinon.stub(App.AlertDefinition, 'find', function () {
        return [
          {
            serviceName: 'HDFS'
          },
          {
            serviceName: 'YARN'
          }
        ];
      });
    });

    afterEach(function () {
      App.AlertDefinition.find.restore();
    });

    it('should return true if at least one alert definition for this service exists', function () {
      view.set('controller.content', Em.Object.create({
        serviceName: 'HDFS'
      }));
      expect(view.get('hasAlertDefinitions')).to.be.true;
    });

    it('should return false if there is no alert definition for this service', function () {
      view.set('controller.content', Em.Object.create({
        serviceName: 'ZOOKEEPER'
      }));
      expect(view.get('hasAlertDefinitions')).to.be.false;
    });

  });

  describe("#restartAllStaleConfigComponents", function () {

    describe('trigger restartAllServiceHostComponents', function () {

      beforeEach(function () {
        view.set('controller.content', Em.Object.create({
          serviceName: "HDFS"
        }));
        view.set('service', Em.Object.create({
          displayName: 'HDFS'
        }));
        sinon.stub(batchUtils, "restartAllServiceHostComponents", Em.K);
      });

      afterEach(function () {
        batchUtils.restartAllServiceHostComponents.restore();
      });

      it('batch request is started', function () {
        view.restartAllStaleConfigComponents().onPrimary();
        expect(batchUtils.restartAllServiceHostComponents.calledOnce).to.equal(true);
      });

    });

    describe('trigger check last check point warning before triggering restartAllServiceHostComponents', function () {

      var mainServiceItemController;

      beforeEach(function () {
        view.set('controller.content', Em.Object.create({
          serviceName: "HDFS",
          hostComponents: [{
            componentName: 'NAMENODE',
            workStatus: 'STARTED'
          }],
          restartRequiredHostsAndComponents: {
            "host1": ['NameNode'],
            "host2": ['DataNode', 'ZooKeeper']
          }
        }));
        view.set('service', Em.Object.create({
          displayName: 'HDFS'
        }));
        mainServiceItemController = App.MainServiceItemController.create({});
        sinon.stub(mainServiceItemController, 'checkNnLastCheckpointTime', function() {
          return true;
        });
        sinon.stub(App.router, 'get', function(k) {
          if ('mainServiceItemController' === k) {
            return mainServiceItemController;
          }
          return Em.get(App.router, k);
        });
      });

      afterEach(function () {
        mainServiceItemController.checkNnLastCheckpointTime.restore();
        App.router.get.restore();
      });

      it('NN Last CheckPoint is checked', function () {
        view.restartAllStaleConfigComponents();
        expect(mainServiceItemController.checkNnLastCheckpointTime.calledOnce).to.equal(true);
      });

    });

  });

  describe("#setComponentsContent()", function() {

    beforeEach(function() {
      sinon.stub(Em.run, 'next', Em.clb);
      sinon.stub(view, 'updateComponentList');
      view.set('service', Em.Object.create({
        hostComponents: [],
        slaveComponents: [],
        clientComponents: []
      }));
      view.setProperties({
        mastersLength: 0,
        slavesLength: 0,
        clientsLength: 0,
        mastersObj: ['master'],
        slavesObj: ['slave'],
        clientObj: ['client']
      });
    });
    afterEach(function() {
      Em.run.next.restore();
      view.updateComponentList.restore();
    });

    it("service is null", function() {
      view.set('service', null);
      view.setComponentsContent();
      expect(Em.run.next.calledOnce).to.be.true;
      expect(view.updateComponentList.called).to.be.false
    });

    it("update master length", function() {
      view.set('mastersLength', 1);
      view.setComponentsContent();
      expect(Em.run.next.calledOnce).to.be.true;
      expect(view.updateComponentList.calledWith(['master'], [])).to.be.true;
      expect(view.get('mastersLength')).to.be.equal(0);
    });

    it("update slave length", function() {
      view.set('slavesLength', 1);
      view.setComponentsContent();
      expect(Em.run.next.calledOnce).to.be.true;
      expect(view.updateComponentList.calledWith(['slave'], [])).to.be.true;
      expect(view.get('slavesLength')).to.be.equal(0);
    });

    it("update client length", function() {
      view.set('clientsLength', 1);
      view.setComponentsContent();
      expect(Em.run.next.calledOnce).to.be.true;
      expect(view.updateComponentList.calledWith(['client'], [])).to.be.true;
      expect(view.get('clientsLength')).be.equal(0);
    });
  });

  describe("#clientsHostText", function() {

    it("no installed clients", function() {
      view.set('controller.content.installedClients', []);
      view.propertyDidChange('clientsHostText');
      expect(view.get('clientsHostText')).to.be.empty;
    });

    it("has many clients", function() {
      view.set('controller.content.installedClients', [1]);
      view.reopen({
        hasManyClients: true
      });
      view.propertyDidChange('clientsHostText');
      expect(view.get('clientsHostText')).to.be.equal(Em.I18n.t('services.service.summary.viewHosts'));
    });

    it("otherwise", function() {
      view.set('controller.content.installedClients', [1]);
      view.reopen({
        hasManyClients: false
      });
      view.propertyDidChange('clientsHostText');
      expect(view.get('clientsHostText')).to.be.equal(Em.I18n.t('services.service.summary.viewHost'));
    });
  });

  describe("#historyServerUI", function() {

    it("singleNodeInstall is true", function() {
      App.set('singleNodeInstall', true);
      App.set('singleNodeAlias', 'alias');
      view.propertyDidChange('historyServerUI');
      expect(view.get('historyServerUI')).to.equal("http://alias:19888");
    });

    it("singleNodeInstall is false", function () {
      App.set('singleNodeInstall', false);
      view.set('controller.content', Em.Object.create({
        hostComponents: [
          Em.Object.create({
            isMaster: true,
            host: Em.Object.create({
              publicHostName: 'host1'
            })
          })
        ]
      }));
      view.propertyDidChange('historyServerUI');
      expect(view.get('historyServerUI')).to.equal("http://host1:19888");
    });
  });

  describe("#serversHost", function() {

    it("should return empty object", function() {
      view.set('controller.content', Em.Object.create({
        id: 'S1',
        hostComponents: []
      }));
      view.propertyDidChange('serversHost');
      expect(view.get('serversHost')).to.be.empty;
    });

    it("should return server object", function() {
      view.set('controller.content', Em.Object.create({
        id: 'ZOOKEEPER',
        hostComponents: [
          Em.Object.create({
            isMaster: true
          })
        ]
      }));
      view.propertyDidChange('serversHost');
      expect(view.get('serversHost')).to.eql(Em.Object.create({
        isMaster: true
      }));
    });
  });

  describe("#updateComponentList()", function() {

    it("add components to empty source", function() {
      var source = [],
          data = [{id: 1}];
      view.updateComponentList(source, data);
      expect(source.mapProperty('id')).to.eql([1]);
    });

    it("add components to exist source", function() {
      var source = [{id: 1}],
        data = [{id: 1}, {id: 2}];
      view.updateComponentList(source, data);
      expect(source.mapProperty('id')).to.eql([1, 2]);
    });

    it("remove components from exist source", function() {
      var source = [{id: 1}, {id: 2}],
        data = [{id: 1}];
      view.updateComponentList(source, data);
      expect(source.mapProperty('id')).to.eql([1]);
    });
  });

  describe("#componentNameView", function () {
    var componentNameView;

    beforeEach(function () {
      componentNameView = view.get('componentNameView').create();
    });

    describe("#displayName", function () {

      it("component is MYSQL_SERVER", function () {
        componentNameView.set('comp', Em.Object.create({
          componentName: 'MYSQL_SERVER'
        }));
        componentNameView.propertyDidChange('displayName');
        expect(componentNameView.get('displayName')).to.equal(Em.I18n.t('services.hive.databaseComponent'));
      });

      it("any component", function () {
        componentNameView.set('comp', Em.Object.create({
          componentName: 'C1',
          displayName: 'c1'
        }));
        componentNameView.propertyDidChange('displayName');
        expect(componentNameView.get('displayName')).to.equal('c1');
      });
    });
  });


  describe("#getServiceModel()", function() {

    beforeEach(function() {
      sinon.stub(App.Service, 'find').returns({serviceName: 'S1'});
      sinon.stub(App.HDFSService, 'find').returns([{serviceName: 'HDFS'}]);
    });
    afterEach(function() {
      App.Service.find.restore();
      App.HDFSService.find.restore();
    });

    it("HDFS service", function() {
      expect(view.getServiceModel('HDFS')).to.eql({serviceName: 'HDFS'});
    });

    it("Simple model service", function() {
      expect(view.getServiceModel('S1')).to.eql({serviceName: 'S1'});
    });
  });

  describe("#updateComponentInformation()", function () {
    it("should count hosts and components", function () {
      view.set('controller.content.restartRequiredHostsAndComponents', {
        'host1': ['c1', 'c2']
      });
      view.updateComponentInformation();
      expect(view.get('componentsCount')).to.equal(2);
      expect(view.get('hostsCount')).to.equal(1);
    });
  });

  describe("#rollingRestartSlaveComponentName ", function() {

    beforeEach(function() {
      sinon.stub(batchUtils, 'getRollingRestartComponentName').returns('C1');
    });
    afterEach(function() {
      batchUtils.getRollingRestartComponentName.restore();
    });

    it("should returns component name", function() {
      view.set('serviceName', 'S1');
      view.propertyDidChange('rollingRestartSlaveComponentName');
      expect(view.get('rollingRestartSlaveComponentName')).to.equal('C1');
    });
  });

  describe("#rollingRestartActionName ", function() {

    beforeEach(function() {
      sinon.stub(App.format, 'role').returns('C1');
    });
    afterEach(function() {
      App.format.role.restore();
    });

    it("rollingRestartSlaveComponentName is set", function() {
      view.reopen({
        rollingRestartSlaveComponentName: 'C1'
      });
      view.propertyDidChange('rollingRestartActionName');
      expect(view.get('rollingRestartActionName')).to.equal(Em.I18n.t('rollingrestart.dialog.title').format('C1'));
    });

    it("rollingRestartSlaveComponentName is null", function() {
      view.reopen({
        rollingRestartSlaveComponentName: null
      });
      view.propertyDidChange('rollingRestartActionName');
      expect(view.get('rollingRestartActionName')).to.be.null;
    });
  });

  describe("#rollingRestartStaleConfigSlaveComponents() ", function() {

    beforeEach(function() {
      sinon.stub(batchUtils, 'launchHostComponentRollingRestart');
    });
    afterEach(function() {
      batchUtils.launchHostComponentRollingRestart.restore();
    });

    it("launchHostComponentRollingRestart should be called", function() {
      view.get('service').setProperties({
        displayName: 's1',
        passiveState: 'ON'
      });
      view.rollingRestartStaleConfigSlaveComponents({context: 'C1'});
      expect(batchUtils.launchHostComponentRollingRestart.calledWith(
        'C1', 's1', true, true
      )).to.be.true;
    });
  });

  describe("#constructGraphObjects()", function() {
    var mock = Em.Object.create({
      isServiceWithWidgets: false
    });

    beforeEach(function() {
      sinon.stub(App.StackService, 'find').returns(mock);
      sinon.stub(view, 'getUserPref').returns({
        complete: function(callback){callback();}
      })
    });
    afterEach(function() {
      App.StackService.find.restore();
      view.getUserPref.restore();
    });

    it("metrics not loaded", function() {
      mock.set('isServiceWithWidgets', false);
      view.constructGraphObjects(null);
      expect(view.get('isServiceMetricLoaded')).to.be.false;
      expect(view.getUserPref.called).to.be.false;
    });

    it("metrics loaded", function() {
      App.ChartServiceMetricsG1 = Em.Object.extend();
      mock.set('isServiceWithWidgets', true);
      view.constructGraphObjects(['G1']);
      expect(view.get('isServiceMetricLoaded')).to.be.true;
      expect(view.getUserPref.calledOnce).to.be.true;
      expect(view.get('serviceMetricGraphs')).to.not.be.empty;
    });
  });

  describe("#getUserPrefSuccessCallback()", function() {

    it("currentTimeRangeIndex should be set", function() {
      view.getUserPrefSuccessCallback(1);
      expect(view.get('currentTimeRangeIndex')).to.equal(1);
    });
  });

  describe("#getUserPrefErrorCallback()", function() {

    beforeEach(function() {
      sinon.stub(view, 'postUserPref');
    });
    afterEach(function() {
      view.postUserPref.restore();
    });

    it("request.status = 404", function() {
      view.getUserPrefErrorCallback({status: 404});
      expect(view.get('currentTimeRangeIndex')).to.equal(0);
      expect(view.postUserPref.calledOnce).to.be.true;
    });

    it("request.status = 403", function() {
      view.getUserPrefErrorCallback({status: 403});
      expect(view.postUserPref.called).to.be.false;
    });
  });

  describe("#widgetActions", function() {

    beforeEach(function() {
      this.mock = sinon.stub(App, 'isAuthorized');
      view.setProperties({
        staticWidgetLayoutActions: [{id: 1}],
        staticAdminPrivelegeWidgetActions: [{id: 2}],
        staticGeneralWidgetActions: [{id: 3}]
      });
    });
    afterEach(function() {
      this.mock.restore();
    });

    it("not authorized", function() {
      this.mock.returns(false);
      view.propertyDidChange('widgetActions');
      expect(view.get('widgetActions').mapProperty('id')).to.eql([3]);
    });

    it("is authorized", function() {
      this.mock.returns(true);
      App.supports.customizedWidgetLayout = true;
      view.propertyDidChange('widgetActions');
      expect(view.get('widgetActions').mapProperty('id')).to.eql([1, 2, 3]);
    });
  });

  describe("#doWidgetAction()", function() {

    beforeEach(function() {
      view.set('controller.action1', Em.K);
      sinon.stub(view.get('controller'), 'action1');
    });
    afterEach(function() {
      view.get('controller').action1.restore();
    });

    it("action exist", function() {
      view.doWidgetAction({context: 'action1'});
      expect(view.get('controller').action1.calledOnce).to.be.true;
    });
  });

  describe("#setTimeRange", function() {

    it("range = 0", function() {
      var widget = Em.Object.create({
        widgetType: 'GRAPH',
        properties: {
          time_range: '0'
        }
      });
      view.set('controller.widgets', [widget]);
      view.setTimeRange({context: {value: '0'}});
      expect(widget.get('properties').time_range).to.be.equal('0')
    });

    it("range = 1", function() {
      var widget = Em.Object.create({
        widgetType: 'GRAPH',
        properties: {
          time_range: 0
        }
      });
      view.set('controller.widgets', [widget]);
      view.setTimeRange({context: {value: '1'}});
      expect(widget.get('properties').time_range).to.be.equal('1')
    });
  });

  describe("#makeSortable()", function() {
    var mock = {
      on: function(arg1, arg2, callback) {
        callback();
      },
      off: Em.K,
      sortable: function() {
        return {
          disableSelection: Em.K
        }
      }
    };

    beforeEach(function() {
      sinon.stub(window, '$').returns(mock);
      sinon.spy(mock, 'on');
      sinon.spy(mock, 'off');
      sinon.spy(mock, 'sortable');
      view.makeSortable();
    });
    afterEach(function() {
      window.$.restore();
      mock.on.restore();
      mock.off.restore();
      mock.sortable.restore();
    });

    it("on() should be called", function() {
      expect(mock.on.calledWith('DOMNodeInserted', '#widget_layout')).to.be.true;
    });

    it("sortable() should be called", function() {
      expect(mock.sortable.calledOnce).to.be.true;
    });

    it("off() should be called", function() {
      expect(mock.off.calledWith('DOMNodeInserted', '#widget_layout')).to.be.true;
    });
  });

  describe('#didInsertElement', function () {

    beforeEach(function () {
      sinon.stub(view, 'constructGraphObjects', Em.K);
      this.mock = sinon.stub(App, 'get');
      sinon.stub(view, 'getServiceModel');
      sinon.stub(view.get('controller'), 'getActiveWidgetLayout');
      sinon.stub(view.get('controller'), 'loadWidgetLayouts');
      sinon.stub(view, 'adjustSummaryHeight');
      sinon.stub(view, 'makeSortable');
      sinon.stub(view, 'addWidgetTooltip');

    });

    afterEach(function () {
      view.constructGraphObjects.restore();
      this.mock.restore();
      view.getServiceModel.restore();
      view.get('controller').getActiveWidgetLayout.restore();
      view.get('controller').loadWidgetLayouts.restore();
      view.adjustSummaryHeight.restore();
      view.makeSortable.restore();
      view.addWidgetTooltip.restore();
    });

    it("getServiceModel should be called", function() {
      view.didInsertElement();
      expect(view.getServiceModel.calledOnce).to.be.true;
    });
    it("adjustSummaryHeight should be called", function() {
      view.didInsertElement();
      expect(view.adjustSummaryHeight.calledOnce).to.be.true;
    });
    it("addWidgetTooltip should be called", function() {
      view.didInsertElement();
      expect(view.addWidgetTooltip.calledOnce).to.be.true;
    });
    it("makeSortable should be called", function() {
      view.didInsertElement();
      expect(view.makeSortable.calledOnce).to.be.true;
    });
    it("getActiveWidgetLayout should be called", function() {
      view.didInsertElement();
      expect(view.get('controller').getActiveWidgetLayout.calledOnce).to.be.true;
    });

    describe("serviceName is null, metrics not supported, widgets not supported", function() {
      beforeEach(function () {
        view.set('controller.content.serviceName', null);
        this.mock.returns(false);
        view.didInsertElement();
      });

      it("loadWidgetLayouts should not be called", function() {
        expect(view.get('controller').loadWidgetLayouts.called).to.be.false;
      });
      it("constructGraphObjects should not be called", function() {
        expect(view.constructGraphObjects.called).to.be.false;
      });
    });

    describe("serviceName is set, metrics is supported, widgets is supported", function() {
      beforeEach(function () {
        view.set('controller.content.serviceName', 'S1');
        this.mock.returns(true);
        view.didInsertElement();
      });

      it("loadWidgetLayouts should be called", function() {
        expect(view.get('controller').loadWidgetLayouts.calledOnce).to.be.true;
      });
      it("constructGraphObjects should be called", function() {
        expect(view.constructGraphObjects.calledOnce).to.be.true;
      });
    });
  });

  describe("#addWidgetTooltip()", function() {
    var mock = {
      hoverIntent: Em.K
    };

    beforeEach(function() {
      sinon.stub(Em.run, 'later', function(arg1, callback) {
        callback();
      });
      sinon.stub(App, 'tooltip');
      sinon.stub(window, '$').returns(mock);
      sinon.spy(mock, 'hoverIntent');
      view.addWidgetTooltip();
    });
    afterEach(function() {
      Em.run.later.restore();
      App.tooltip.restore();
      window.$.restore();
      mock.hoverIntent.restore();
    });

    it("Em.run.later should be called", function() {
      expect(Em.run.later.calledOnce).to.be.true;
    });
    it("App.tooltip should be called", function() {
      expect(App.tooltip.calledOnce).to.be.true;
    });
    it("hoverIntent should be called", function() {
      expect(mock.hoverIntent.calledOnce).to.be.true;
    });
  });

  describe("#adjustSummaryHeight()", function() {
    var jQueryMock = {
      find: Em.K,
      attr: Em.K
    };

    beforeEach(function() {
      sinon.stub(window, '$').returns(jQueryMock);
      this.mockFind = sinon.stub(jQueryMock, 'find');
      sinon.spy(jQueryMock, 'attr');
      this.mockGetElementById = sinon.stub(document, 'getElementById');
    });
    afterEach(function() {
      this.mockGetElementById.restore();
      window.$.restore();
      this.mockFind.restore();
      jQueryMock.attr.restore();
    });

    it("summary-info not in DOM", function() {
      this.mockGetElementById.returns(null);
      view.adjustSummaryHeight();
      expect(jQueryMock.find.called).to.be.false;
    });

    it("summary-info has no rows", function() {
      this.mockGetElementById.returns({});
      this.mockFind.returns(null);
      view.adjustSummaryHeight();
      expect(jQueryMock.find.calledOnce).to.be.true;
      expect(jQueryMock.attr.called).to.be.false;
    });

    it("summary-info has rows", function() {
      this.mockGetElementById.returns({
        clientHeight: 10
      });
      this.mockFind.returns([{}]);
      view.adjustSummaryHeight();
      expect(jQueryMock.attr.calledWith('style', "height:20px;")).to.be.true;
    });
  });
});
});

require.register("test/views/main/service/item_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/service/item');

var view;

function getView() {
  return App.MainServiceItemView.create({
    controller: Em.Object.create({
      content: Em.Object.create({
        hostComponents: []
      })
    })
  });
}

describe('App.MainServiceItemView', function () {

  App.TestAliases.testAsComputedAlias(getView(), 'serviceName', 'controller.content.serviceName', 'string');

  App.TestAliases.testAsComputedAlias(getView(), 'displayName', 'controller.content.displayName', 'string');

  describe('#mastersExcludedCommands', function () {

    view = App.MainServiceItemView.create({
      controller: Em.Object.create({
        content: Em.Object.create({
          hostComponents: []
        })
      })
    });

    var nonCustomAction = ['RESTART_ALL', 'RUN_SMOKE_TEST', 'REFRESH_CONFIGS', 'ROLLING_RESTART', 'TOGGLE_PASSIVE', 'TOGGLE_NN_HA', 'TOGGLE_RM_HA', 'MOVE_COMPONENT', 'DOWNLOAD_CLIENT_CONFIGS', 'MASTER_CUSTOM_COMMAND'];
    var keys = Object.keys(view.mastersExcludedCommands);
    var mastersExcludedCommands = [];
    for (var i = 0; i < keys.length; i++) {
      mastersExcludedCommands[i] = view.mastersExcludedCommands[keys[i]];
    }
    var allMastersExcludedCommands = mastersExcludedCommands.reduce(function (previous, current) {
      return previous.concat(current);
    });
    var actionMap = App.HostComponentActionMap.getMap(view);

    var customActionsArray = [];
    Object.keys(actionMap).forEach(function (iter) {
      customActionsArray.push(actionMap[iter]);
    });
    var customActions = customActionsArray.mapProperty('customCommand').filter(function (action) {
      return !nonCustomAction.contains(action);
    }).uniq();

    // remove null and undefined from the list
    customActions = customActions.filter(function (value) {
      return !Em.isNone(value);
    });

    customActions.forEach(function (action) {
      it(action + ' should be present in App.MainServiceItemView mastersExcludedCommands object', function () {
        expect(allMastersExcludedCommands).to.contain(action);
      });
    });
  });

  describe('#observeMaintenance', function () {

    var cases = [
      {
        isMaintenanceSet: true,
        isServicesInfoLoaded: true,
        isServiceConfigsLoaded: true,
        observeMaintenanceOnceCallCount: 0,
        title: 'actions array set, services info loaded'
      },
      {
        isMaintenanceSet: true,
        isServicesInfoLoaded: false,
        isServiceConfigsLoaded: true,
        observeMaintenanceOnceCallCount: 0,
        title: 'actions array set, services info not loaded'
      },
      {
        isMaintenanceSet: false,
        isServicesInfoLoaded: true,
        isServiceConfigsLoaded: true,
        observeMaintenanceOnceCallCount: 1,
        title: 'actions array not set, services info loaded'
      },
      {
        isMaintenanceSet: false,
        isServicesInfoLoaded: false,
        isServiceConfigsLoaded: true,
        observeMaintenanceOnceCallCount: 0,
        title: 'actions array not set, services info not loaded'
      }
    ];

    beforeEach(function () {
      sinon.stub(view, 'observeMaintenanceOnce', Em.K);
    });

    afterEach(function () {
      view.observeMaintenanceOnce.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.setProperties({
          'isMaintenanceSet': item.isMaintenanceSet,
          'controller.isServicesInfoLoaded': item.isServicesInfoLoaded,
          'controller.isServiceConfigsLoaded': item.isServiceConfigsLoaded
        });
        view.observeMaintenance();
        expect(view.observeMaintenanceOnce.callCount).to.equal(item.observeMaintenanceOnceCallCount);
      });
    });

  });

  describe('#observeMaintenanceOnce', function () {

    var mastersExcludedCommands = {
        NAMENODE: ["DECOMMISSION", "REBALANCEHDFS"],
        RESOURCEMANAGER: ["DECOMMISSION", "REFRESHQUEUES"],
        HBASE_MASTER: ["DECOMMISSION"],
        KNOX_GATEWAY: ["STARTDEMOLDAP", "STOPDEMOLDAP"]
      },
      hasConfigTab = true,
      testCases = [
        {
          serviceName: "HDFS",
          displayName: "HDFS",
          isSingleNode: true,
          serviceTypes: ["HA_MODE"],
          slaveComponents: [
            Em.Object.create({
              componentName: 'DATANODE',
              totalCount: 1
            })
          ],
          clientComponents: [
            Em.Object.create({
              componentName: 'HDFS_CLIENT',
              totalCount: 1
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'NAMENODE',
              isNotInstalled: true,
              isMaster: true,
              isSlave: false
            }),
            Em.Object.create({
              componentName: 'SECONDARY_NAMENODE',
              isMaster: true,
              isSlave: false
            })
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "HDFS", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "rollingRestart", "label": "Restart DataNodes", "cssClass": "icon-time", "disabled": false, "context": "DATANODE"},
            {"action": "reassignMaster", "context": "NAMENODE", "label": "Move NameNode", "cssClass": "icon-share-alt", "disabled": false},
            {"action": "reassignMaster", "context": "SECONDARY_NAMENODE", "label": "Move SNameNode", "cssClass": "icon-share-alt", "disabled": false},
            {"action": "enableHighAvailability", "label": "Enable NameNode HA", "cssClass": "icon-arrow-up", "isHidden": false, "disabled": true},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for HDFS", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"action": "rebalanceHdfsNodes", "customCommand": "REBALANCEHDFS", "context": "Rebalance HDFS", "label": "Rebalance HDFS", "cssClass": "icon-refresh", "disabled": false},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": false, "disabled": false, hasSubmenu: false, submenuOptions: []}
          ]
        },
        {
          serviceName: "ZOOKEEPER",
          displayName: "ZooKeeper",
          serviceTypes: [],
          slaveComponents: [],
          clientComponents: [
            Em.Object.create({
              componentName: 'ZOOKEEPER_CLIENT',
              totalCount: 1
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'ZOOKEEPER_SERVER',
              isMaster: true,
              isSlave: false
            })
          ],
          controller: [
            {'addDisabledTooltipZOOKEEPER_SERVER': ''},
            {'isAddDisabled-ZOOKEEPER_SERVER': 'disabled'}
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "ZOOKEEPER", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for ZooKeeper", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"cssClass": "icon-plus", "label": "Add ZooKeeper Server", "service": "ZOOKEEPER", "component": "ZOOKEEPER_SERVER", "action": "addComponent", "disabled": "", tooltip: ''},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": false, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "YARN",
          displayName: "YARN",
          serviceTypes: ['HA_MODE'],
          slaveComponents: [
            Em.Object.create({
              componentName: 'NODEMANAGER',
              totalCount: 1
            })
          ],
          clientComponents: [
            Em.Object.create({
              componentName: 'YARN_CLIENT',
              totalCount: 1
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'APP_TIMELINE_SERVER',
              isMaster: true,
              isSlave: false
            }),
            Em.Object.create({
              componentName: 'RESOURCEMANAGER',
              isMaster: true,
              isSlave: false,
              isNotInstalled: false
            })
          ],
          result: [
            {"action": "refreshYarnQueues", "customCommand": "REFRESHQUEUES", "context": "Refresh YARN Capacity Scheduler", "label": "Refresh YARN Capacity Scheduler", "cssClass": "icon-refresh", "disabled": false},
            {"action": "restartAllHostComponents", "context": "YARN", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "rollingRestart", "label": "Restart NodeManagers", "cssClass": "icon-time", "disabled": false, "context": "NODEMANAGER"},
            {"action": "reassignMaster", "context": "APP_TIMELINE_SERVER", "label": "Move App Timeline Server", "cssClass": "icon-share-alt", "disabled": false},
            {"action": "reassignMaster", "context": "RESOURCEMANAGER", "label": "Move ResourceManager", "cssClass": "icon-share-alt", "disabled": false},
            {"action": "enableRMHighAvailability", "label": "Enable ResourceManager HA", "cssClass": "icon-arrow-up", "isHidden": false, disabled: false},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for YARN", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": false, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "MAPREDUCE2",
          displayName: "MapReduce2",
          serviceTypes: [],
          slaveComponents: [],
          clientComponents: [
            Em.Object.create({
              componentName: 'MAPREDUCE2_CLIENT',
              totalCount: 1
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'HISTORYSERVER',
              isMaster: true,
              isSlave: false
            })
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "MAPREDUCE2", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for MapReduce2", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": false, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "KAFKA",
          displayName: "Kafka",
          serviceTypes: [],
          slaveComponents: [],
          clientComponents: [],
          hostComponents: [
            Em.Object.create({
              componentName: 'KAFKA_BROKER',
              isMaster: true,
              isSlave: false
            })
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "KAFKA", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for Kafka", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": true, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "FLUME",
          displayName: "Flume",
          serviceTypes: [],
          clientComponents: [],
          slaveComponents: [
            Em.Object.create({
              componentName: 'FLUME_HANDLER',
              totalCount: 1
            })
          ],
          hostComponents: [
          ],
          controller: [
            {'addDisabledTooltipFLUME_HANDLER': ''},
            {'isAddDisabled-FLUME_HANDLER': ''}
          ],
          result: [
            {"action": "refreshConfigs", "label": "Refresh configs", "cssClass": "icon-refresh", "disabled": false},
            {"action": "restartAllHostComponents", "context": "FLUME", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "rollingRestart", "label": "Restart Flumes", "cssClass": "icon-time", "disabled": false, "context": "FLUME_HANDLER"},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for Flume", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"cssClass": "icon-plus", "label": "Add Flume Component", "service": "FLUME", "component": "FLUME_HANDLER", "action": "addComponent", "disabled": '', tooltip: ''},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": true, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "HBASE",
          displayName: "HBase",
          serviceTypes: [],
          slaveComponents: [
            Em.Object.create({
              componentName: 'HBASE_REGIONSERVER',
              totalCount: 1
            })
          ],
          clientComponents: [
            Em.Object.create({
              componentName: 'HBASE_CLIENT',
              totalCount: 1
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'HBASE_MASTER',
              isMaster: true,
              isSlave: false
            })
          ],
          controller: [
            {'addDisabledTooltipHBASE_MASTER': ''},
            {'isAddDisabled-HBASE_MASTER': ''}
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "HBASE", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "rollingRestart", "label": "Restart RegionServers", "cssClass": "icon-time", "disabled": false, "context": "HBASE_REGIONSERVER"},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for HBase", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"cssClass": "icon-plus", "label": "Add HBase Master", "service": "HBASE", "component": "HBASE_MASTER", "action": "addComponent", "disabled": '', tooltip: ''},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": false, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "OOZIE",
          displayName: "Oozie",
          serviceTypes: [],
          slaveComponents: [],
          clientComponents: [
            Em.Object.create({
              componentName: 'OOZIE_CLIENT',
              totalCount: 1
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'OOZIE_SERVER',
              isMaster: true,
              isSlave: false
            })
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "OOZIE", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "reassignMaster", "context": "OOZIE_SERVER", "label": "Move Oozie Server", "cssClass": "icon-share-alt", "disabled": false},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for Oozie", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"cssClass": "icon-plus", "label": "Add Oozie Server", "service": "OOZIE", "component": "OOZIE_SERVER", "action": "addComponent", "disabled": "disabled", tooltip: Em.I18n.t('services.summary.allHostsAlreadyRunComponent').format('OOZIE_SERVER')},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": false, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "KNOX",
          displayName: "Knox",
          serviceTypes: [],
          slaveComponents: [],
          clientComponents: [],
          hostComponents: [
            Em.Object.create({
              componentName: 'KNOX_GATEWAY',
              isMaster: true,
              isSlave: false
            })
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "KNOX", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for Knox", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"action": "startLdapKnox", "customCommand": "STARTDEMOLDAP", "context": "Start Demo LDAP", "label": "Start Demo LDAP", "cssClass": "icon-play-sign", "disabled": false},
            {"action": "stopLdapKnox", "customCommand": "STOPDEMOLDAP", "context": "Stop Demo LDAP", "label": "Stop Demo LDAP", "cssClass": "icon-stop", "disabled": false},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": true, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "STORM",
          displayName: "Storm",
          serviceTypes: [],
          slaveComponents: [],
          clientComponents: [],
          hostComponents: [
            Em.Object.create({
              componentName: 'NIMBUS',
              isMaster: true,
              isSlave: false
            })
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "STORM", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for Storm", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": true, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        }
      ];

    beforeEach(function () {

      view = App.MainServiceItemView.create({});

      sinon.stub(App, 'get', function (k) {
        switch (k) {
          case 'isSingleNode':
            return view.get('controller.content.serviceName') === 'HDFS';
          case 'supports.autoRollbackHA':
          case 'isRMHaEnabled':
          case 'isHaEnabled':
            return false;
          case 'components.rollinRestartAllowed':
            return ["DATANODE", "JOURNALNODE", "ZKFC", "NODEMANAGER", "GANGLIA_MONITOR", "HBASE_REGIONSERVER", "SUPERVISOR", "FLUME_HANDLER"];
          case 'components.reassignable':
            return ["NAMENODE", "SECONDARY_NAMENODE", "APP_TIMELINE_SERVER", "RESOURCEMANAGER", "WEBHCAT_SERVER", "OOZIE_SERVER"];
          case 'services.supportsServiceCheck':
            return ["HDFS", "MAPREDUCE2", "YARN", "HIVE", "HBASE", "PIG", "SQOOP", "OOZIE", "ZOOKEEPER", "FALCON", "STORM", "FLUME", "SLIDER", "KNOX", "KAFKA"];
          case 'components.addableToHost':
            return ["DATANODE", "HDFS_CLIENT", "MAPREDUCE2_CLIENT", "NODEMANAGER", "YARN_CLIENT", "TEZ_CLIENT", "GANGLIA_MONITOR", "HCAT", "HIVE_CLIENT", "HIVE_METASTORE", "HIVE_SERVER", "WEBHCAT_SERVER", "HBASE_CLIENT", "HBASE_MASTER", "HBASE_REGIONSERVER", "PIG", "SQOOP", "OOZIE_CLIENT", "OOZIE_SERVER", "ZOOKEEPER_CLIENT", "ZOOKEEPER_SERVER", "FALCON_CLIENT", "SUPERVISOR", "FLUME_HANDLER", "METRICS_MONITOR", "KAFKA_BROKER", "KERBEROS_CLIENT", "KNOX_GATEWAY", "SLIDER", "SPARK_CLIENT"];
          case 'allHostNames.length':
            return 2;
          default:
            return Em.get(App, k);
        }
      });

      sinon.stub(App.HostComponent, 'find', function () {
        return [
          Em.Object.create({
            hostName: 'host1',
            componentName: 'NAMENODE'
          }),
          Em.Object.create({
            hostName: 'host1',
            componentName: 'SECONDARY_NAMENODE'
          }),
          Em.Object.create({
            hostName: 'host1',
            componentName: 'APP_TIMELINE_SERVER'
          }),
          Em.Object.create({
            hostName: 'host1',
            componentName: 'RESOURCEMANAGER'
          }),
          Em.Object.create({
            hostName: 'host1',
            componentName: 'OOZIE_SERVER'
          })
        ];
      });

      /*eslint-disable complexity */
      sinon.stub(App.StackServiceComponent, 'find', function (id) {
        switch (id) {
          case 'NAMENODE':
            return Em.Object.create({ customCommands: ["DECOMMISSION", "REBALANCEHDFS"] });
          case 'RESOURCEMANAGER':
            return Em.Object.create({ customCommands: ["DECOMMISSION", "REFRESHQUEUES"] });
          case 'HBASE_MASTER':
            return Em.Object.create({ customCommands: ["DECOMMISSION"] });
          case 'KNOX_GATEWAY':
            return Em.Object.create({ customCommands: ["STARTDEMOLDAP", "STOPDEMOLDAP"] });
          case 'HIVE_SERVER_INTERACTIVE':
            return Em.Object.create({ customCommands: ["RESTART_LLAP"] });
          case 'HISTORYSERVER':
          case 'SECONDARY_NAMENODE':
          case 'ZOOKEEPER_SERVER':
          case 'APP_TIMELINE_SERVER':
          case 'KAFKA_BROKER':
          case 'OOZIE_SERVER':
          case 'NIMBUS':
            return Em.Object.create({ customCommands: [] });
          default:
            return [
              Em.Object.create({
                customCommands: ["DECOMMISSION", "REBALANCEHDFS"],
                componentName: 'NAMENODE'
              }),
              Em.Object.create({
                customCommands: ["STARTDEMOLDAP", "STOPDEMOLDAP"],
                componentName: 'KNOX_GATEWAY'
              })
            ];
        }
      });
      /*eslint-enable complexity */
    });

    afterEach(function () {
      App.get.restore();
      App.HostComponent.find.restore();
      App.StackServiceComponent.find.restore();
    });

    testCases.forEach(function (testCase) {

      describe('Maintenance for ' + testCase.serviceName + ' service', function () {

        beforeEach(function () {
          view.reopen({
            controller: Em.Object.create({
              content: Em.Object.create({
                hostComponents: testCase.hostComponents,
                slaveComponents: testCase.slaveComponents,
                clientComponents: testCase.clientComponents,
                serviceName: testCase.serviceName,
                displayName: testCase.displayName,
                serviceTypes: testCase.serviceTypes,
                passiveState: 'OFF'
              }),
              isSeveralClients: false,
              clientComponents: [],
              isStopDisabled: false,
              isSmokeTestDisabled: false
            }),
            mastersExcludedCommands: mastersExcludedCommands,
            hasConfigTab: hasConfigTab
          });
          if (testCase.controller) {
            testCase.controller.forEach(function (item) {
              Object.keys(item).forEach(function (key) {
                view.set('controller.' + key, item[key]);
              });
            });
          }
          view.observeMaintenanceOnce();
        });
        testCase.result.forEach(function (option, index) {
          Object.keys(option).forEach(function (key) {
            it(option.action + ', key - ' + key, function () {
              var r = view.get('maintenance')[index];
              expect(Em.get(option, key)).to.eql(Em.get(r, key));
            });
          });
        });

        it('maintenance is updated', function () {
          var oldMaintenance = JSON.parse(JSON.stringify(view.get('maintenance')));
          view.set('controller.content.passiveState', 'ON');
          view.observeMaintenanceOnce();
          expect(view.get('maintenance')).to.not.eql(oldMaintenance);
          expect(view.get('isMaintenanceSet')).to.be.true;
        });
      });

    });
  });

  describe('#clearIsMaintenanceSet', function () {
    it('isMaintenanceSet should be false', function () {
      view.set('isMaintenanceSet', true);
      view.clearIsMaintenanceSet();
      expect(view.get('isMaintenanceSet')).to.be.false;
    });
  });

});


});

require.register("test/views/main/service/menu_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/service/menu');

describe('App.MainServiceMenuView', function () {

  var mainServiceMenuView;

  beforeEach(function(){
    mainServiceMenuView = App.MainServiceMenuView.create();
    var view = mainServiceMenuView.get('itemViewClass').create({
      content:{
        alertsCount: 2
      }
    });
    mainServiceMenuView.set('itemViewClass',view);
  });

  var cases = [
    {
      title:'alertsCount=0 test case:',
      alertsCount:0,
      result:0
    },
    {
      title:'alertsCount=5 test case:',
      alertsCount:5,
      result:5
    },
    {
      title:'alertsCount=200 test case:',
      alertsCount:200,
      result:"99+"
    },
    {
      title:'alertsCount=99 test case:',
      alertsCount:99,
      result:99
    }
  ];


  cases.forEach(function(item){
    it(item.title,function(){
      mainServiceMenuView.get('itemViewClass').set('content.alertsCount',item.alertsCount);
      expect(mainServiceMenuView.get('itemViewClass.alertsCount')).to.not.be.undefined;
      expect(mainServiceMenuView.get('itemViewClass.alertsCount')).to.equal(item.result);
    });
  });
});

});

require.register("test/views/main/service/services/flume_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('/views/main/service/services/flume');

describe('App.MainDashboardServiceFlumeView', function () {
  var view;

  beforeEach(function() {
    view = App.MainDashboardServiceFlumeView.create({
      service: Em.Object.create({
        agents: []
      })
    });
  });

  describe("#content", function() {

    it("should return content", function() {
      view.set('service.agents', [
        {hostName: 'host1'},
        {hostName: 'host2'},
        {hostName: 'host2'}
      ]);
      view.propertyDidChange('content');
      expect(view.get('content').mapProperty('hostName')).to.be.eql(['host1', 'host2']);
      expect(view.get('content').mapProperty('rowspan')).to.be.eql([1, 2]);
      expect(view.get('content').mapProperty('firtstAgent')).to.be.eql([{hostName: 'host1'}, {hostName: 'host2'}]);
    });
  });

  describe("#summaryHeader", function() {

    beforeEach(function() {
      this.mock = sinon.stub(App.FlumeService, 'find');
    });
    afterEach(function() {
      this.mock.restore();
    });

    it("single host", function() {
      this.mock.returns([
        Em.Object.create({
          agents: [{}]
        })
      ]);
      view.set('service.flumeHandlersTotal', 1);
      view.propertyDidChange('summaryHeader');
      expect(view.get('summaryHeader')).to.be.equal(view.t("dashboard.services.flume.summary.title").format(1, "", 1, ""));
    });

    it("multiple hosts", function() {
      this.mock.returns([
        Em.Object.create({
          agents: [{}, {}]
        })
      ]);
      view.set('service.flumeHandlersTotal', 2);
      view.propertyDidChange('summaryHeader');
      expect(view.get('summaryHeader')).to.be.equal(view.t("dashboard.services.flume.summary.title").format(2, "s", 2, "s"));
    });
  });

  describe("#didInsertElement()", function() {
    var mock = {
      on: function(a1, a2, callback) {
        callback();
      }
    };

    beforeEach(function() {
      sinon.stub(view, 'filter');
      sinon.stub(view, 'setDropdownPosition');
      sinon.stub(mock, 'on');
      sinon.stub(view, '$').returns(mock);
      view.didInsertElement();
    });
    afterEach(function() {
      view.filter.restore();
      view.setDropdownPosition();
      mock.on.restore();
      view.$.restore();
    });

    it("filter should be called", function() {
      expect(view.filter.calledOnce).to.be.true;
    });

    it("setDropdownPosition should be called", function() {
      expect(view.filter.calledOnce).to.be.true;
    });
  });

  describe("#willDestroyElement()", function() {
    var mock = {
      off: Em.K
    };

    beforeEach(function() {
      sinon.stub(mock, 'off');
      sinon.stub(view, '$').returns(mock);
      view.willDestroyElement();
    });
    afterEach(function() {
      mock.off.restore();
      view.$.restore();
    });

    it("off should be called", function() {
      expect(mock.off.calledOnce).to.be.true;
    });
  });

  describe("#setActionsDropdownClasses()", function() {

    it("should disable dropdown", function() {
      view.reopen({
        content: [
          Em.Object.create({
            agents: [
              Em.Object.create({status: 'RUNNING'}),
              Em.Object.create({status: 'NOT_RUNNING'})
            ]
          })
        ]
      });
      view.setActionsDropdownClasses();
      var agents = view.get('content.0.agents');
      expect(agents[0].get('isStartAgentDisabled')).to.be.true;
      expect(agents[0].get('isStopAgentDisabled')).to.be.false;
      expect(agents[1].get('isStartAgentDisabled')).to.be.false;
      expect(agents[1].get('isStopAgentDisabled')).to.be.true;
    });
  });

  describe("#updateFlumeAgentsCount()", function() {

    it("should update flumeAgentsCount", function() {
      view.set('service', Em.Object.create({
        agents: [{}]
      }));
      view.updateFlumeAgentsCount();
      expect(view.get('flumeAgentsCount')).to.be.equal(1);
    });
  });

  describe("#showAgentInfo()", function() {

    beforeEach(function() {
      sinon.stub(view, 'setAgentMetrics');
    });
    afterEach(function() {
      view.setAgentMetrics.restore();
    });

    it("setAgentMetrics should be called", function() {
      var host = {hostName: 'host1'};
      view.showAgentInfo(host);
      expect(view.setAgentMetrics.calledWith(host)).to.be.true;
      expect(view.get('selectedHost')).to.be.eql(host);
    });
  });
});
});

require.register("test/views/main/service/services/hbase_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('/views/main/service/services/hbase');

var view;

function getView() {
  return App.MainDashboardServiceHbaseView.create();
}

describe('App.MainDashboardServiceHbaseView', function () {

  beforeEach(function () {
    view = getView();
  });

  App.TestAliases.testAsComputedFilterBy(getView(), 'masters', 'service.hostComponents', 'isMaster', true);

  App.TestAliases.testAsComputedFilterBy(getView(), 'passiveMasters', 'masters', 'haStatus', 'false');

  App.TestAliases.testAsComputedFindBy(getView(), 'activeMaster', 'masters', 'haStatus', 'true');

  App.TestAliases.testAsComputedCountBasedMessage(getView(), 'regionServesText', 'service.regionServersTotal', '', Em.I18n.t('services.service.summary.viewHost'), Em.I18n.t('services.service.summary.viewHosts'));

  App.TestAliases.testAsComputedCountBasedMessage(getView(), 'phoenixServersText', 'service.phoenixServersTotal', '', Em.I18n.t('services.service.summary.viewHost'), Em.I18n.t('services.service.summary.viewHosts'));

  describe('#averageLoad', function () {

    beforeEach(function () {
      view.reopen({service: Em.Object.create()});
    });

    Em.A([
      {
        averageLoad: NaN,
        e: Em.I18n.t('dashboard.services.hbase.averageLoadPerServer').format(Em.I18n.t('services.service.summary.notAvailable'))
      },
      {
        averageLoad: 12,
        e: Em.I18n.t('dashboard.services.hbase.averageLoadPerServer').format(12)
      }
    ]).forEach(function (test, index) {
      it('test# ' + (index + 1), function () {
        view.set('service.averageLoad', test.averageLoad);
        expect(view.get('averageLoad')).to.be.equal(test.e);
      });
    });

  });

  describe("#summaryHeader", function() {

    it("averageLoad is NaN", function() {
      view.set('service', Em.Object.create({
        averageLoad: 'null',
        regionServersTotal: 1
      }));
      view.propertyDidChange('summaryHeader');
      expect(view.get('summaryHeader')).to.be.equal(view.t("dashboard.services.hbase.summary").format(1, view.t("services.service.summary.unknown")));
    });

    it("averageLoad is number", function() {
      view.set('service', Em.Object.create({
        averageLoad: 99,
        regionServersTotal: 1
      }));
      view.propertyDidChange('summaryHeader');
      expect(view.get('summaryHeader')).to.be.equal(view.t("dashboard.services.hbase.summary").format(1, 99));
    });
  });

  describe("#hbaseMasterWebUrl", function() {

    it("activeMaster is present", function() {
      view.reopen({
        activeMaster: Em.Object.create({
          host: Em.Object.create({
            publicHostName: 'host1'
          })
        })
      });
      App.set('singleNodeInstall', false);
      view.propertyDidChange('hbaseMasterWebUrl');
      expect(view.get('hbaseMasterWebUrl')).to.be.equal('http://host1:60010');
    });
    it("activeMaster is null", function() {
      view.reopen({
        activeMaster: null
      });
      view.propertyDidChange('hbaseMasterWebUrl');
      expect(view.get('hbaseMasterWebUrl')).to.be.undefined;
    });
  });

});
});

require.register("test/views/main/service/services/hdfs_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var date = require('utils/date/date');
require('/views/main/service/services/hdfs');

function getView(options) {
  return App.MainDashboardServiceHdfsView.create(options || {});
}

describe('App.MainDashboardServiceHdfsView', function () {
  var view;

  beforeEach(function() {
    view = getView({service: Em.Object.create()});
  });

  App.TestAliases.testAsComputedAlias(getView(), 'dataNodesDead', 'service.dataNodesInstalled', 'boolean');

  App.TestAliases.testAsComputedAlias(getView(), 'journalNodesTotal', 'service.journalNodes.length', 'number');

  describe("#Chart", function() {
    var chartView;

    beforeEach(function() {
      chartView = view.get('Chart').create();
    });

    describe("#data", function () {

      it("should return data", function () {
        chartView.set('service', Em.Object.create({
          capacityTotal: 100,
          capacityRemaining: 1
        }));
        chartView.propertyDidChange('data');
        expect(chartView.get('data')).to.be.eql([99, 1]);
      });
    });
  });

  describe("#dashboardMasterComponentView", function() {
    var dashboardMasterComponentView;

    beforeEach(function() {
      dashboardMasterComponentView = view.get('dashboardMasterComponentView').create({
        parentView: Em.Object.create()
      });
    });

    describe("#mastersComp", function () {

      it("should return master components", function () {
        dashboardMasterComponentView.set('parentView.service', Em.Object.create({
          hostComponents: [
            Em.Object.create({
              componentName: 'ZKFC'
            }),
            Em.Object.create({
              componentName: 'JOURNALNODE'
            }),
            Em.Object.create({
              componentName: 'NAMENODE',
              isMaster: true
            })
          ]
        }));
        dashboardMasterComponentView.propertyDidChange('mastersComp');
        expect(dashboardMasterComponentView.get('mastersComp').mapProperty('componentName')).to.be.eql(['NAMENODE', 'ZKFC']);
        expect(dashboardMasterComponentView.get('mastersComp')[0].get('isMaster')).to.be.true;
        expect(dashboardMasterComponentView.get('mastersComp')[1].get('isSubComponent')).to.be.true;
      });
    });

    describe("#didInsertElement()", function() {

      beforeEach(function() {
        sinon.stub(App, 'tooltip');
      });
      afterEach(function() {
        App.tooltip.restore();
      });

      it("App.tooltip should be called", function() {
        dashboardMasterComponentView.didInsertElement();
        expect(App.tooltip.calledOnce).to.be.true;
      });
    });

    describe("#willDestroyElement()", function() {
      var mock = {
        tooltip: Em.K
      };

      beforeEach(function() {
        sinon.stub(mock, 'tooltip');
        sinon.stub(window, '$').returns(mock);
      });
      afterEach(function() {
        mock.tooltip.restore();
        window.$.restore();
      });

      it("tooltip destroy should be called", function() {
        dashboardMasterComponentView.willDestroyElement();
        expect(mock.tooltip.calledWith('destroy')).to.be.true;
      });
    });
  });

  describe("#metricsNotAvailableObserver()", function() {

    beforeEach(function() {
      sinon.stub(App, 'tooltip');
    });
    afterEach(function() {
      App.tooltip.restore();
    });

    it("App.tooltip should be called", function() {
      view.set("service", Em.Object.create({
        metricsNotAvailable: false
      }));
      expect(App.tooltip.calledOnce).to.be.true;
    });
  });

  describe("#willDestroyElement()", function() {
    var mock = {
      tooltip: Em.K
    };

    beforeEach(function() {
      sinon.stub(mock, 'tooltip');
      sinon.stub(window, '$').returns(mock);
    });
    afterEach(function() {
      mock.tooltip.restore();
      window.$.restore();
    });

    it("tooltip destroy should be called", function() {
      view.willDestroyElement();
      expect(mock.tooltip.calledWith('destroy')).to.be.true;
    });
  });

  describe("#journalNodesLive", function() {

    it("should return live journal nodes count", function() {
      view.set('service', Em.Object.create({
        journalNodes: [
          Em.Object.create({workStatus: 'STARTED'}),
          Em.Object.create()
        ]
      }));
      view.propertyDidChange('journalNodesLive');
      expect(view.get('journalNodesLive')).to.be.equal(1);
    });
  });

  describe("#nodeUptime", function() {

    beforeEach(function() {
      sinon.stub(App, 'dateTime').returns(10);
      sinon.stub(date, 'timingFormat').returns('11');
    });
    afterEach(function() {
      App.dateTime.restore();
      date.timingFormat.restore();
    });

    it("nameNodeStartTime is 0", function() {
      view.set('service.nameNodeStartTime', 0);
      view.propertyDidChange('nodeUptime');
      expect(view.get('nodeUptime')).to.be.equal(view.t('services.service.summary.notRunning'));
    });

    it("nameNodeStartTime is -1", function() {
      view.set('service.nameNodeStartTime', -1);
      view.propertyDidChange('nodeUptime');
      expect(view.get('nodeUptime')).to.be.equal(view.t('services.service.summary.notRunning'));
    });

    it("nameNodeStartTime is 1", function() {
      view.set('service.nameNodeStartTime', 1);
      view.propertyDidChange('nodeUptime');
      expect(view.get('nodeUptime')).to.be.equal(view.t('dashboard.services.uptime').format('11'));
      expect(date.timingFormat.calledWith(9)).to.be.true;
    });

    it("nameNodeStartTime is 11", function() {
      view.set('service.nameNodeStartTime', 11);
      view.propertyDidChange('nodeUptime');
      expect(view.get('nodeUptime')).to.be.equal(view.t('dashboard.services.uptime').format('11'));
      expect(date.timingFormat.calledWith(0)).to.be.true;
    });
  });

  describe("#nodeWebUrl", function () {

    it("singleNodeInstall is true", function () {
      App.set('singleNodeInstall', true);
      App.set('singleNodeAlias', 'host1');

      view.propertyDidChange('nodeWebUrl');
      expect(view.get('nodeWebUrl')).to.be.equal("http://host1:50070");
    });

    it("singleNodeInstall is false", function () {
      App.set('singleNodeInstall', false);
      view.set('service.nameNode', Em.Object.create({
        publicHostName: 'host2'
      }));
      view.propertyDidChange('nodeWebUrl');
      expect(view.get('nodeWebUrl')).to.be.equal("http://host2:50070");
    });
  });

  describe("#nonDfsUsed", function() {
    var testCases = [
      {
        input: {
          capacityTotal: null,
          capacityRemaining: 1,
          capacityUsed: 90
        },
        expected: null
      },
      {
        input: {
          capacityTotal: 100,
          capacityRemaining: null,
          capacityUsed: 90
        },
        expected: null
      },
      {
        input: {
          capacityTotal: 100,
          capacityRemaining: 1,
          capacityUsed: null
        },
        expected: null
      },
      {
        input: {
          capacityTotal: 100,
          capacityRemaining: 1,
          capacityUsed: 90
        },
        expected: 9
      }
    ];

    testCases.forEach(function(test) {
      it("total=" + test.input.capacityTotal + " remaining" + test.input.capacityRemaining + " used" + test.input.capacityUsed, function() {
        view.get('service').setProperties(test.input);
        view.propertyDidChange('nonDfsUsed');
        expect(view.get('nonDfsUsed')).to.be.equal(test.expected);
      });
    });
  });

  describe("#isNfsInStack", function() {

    beforeEach(function() {
      this.mock = sinon.stub(App.StackServiceComponent, 'find');
    });
    afterEach(function() {
      this.mock.restore();
    });

    it("no NFS_GATEWAY component", function() {
      this.mock.returns([]);
      view.propertyDidChange('isNfsInStack');
      expect(view.get('isNfsInStack')).to.be.false;
    });

    it("NFS_GATEWAY component present", function() {
      this.mock.returns([{componentName: 'NFS_GATEWAY'}]);
      view.propertyDidChange('isNfsInStack');
      expect(view.get('isNfsInStack')).to.be.true;
    });
  });

  describe("#safeModeStatus", function() {

    it("safeModeStatus is null", function() {
      view.set('service.safeModeStatus', null);
      view.propertyDidChange('safeModeStatus');
      expect(view.get('safeModeStatus')).to.be.equal(Em.I18n.t("services.service.summary.notAvailable"));
    });

    it("safeModeStatus is empty", function() {
      view.set('service.safeModeStatus', "");
      view.propertyDidChange('safeModeStatus');
      expect(view.get('safeModeStatus')).to.be.equal(Em.I18n.t("services.service.summary.safeModeStatus.notInSafeMode"));
    });

    it("safeModeStatus is on", function() {
      view.set('service.safeModeStatus', 'on');
      view.propertyDidChange('safeModeStatus');
      expect(view.get('safeModeStatus')).to.be.equal(Em.I18n.t("services.service.summary.safeModeStatus.inSafeMode"));
    });
  });

  describe("#upgradeStatus", function() {

    it("upgradeStatus is 'true'", function() {
      view.set('service.upgradeStatus', 'true');
      view.propertyDidChange('upgradeStatus');
      expect(view.get('upgradeStatus')).to.be.equal(Em.I18n.t('services.service.summary.pendingUpgradeStatus.notPending'));
    });

    it("upgradeStatus is 'false', healthStatus is 'green'", function() {
      view.set('service.upgradeStatus', 'false');
      view.set('service.healthStatus', 'green');
      view.propertyDidChange('upgradeStatus');
      expect(view.get('upgradeStatus')).to.be.equal(Em.I18n.t('services.service.summary.pendingUpgradeStatus.notFinalized'));
    });

    it("upgradeStatus is null", function() {
      view.set('service.upgradeStatus', null);
      view.propertyDidChange('upgradeStatus');
      expect(view.get('upgradeStatus')).to.be.equal(Em.I18n.t('services.service.summary.notAvailable'));
    });
  });

  describe("#isUpgradeStatusWarning", function() {

    it("upgradeStatus is 'false', healthStatus is 'green'", function() {
      view.set('service.upgradeStatus', 'false');
      view.set('service.healthStatus', 'green');
      view.propertyDidChange('isUpgradeStatusWarning');
      expect(view.get('isUpgradeStatusWarning')).to.be.true;
    });

    it("upgradeStatus is 'true', healthStatus is 'green'", function() {
      view.set('service.upgradeStatus', 'true');
      view.set('service.healthStatus', 'green');
      view.propertyDidChange('isUpgradeStatusWarning');
      expect(view.get('isUpgradeStatusWarning')).to.be.false;
    });

    it("upgradeStatus is 'false', healthStatus is 'red'", function() {
      view.set('service.upgradeStatus', 'false');
      view.set('service.healthStatus', 'red');
      view.propertyDidChange('isUpgradeStatusWarning');
      expect(view.get('isUpgradeStatusWarning')).to.be.false;
    });
  });


});

});

require.register("test/views/main/service/services/hive_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('/views/main/service/services/hive');

describe('App.MainDashboardServiceHiveView', function () {

});
});

require.register("test/views/main/service/services/mapreduce2_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('/views/main/service/services/mapreduce2');

describe('App.MainDashboardServiceMapreduce2View', function () {
  var view;

  beforeEach(function() {
    view = App.MainDashboardServiceMapreduce2View.create();
  });

 describe("#titleInfo", function() {

   it("HISTORYSERVER stopped", function() {
     view.set('service', Em.Object.create({
       hostComponents: [
         Em.Object.create({
           componentName: 'HISTORYSERVER',
           workStatus: App.HostComponentStatus.stopped
         })
       ]
     }));
     view.propertyDidChange('titleInfo');
     expect(view.get('titleInfo')).to.be.equal(view.t('services.mapreduce2.history.stopped'));
   });

   it("HISTORYSERVER absent", function() {
     view.set('service', Em.Object.create({
       hostComponents: []
     }));
     view.propertyDidChange('titleInfo');
     expect(view.get('titleInfo')).to.be.equal(view.t('services.mapreduce2.history.unknown'));
   });

   it("HISTORYSERVER started", function() {
     view.set('service', Em.Object.create({
       hostComponents: [
         Em.Object.create({
           componentName: 'HISTORYSERVER',
           workStatus: App.HostComponentStatus.started
         })
       ]
     }));
     view.propertyDidChange('titleInfo');
     expect(view.get('titleInfo')).to.be.equal(view.t('services.mapreduce2.history.running'));
   });
 });
});
});

require.register("test/views/main/service/services/oozie_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('/views/main/service/services/oozie');

describe('App.MainDashboardServiceOozieView', function () {
  var view;

  beforeEach(function() {
    view = App.MainDashboardServiceOozieView.create();
  });

  describe("#webUi", function () {

    it("singleNodeInstall is true", function () {
      App.set('singleNodeInstall', true);
      App.set('singleNodeAlias', 'host1');

      view.propertyDidChange('webUi');
      expect(view.get('webUi')).to.be.equal("http://host1:11000/oozie");
    });

    it("singleNodeInstall is false", function () {
      App.set('singleNodeInstall', false);
      view.set('service', Em.Object.create({
        hostComponents: [
          Em.Object.create({
            componentName: 'OOZIE_SERVER',
            host: Em.Object.create({
              publicHostName: 'host2'
            })
          })
        ]
      }));
      view.propertyDidChange('webUi');
      expect(view.get('webUi')).to.be.equal("http://host2:11000/oozie");
    });
  });
});
});

require.register("test/views/main/service/services/ranger_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('/views/main/service/services/ranger');

describe('App.MainDashboardServiceRangerView', function () {

  var view;

  beforeEach(function () {
    view = App.MainDashboardServiceRangerView.create({
      controller: App.MainServiceInfoSummaryController.create()
    });
  });

  describe('#didInsertElement', function () {

    it('should run updater', function () {
      view.didInsertElement();
      expect(App.updater.run.calledOnce).to.be.true;
      expect(App.updater.immediateRun.calledOnce).to.be.true;
    });
  });

  describe('#willDestroyElement', function () {
    it('should not run updater if not on Ranger summary page', function () {
      view.willDestroyElement();
      expect(view.get('controller.isRangerUpdateWorking')).to.be.false;
    });
  });
});
});

require.register("test/views/main/service/services/storm_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('/views/main/service/services/storm');

function getView(options) {
  return App.MainDashboardServiceStormView.create(options || {});
}

describe('App.MainDashboardServiceStormView', function () {
  var view;

  beforeEach(function() {
    view = getView();
  });

  App.TestAliases.testAsComputedPercents(getView(), 'freeSlotsPercentage', 'service.freeSlots', 'service.totalSlots');

  App.TestAliases.testAsComputedAlias(getView(), 'superVisorsLive', 'service.superVisorsStarted');

  App.TestAliases.testAsComputedAlias(getView(), 'superVisorsTotal', 'service.superVisorsTotal');

  describe("#nimbusUptimeFormatted", function () {

    it("nimbusUptime is set", function () {
      view.set('service', Em.Object.create({
        nimbusUptime: '1'
      }));
      view.propertyDidChange('nimbusUptimeFormatted');
      expect(view.get('nimbusUptimeFormatted')).to.be.equal('1');
    });

    it("nimbusUptime is not set", function () {
      view.set('service', null);
      view.propertyDidChange('nimbusUptimeFormatted');
      expect(view.get('nimbusUptimeFormatted')).to.be.equal(Em.I18n.t('services.service.summary.notRunning'));
    });
  });
});
});

require.register("test/views/main/service/services/yarn_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var date = require('utils/date/date');
var numberUtils = require('utils/number_utils');

require('/views/main/service/services/yarn');

function getView(options) {
  return App.MainDashboardServiceYARNView.create(options || {});
}

describe('App.MainDashboardServiceYARNView', function () {
  var view;

  beforeEach(function() {
    view = getView({service: Em.Object.create()});
  });

  App.TestAliases.testAsComputedCountBasedMessage(getView(), 'nodeManagerText', 'service.nodeManagersTotal', '', Em.I18n.t('services.service.summary.viewHost'), Em.I18n.t('services.service.summary.viewHosts'));

  App.TestAliases.testAsComputedGt(getView(), 'hasManyYarnClients', 'service.installedClients', 1);

  App.TestAliases.testAsComputedFormatNa(getView(), '_nmActive', 'service.nodeManagersCountActive');
  App.TestAliases.testAsComputedFormatNa(getView(), '_nmLost', 'service.nodeManagersCountLost');
  App.TestAliases.testAsComputedFormatNa(getView(), '_nmUnhealthy', 'service.nodeManagersCountUnhealthy');
  App.TestAliases.testAsComputedFormatNa(getView(), '_nmRebooted', 'service.nodeManagersCountRebooted');
  App.TestAliases.testAsComputedFormatNa(getView(), '_nmDecom', 'service.nodeManagersCountDecommissioned');

  App.TestAliases.testAsComputedFormatNa(getView(), '_allocated', 'service.containersAllocated');
  App.TestAliases.testAsComputedFormatNa(getView(), '_pending', 'service.containersPending');
  App.TestAliases.testAsComputedFormatNa(getView(), '_reserved', 'service.containersReserved');

  App.TestAliases.testAsComputedFormatNa(getView(), '_appsSubmitted', 'service.appsSubmitted');
  App.TestAliases.testAsComputedFormatNa(getView(), '_appsRunning', 'service.appsRunning');
  App.TestAliases.testAsComputedFormatNa(getView(), '_appsPending', 'service.appsPending');
  App.TestAliases.testAsComputedFormatNa(getView(), '_appsCompleted', 'service.appsCompleted');
  App.TestAliases.testAsComputedFormatNa(getView(), '_appsKilled', 'service.appsKilled');
  App.TestAliases.testAsComputedFormatNa(getView(), '_appsFailed', 'service.appsFailed');

  App.TestAliases.testAsComputedFormatNa(getView(), '_queuesCountFormatted', 'service.queuesCount');

  describe("#nodeUptime", function() {

    beforeEach(function() {
      sinon.stub(App, 'dateTime').returns(10);
      sinon.stub(date, 'timingFormat').returns('11');
    });
    afterEach(function() {
      App.dateTime.restore();
      date.timingFormat.restore();
    });

    it("resourceManagerStartTime is 0", function() {
      view.set('service.resourceManagerStartTime', 0);
      view.propertyDidChange('nodeUptime');
      expect(view.get('nodeUptime')).to.be.equal(view.t('services.service.summary.notRunning'));
    });

    it("resourceManagerStartTime is -1", function() {
      view.set('service.resourceManagerStartTime', -1);
      view.propertyDidChange('nodeUptime');
      expect(view.get('nodeUptime')).to.be.equal(view.t('services.service.summary.notRunning'));
    });

    it("resourceManagerStartTime is 1", function() {
      view.set('service.resourceManagerStartTime', 1);
      view.propertyDidChange('nodeUptime');
      expect(view.get('nodeUptime')).to.be.equal(view.t('dashboard.services.uptime').format('11'));
      expect(date.timingFormat.calledWith(9)).to.be.true;
    });

    it("resourceManagerStartTime is 11", function() {
      view.set('service.resourceManagerStartTime', 11);
      view.propertyDidChange('nodeUptime');
      expect(view.get('nodeUptime')).to.be.equal(view.t('dashboard.services.uptime').format('11'));
      expect(date.timingFormat.calledWith(0)).to.be.true;
    });
  });

  describe("#memory", function() {

    beforeEach(function() {
      sinon.stub(numberUtils, 'bytesToSize', function(arg1) {
        return arg1;
      })
    });
    afterEach(function() {
      numberUtils.bytesToSize.restore();
    });

    it("should return formatted memory", function() {
      view.set('service', Em.Object.create({
        allocatedMemory: 1,
        reservedMemory: 2,
        availableMemory: 3
      }));
      view.propertyDidChange('memory');
      expect(view.get('memory')).to.be.equal(Em.I18n.t('dashboard.services.yarn.memory.msg').format(1,2,3));
    });
  });

  describe("#didInsertElement()", function() {

    beforeEach(function() {
      sinon.stub(App, 'tooltip');
    });
    afterEach(function() {
      App.tooltip.restore();
    });

    it("App.tooltip should be called", function() {
      view.didInsertElement();
      expect(App.tooltip.calledTwice).to.be.true;
    });
  });

  describe("#willDestroyElement()", function() {
    var mock = {
      tooltip: Em.K
    };

    beforeEach(function() {
      sinon.stub(window, '$').returns(mock);
      sinon.stub(mock, 'tooltip');
    });
    afterEach(function() {
      window.$.restore();
      mock.tooltip.restore();
    });

    it("tooltip destroy should be called", function() {
      view.willDestroyElement();
      expect(mock.tooltip.calledWith('destroy')).to.be.true;
    });
  });

});

});

require.register("test/views/main/service/services/zookeeper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('/views/main/service/services/zookeeper');

describe('App.MainDashboardServiceZookeperView', function () {
  var view;

  beforeEach(function () {
    view = App.MainDashboardServiceZookeperView.create();
  });

  describe("#titleInfo", function () {

    it("should return ZOOKEEPER info", function () {
      view.set('service', Em.Object.create({
        hostComponents: [
          Em.Object.create({
            componentName: 'ZOOKEEPER_SERVER',
            workStatus: App.HostComponentStatus.stopped
          }),
          Em.Object.create({
            componentName: 'ZOOKEEPER_SERVER',
            workStatus: App.HostComponentStatus.started
          })
        ]
      }));
      view.propertyDidChange('titleInfo');
      expect(view.get('titleInfo')).to.be.eql({
        pre: view.t('services.zookeeper.prefix').format(1),
        title: view.t('services.zookeeper.title').format(2),
        component: Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: App.HostComponentStatus.stopped
        })
      });
    });
  });
});
});

require.register("test/views/main/service/widgets/create/expression_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var numberUtils = require("utils/number_utils");
var misc = require('utils/misc');


describe('App.WidgetWizardExpressionView', function () {
  var view;

  beforeEach(function() {
    view = App.WidgetWizardExpressionView.create({
      expression: {
        data: []
      },
      controller: Em.Object.create({
        updateExpressions: Em.K
      })
    });
    view.removeObserver('expression.data.length', view, 'validate');
  });

  describe("#validate()", function() {
    var testCases = [
      {
        data: [],
        result: false
      },
      {
        data: [
          {isMetric: true, name:'1'}
        ],
        result: false
      },
      {
        data: [
          {isMetric: true, name:'1'},
          {name: '+'},
          {isMetric: true, name:'1'}
        ],
        result: false
      },
      {
        data: [
          {name: '('},
          {isMetric: true, name:'1'},
          {name: '-'},
          {isMetric: true, name:'1'},
          {name: ')'}
        ],
        result: false
      },
      {
        data: [
          {name: '('},
          {isMetric: true, name:'1'},
          {name: '-'},
          {isMetric: true, name:'1'},
          {name: ')'},
          {name: '*'},
          {isMetric: true, name:'1'}
        ],
        result: false
      },
      {
        data: [
          {name: '('},
          {name: '('},
          {isMetric: true, name:'1'},
          {name: '-'},
          {isMetric: true, name:'1'},
          {name: ')'},
          {name: '*'},
          {isMetric: true, name:'1'},
          {name: ')'}
        ],
        result: false
      },
      {
        data: [
          {name: '-'}
        ],
        result: true
      },
      {
        data: [
          {name: '-'},
          {isMetric: true, name:'1'}
        ],
        result: true
      },
      {
        data: [
          {isMetric: true, name:'1'},
          {name: '+'}
        ],
        result: true
      },
      {
        data: [
          {name: '*'},
          {isMetric: true, name:'1'},
          {name: '+'}
        ],
        result: true
      },
      {
        data: [
          {isMetric: true, name:'1'},
          {name: '('}
        ],
        result: true
      },
      {
        data: [
          {name: ')'},
          {isMetric: true, name:'1'}
        ],
        result: true
      },
      {
        data: [
          {name: '('}
        ],
        result: true
      },
      {
        data: [
          {name: '('},
          {isMetric: true, name:'1'}
        ],
        result: true
      },
      {
        data: [
          {isMetric: true, name:'1'},
          {name: '('}
        ],
        result: true
      },
      {
        data: [
          {name: '('},
          {isMetric: true, name:'1'},
          {name: '+'},
          {isMetric: true, name:'1'}
        ],
        result: true
      },
      {
        data: [
          {isMetric: true, name:'1'},
          {name: '+'},
          {isMetric: true, name:'1'},
          {name: ')'}
        ],
        result: true
      },
      {
        data: [
          {name: '('},
          {name: '('},
          {isMetric: true, name:'1'},
          {name: '+'},
          {isMetric: true, name:'1'},
          {name: ')'}
        ],
        result: true
      }
    ];
    testCases.forEach(function (test) {
      it(test.data.mapProperty('name').join("") + " - isInvalid = " + test.result, function () {
        view.set('expression.data', test.data);
        view.validate();
        expect(view.get('isInvalid')).to.equal(test.result);
      });
    }, this);
  });

  describe("#isNumberValueInvalid", function() {

    beforeEach(function() {
      sinon.stub(numberUtils, 'isPositiveNumber').returns(true)
    });
    afterEach(function() {
      numberUtils.isPositiveNumber.restore();
    });

    it("numberValue is empty", function() {
      view.set('numberValue', '');
      view.propertyDidChange('isNumberValueInvalid');
      expect(view.get('isNumberValueInvalid')).to.be.true;
    });

    it("numberValue is ' '", function() {
      view.set('numberValue', ' ');
      view.propertyDidChange('isNumberValueInvalid');
      expect(view.get('isNumberValueInvalid')).to.be.true;
    });

    it("numberValue is '2'", function() {
      view.set('numberValue', '2');
      view.propertyDidChange('isNumberValueInvalid');
      expect(view.get('isNumberValueInvalid')).to.be.false;
    });
  });

  describe("#addOperator()", function() {

    it("add first operator", function() {
      var event = {context: 'o1'};
      view.set('expression', Em.Object.create({
        data: []
      }));
      view.addOperator(event);
      expect(view.get('expression.data').mapProperty('id')).to.eql([1]);
      expect(view.get('expression.data').mapProperty('name')).to.eql(['o1']);
    });

    it("add second operator", function() {
      var event = {context: 'o2'};
      view.set('expression', Em.Object.create({
        data: [{id: 1, name: 'o1'}]
      }));
      view.addOperator(event);
      expect(view.get('expression.data').mapProperty('id')).to.eql([1, 2]);
      expect(view.get('expression.data').mapProperty('name')).to.eql(['o1', 'o2']);
    });
  });

  describe("#addNumber()", function() {

    it("add first number", function() {
      view.set('expression', Em.Object.create({
        data: []
      }));
      view.set('numberValue', '1');
      view.addNumber();
      expect(view.get('expression.data').mapProperty('id')).to.eql([1]);
      expect(view.get('expression.data').mapProperty('name')).to.eql(['1']);
      expect(view.get('numberValue')).to.be.empty;
    });

    it("add second number", function() {
      view.set('expression', Em.Object.create({
        data: [{id: 1, name: '1'}]
      }));
      view.set('numberValue', '2');
      view.addNumber();
      expect(view.get('expression.data').mapProperty('id')).to.eql([1, 2]);
      expect(view.get('expression.data').mapProperty('name')).to.eql(['1', '2']);
      expect(view.get('numberValue')).to.be.empty;
    });
  });

  describe("#redrawField()", function() {

    beforeEach(function() {
      sinon.stub(misc, 'sortByOrder').returns([{}]);
    });
    afterEach(function() {
      misc.sortByOrder.restore();
    });

    it("sortByOrder should be called", function() {
      view.redrawField();
      expect(misc.sortByOrder.calledOnce).to.be.true;
      expect(view.get('expression.data')).to.be.eql([{}]);
    });
  });

  describe("#didInsertElement()", function() {

    beforeEach(function() {
      sinon.stub(view, 'propertyDidChange');
      sinon.stub(Em.run, 'next');
    });
    afterEach(function() {
      view.propertyDidChange.restore();
      Em.run.next.restore();
    });

    it("Em.run.next should be called", function() {
      view.didInsertElement();
      expect(view.propertyDidChange.calledOnce).to.be.true;
      expect(Em.run.next.calledOnce).to.be.true;
    });
  });

  describe("#removeElement()", function() {

    it("object should be removed", function() {
      var event = {context: 'el1'};
      view.set('expression.data', [event.context]);
      view.removeElement(event);
      expect(view.get('expression.data')).to.be.empty;
    });
  });
});

describe("App.AddNumberExpressionView", function() {

  var view;

  beforeEach(function() {
    view = App.AddNumberExpressionView.create();
  });

  describe("#isInvalid", function() {

    beforeEach(function() {
      sinon.stub(numberUtils, 'isPositiveNumber').returns(true)
    });
    afterEach(function() {
      numberUtils.isPositiveNumber.restore();
    });

    it("value is empty", function() {
      view.set('value', '');
      view.propertyDidChange('isInvalid');
      expect(view.get('isInvalid')).to.be.false;
    });

    it("value is ' '", function() {
      view.set('value', ' ');
      view.propertyDidChange('isInvalid');
      expect(view.get('isInvalid')).to.be.false;
    });

    it("value is '2'", function() {
      view.set('value', '2');
      view.propertyDidChange('isInvalid');
      expect(view.get('isInvalid')).to.be.false;
    });
  });
});

describe("App.InputCursorTextfieldView", function() {

  var view;

  beforeEach(function() {
    view = App.InputCursorTextfieldView.create({
      parentView: App.WidgetWizardExpressionView.create({
        expression: {
          data: []
        },
        controller: Em.Object.create({
          updateExpressions: Em.K
        })
      })
    });
    view.removeObserver('value', view, 'validateInput');
  });

  describe("#didInsertElement()", function() {

    beforeEach(function() {
      sinon.stub(view, 'focusCursor');
    });
    afterEach(function() {
      view.focusCursor.restore();
    });

    it("focusCursor should be called", function() {
      view.didInsertElement();
      expect(view.focusCursor.calledOnce).to.be.true;
    });
  });

  describe("#focusOut()", function() {

    beforeEach(function() {
      sinon.stub(view, 'saveNumber');
    });
    afterEach(function() {
      view.saveNumber.restore();
    });

    it("saveNumber should be called", function() {
      view.focusOut();
      expect(view.saveNumber.calledOnce).to.be.true;
    });
  });

  describe("#focusCursor()", function() {
    var mock = {
      focus: Em.K
    };

    beforeEach(function() {
      sinon.stub(Em.run, 'next', Em.clb);
      sinon.stub(view, '$').returns(mock);
      sinon.stub(mock, 'focus');
      view.focusCursor();
    });
    afterEach(function() {
      Em.run.next.restore();
      view.$.restore();
      mock.focus.restore();
    });

    it("Em.run.next should be called", function() {
      expect(Em.run.next.calledOnce).to.be.true;
    });

    it("$ should be called", function() {
      expect(view.$.calledTwice).to.be.true;
    });

    it("focus should be called", function() {
      expect(mock.focus.calledOnce).to.be.true;
    });
  });

  describe("#validateInput()", function() {

    beforeEach(function() {
      this.mock = sinon.stub(numberUtils, 'isPositiveNumber');
    });
    afterEach(function() {
      this.mock.restore();
    });

    it("value is positive number", function() {
      this.mock.returns(true);
      view.validateInput();
      expect(view.get('isInvalid')).to.be.false;
    });

    it("value is null", function() {
      this.mock.returns(false);
      view.set('value', null);
      view.validateInput();
      expect(view.get('isInvalid')).to.be.false;
    });

    it("value is empty", function() {
      this.mock.returns(false);
      view.set('value', '');
      view.validateInput();
      expect(view.get('isInvalid')).to.be.false;
    });

    it("value is operator", function() {
      this.mock.returns(false);
      view.set('value', '+');
      view.validateInput();
      expect(view.get('isInvalid')).to.be.false;
      expect(view.get('parentView.expression.data')).to.not.be.empty;
      expect(view.get('value')).to.be.empty;
    });

    it("value is 'm'", function() {
      this.mock.returns(false);
      view.set('value', '+');
      view.validateInput();
      expect(view.get('isInvalid')).to.be.false;
      expect(view.get('value')).to.be.empty;
    });

    it("value is invalid", function() {
      this.mock.returns(false);
      view.set('value', '%');
      view.validateInput();
      expect(view.get('isInvalid')).to.be.true;
    });
  });

  describe("#keyDown()", function() {

    beforeEach(function() {
      sinon.stub(view, 'saveNumber');
    });
    afterEach(function() {
      view.saveNumber.restore();
    });

    it("unexpected key", function() {
      view.set('parentView.expression.data', [{name: '1'}, {name: '2'}]);
      view.keyDown({keyCode: 9});
      expect(view.saveNumber.called).to.be.false;
      expect(view.get('parentView.expression.data.length')).to.be.equal(2);
    });

    it("backspace key and not empty value", function() {
      view.set('value', 'm');
      view.set('parentView.expression.data', [{name: '1'}, {name: '2'}]);
      view.keyDown({keyCode: 8});
      expect(view.saveNumber.called).to.be.false;
      expect(view.get('parentView.expression.data.length')).to.be.equal(2);
    });

    it("backspace key and empty value", function() {
      view.set('value', '');
      view.set('parentView.expression.data', [{name: '1'}, {name: '2'}]);
      view.keyDown({keyCode: 8});
      expect(view.saveNumber.called).to.be.false;
      expect(view.get('parentView.expression.data.length')).to.be.equal(1);
    });

    it("enter key", function() {
      view.set('value', '');
      view.set('parentView.expression.data', [{name: '1'}, {name: '2'}]);
      view.keyDown({keyCode: 13});
      expect(view.saveNumber.called).to.be.true;
      expect(view.get('parentView.expression.data.length')).to.be.equal(2);
    });
  });

  describe("#saveNumber()", function() {

    beforeEach(function() {
      this.mock = sinon.stub(numberUtils, 'isPositiveNumber');
    });
    afterEach(function() {
      this.mock.restore();
    });

    it("value is a positive number", function() {
      view.set('value', '1');
      this.mock.returns(true);
      view.saveNumber();
      expect(view.get('parentView.expression.data').mapProperty('name')).to.be.eql(['1']);
      expect(view.get('numberValue')).to.be.empty;
      expect(view.get('isInvalid')).to.be.false;
      expect(view.get('value')).to.be.empty;
    });

    it("value is not a positive number", function() {
      view.set('value', '-1');
      this.mock.returns(false);
      view.saveNumber();
      expect(view.get('parentView.expression.data')).to.be.empty;
      expect(view.get('value')).to.be.equal('-1');
    });
  });

});

});

require.register("test/views/main/service/widgets/create/step1_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('/views/main/service/widgets/create/step1_view');


describe('App.WidgetWizardStep1View', function () {
  var view;

  beforeEach(function() {
    view = App.WidgetWizardStep1View.create({
      controller: Em.Object.create({
        content: Em.Object.create(),
        loadStep: Em.K
      })
    });
  });

  describe("#didInsertElement()", function() {

    beforeEach(function () {
      sinon.stub(Em.run, 'later', function (ctx, callback) {
        callback();
      });
      sinon.stub(App, 'tooltip');
      sinon.stub(view.get('controller'), 'loadStep');
      view.didInsertElement();
    });
    afterEach(function () {
      Em.run.later.restore();
      App.tooltip.restore();
      view.get('controller').loadStep.restore();
    });

    it("loadStep should be called", function() {
      expect(view.get('controller').loadStep.calledOnce).to.be.true;
    });

    it("Em.run.later should be called", function() {
      expect(Em.run.later.calledOnce).to.be.true;
    });

    it("App.tooltip should be called", function() {
      expect(App.tooltip.calledOnce).to.be.true;
    });
  });
});

});

require.register("test/views/main/service/widgets/create/step2_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('/views/main/service/widgets/create/step2_view');


describe('App.WidgetWizardStep2View', function () {
  var view;

  beforeEach(function() {
    view = App.WidgetWizardStep2View.create({
      controller: Em.Object.create({
        content: Em.Object.create(),
        convertData: Em.K,
        initWidgetData: Em.K,
        renderProperties: Em.K,
        updateExpressions: Em.K
      })
    });
  });

  describe("#templateType", function () {

    it("widgetType is null", function () {
      view.set('controller.content.widgetType', null);
      view.propertyDidChange('templateType');
      expect(view.get('templateType')).to.be.empty;
    });

    it("widgetType is GAUGE", function () {
      view.set('controller.content.widgetType', 'GAUGE');
      view.propertyDidChange('templateType');
      expect(view.get('templateType')).to.eql({isNumber: true});
    });

    it("widgetType is NUMBER", function () {
      view.set('controller.content.widgetType', 'NUMBER');
      view.propertyDidChange('templateType');
      expect(view.get('templateType')).to.eql({isNumber: true});
    });

    it("widgetType is TEMPLATE", function () {
      view.set('controller.content.widgetType', 'TEMPLATE');
      view.propertyDidChange('templateType');
      expect(view.get('templateType')).to.eql({isTemplate: true});
    });

    it("widgetType is GRAPH", function () {
      view.set('controller.content.widgetType', 'GRAPH');
      view.propertyDidChange('templateType');
      expect(view.get('templateType')).to.eql({isGraph: true});
    });
  });

  describe("#ensureTooltip()", function() {

    beforeEach(function () {
      sinon.stub(Em.run, 'later', function (ctx, callback) {
        callback();
      });
      sinon.stub(App, 'tooltip');
      view.ensureTooltip();
    });
    afterEach(function () {
      Em.run.later.restore();
      App.tooltip.restore();
    });

    it("Em.run.later should be called", function() {
      expect(Em.run.later.calledOnce).to.be.true;
    });

    it("App.tooltip should be called", function() {
      expect(App.tooltip.calledOnce).to.be.true;
    });
  });

  describe("#didInsertElement()", function () {

    beforeEach(function () {
      sinon.stub(view, 'ensureTooltip');
      sinon.stub(view.get('controller'), 'convertData');
      sinon.stub(view.get('controller'), 'initWidgetData');
      sinon.stub(view.get('controller'), 'renderProperties');
      sinon.stub(view.get('controller'), 'updateExpressions');
      view.didInsertElement();
    });
    afterEach(function () {
      view.ensureTooltip.restore();
      view.get('controller').convertData.restore();
      view.get('controller').initWidgetData.restore();
      view.get('controller').renderProperties.restore();
      view.get('controller').updateExpressions.restore();
    });

    it("ensureTooltip should be called", function () {
      expect(view.ensureTooltip.calledOnce).to.be.true;
    });

    it("convertData should be called", function () {
      expect(view.get('controller').convertData.calledOnce).to.be.true;
    });

    it("initWidgetData should be called", function () {
      expect(view.get('controller').initWidgetData.calledOnce).to.be.true;
    });

    it("renderProperties should be called", function () {
      expect(view.get('controller').renderProperties.calledOnce).to.be.true;
    });

    it("updateExpressions should be called", function () {
      expect(view.get('controller').updateExpressions.calledOnce).to.be.true;
    });
  });
});

});

require.register("test/views/main/service/widgets/create/step3_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('/views/main/service/widgets/create/step3_view');


describe('App.WidgetWizardStep3View', function () {
  var view;

  beforeEach(function() {
    view = App.WidgetWizardStep3View.create({
      controller: Em.Object.create({
        initPreviewData: Em.K
      })
    });
  });

  describe("#didInsertElement()", function() {

    beforeEach(function () {
      sinon.stub(view.get('controller'), 'initPreviewData');
    });
    afterEach(function () {
      view.get('controller').initPreviewData.restore();
    });

    it("initPreviewData should be called", function() {
      view.didInsertElement();
      expect(view.get('controller').initPreviewData.calledOnce).to.be.true;
    });
  });
});

});

require.register("test/views/main/service/widgets/create/wizard_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('/views/main/service/widgets/create/wizard_view');


describe('App.WidgetWizardView', function () {
  var view;

  beforeEach(function() {
    view = App.WidgetWizardView.create({
      controller: Em.Object.create({
        content: Em.Object.create()
      })
    });
  });

  describe("#previewWidgetClass", function() {

    it("widgetType is null", function() {
      view.set('controller.content.widgetType', null);
      view.propertyDidChange('previewWidgetClass');
      expect(view.get('previewWidgetClass').create()).to.be.instanceof(Em.View);
    });

    it("widgetType is GRAPH", function() {
      view.set('controller.content.widgetType', 'GRAPH');
      view.propertyDidChange('previewWidgetClass');
      expect(view.get('previewWidgetClass').create()).to.be.instanceof(App.GraphWidgetView);
    });

    it("widgetType is TEMPLATE", function() {
      view.set('controller.content.widgetType', 'TEMPLATE');
      view.propertyDidChange('previewWidgetClass');
      expect(view.get('previewWidgetClass').create()).to.be.instanceof(App.TemplateWidgetView);
    });

    it("widgetType is NUMBER", function() {
      view.set('controller.content.widgetType', 'NUMBER');
      view.propertyDidChange('previewWidgetClass');
      expect(view.get('previewWidgetClass').create()).to.be.instanceof(App.NumberWidgetView);
    });

    it("widgetType is GAUGE", function() {
      view.set('controller.content.widgetType', 'GAUGE');
      view.propertyDidChange('previewWidgetClass');
      expect(view.get('previewWidgetClass').create()).to.be.instanceof(App.GaugeWidgetView);
    });
  });

  describe("#isStep2", function() {

    it("currentStep is '2'", function() {
      view.set('controller.currentStep', '2');
      view.propertyDidChange('isStep2');
      expect(view.get('isStep2')).to.be.true;
    });

    it("currentStep is 2", function() {
      view.set('controller.currentStep', 2);
      view.propertyDidChange('isStep2');
      expect(view.get('isStep2')).to.be.true;
    });

    it("currentStep is null", function() {
      view.set('controller.currentStep', null);
      view.propertyDidChange('isStep2');
      expect(view.get('isStep2')).to.be.false;
    });
  });

  describe("#isStep3", function() {

    it("currentStep is '3'", function() {
      view.set('controller.currentStep', '3');
      view.propertyDidChange('isStep3');
      expect(view.get('isStep3')).to.be.true;
    });

    it("currentStep is 3", function() {
      view.set('controller.currentStep', 3);
      view.propertyDidChange('isStep3');
      expect(view.get('isStep3')).to.be.true;
    });

    it("currentStep is null", function() {
      view.set('controller.currentStep', null);
      view.propertyDidChange('isStep3');
      expect(view.get('isStep3')).to.be.false;
    });
  });

});

});

require.register("test/views/wizard/step0_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step0_view');

var view, controller = Em.Object.create({
  clusterNameError: '',
  loadStep: Em.K
});

describe('App.WizardStep0View', function () {

  beforeEach(function () {
    view = App.WizardStep0View.create({'controller': controller});
  });

  describe('#onError', function () {
    it('should be true if clusterNameError appears', function () {
      controller.set('clusterNameError', 'ERROR');
      expect(view.get('onError')).to.equal(true);
    });
    it('should be false if clusterNameError doesn\'t appears', function () {
      controller.set('clusterNameError', '');
      expect(view.get('onError')).to.equal(false);
    });
  });

  describe('#didInsertElement', function () {
    beforeEach(function () {
      sinon.stub(App, 'popover', Em.K);
      sinon.spy(view.get('controller'), 'loadStep');
    });
    afterEach(function () {
      App.popover.restore();
      view.get('controller').loadStep.restore();
    });
    it('should call loadStep', function () {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
    });
    it('should create popover', function () {
      view.didInsertElement();
      expect(App.popover.calledOnce).to.equal(true);
    });
  });

});

describe('App.WizardStep0ViewClusterNameInput', function () {

  beforeEach(function() {
    view = App.WizardStep0ViewClusterNameInput.create({
      parentView: Em.Object.create({
        controller: Em.Object.create({
          submit: Em.K
        })
      })
    });
  });

  describe('#keyPress', function() {

    beforeEach(function () {
      sinon.spy(view.get('parentView.controller'), 'submit');
    });

    afterEach(function () {
      view.get('parentView.controller').submit.restore();
    });

    it('should return true if pressed not Enter', function() {
      expect(view.keyPress({keyCode: 1})).to.equal(true);
      expect(view.get('parentView.controller').submit.called).to.equal(false);
    });
    it('should submit form if Enter pressed', function() {
      expect(view.keyPress({keyCode: 13})).to.equal(false);
      expect(view.get('parentView.controller').submit.calledOnce).to.equal(true);
    });
  });

});
});

require.register("test/views/wizard/step10_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step10_view');
var view;
describe('App.WizardStep10View', function() {
  beforeEach(function() {
    view = App.WizardStep10View.create({
      controller: App.WizardStep10Controller.create({
        isAddServiceWizard: false
      })
    });
  });
  describe('#didInsertElement()', function() {

    beforeEach(function () {
      sinon.stub(view.get('controller'), 'loadStep', Em.K);
    });

    afterEach(function () {
      view.get('controller').loadStep.restore();
    });

    it('should call loadStep', function() {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
    });
  });

  describe("#serviceRestartText", function() {
    it("text is empty", function() {
      view.set('controller.isAddServiceWizard', false);
      expect(view.get('serviceRestartText')).to.be.empty;
    });
    it("text is complete", function() {
      view.set('controller.isAddServiceWizard', true);
      expect(view.get('serviceRestartText')).to.equal(Em.I18n.t('common.important.strong') + Em.I18n.t('installer.step10.staleServicesRestartRequired'));
    });
  });
});

});

require.register("test/views/wizard/step1_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step1_view');

var view;

function getView() {
  return App.WizardStep1View.create();
}

describe('App.WizardStep1View', function () {

  beforeEach(function () {
    view = getView();
  });

  App.TestAliases.testAsComputedEveryBy(getView(), 'isNoOsChecked', 'controller.selectedStack.operatingSystems', 'isSelected', false);

  App.TestAliases.testAsComputedOr(getView(), 'isSubmitDisabled', ['invalidFormatUrlExist', 'isNoOsChecked', 'isNoOsFilled', 'controller.content.isCheckInProgress', 'App.router.btnClickInProgress']);

  App.TestAliases.testAsComputedSomeBy(getView(), 'invalidUrlExist', 'allRepositories', 'validation', App.Repository.validation.INVALID);

  describe('#editLocalRepository', function () {

    it('should update repository', function () {
      view.reopen({
        allRepositories: [
          Em.Object.create({
            isSelected: true,
            baseUrl: 'b1',
            validation: 'icon-exclamation-sign'
          })
        ]
      });
      view.editLocalRepository();
      var repository = view.get('allRepositories.firstObject');
      expect(repository.get('lastBaseUrl')).to.equal(repository.get('baseUrl'));
      expect(repository.get('validation')).to.be.empty;
    });
  });
});
});

require.register("test/views/wizard/step2_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step2_view');

var view, controller = Em.Object.create({
  clusterNameError: ''
});

function getView() {
  return App.WizardStep2View.create({'controller': controller});
}

describe('App.WizardStep0View', function () {

  beforeEach(function() {
    view = getView();
  });

  App.TestAliases.testAsComputedAlias(getView(), 'sshKeyState', 'controller.content.installOptions.manualInstall', 'string');

  describe('#didInsertElement', function() {
    beforeEach(function () {
      sinon.stub(App, 'popover', Em.K);
      sinon.stub(App, 'tooltip', Em.K);
      view.set('controller.hostsError', 'some text');
      view.set('controller.sshKeyError', 'some text');
    });
    afterEach(function () {
      App.popover.restore();
      App.tooltip.restore();
    });
    it('should clean hostsError', function () {
      view.didInsertElement();
      expect(view.get('controller.hostsError')).to.be.null;
    });
    it('should clean sshKeyError', function () {
      view.didInsertElement();
      expect(view.get('controller.sshKeyError')).to.be.null;
    });
    it('should create popover', function () {
      view.didInsertElement();
      expect(App.popover.calledOnce).to.equal(true);
    });
    it('should create tooltip', function () {
      view.didInsertElement();
      expect(App.tooltip.calledOnce).to.equal(true);
    });
  });

  describe('#providingSSHKeyRadioButton', function() {
    var v;

    beforeEach(function() {
      v = view.get('providingSSHKeyRadioButton').create({
        controller: Em.Object.create({
          content: {
            installOptions: {
              useSsh: true,
              manualInstall: true
            }
          }
        })
      });
    });

    describe('#checked', function() {
      it('should be equal to controller.content.installOptions.useSsh', function () {
        v.set('controller.content.installOptions.useSsh', false);
        expect(v.get('checked')).to.equal(false);
        v.set('controller.content.installOptions.useSsh', true);
        expect(v.get('checked')).to.equal(true);
      });
    });

    describe('#click', function() {
      it('should update controller.content.installOptions.useSsh', function () {
        v.set('controller.content.installOptions.useSsh', false);
        v.click();
        expect(v.get('controller.content.installOptions.useSsh')).to.equal(true);
      });
      it('should update controller.content.installOptions.manualInstall', function () {
        v.set('controller.content.installOptions.manualInstall', true);
        v.click();
        expect(v.get('controller.content.installOptions.manualInstall')).to.equal(false);
      });
    });

  });

  describe('#manualRegistrationRadioButton', function() {
    var v;

    beforeEach(function() {
      v = view.get('manualRegistrationRadioButton').create({
        controller: Em.Object.create({
          content: {
            installOptions: {
              useSsh: true,
              manualInstall: true
            }
          }
        })
      });
    });

    describe('#checked', function() {
      it('should be equal to controller.content.installOptions.manualInstall', function () {
        v.set('controller.content.installOptions.manualInstall', false);
        expect(v.get('checked')).to.equal(false);
        v.set('controller.content.installOptions.manualInstall', true);
        expect(v.get('checked')).to.equal(true);
      });
    });

    describe('#click', function() {
      it('should update controller.content.installOptions.useSsh', function () {
        v.set('controller.content.installOptions.useSsh', true);
        v.click();
        expect(v.get('controller.content.installOptions.useSsh')).to.equal(false);
      });
      it('should update controller.content.installOptions.manualInstall', function () {
        v.set('controller.content.installOptions.manualInstall', false);
        v.click();
        expect(v.get('controller.content.installOptions.manualInstall')).to.equal(true);
      });
    });

  });

  describe('#textFieldView', function() {
    var v;

    beforeEach(function() {
      v = view.get('textFieldView').create();
    });

    describe('#disabled', function() {
      it('should be inverted to isEnabled', function () {
        v.set('isEnabled', false);
        expect(v.get('disabled')).to.equal(true);
        v.set('isEnabled', true);
        expect(v.get('disabled')).to.equal(false);
      });
    });

  });

});
});

require.register("test/views/wizard/step3/hostLogPopupBody_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step3/hostLogPopupBody_view');
var view;

function getView() {
  return App.WizardStep3HostLogPopupBody.create({
    parentView: Em.Object.create({
      host: Em.Object.create()
    })
  });
}

describe('App.WizardStep3HostLogPopupBody', function() {

  beforeEach(function() {
    view = getView();
  });

  describe('#textArea', function() {

    var v;

    beforeEach(function() {
      v = view.get('textArea').create();
    });

    describe('#value', function() {
      it('should be equal to content', function() {
        var c = 'Relax, you are doing fine';
        v.set('content', c);
        expect(v.get('value')).to.equal(c);
      });
    });

  });

  App.TestAliases.testAsComputedAlias(getView(), 'bootLog', 'parentView.host.bootLog', 'string');


});
});

require.register("test/views/wizard/step3/hostWarningPopupBody_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var lazyloading = require('utils/lazy_loading');
require('views/wizard/step3/hostWarningPopupBody_view');
var view;

function getView() {
  return App.WizardStep3HostWarningPopupBody.create({
    didInsertElement: Em.K,
    $: function() {
      return Em.Object.create({
        toggle: Em.K
      })
    }
  });
}

describe('App.WizardStep3HostWarningPopupBody', function() {

  beforeEach(function() {
    view = getView();
  });

  App.TestAliases.testAsComputedAlias(getView(), 'warningsByHost', 'bodyController.warningsByHost', 'array');

  App.TestAliases.testAsComputedAlias(getView(), 'warnings', 'bodyController.warnings', 'array');

  describe('#onToggleBlock', function() {
    it('should toggle', function() {
      var context = Em.Object.create({isCollapsed: false});
      view.onToggleBlock({context: context});
      expect(context.get('isCollapsed')).to.equal(true);
      view.onToggleBlock({context: context});
      expect(context.get('isCollapsed')).to.equal(false);
    });
  });

  describe('#showHostsPopup', function() {

    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show', Em.K);
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('should call App.ModalPopup.show', function() {
      view.showHostsPopup({context: []});
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
  });

  describe('#categoryWarnings', function() {
    it('should return empty array', function() {
      var warningsByHost = null;
      view.reopen({warningsByHost: warningsByHost});
      expect(view.get('categoryWarnings')).to.eql([]);
    });
    it('should return filtered warnings', function() {
      var warningsByHost = [
        {name: 'c', warnings: [{}, {}, {}]},
        {name: 'd', warnings: [{}]}
      ];
      view.reopen({warningsByHost: warningsByHost, category: 'c'});
      expect(view.get('categoryWarnings.length')).to.equal(3);
    });
  });

  describe('#warningHostsNamesCount', function() {
    it('should parse warnings', function() {
      view.set('bodyController', Em.Object.create({
        repoCategoryWarnings: [
          {hostsNames: ['h1', 'h4']}
        ],
        thpCategoryWarnings: [
          {hostsNames: ['h2', 'h3']}
        ],
        jdkCategoryWarnings: [
          {hostsNames: ['h3', 'h5']}
        ],
        hostCheckWarnings: [
          {hostsNames: ['h1', 'h2']}
        ],
        diskCategoryWarnings: [
          {hostsNames: ['h2', 'h5']}
        ],
        warningsByHost: [
          {},
          { name: 'h1', warnings: [{}, {}, {}] },
          { name: 'h2', warnings: [{}, {}, {}] },
          { name: 'h3', warnings: [] }
        ]
      }));
      expect(view.warningHostsNamesCount()).to.equal(5);
    });
  });

  describe('#hostSelectView', function() {

    var v;

    beforeEach(function() {
      v = view.get('hostSelectView').create();
    });

    describe('#click', function() {

      beforeEach(function () {
        sinon.spy(lazyloading, 'run');
      });

      afterEach(function () {
        lazyloading.run.restore();
      });

      Em.A([
          {
            isLoaded: false,
            isLazyLoading: true,
            e: true
          },
          {
            isLoaded: true,
            isLazyLoading: true,
            e: false
          },
          {
            isLoaded: false,
            isLazyLoading: false,
            e: false
          },
          {
            isLoaded: true,
            isLazyLoading: false,
            e: false
          }
        ]).forEach(function (test) {
          it('isLoaded: ' + test.isLoaded.toString() + ', isLazyLoading: ' + test.isLazyLoading.toString(), function () {
            v.reopen({
              isLoaded: test.isLoaded,
              isLazyLoading: test.isLazyLoading
            });
            v.click();
            if (test.e) {
              expect(lazyloading.run.calledOnce).to.equal(true);
            }
            else {
              expect(lazyloading.run.called).to.equal(false);
            }
          });
        });
    });

  });

  describe('#contentInDetails', function() {
    var content = [
      {category: 'firewall', warnings: [{name: 'n1'}, {name: 'n2'}, {name: 'n3'}]},
      {category: 'fileFolders', warnings: [{name: 'n4'}, {name: 'n5'}, {name: 'n6'}]},
      {category: 'reverseLookup', warnings: [{name: 'n19', hosts: ["h1"], hostsLong: ["h1"]}]},
      {
        category: 'process',
        warnings: [
          {name: 'n7', hosts:['h1', 'h2'], hostsLong:['h1', 'h2'], user: 'u1', pid: 'pid1'},
          {name: 'n8', hosts:['h2'], hostsLong:['h2'], user: 'u2', pid: 'pid2'},
          {name: 'n9', hosts:['h3'], hostsLong:['h3'], user: 'u1', pid: 'pid3'}
        ]
      },
      {category: 'package', warnings: [{name: 'n10'}, {name: 'n11'}, {name: 'n12'}]},
      {category: 'service', warnings: [{name: 'n13'}, {name: 'n14'}, {name: 'n15'}]},
      {category: 'user', warnings: [{name: 'n16'}, {name: 'n17'}, {name: 'n18'}]},
      {category: 'jdk', warnings: []},
      {category: 'disk', warnings: []},
      {category: 'repositories', warnings: []},
      {category: 'hostNameResolution', warnings: []},
      {category: 'thp', warnings: []}
    ];
    beforeEach(function() {
      view.reopen({content: content, warningsByHost: [], hostNamesWithWarnings: ['c', 'd']});
      this.newContent = view.get('contentInDetails');
    });
    it('should map hosts', function() {
      expect(this.newContent.contains('c d')).to.equal(true);
    });
    it('should map firewall warnings', function() {
      expect(this.newContent.contains('n1<br>n2<br>n3')).to.equal(true);
    });
    it('should map fileFolders warnings', function() {
      expect(this.newContent.contains('n4 n5 n6')).to.equal(true);
    });
    it('should map process warnings', function() {
      expect(this.newContent.contains('(h1,u1,pid1)')).to.equal(true);
      expect(this.newContent.contains('(h2,u1,pid1)')).to.equal(true);
      expect(this.newContent.contains('(h2,u2,pid2)')).to.equal(true);
      expect(this.newContent.contains('(h3,u1,pid3)')).to.equal(true);
    });
    it('should map package warnings', function() {
      expect(this.newContent.contains('n10 n11 n12')).to.equal(true);
    });
    it('should map service warnings', function() {
      expect(this.newContent.contains('n13 n14 n15')).to.equal(true);
    });
    it('should map user warnings', function() {
      expect(this.newContent.contains('n16 n17 n18')).to.equal(true);
    });
    it('should map reverse lookup warnings', function() {
      expect(this.newContent.contains('h1')).to.equal(true);
    });
  });

  describe('#content', function () {

    beforeEach(function () {
      view.set('bodyController', Em.Object.create({
        hostCheckWarnings: [
          {
            hosts: ['h0', 'h1', 'h2', 'h3', 'h4', 'h5', 'h5', 'h7', 'h8', 'h9', 'h10']
          }
        ],
        repoCategoryWarnings: [
          {
            hosts: ['h11', 'h12']
          }
        ],
        diskCategoryWarnings: [
          {
            hosts: ['h13']
          }
        ],
        jdkCategoryWarnings: [
          {
            hosts: ['h14']
          }
        ],
        thpCategoryWarnings: [
          {
            hosts: ['h15']
          }
        ]
      }));
      view.reopen({
        categoryWarnings: [
          {
            category: 'firewall',
            hosts: ['h16']
          },
          {
            category: 'firewall',
            hosts: ['h17']
          },
          {
            category: 'processes',
            hosts: ['h18']
          },
          {
            category: 'packages',
            hosts: ['h19']
          },
          {
            category: 'fileFolders',
            hosts: ['h20']
          },
          {
            category: 'services',
            hosts: ['h21']
          },
          {
            category: 'users',
            hosts: ['h22']
          },
          {
            category: 'misc',
            hosts: ['h23']
          },
          {
            category: 'alternatives',
            hosts: ['h24']
          },
          {
            category: 'reverseLookup',
            hosts: ['h25']
          },
          {
            category: 'reverseLookup',
            hosts: ['h26']
          },
          {
            category: 'reverseLookup',
            hosts: ['h27']
          },
          {
            category: 'reverseLookup',
            hosts: ['h28']
          },
          {
            category: 'reverseLookup',
            hosts: ['h29']
          },
          {
            category: 'reverseLookup',
            hosts: ['h30']
          },
          {
            category: 'reverseLookup',
            hosts: ['h31']
          },
          {
            category: 'reverseLookup',
            hosts: ['h32']
          },
          {
            category: 'reverseLookup',
            hosts: ['h33']
          },
          {
            category: 'reverseLookup',
            hosts: ['h34']
          },
          {
            category: 'reverseLookup',
            hosts: ['h35', 'h36']
          }
        ]
      });
      this.content = view.get('content');
    });

    it('isCollapsed', function () {
      expect(this.content.mapProperty('isCollapsed').uniq()).to.eql([true]);
    });

    it('hostNameResolution', function () {
      expect(this.content.findProperty('category', 'hostNameResolution').get('warnings')[0].hostsList).
        to.equal('h0<br>h1<br>h2<br>h3<br>h4<br>h5<br>h5<br>h7<br>h8<br>h9<br> ' + Em.I18n.t('installer.step3.hostWarningsPopup.moreHosts').format(1));
    });

    it('repositories', function () {
      expect(this.content.findProperty('category', 'repositories').get('warnings')[0].hostsList).to.equal('h11<br>h12');
    });

    it('disk', function () {
      expect(this.content.findProperty('category', 'disk').get('warnings')[0].hostsList).to.equal('h13');
    });

    it('jdk', function () {
      expect(this.content.findProperty('category', 'jdk').get('warnings')[0].hostsList).to.equal('h14');
    });

    it('thp', function () {
      expect(this.content.findProperty('category', 'thp').get('warnings')[0].hostsList).to.equal('h15');
    });

    it('firewall', function () {
      expect(this.content.findProperty('category', 'firewall').get('warnings').mapProperty('hostsList')).to.eql(['h16', 'h17']);
    });

    it('process', function () {
      expect(this.content.findProperty('category', 'process').get('warnings')[0].hostsList).to.equal('h18');});

    it('package', function () {
      expect(this.content.findProperty('category', 'package').get('warnings')[0].hostsList).to.equal('h19');
    });

    it('fileFolders', function () {
      expect(this.content.findProperty('category', 'fileFolders').get('warnings')[0].hostsList).to.equal('h20');
    });

    it('service', function () {
      expect(this.content.findProperty('category', 'service').get('warnings')[0].hostsList).to.equal('h21');
    });

    it('user', function () {
      expect(this.content.findProperty('category', 'user').get('warnings')[0].hostsList).to.equal('h22');
    });

    it('misc', function () {
      expect(this.content.findProperty('category', 'misc').get('warnings')[0].hostsList).to.equal('h23');
    });

    it('alternatives', function () {
      expect(this.content.findProperty('category', 'alternatives').get('warnings')[0].hostsList).to.equal('h24');
    });

    it('reverseLookup', function () {
      expect(this.content.findProperty('category', 'reverseLookup').get('warnings').mapProperty('hostsList')).to.eql([
        'h25', 'h26', 'h27', 'h28', 'h29', 'h30', 'h31', 'h32', 'h33', 'h34', 'h35<br>h36'
      ]);
    });

  });

});
});

require.register("test/views/wizard/step3/hostWarningPopupFooter_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step3/hostWarningPopupFooter_view');
var view;

describe('App.WizardStep3HostWarningPopupFooter', function() {

  beforeEach(function() {
    view = App.WizardStep3HostWarningPopupFooter.create();
    view.reopen({footerController: Em.Object.create()});
  });

  describe('#progressWidth', function() {
    it('based on footerController.checksUpdateProgress', function() {
      view.set('footerController.checksUpdateProgress', 42);
      expect(view.get('progressWidth')).to.equal('width:42%');
    });
  });

  describe('#isUpdateInProgress', function() {
    var tests = Em.A([
      {checksUpdateProgress: 0, e: false},
      {checksUpdateProgress: 100, e: false},
      {checksUpdateProgress: 50, e: true}
    ]);
    tests.forEach(function(test) {
      it(test.checksUpdateProgress, function() {
        view.set('footerController.checksUpdateProgress', test.checksUpdateProgress);
        expect(view.get('isUpdateInProgress')).to.equal(test.e);
      });
    });
  });

  describe('#updateStatusClass', function() {
    var tests = Em.A([
      {checksUpdateStatus: 'SUCCESS', e: 'text-success'},
      {checksUpdateStatus: 'FAILED', e: 'text-error'},
      {checksUpdateStatus: 'PANIC', e: null}
    ]);
    tests.forEach(function(test) {
      it(test.checksUpdateStatus, function() {
        view.set('footerController.checksUpdateStatus', test.checksUpdateStatus);
        if (Em.isNone(test.e)) {
          expect(view.get('updateStatusClass')).to.be.null;
        }
        else {
          expect(view.get('updateStatusClass')).to.equal(test.e);
        }
      })
    });
  });

  describe('#updateStatus', function() {
    var tests = Em.A([
      {checksUpdateStatus: 'SUCCESS', e: Em.I18n.t('installer.step3.warnings.updateChecks.success')},
      {checksUpdateStatus: 'FAILED', e: Em.I18n.t('installer.step3.warnings.updateChecks.failed')},
      {checksUpdateStatus: 'PANIC', e: null}
    ]);
    tests.forEach(function(test) {
      it(test.checksUpdateStatus, function() {
        view.set('footerController.checksUpdateStatus', test.checksUpdateStatus);
        if (Em.isNone(test.e)) {
          expect(view.get('updateStatus')).to.be.null;
        }
        else {
          expect(view.get('updateStatus')).to.equal(test.e);
        }
      })
    });
  });

});
});

require.register("test/views/wizard/step3_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('messages');
require('views/wizard/step3_view');
var v;
function getView() {
  return App.WizardStep3View.create({
    monitorStatuses: function () {
    },
    content: [
      Em.Object.create({
        name: 'host1',
        bootStatus: 'PENDING',
        isChecked: false
      }),
      Em.Object.create({
        name: 'host2',
        bootStatus: 'PENDING',
        isChecked: true
      }),
      Em.Object.create({
        name: 'host3',
        bootStatus: 'PENDING',
        isChecked: true
      })
    ],
    pageContent: function () {
      return this.get('content');
    }.property('content')
  });
}

describe('App.WizardStep3View', function () {

  var view = getView();

  describe('#watchSelection', function () {
    it('2 of 3 hosts selected', function () {
      view.watchSelection();
      expect(view.get('noHostsSelected')).to.equal(false);
      expect(view.get('selectedHostsCount')).to.equal(2);
    });
    it('all hosts selected', function () {
      view.selectAll();
      view.watchSelection();
      expect(view.get('noHostsSelected')).to.equal(false);
      expect(view.get('selectedHostsCount')).to.equal(3);
    });
    it('none hosts selected', function () {
      view.unSelectAll();
      view.watchSelection();
      expect(view.get('noHostsSelected')).to.equal(true);
      expect(view.get('selectedHostsCount')).to.equal(0);
    });
  });

  describe('#selectAll', function () {
    it('select all hosts', function () {
      view.selectAll();
      expect(view.get('content').everyProperty('isChecked', true)).to.equal(true);
    });
  });

  describe('#unSelectAll', function () {
    it('unselect all hosts', function () {
      view.unSelectAll();
      expect(view.get('content').everyProperty('isChecked', false)).to.equal(true);
    });
  });

  var testCases = Em.A([
    {
      title: 'none hosts',
      content: [],
      result: {
        "ALL": 0,
        "RUNNING": 0,
        "REGISTERING": 0,
        "REGISTERED": 0,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts RUNNING',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'RUNNING'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'RUNNING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'RUNNING'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 3,
        "REGISTERING": 0,
        "REGISTERED": 0,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts REGISTERING',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERING'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 3,
        "REGISTERED": 0,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts REGISTERED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'REGISTERED'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'REGISTERED'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 0,
        "REGISTERED": 3,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts FAILED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'FAILED'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'FAILED'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'FAILED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 0,
        "REGISTERED": 0,
        "FAILED": 3
      }
    },
    {
      title: 'first host is FAILED, second is RUNNING, third is REGISTERED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'FAILED'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'RUNNING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 1,
        "REGISTERING": 0,
        "REGISTERED": 1,
        "FAILED": 1
      }
    },
    {
      title: 'two hosts is REGISTERING, one is REGISTERED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 2,
        "REGISTERED": 1,
        "FAILED": 0
      }
    }
  ]);

  describe('#countCategoryHosts', function () {
    var _view;
    testCases.forEach(function (test) {
      describe(test.title, function () {

        beforeEach(function () {
          _view = getView();
          _view.set('content', test.content);
          _view.countCategoryHosts();
        });

        Object.keys(test.result).forEach(function (categoryName) {
          it('`' + categoryName + '`', function () {
            expect(_view.get('categories').findProperty('hostsBootStatus', categoryName).get('hostsCount')).to.be.equal(test.result[categoryName])
          });
        });

      });
    }, this);
  });

  describe('#doFilter', function () {
    testCases.forEach(function (test) {
      describe(test.title, function () {
        view.get('categories').forEach(function (category) {
          it('. Selected category - ' + category.get('hostsBootStatus'), function () {
            view.set('content', test.content);
            view.reopen({
              selectedCategory: category
            });
            view.doFilter();
            expect(view.get('filteredContent').length).to.equal(test.result[category.get('hostsBootStatus')])
          });
        });
      });
    }, this);
  });

  describe('#monitorStatuses', function() {
    var tests = Em.A([
      {
        controller: Em.Object.create({bootHosts: Em.A([])}),
        m: 'Empty hosts list',
        e: {status: 'alert-warn', linkText: ''}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: false}),
        m: 'isWarningsLoaded false',
        e: {status: 'alert-info', linkText: ''}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, isHostHaveWarnings: true}),
        m: 'isWarningsLoaded true, isHostHaveWarnings true',
        e: {status: 'alert-warn', linkText: Em.I18n.t('installer.step3.warnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, repoCategoryWarnings: ['']}),
        m: 'isWarningsLoaded true, repoCategoryWarnings not empty',
        e: {status: 'alert-warn', linkText: Em.I18n.t('installer.step3.warnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, diskCategoryWarnings: ['']}),
        m: 'isWarningsLoaded true, diskCategoryWarnings not empty',
        e: {status: 'alert-warn', linkText: Em.I18n.t('installer.step3.warnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, diskCategoryWarnings: [], repoCategoryWarnings: []}),
        m: 'isWarningsLoaded true, diskCategoryWarnings is empty, repoCategoryWarnings is empty',
        e: {status: 'alert-success', linkText: Em.I18n.t('installer.step3.noWarnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{bootStatus: 'FAILED'}]), isWarningsLoaded: true, diskCategoryWarnings: [], repoCategoryWarnings: []}),
        m: 'isWarningsLoaded true, diskCategoryWarnings is empty, repoCategoryWarnings is empty, all failed',
        e: {status: 'alert-warn', linkText: ''}
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        v = App.WizardStep3View.create({
          controller: test.controller
        });
        v.monitorStatuses();
        expect(v.get('status')).to.equal(test.e.status);
        expect(v.get('linkText')).to.equal(test.e.linkText);
      });
    });
  });

  describe('#retrySelectedHosts', function() {
    it('should set active category "All"', function() {
      view.set('controller', Em.Object.create({retrySelectedHosts: Em.K, registeredHosts: []}));
      view.retrySelectedHosts();
      expect(view.get('categories').findProperty('hostsBootStatus', 'ALL').get('isActive')).to.equal(true);
    });
  });

  describe('#selectCategory', function() {
    var tests = Em.A(['ALL','RUNNING','REGISTERING','REGISTERED','FAILED']);
    tests.forEach(function(test) {
      it('should set active category "' + test + '"', function() {
        view.set('controller', Em.Object.create({retrySelectedHosts: Em.K, registeredHosts: []}));
        view.selectCategory({context:Em.Object.create({hostsBootStatus:test})});
        expect(view.get('categories').findProperty('hostsBootStatus', test).get('isActive')).to.equal(true);
      });
    });
  });

  describe('#countCategoryHosts', function() {
    it('should set host count for each category', function() {
      view.set('content', Em.A([
        Em.Object.create({bootStatus: 'RUNNING'}),
        Em.Object.create({bootStatus: 'REGISTERING'}),
        Em.Object.create({bootStatus: 'REGISTERED'}),
        Em.Object.create({bootStatus: 'FAILED'})
      ]));
      view.countCategoryHosts();
      expect(view.get('categories').mapProperty('hostsCount')).to.eql([4,1,1,1,1]);
    });
  });

  describe('#hostBootStatusObserver', function() {

    beforeEach(function () {
      sinon.spy(Em.run, 'once');
      view.hostBootStatusObserver();
    });

    afterEach(function () {
      Em.run.once.restore();
    });

    it('should call "Em.run.once" three times', function() {
      expect(Em.run.once.firstCall.args[1]).to.equal('countCategoryHosts');
      expect(Em.run.once.secondCall.args[1]).to.equal('filter');
      expect(Em.run.once.thirdCall.args[1]).to.equal('monitorStatuses');
    });
  });

  describe('#watchSelection', function() {
    describe('should set "pageChecked"', function() {
      var tests = Em.A([
        {pageContent: Em.A([]),m:'false if empty "pageContent"', e: false},
        {pageContent: Em.A([{isChecked: false}]),m:'false if not-empty "pageContent" and not all "isChecked" true', e: false},
        {pageContent: Em.A([{isChecked: true}]),m:'true if not-empty "pageContent" and all "isChecked" true', e: false}
      ]);
      tests.forEach(function(test) {
        it(test.m, function() {
          view.set('pageContent', test.pageContent);
          view.watchSelection();
          expect(view.get('pageChecked')).to.equal(test.e);
        });
      });
    });
    describe('should set "noHostsSelected" and "selectedHostsCount"', function() {
      var tests = Em.A([
        {pageContent: Em.A([]),content:Em.A([]),m:' - "true", "0" if content is empty',e:{selectedHostsCount: 0, noHostsSelected: true}},
        {pageContent: Em.A([]),content:Em.A([Em.Object.create({isChecked: false})]),m:' - "true", "0" if no one isChecked',e:{selectedHostsCount: 0, noHostsSelected: true}},
        {pageContent: Em.A([]),content:Em.A([Em.Object.create({isChecked: true}),Em.Object.create({isChecked: false})]),m:' - "false", "1" if one isChecked',e:{selectedHostsCount: 1, noHostsSelected: false}}
      ]);
      tests.forEach(function(test) {
        it(test.m, function() {
          view.set('pageContent', test.pageContent);
          view.set('content', test.content);
          view.watchSelection();
          expect(view.get('noHostsSelected')).to.equal(test.e.noHostsSelected);
          expect(view.get('selectedHostsCount')).to.equal(test.e.selectedHostsCount);
        });
      });
    });
  });

  describe('#watchSelectionOnce', function() {

    beforeEach(function () {
      sinon.spy(Em.run, 'once');
      view.watchSelectionOnce();
    });

    afterEach(function () {
      Em.run.once.restore();
    });

    it('should call "Em.run.once" one time', function() {
      expect(Em.run.once.calledOnce).to.equal(true);
      expect(Em.run.once.firstCall.args[1]).to.equal('watchSelection');
    });
  });

  describe('#selectedCategory', function() {
    it('should equal category with isActive = true', function() {
      view.get('categories').findProperty('hostsBootStatus', 'FAILED').set('isActive', true);
      expect(view.get('selectedCategory.hostsBootStatus')).to.equal('FAILED');
    });
  });

  describe('#onPageChecked', function() {
    var tests = Em.A([
      {
        selectionInProgress: true,
        pageContent: [Em.Object.create({isChecked: true}), Em.Object.create({isChecked: false})],
        pageChecked: true,
        m: 'shouldn\'t do nothing if selectionInProgress is true',
        e: [true, false]
      },
      {
        selectionInProgress: false,
        pageContent: [Em.Object.create({isChecked: true}), Em.Object.create({isChecked: false})],
        pageChecked: true,
        m: 'should set each isChecked to pageChecked value',
        e: [true, true]
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        v = App.WizardStep3View.create({
          'pageContent': test.pageContent,
          'pageChecked': test.pageChecked,
          'selectionInProgress': test.selectionInProgress
        });
        v.onPageChecked();
        expect(v.get('pageContent').mapProperty('isChecked')).to.eql(test.e);
      });
    });
  });

  describe('#didInsertElement', function() {
    beforeEach(function() {
      v = App.WizardStep3View.create({
        controller: Em.Object.create({
          loadStep: Em.K
        })
      });
      sinon.spy(v.get('controller'), 'loadStep');
    });
    afterEach(function() {
      v.get('controller').loadStep.restore();
    });
    it('should call loadStep', function() {
      v.didInsertElement();
      expect(v.get('controller').loadStep.calledOnce).to.equal(true);
    });
  });

  describe('#categoryObject', function() {
    var o;
    beforeEach(function() {
      v = App.WizardStep3View.create();
      o = v.get('categoryObject').create();
    });

    describe('#label', function() {
      it('should use value and hostCount', function() {
        o.setProperties({
          value: 'abc',
          hostsCount: 3
        });
        expect(o.get('label')).to.equal('abc (3)');
      });
    });

    describe('#itemClass', function() {
      it('should depends on isActive', function() {
        o.set('isActive', true);
        expect(o.get('itemClass')).to.equal('active');
        o.set('isActive', false);
        expect(o.get('itemClass')).to.equal('');
      });
    });

  });

});

var wView;
describe('App.WizardHostView', function() {

  beforeEach(function() {
    wView = App.WizardHostView.create({
      hostInfo: {},
      controller: Em.Object.create({
        removeHost: Em.K,
        retryHost: Em.K
      })
    });
    sinon.spy(wView.get('controller'), 'retryHost');
    sinon.spy(wView.get('controller'), 'removeHost');
  });

  afterEach(function() {
    wView.get('controller').retryHost.restore();
    wView.get('controller').removeHost.restore();
  });

  describe('#retry', function() {
    it('should call controller.retryHost', function() {
      wView.retry();
      expect(wView.get('controller').retryHost.calledWith({})).to.equal(true);
      expect(wView.get('controller').retryHost.calledOnce).to.equal(true);
    });
  });

  describe('#remove', function() {
    it('should call controller.removeHost', function() {
      wView.remove();
      expect(wView.get('controller').removeHost.calledWith({})).to.equal(true);
      expect(wView.get('controller').removeHost.calledOnce).to.equal(true);
    });
  });

});

});

require.register("test/views/wizard/step4_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

describe('App.WizardStep4View', function () {

});

});

require.register("test/views/wizard/step5_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/wizard/step5_view');
var stringUtils = require('utils/string_utils');
var view;

describe('App.WizardStep5View', function() {

  beforeEach(function() {
    view = App.WizardStep5View.create({
      controller: App.WizardStep5Controller.create({})
    });
  });

  describe("#title", function() {
    beforeEach(function () {
      view.set('controller.content', Em.Object.create());
    });

    it("controller name is reassignMasterController", function() {
      view.set('controller.content.controllerName', 'reassignMasterController');
      view.propertyDidChange('title');
      expect(view.get('title')).to.equal(Em.I18n.t('installer.step5.reassign.header'));
    });
    it("controller name is ''", function() {
      view.set('controller.content.controllerName', '');
      view.propertyDidChange('title');
      expect(view.get('title')).to.equal(Em.I18n.t('installer.step5.header'));
    });
  });

  describe("#setCoHostedComponentText()", function () {
    beforeEach(function () {
      sinon.stub(App.StackServiceComponent, 'find').returns([
        Em.Object.create({
          componentName: 'C1',
          displayName: 'c1',
          isOtherComponentCoHosted: true,
          stackService: {
            isSelected: true
          },
          coHostedComponents: ['C2']
        }),
        Em.Object.create({
          componentName: 'C2',
          displayName: 'c2',
          isOtherComponentCoHosted: false,
          stackService: {
            isSelected: true
          }
        })
      ]);
      sinon.stub(stringUtils, 'getFormattedStringFromArray', function(str){
        return str;
      });
    });
    afterEach(function () {
      App.StackServiceComponent.find.restore();
      stringUtils.getFormattedStringFromArray.restore();
    });
    it("isReassignWizard - true", function () {
      view.set('controller.isReassignWizard', true);
      view.setCoHostedComponentText();
      expect(view.get('coHostedComponentText')).to.be.empty;
    });
    it("isReassignWizard - false", function () {
      view.set('controller.isReassignWizard', false);
      view.setCoHostedComponentText();
      expect(view.get('coHostedComponentText')).to.equal('<br/>' + Em.I18n.t('installer.step5.body.coHostedComponents').format(['c1', 'c2']));
    });
  });

  describe('#didInsertElement', function() {

    beforeEach(function () {
      sinon.stub(view.get('controller'), 'loadStep', Em.K);
    });

    afterEach(function () {
      view.get('controller').loadStep.restore();
    });

    it('should call controller.loadStep', function() {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
    });
  });

  describe('#shouldUseInputs', function() {

    Em.A([
      {range: 25, e: false},
      {range: 26, e: true},
      {range: 24, e: false}
    ]).forEach(function (test) {
      it(test.e + ' for ' + test.range + ' hosts', function () {
        view.set('controller.hosts', d3.range(0, test.range).map(function() {return {};}));
        expect(view.get('shouldUseInputs')).to.be.equal(test.e);
      });

    });

  });

});

describe('App.SelectHostView', function() {
  var models = require('test/init_model_test');

  beforeEach(function() {
    view = App.SelectHostView.create({
      controller: App.WizardStep5Controller.create({}),
      $: function() {return {typeahead: function(){return {on: Em.K}}}},
      updateErrorStatus: Em.K
    });
  });

  describe('#change', function() {

    beforeEach(function() {
      sinon.stub(view, 'initContent', Em.K);
      sinon.stub(view, 'changeHandler', Em.K);
      models.setupStackServiceComponent();
    });

    afterEach(function() {
      view.initContent.restore();
      view.changeHandler.restore();
      models.cleanStackServiceComponent();
    });

    it('should call initContent', function() {
      view.change();
      expect(view.initContent.calledOnce).to.be.true;
    });
  });

  describe('#didInsertElement', function() {

    it('should set value', function() {
      view.set('value', '');
      view.set('component', {selectedHost: 'h1'});
      view.didInsertElement();
      expect(view.get('value')).to.equal('h1');
    });

  });

  describe('#changeHandler', function() {

    beforeEach(function() {
      view.get('controller').reopen({multipleComponents: ['HBASE_MASTER', 'ZOOKEEPER_SERVER']});
      view.set('component', {component_name: 'ZOOKEEPER_SERVER', serviceComponentId: 1});
      view.set('controller.hosts', [Em.Object.create({host_info: 'h1 info', host_name: 'h1'})]);
      view.set('value', 'h1 info');
      view.set('controller.rebalanceComponentHostsCounter', 0);
      view.set('controller.componentToRebalance', '');
      sinon.stub(view.get('controller'), 'assignHostToMaster', Em.K);
      sinon.stub(view.get('controller'), 'updateIsHostNameValidFlag', Em.K);
      sinon.stub(view, 'shouldChangeHandlerBeCalled', function() {return true;});
    });

    afterEach(function() {
      view.get('controller').assignHostToMaster.restore();
      view.get('controller').updateIsHostNameValidFlag.restore();
      view.shouldChangeHandlerBeCalled.restore();
    });

    it('shouldn\'t do nothing if view is destroyed', function() {
      view.set('state', 'destroyed');
      expect(view.get('controller').assignHostToMaster.called).to.be.false;
    });

    it('should call assignHostToMaster', function() {
      view.changeHandler();
      expect(view.get('controller').assignHostToMaster.args[0]).to.be.eql(['ZOOKEEPER_SERVER', 'h1 info', 1]);
    });

    it('should increment rebalanceComponentHostsCounter if component it is multiple', function() {
      view.set('component', {component_name: 'ZOOKEEPER_SERVER'});
      view.changeHandler();
      expect(view.get('controller.rebalanceComponentHostsCounter')).to.equal(1);
    });

    it('should set componentToRebalance', function() {
      view.changeHandler();
      expect(view.get('controller.componentToRebalance')).to.equal('ZOOKEEPER_SERVER');
    });

  });

});

describe('App.InputHostView', function() {

  beforeEach(function() {
    view = App.InputHostView.create({
      controller: App.WizardStep5Controller.create({}),
      $: function() {return {typeahead: function(){return {on: Em.K}}}},
      updateErrorStatus: Em.K
    });
  });

  describe('#didInsertElement', function() {

    beforeEach(function() {
      sinon.stub(view, 'initContent', Em.K);
      view.set('content', [Em.Object.create({host_name: 'h1', host_info: 'h1 info'})]);
      view.set('component', {selectedHost: 'h1'});
    });

    afterEach(function() {
      view.initContent.restore();
    });

    it('should call initContent', function() {
      view.didInsertElement();
      expect(view.initContent.calledOnce).to.equal(true);
    });

    it('should set selectedHost host_name to value', function() {
      view.set('value', '');
      view.didInsertElement();
      expect(view.get('value')).to.equal('h1');
    });

  });

  describe('#changeHandler', function() {

    beforeEach(function() {
      view.get('controller').reopen({multipleComponents: ['HBASE_MASTER', 'ZOOKEEPER_SERVER']});
      view.set('component', {component_name: 'ZOOKEEPER_SERVER', serviceComponentId: 1});
      view.set('controller.hosts', [Em.Object.create({host_info: 'h1 info', host_name: 'h1'})]);
      view.set('value', 'h1');
      view.set('controller.rebalanceComponentHostsCounter', 0);
      view.set('controller.componentToRebalance', '');
      sinon.stub(view.get('controller'), 'assignHostToMaster', Em.K);
      sinon.stub(view.get('controller'), 'updateIsHostNameValidFlag', Em.K);
      sinon.stub(view, 'shouldChangeHandlerBeCalled', function() {return true;});
    });

    afterEach(function() {
      view.get('controller').assignHostToMaster.restore();
      view.get('controller').updateIsHostNameValidFlag.restore();
      view.shouldChangeHandlerBeCalled.restore();
    });

    it('shouldn\'t do nothing if view is destroyed', function() {
      view.set('state', 'destroyed');
      expect(view.get('controller').assignHostToMaster.called).to.be.false;
    });

    it('should call assignHostToMaster', function() {
      view.changeHandler();
      expect(view.get('controller').assignHostToMaster.args[0]).to.be.eql(['ZOOKEEPER_SERVER', 'h1', 1]);
    });

    it('should increment rebalanceComponentHostsCounter if component it is multiple', function() {
      view.set('component', {component_name: 'ZOOKEEPER_SERVER'});
      view.changeHandler();
      expect(view.get('controller.rebalanceComponentHostsCounter')).to.equal(1);
    });

    it('should set componentToRebalance', function() {
      view.changeHandler();
      expect(view.get('controller.componentToRebalance')).to.equal('ZOOKEEPER_SERVER');
    });

  });

  describe('#getAvailableHosts', function() {
    var tests = Em.A([
      {
        hosts: Em.A([]),
        selectedHost: 'h2',
        componentName: 'ZOOKEEPER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'ZOOKEEPER_SERVER', selectedHost: 'h1'})
        ]),
        m: 'Empty hosts',
        e: []
      },
      {
        hosts: Em.A([
          Em.Object.create({host_name: 'h1'}),
          Em.Object.create({host_name: 'h2'})
        ]),
        selectedHost: 'h2',
        componentName: 'c1',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'c2', selectedHost: 'h1'})
        ]),
        m: 'Two hosts',
        e: ['h1', 'h2']
      },
      {
        hosts: Em.A([
          Em.Object.create({host_name: 'h1'}),
          Em.Object.create({host_name: 'h2'})
        ]),
        selectedHost: 'h2',
        componentName: 'ZOOKEEPER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'ZOOKEEPER_SERVER', selectedHost: 'h1'})
        ]),
        m: 'Two hosts, ZOOKEEPER_SERVER',
        e: ['h2']
      },
      {
        hosts: Em.A([
          Em.Object.create({host_name: 'h1'}),
          Em.Object.create({host_name: 'h2'})
        ]),
        selectedHost: 'h2',
        componentName: 'HBASE_MASTER',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'HBASE_MASTER', selectedHost: 'h1'})
        ]),
        m: 'Two hosts, HBASE_MASTER',
        e: ['h2']
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        view.set('controller.hosts', test.hosts);
        view.get('controller').reopen({multipleComponents: ['HBASE_MASTER', 'ZOOKEEPER_SERVER']});
        view.set('component', {component_name: test.componentName});
        view.set('controller.selectedServicesMasters', test.selectedServicesMasters);
        var r = view.getAvailableHosts();
        expect(r.mapProperty('host_name')).to.eql(test.e);
      });
    });
  });

  describe('#rebalanceComponentHostsOnce', function() {
    var tests = Em.A([
      {
        componentName: 'c1',
        componentToRebalance: 'c2',
        content: [{}],
        m: 'componentName not equal to componentToRebalance',
        e: {
          initContent: false
        }
      },
      {
        componentName: 'c2',
        componentToRebalance: 'c2',
        content: [{}],
        m: 'componentName equal to componentToRebalance',
        e: {
          initContent: true
        }
      }
    ]);

    beforeEach(function () {
      sinon.stub(view, 'initContent', Em.K);
    });

    afterEach(function () {
      view.initContent.restore();
    });

    tests.forEach(function(test) {
      it(test.m, function() {
        view.set('content', test.content);
        view.set('component', {component_name: test.componentName});
        view.set('controller.componentToRebalance', test.componentToRebalance);
        view.rebalanceComponentHostsOnce();
        expect(view.initContent.calledOnce).to.equal(test.e.initContent);
      });
    });
  });

  describe('#initContent', function() {
    var tests = Em.A([
      {
        hosts: 25,
        m: 'not lazy loading, 25 hosts, no selected host',
        e: 25
      },
      {
        hosts: 25,
        h: 4,
        m: 'not lazy loading, 25 hosts, one selected host',
        e: 25
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        view.reopen({getAvailableHosts: function() {return d3.range(0, test.hosts).map(function(indx){return Em.Object.create({host_name: indx})});}});
        if (test.h) {
          view.set('selectedHost', test.h);
        }
        view.initContent();
        expect(view.get('content.length')).to.equal(test.e);
      });
    });
  });

  describe('#change', function() {

    beforeEach(function() {
      sinon.stub(view, 'changeHandler', Em.K);
    });

    afterEach(function() {
      view.changeHandler.restore();
    });

    it('shouldn\'t do nothing if view is destroyed', function() {
      view.set('controller.hostNameCheckTrigger', false);
      view.set('state', 'destroyed');
      view.change();
      expect(view.get('controller.hostNameCheckTrigger')).to.equal(false);
    });

    it('should toggle hostNameCheckTrigger', function() {
      view.set('controller.hostNameCheckTrigger', false);
      view.change();
      expect(view.get('controller.hostNameCheckTrigger')).to.equal(true);
    });

  });

});

describe('App.RemoveControlView', function() {

  beforeEach(function() {
    view = App.RemoveControlView.create({
      controller: App.WizardStep5Controller.create({})
    });
  });

  describe('#click', function() {
    beforeEach(function() {
      sinon.stub(view.get('controller'), 'removeComponent', Em.K);
    });
    afterEach(function() {
      view.get('controller').removeComponent.restore();
    });
    it('should call removeComponent', function() {
      view.set('serviceComponentId', 1);
      view.set('componentName', 'c1');
      view.click();
      expect(view.get('controller').removeComponent.calledWith('c1', 1)).to.equal(true);
    });
  });

});

describe('App.AddControlView', function() {

  beforeEach(function() {
    view = App.AddControlView.create({
      controller: App.WizardStep5Controller.create({})
    });
  });

  describe('#click', function() {

    beforeEach(function() {
      sinon.stub(view.get('controller'), 'addComponent', Em.K);
    });

    afterEach(function() {
      view.get('controller').addComponent.restore();
    });

    it('should call addComponent', function() {
      view.set('componentName', 'c1');
      view.click();
      expect(view.get('controller').addComponent.calledWith('c1')).to.equal(true);
    });

  });

});

});

require.register("test/views/wizard/step6_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('utils/helper');
require('utils/string_utils');
require('views/wizard/step6_view');
var view;

function getView() {
  return App.WizardStep6View.create({
    controller: App.WizardStep6Controller.create()
  });
}

describe('App.WizardStep6View', function() {

  beforeEach(function() {
    view = getView();
  });

  App.TestAliases.testAsComputedAlias(getView(), 'filteredContent', 'content', 'array');

  describe('#content', function() {
    it('should be same to controller.hosts', function() {
      view.set('content', []);
      var d = [{}, {}];
      view.set('controller.hosts', d);
      expect(view.get('content')).to.eql(d);
    });
  });

  describe('#didInsertElement', function() {

    beforeEach(function() {
      sinon.stub(view.get('controller'), 'loadStep', Em.K);
      sinon.stub(App, 'tooltip', Em.K);
      sinon.stub(view, 'setLabel', Em.K);
    });

    afterEach(function() {
      view.get('controller').loadStep.restore();
      App.tooltip.restore();
      view.setLabel.restore();
    });

    it('should call loadStep', function() {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
    });

    it('should call setLabel if not controller.isMasters', function() {
      view.set('controller.isMasters', false);
      view.didInsertElement();
      expect(view.setLabel.calledOnce).to.equal(true);
    });

  });

  describe('#setLabel', function() {
    var tests = Em.A([
      {
        clients: [{display_name: 'c1'}],
        m: 'One client',
        e: 'c1'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}],
        m: 'Two clients',
        e: 'c1 and c2.'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}, {display_name: 'c3'}],
        m: 'Three clients',
        e: 'c1, c2 and c3.'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}, {display_name: 'c3'}, {display_name: 'c4'}],
        m: 'Four clients',
        e: 'c1, c2, c3 and c4.'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}, {display_name: 'c3'}, {display_name: 'c4'}, {display_name: 'c5'}],
        m: 'Five clients',
        e: 'c1, c2, c3, c4 and c5.'
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        view.set('controller.content', {clients: test.clients});
        view.setLabel();
        expect(view.get('label').endsWith(test.e)).to.equal(true);
      });
    });
  });

  describe("#checkboxClick()", function() {
    var e;
    beforeEach(function() {
      sinon.stub(view.get('controller'), 'checkCallback', Em.K);
      sinon.stub(view.get('controller'), 'callValidation', Em.K);
      e = {
        context: {
          checked: true,
          component: 'c1'
        }
      };
      view.checkboxClick(e);
    });
    afterEach(function() {
      view.get('controller').checkCallback.restore();
      view.get('controller').callValidation.restore();
    });

    it("checked is false", function() {
      expect(e.context.checked).to.be.false;
    });

    it("checkCallback is called with correct data", function() {
      expect(view.get('controller').checkCallback.calledWith('c1')).to.be.true;
    });

    it("callValidation is called once", function() {
      expect(view.get('controller').callValidation.calledOnce).to.be.true;
    });
  });

  describe("#columnCount", function() {
    it("hosts present", function() {
      view.set('controller.hosts', [
        Em.Object.create({checkboxes: [{}, {}, {}]})
      ]);
      view.propertyDidChange('columnCount');
      expect(view.get('columnCount')).to.equal(4);
    });
    it("hosts absent", function() {
      view.set('controller.hosts', []);
      view.propertyDidChange('columnCount');
      expect(view.get('columnCount')).to.equal(1);
    });
  });
});

describe('App.WizardStep6HostView', function() {

  beforeEach(function() {
    view = App.WizardStep6HostView.create({
      controller: App.WizardStep6Controller.create()
    });
  });

  describe('#didInsertElement', function() {

    var data = [];

    beforeEach(function() {
      sinon.stub(App, 'popover', Em.K);
      sinon.stub(view.get('controller'), 'getMasterComponentsForHost', function() {return data;});
    });

    afterEach(function() {
      App.popover.restore();
      view.get('controller').getMasterComponentsForHost.restore();
    });

    it('should create popover if not controller.isMasters', function() {
      data = [{}, {}];
      view.set('controller.isMasters', false);
      view.didInsertElement();
      expect(App.popover.calledOnce).to.equal(true);
    });

    it('should create popover even if controller.getMasterComponentsForHost is an empty array', function() {
      data = [{}];
      view.set('controller.isMasters', true);
      view.didInsertElement();
      expect(App.popover.calledOnce).to.equal(true);
    });
  });

});

});

require.register("test/views/wizard/step7/assign_master_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step9/hostLogPopupBody_view');
var stringUtils = require('utils/string_utils');
var view;

function getView() {
  return App.AssignMasterOnStep7View.create({
    controller: Em.Object.create()
  });
}

describe('App.AssignMasterOnStep7View', function () {

  beforeEach(function () {
    view = getView();
  });

  describe("#willInsertElement()", function () {

    beforeEach(function () {
      sinon.stub(view, 'setAlertMessage');
    });

    afterEach(function () {
      view.setAlertMessage.restore();
    });

    it("setAlertMessage should be called", function () {
      view.willInsertElement();
      expect(view.setAlertMessage.calledOnce).to.be.true;
    });
  });

  describe("#getDependentComponents()", function () {

    beforeEach(function () {
      sinon.stub(App.StackServiceComponent, 'find').returns(Em.Object.create({
        dependencies: [{
          scope: 'host',
          componentName: 'C1'
        }]
      }));
      sinon.stub(App.format, 'role', function (arg) {
        return arg;
      });
    });

    afterEach(function () {
      App.StackServiceComponent.find.restore();
      App.format.role.restore();
    });

    it("should return dependent components", function () {
      expect(view.getDependentComponents([{}])).to.be.eql(['C1']);
    });
  });

  describe("#setAlertMessage()", function () {

    beforeEach(function () {
      sinon.stub(App.format, 'role', function (arg) {
        return arg;
      });
      sinon.stub(view, 'getDependentComponents').returns(['c1']);
      sinon.stub(stringUtils, 'getFormattedStringFromArray').returns('');
      this.mock = sinon.stub(App, 'get');
    });

    afterEach(function () {
      App.format.role.restore();
      view.getDependentComponents.restore();
      stringUtils.getFormattedStringFromArray.restore();
      this.mock.restore();
    });

    it("isManualKerberos false, single master", function () {

      var expected = [
        Em.I18n.t('installer.step7.assign.master.body').format('c1', Em.I18n.t('common.host').toLowerCase(), Em.I18n.t('it')),
        Em.I18n.t('installer.step7.assign.master.dependent.component.body').format('')
      ].join('<br/>');

      view.set('controller.mastersToCreate', ['c1']);
      this.mock.returns(false);

      view.setAlertMessage();
      expect(view.get('alertMessage')).to.be.equal(expected);
    });

    it("isManualKerberos false, multiple masters", function () {

      var expected = [
        Em.I18n.t('installer.step7.assign.master.body').format('c1,c2', Em.I18n.t('common.hosts').toLowerCase(), Em.I18n.t('then')),
        Em.I18n.t('installer.step7.assign.master.dependent.component.body').format('')
      ].join('<br/>');

      view.set('controller.mastersToCreate', ['c1', 'c2']);
      this.mock.returns(false);

      view.setAlertMessage();
      expect(view.get('alertMessage')).to.be.equal(expected);
    });

    it("isManualKerberos true, single master", function () {

      var expected = [
        Em.I18n.t('installer.step7.assign.master.body').format('c1', Em.I18n.t('common.host').toLowerCase(), Em.I18n.t('it')),
        Em.I18n.t('installer.step7.assign.master.dependent.component.body').format(''),
        Em.I18n.t('common.warn.message').format(Em.I18n.t('common.important.strong') + ': ' + Em.I18n.t('installer.step8.kerberors.warning'))
      ].join('<br/>');

      view.set('controller.mastersToCreate', ['c1']);
      this.mock.returns(true);

      view.setAlertMessage();
      expect(view.get('alertMessage')).to.be.equal(expected);
    });
  });

});
});

require.register("test/views/wizard/step7_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


describe('App.WizardStep7View', function() {

});

});

require.register("test/views/wizard/step8_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('utils/helper');
require('utils/string_utils');
require('views/wizard/step8_view');
var view;

describe('App.WizardStep8View', function() {

  beforeEach(function() {
    view = App.WizardStep8View.create();
  });

  describe('#didInsertElement', function() {

    beforeEach(function () {
      view.set('controller', Em.Object.create({
        loadStep: Em.K
      }));
      sinon.spy(view.get('controller'), 'loadStep');
    });

    afterEach(function () {
      view.get('controller').loadStep.restore();
    });

    it('should call loadStep', function() {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
    });
  });

  describe('#printReview', function() {

    beforeEach(function() {
      sinon.stub($.fn, 'jqprint', Em.K);
    });

    afterEach(function () {
      $.fn.jqprint.restore();
    });

    it('should call jqprint', function() {
      view.printReview();
      expect($.fn.jqprint.calledOnce).to.equal(true);
    });
  });

});
});

require.register("test/views/wizard/step9/hostLogPopupBody_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step9/hostLogPopupBody_view');
var view;

function getView() {
  return App.WizardStep9HostLogPopupBodyView.create({
    parentView: Em.Object.create({
      host: Em.Object.create()
    })
  });
}

describe('App.WizardStep9HostLogPopupBodyView', function() {

  beforeEach(function() {
    view = getView();
  });

  App.TestAliases.testAsComputedAlias(getView(), 'isNoTasksScheduled', 'parentView.host.isNoTasksForInstall', 'boolean');

  describe('#isHeartbeatLost', function() {
    it('should depends on parentView.host.status', function() {
      view.set('parentView.host.status', 'success');
      expect(view.get('isHeartbeatLost')).to.equal(false);
      view.set('parentView.host.status', 'heartbeat_lost');
      expect(view.get('isHeartbeatLost')).to.equal(true);
    });
  });

  describe('#visibleTasks', function() {
    Em.A([
        {
          value: 'pending',
          f: ['pending', 'queued']
        },
        {
          value: 'in_progress',
          f: ['in_progress']
        },
        {
          value: 'failed',
          f: ['failed']
        },
        {
          value: 'completed',
          f: ['completed']
        },
        {
          value: 'aborted',
          f: ['aborted']
        },
        {
          value: 'timedout',
          f: ['timedout']
        },
        {
          value: 'all'
        }
      ]).forEach(function(test) {
        it(test.value, function() {
          view.reopen({
            category: Em.Object.create({value: test.value}),
            tasks: Em.A([
              {status: 'pending', isVisible: false},
              {status: 'queued', isVisible: false},
              {status: 'in_progress', isVisible: false},
              {status: 'failed', isVisible: false},
              {status: 'completed', isVisible: false},
              {status: 'aborted', isVisible: false},
              {status: 'timedout', isVisible: false}
            ])
          });
          view.visibleTasks();
          var visibleTasks = view.get('tasks').filter(function(task) {
            if (test.f) {
              return test.f.contains(task.status);
            }
            return true;
          });
          expect(visibleTasks.everyProperty('isVisible', true)).to.equal(true);
        });
    });
  });

  describe('#backToTaskList', function() {

    beforeEach(function () {
      sinon.stub(view, 'destroyClipBoard', Em.K);
    });

    afterEach(function () {
      view.destroyClipBoard.restore();
    });

    it('should call destroyClipBoard', function() {
      view.backToTaskList();
      expect(view.destroyClipBoard.calledOnce).to.equal(true);
    });
    it('should set isLogWrapHidden to true', function() {
      view.set('isLogWrapHidden', false);
      view.backToTaskList();
      expect(view.get('isLogWrapHidden')).to.equal(true);
    });
  });

  describe('#getStartedTasks', function() {
    it('should return tasks with some status', function() {
      var logTasks = Em.A([
        {Tasks: {}}, {Tasks: {status: 's'}}, {Tasks: {status: null}}, {Tasks: {status: 'v'}}
      ]);
      expect(view.getStartedTasks({logTasks: logTasks}).length).to.equal(2);
    });
  });

  describe('#openedTask', function() {
    it('should return currently open task', function() {
      var task = Em.Object.create({id: 2});
      view.reopen({
        tasks: Em.A([
          Em.Object.create({id: 1}),
          Em.Object.create({id: 3}),
          task,
          Em.Object.create({id: 4})
        ])
      });
      view.set('parentView.c', {currentOpenTaskId: 2});
      expect(view.get('openedTask.id')).to.equal(2);
    });
  });

  describe('#tasks', function() {
    var testTask = {
      Tasks: {
        status: 'init',
        id: 1,
        request_id: 2,
        role: 'PIG',
        stderr: 'stderr',
        stdout: 'stdout',
        host_name: 'host1',
        command: 'Cmd',
        command_detail: 'TEST SERVICE/COMPONENT_DESCRIPTION'
      }
    };

    beforeEach(function () {
      view.set('parentView.host.logTasks', [testTask]);
      this.t = view.get('tasks');
      this.first = this.t[0];
    });

    it('should map tasks', function() {
      expect(this.t.length).to.equal(1);
    });

    it('should map id', function() {
      expect(this.first.get('id')).to.equal(1);
    });

    it('should map requestId', function() {
      expect(this.first.get('requestId')).to.equal(2);
    });

    it('should map command', function() {
      expect(this.first.get('command')).to.equal('cmd');
    });

    it('should map commandDetail', function() {
      expect(this.first.get('commandDetail')).to.equal(' Test Component Description');
    });

    it('should map role', function() {
      expect(this.first.get('role')).to.equal('Pig');
    });

    it('should map stderr', function() {
      expect(this.first.get('stderr')).to.equal('stderr');
    });

    it('should map stdout', function() {
      expect(this.first.get('stdout')).to.equal('stdout');
    });

    it('should map isVisible', function() {
      expect(this.first.get('isVisible')).to.equal(true);
    });

    it('should map hostName', function() {
      expect(this.first.get('hostName')).to.equal('host1');
    });

    describe('icons', function () {

      Em.A([
        {
          status: 'pending',
          icon:'icon-cog'
        },
        {
          status: 'queued',
          icon:'icon-cog'
        },
        {
          status: 'in_progress',
          icon:'icon-cogs'
        },
        {
          status: 'completed',
          icon:'icon-ok'
        },
        {
          status: 'failed',
          icon:'icon-exclamation-sign'
        },
        {
          status: 'aborted',
          icon:'icon-minus'
        },
        {
          status: 'timedout',
          icon:'icon-time'
        }
      ]).forEach(function (test) {
        it(test.status + ' -> ' + test.icon, function () {
          var t = Em.copy(testTask);
          t.Tasks.status = test.status;
          view.set('parentView.host.logTasks', [t]);
          view.propertyDidChange('tasks');
          expect(view.get('tasks')[0].icon).to.equal(test.icon);
        });
      });

    });

  });

  describe('#toggleTaskLog', function() {

    beforeEach(function () {
      view.set('parentView.c', Em.Object.create({loadCurrentTaskLog: Em.K}));
      sinon.spy(view.get('parentView.c'), 'loadCurrentTaskLog');
    });

    afterEach(function () {
      view.get('parentView.c').loadCurrentTaskLog.restore();
    });

    describe('isLogWrapHidden is true', function () {

      var taskInfo = {
        id: 1,
        requestId: 2
      };

      beforeEach(function () {
        view.set('isLogWrapHidden', true);
        view.toggleTaskLog({context: taskInfo});
      });

      it('isLogWrapHidden is set false', function() {
        expect(view.get('isLogWrapHidden')).to.equal(false);
      });

      it('currentOpenTaskId is equal to id', function() {
        expect(view.get('parentView.c.currentOpenTaskId')).to.equal(taskInfo.id);
      });

      it('currentOpenTaskRequestId is equal to requestId', function() {
        expect(view.get('parentView.c.currentOpenTaskRequestId')).to.equal(taskInfo.requestId);
      });

      it('loadCurrentTaskLog called once', function() {
        expect(view.get('parentView.c').loadCurrentTaskLog.calledOnce).to.equal(true);
      });

    });

    describe('isLogWrapHidden is false', function () {

      var taskInfo = {};

      beforeEach(function () {
        view.set('isLogWrapHidden', false);
        view.toggleTaskLog({context: taskInfo});
      });

      it('isLogWrapHidden is set true', function() {
        expect(view.get('isLogWrapHidden')).to.equal(true);
      });

      it('currentOpenTaskId is 0', function() {
        expect(view.get('parentView.c.currentOpenTaskId')).to.equal(0);
      });

      it('currentOpenTaskRequestId is 0', function() {
        expect(view.get('parentView.c.currentOpenTaskRequestId')).to.equal(0);
      });

    });
  });

});
});

require.register("test/views/wizard/step9_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step9_view');

var v;
function getView() {
  return App.WizardStep9View.create({
    onStatus: function () {},
    content: [],
    pageContent: function () {
      return this.get('content');
    }.property('content')
  });
}

describe('App.WizardStep9View', function () {
  beforeEach(function () {
    v = App.WizardStep9View.create({
      controller: App.WizardStep9Controller.create()
    });
  });
  var view = getView();
  var testCases = [
    {
      title: 'none hosts',
      content: [],
      result: {
        "all": 0,
        "inProgress": 0,
        "warning": 0,
        "success": 0,
        "failed": 0
      }
    },
    {
      title: 'all hosts inProgress',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'in_progress'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'info'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'pending'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 3,
        "warning": 0,
        "success": 0,
        "failed": 0
      }
    },
    {
      title: 'all hosts warning',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'warning'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'warning'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'warning'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 3,
        "success": 0,
        "failed": 0
      }
    },
    {
      title: 'all hosts success',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'success'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'success'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'success'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 0,
        "success": 3,
        "failed": 0
      }
    },
    {
      title: 'all hosts failed',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'failed'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'failed'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'heartbeat_lost'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 0,
        "success": 0,
        "failed": 3
      }
    },
    {
      title: 'first host is failed, second is warning, third is success',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'failed'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'success'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'warning'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 1,
        "success": 1,
        "failed": 1
      }
    },
    {
      title: 'two hosts is inProgress, one is success',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'pending'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'in_progress'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'success'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 2,
        "warning": 0,
        "success": 1,
        "failed": 0
      }
    }
  ];

  describe('#countCategoryHosts', function () {
    testCases.forEach(function (test) {
      describe(test.title, function () {
        var _v;
        beforeEach(function () {
          _v = getView();
          _v.set('content', test.content);
          _v.countCategoryHosts();
        });

        Object.keys(test.result).forEach(function (categoryName) {
          it('`' + categoryName + '`', function () {
            expect(_v.get('categories').findProperty('hostStatus', categoryName).get('hostsCount')).to.equal(test.result[categoryName])
          });
        });

      });
    }, this);
  });

  describe('#doFilter', function () {
    testCases.forEach(function (test) {
      describe(test.title, function () {
        view.get('categories').forEach(function (category) {
          it('. Selected category - ' + category.get('hostStatus'), function () {
            view.set('content', test.content);
            view.reopen({selectedCategory: category});
            view.doFilter();
            expect(view.get('filteredContent').length).to.equal(test.result[category.get('hostStatus')])
          });
        })
      });
    }, this);
  });

  describe('#isStepCompleted', function () {
    it('should be true if progress is 100', function () {
      v.set('controller.progress', '100');
      expect(v.get('isStepCompleted')).to.equal(true);
    });
    it('should be false if progress isn\'t 100', function () {
      v.set('controller.progress', '50');
      expect(v.get('isStepCompleted')).to.equal(false);
    });
  });

  describe('#content', function () {

    var hosts = [{}, {}, {}];

    beforeEach(function () {
      sinon.stub(v, 'hostStatusObserver', Em.K);
      v.set('controller.hosts', hosts);
    });

    afterEach(function () {
      v.hostStatusObserver.restore();
    });

    it('should be equal to controller.hosts', function () {
      expect(v.get('content')).to.eql(hosts);
    });
  });

  describe('#categoryObject', function () {
    it('label should contains value and hostsCount', function () {
      var value = 'v',
        hostsCount = 10,
        o = v.get('categoryObject').create({value: value, hostsCount: hostsCount});
      expect(o.get('label')).to.equal(value + ' (' + hostsCount + ')');
    });
    it('itemClass should depends on isActive', function () {
      var o = v.get('categoryObject').create();
      o.set('isActive', false);
      expect(o.get('itemClass')).to.equal('');
      o.set('isActive', true);
      expect(o.get('itemClass')).to.equal('active');
    });
  });

  describe('#isHostHeartbeatLost', function () {
    Em.A([
        {
          hostsWithHeartbeatLost: [],
          m: 'should be false if hostsWithHeartbeatLost is empty',
          e: false
        },
        {
          hostsWithHeartbeatLost: [
            {},
            {}
          ],
          m: 'should be true if hostsWithHeartbeatLost contains some values',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          v.set('controller.hostsWithHeartbeatLost', test.hostsWithHeartbeatLost);
          expect(v.get('isHostHeartbeatLost')).to.equal(test.e);
        })
      });
  });

  describe('#barWidth', function () {
    it('should depends on controller.progress', function () {
      var w = '25';
      v.set('controller.progress', w);
      expect(v.get('barWidth')).to.equal('width: ' + w + '%;');
    });
  });

  describe('#progressMessage', function () {
    it('should depends on controller.progress', function () {
      var w = '25';
      v.set('controller.progress', w);
      expect(v.get('progressMessage').contains(w)).to.equal(true);
    });
  });

  describe('#showAllHosts', function () {
    it('should set active to category with all hosts', function () {
      v.get('categories').findProperty('hostStatus', 'inProgress').set('isActive', true);
      v.showAllHosts();
      var allCategory = v.get('categories').findProperty('hostStatus', 'all');
      expect(allCategory.get('isActive')).to.equal(true);
      expect(v.get('categories').without(allCategory).everyProperty('isActive', false)).to.equal(true);
    });
  });

  describe('#didInsertElement', function () {
    beforeEach(function () {
      sinon.stub(v, 'onStatus', Em.K);
      sinon.stub(v.get('controller'), 'navigateStep', Em.K);
    });
    afterEach(function () {
      v.onStatus.restore();
      v.get('controller').navigateStep.restore();
    });
    it('should call onStatus', function () {
      v.didInsertElement();
      expect(v.onStatus.calledOnce).to.equal(true);
    });
    it('should call navigateStep', function () {
      v.didInsertElement();
      expect(v.get('controller').navigateStep.calledOnce).to.equal(true);
    });
  });

  describe('#selectCategory', function () {
    it('should set isActive true to selected category', function () {
      var event = {context: Em.Object.create({hostStatus: 'inProgress'})},
        c = v.get('categories').findProperty('hostStatus', 'inProgress');
      c.set('isActive', false);
      v.selectCategory(event);
      expect(c.get('isActive')).to.equal(true);
    });
  });

  describe('#onStatus', function () {
    Em.A([
        {
          status: 'success',
          e: {
            barColor: 'progress-success',
            resultMsg: Em.I18n.t('installer.step9.status.success'),
            resultMsgColor: 'alert-success'
          }
        },
        {
          status: 'info',
          e: {
            barColor: 'progress-info',
            resultMsg: ''
          }
        },
        {
          status: 'warning',
          e: {
            barColor: 'progress-warning',
            resultMsg: Em.I18n.t('installer.step9.status.warning'),
            resultMsgColor: 'alert-warning'
          }
        },
        {
          status: 'failed',
          e: {
            barColor: 'progress-danger',
            resultMsgColor: 'alert-error'
          }
        }
      ]).forEach(function (test) {
        describe(test.status, function () {

          beforeEach(function () {
            v.set('controller.status', test.status);
            v.onStatus();
          });

          Object.keys(test.e).forEach(function (k) {
            it(k, function () {
              expect(v.get(k)).to.equal(test.e[k]);
            });
          });
        });
      });
    Em.A([
        {
          hostsWithHeartbeatLost: [
            {},
            {}
          ],
          startCallFailed: false,
          m: 'heartbeat lost for 2 hosts',
          resultMsg: Em.I18n.t('installer.step9.status.hosts.heartbeat_lost').format(2)
        },
        {
          hostsWithHeartbeatLost: [],
          startCallFailed: true,
          m: 'heartbeat not lost, startCallFailed true',
          resultMsg: Em.I18n.t('installer.step9.status.start.services.failed')
        },
        {
          hostsWithHeartbeatLost: [],
          startCallFailed: false,
          m: 'heartbeat not lost, startCallFailed false',
          resultMsg: Em.I18n.t('installer.step9.status.failed')
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          v.set('controller.hostsWithHeartbeatLost', test.hostsWithHeartbeatLost);
          v.set('controller.startCallFailed', test.startCallFailed);
          v.set('controller.status', 'failed');
          v.onStatus();
          expect(v.get('resultMsg')).to.equal(test.resultMsg);
        });
      });
  });

  describe('#hostWithInstallFailed', function () {
    it('popup property failedHosts should be equal to hostsWithHeartbeatLost', function () {
      var hostsWithHeartbeatLost = [
        {},
        {}
      ];
      v.set('controller.hostsWithHeartbeatLost', hostsWithHeartbeatLost);
      var body = v.hostWithInstallFailed().get('bodyClass').create();
      expect(body.get('failedHosts')).to.eql(hostsWithHeartbeatLost);
    });
  });

});

var hv;
describe('App.HostStatusView', function () {
  beforeEach(function () {
    hv = App.HostStatusView.create();
  });
  var tests = [
    {
      p: 'isFailed',
      tests: [
        {
          obj: {
            status: 'failed',
            progress: 100
          },
          e: true
        },
        {
          obj: {
            status: 'failed',
            progress: 99
          },
          e: false
        },
        {
          obj: {
            status: 'success',
            progress: 100
          },
          e: false
        },
        {
          obj: {
            status: 'success',
            progress: 99
          },
          e: false
        }
      ]
    },
    {
      p: 'isSuccess',
      tests: [
        {
          obj: {
            status: 'success',
            progress: 100
          },
          e: true
        },
        {
          obj: {
            status: 'success',
            progress: 99
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 100
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 99
          },
          e: false
        }
      ]
    },
    {
      p: 'isWarning',
      tests: [
        {
          obj: {
            status: 'warning',
            progress: 100
          },
          e: true
        },
        {
          obj: {
            status: 'warning',
            progress: 99
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 100
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 99
          },
          e: false
        }
      ]
    }
  ];
  tests.forEach(function (test) {
    describe(test.p, function () {
      test.tests.forEach(function (t) {
        var hostStatusView = App.HostStatusView.create();
        it('obj.progress = ' + t.obj.progress + '; obj.status = ' + t.obj.status, function () {
          hostStatusView.set('obj', t.obj);
          expect(hostStatusView.get(test.p)).to.equal(t.e);
        });
      });
    });
  });

  describe('#barWidth', function () {
    it('should depends of obj.progress', function () {
      hv.set('obj', {progress: '25'});
      expect(hv.get('barWidth')).to.equal('width: 25%;');
    });
  });

  describe('#didInsertElement', function () {

    beforeEach(function () {
      sinon.stub(hv, 'onStatus', Em.K);
    });

    afterEach(function () {
      hv.onStatus.restore();
    });

    it('should call onStatus', function () {
      hv.didInsertElement();
      expect(hv.onStatus.calledOnce).to.equal(true);
    });
  });

  describe('#onStatus', function () {
    Em.A([
        {
          obj: {
            status: 'info'
          },
          e: {
            barColor: 'progress-info'
          }
        },
        {
          obj: {
            status: 'warning'
          },
          e: {
            barColor: 'progress-warning'
          }
        },
        {
          obj: {
            status: 'warning',
            progress: '100'
          },
          e: {
            barColor: 'progress-warning',
            'obj.message': Em.I18n.t('installer.step9.host.status.warning')
          }
        },
        {
          obj: {
            status: 'failed'
          },
          e: {
            barColor: 'progress-danger'
          }
        },
        {
          obj: {
            status: 'failed',
            progress: '100'
          },
          e: {
            barColor: 'progress-danger',
            'obj.message': Em.I18n.t('installer.step9.host.status.failed')
          }
        },
        {
          obj: {
            status: 'heartbeat_lost'
          },
          e: {
            barColor: 'progress-danger'
          }
        },
        {
          obj: {
            status: 'heartbeat_lost',
            progress: '100'
          },
          e: {
            barColor: 'progress-danger',
            'obj.message': Em.I18n.t('installer.step9.host.heartbeat_lost')
          }
        }
      ]).forEach(function (test) {
        describe(JSON.stringify(test.obj), function () {

          beforeEach(function () {
            hv.set('obj', test.obj);
            hv.onStatus();
          });

          Object.keys(test.e).forEach(function (k) {
            it(k, function () {
              expect(hv.get(k)).to.equal(test.e[k]);
            });
          });
        });
      });
    Em.A([
        {
          obj: {
            status: 'success',
            progress: '100'
          },
          progress: '35',
          e: true
        },
        {
          obj: {
            status: 'success',
            progress: '100'
          },
          progress: '34',
          e: false
        },
        {
          obj: {
            status: 'success',
            progress: '99'
          },
          progress: '35',
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: '100'
          },
          progress: '35',
          e: false
        }
      ]).forEach(function (test) {
        describe(JSON.stringify(test.obj) + ' ' + test.progress, function() {
          beforeEach(function () {
            hv.setProperties({
              barColor: '',
              obj: test.obj
            });
            hv.set('obj.message', '');
            hv.set('controller', {progress: test.progress});
            hv.onStatus();
          });

          if (test.e) {
            it('completed successful', function () {
              expect(hv.get('obj.message')).to.be.equal(Em.I18n.t('installer.step9.host.status.success'));
              expect(hv.get('barColor')).to.be.equal('progress-success');
            });
          }
          else {
            it('completed not successful', function () {
              expect(hv.get('obj.message')).to.be.not.equal(Em.I18n.t('installer.step9.host.status.success'));
              expect(hv.get('barColor')).to.be.not.equal('progress-success');
            });
          }
        });
      });
  });

  describe('#hostLogPopup', function() {

    describe('#onClose', function() {

      beforeEach(function() {
        hv.set('controller', {currentOpenTaskId: 123});
        hv.set('obj', Em.Object.create());
        this.p = hv.hostLogPopup();
        sinon.spy(this.p, 'hide');
      });

      afterEach(function () {
        this.p.hide.restore();
      });

      it('popup should clear currentOpenTaskId', function() {
        this.p.onClose();
        expect(hv.get('controller.currentOpenTaskId')).to.equal(0);
      });

      it('onClose popup should hide popup', function() {
        this.p.onClose();
        expect(this.p.hide.calledOnce).to.equal(true);
      });

    });
  });

});

});

